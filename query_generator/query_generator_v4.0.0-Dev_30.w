&ANALYZE-SUSPEND _VERSION-NUMBER AB_v10r12 GUI
&ANALYZE-RESUME
/* Connected Databases 
*/
&Scoped-define WINDOW-NAME hQueryWindow

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _DECLARATIONS hQueryWindow 
routine-level on error undo, throw.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _DEFINITIONS hQueryWindow 
/******************************************************************************/
/*                                      (c) 2013   proALPHA Software AG       */
/*                                                 Auf dem Immel 8            */
/*                                                 67661  Kaiserslautern      */
/*                                                                            */
/*  erstellt am: 02.05.2013                                                   */
/*  Autor......: Manuel Thiemann                                              */
/*                                                                            */
/*  Version....: 4.0.0 Dev 30                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*  AUFGABE                                                                   */
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Ermöglicht das "Zusammenklicken" einer Datenbank-Abfrage als "find first", */
/* "for each" oder "can-find".                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*  ÄNDERUNGSPROTOKOLL                                                        */
/*----------------------------------------------------------------------------*/
/* 02.05.2013 mth Version 1.0.0                                               */
/* 02.05.2013 mth Version 1.1.0                                               */
/* 08.05.2013 mth Version 1.2.0                                               */
/* 15.05.2013 mth Version 2.0.0                                               */
/* 16.05.2013 mth Version 2.1.0                                               */
/* 23.05.2013 mth Version 2.2.0                                               */
/* 20.08.2013 mth Version 3.0.0                                               */
/* 18.09.2013 mth Version 3.1.0                                               */
/* 04.11.2013 mth Version 3.2.0                                               */
/* 03.02.2014 mth Version 3.3.0                                               */
/* 20.02.2014 mth Version 3.4.0                                               */
/* 06.03.2014 mth Version 3.5.0                                               */
/* 02.04.2014 mth Version 3.6.0                                               */
/* 15.05.2014 mth Version 3.7.0                                               */
/* 29.07.2014 mth Version 3.8.0                                               */
/* 14.11.2014 mth Version 3.9.0                                               */
/* 01.02.2015 mth Version 3.10.0                                              */
/* 03.03.2015 mth Version 3.10.1                                              */
/* 23.04.2015 mth Version 3.10.2                                              */
/* 04.08.2015 mth Version 3.11.0                                              */
/* 03.09.2015 mth Version 3.11.1                                              */
/* 03.09.2015 mth Version 3.11.2                                              */
/* ??.??.???? mth Version 4.0.0                                               */
/******************************************************************************/

/*----------------------------------------------------------------------------*/
/*          This .W file was created with the Progress AppBuilder.            */
/*----------------------------------------------------------------------------*/

/* Create an unnamed pool to store all the widgets created 
     by this procedure. This is a good default which assures
     that this procedure's triggers and internal procedures 
     will execute in this procedure's storage, and that proper
     cleanup will occur on deletion of the procedure. */

create widget-pool.

/*----------------------------------------------------------------------------*/
/* Definitionen                                                               */
/*----------------------------------------------------------------------------*/

/* Globals -------------------------------------------------------------------*/


/* SCOPEDs -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Options                                                                    */
/*----------------------------------------------------------------------------*/

&SCOPED-DEFINE K_SHOW_QUERY_TYPE_MODIFIER            no
&SCOPED-DEFINE K_ALWAYS_USE_FIND_FIRST               no
&SCOPED-DEFINE K_ALWAYS_USE_CANFIND_FIRST            no

&SCOPED-DEFINE K_SET_SLIM_MODE_ON_STARTUP            no

&SCOPED-DEFINE K_SHOW_GRID_ON_BROWSE                 no
&SCOPED-DEFINE K_TOGGLE_GRID_ON_BROWSE               no
&SCOPED-DEFINE K_SELECT_COLUMN_ON_BROWSE             yes
&SCOPED-DEFINE K_EXPORT_ON_BROWSE                    yes
&SCOPED-DEFINE K_RECORD_COUNT_ON_BROWSE              yes

&SCOPED-DEFINE K_EDITMODE_ENABLED                    yes
&SCOPED-DEFINE K_COLORED_INDEX_USAGE                 no

&SCOPED-DEFINE K_MAX_FIELD_HISTORY_ENTRIES           50

&SCOPED-DEFINE K_SESSIONTRIGGER_SHOWMESSAGE          yes
&SCOPED-DEFINE K_SESSIONTRIGGER_WRITELOG             no
&SCOPED-DEFINE K_SESSIONTRIGGER_LOGFILENAME          '':U
&SCOPED-DEFINE K_SESSIONTRIGGER_INDEXVALUES          yes
&SCOPED-DEFINE K_SESSIONTRIGGER_STACKTRACE           yes

&SCOPED-DEFINE K_AUTOFILTER_OMIT_TABLE_SUFFIX        '':U

&SCOPED-DEFINE K_DEFAULT_REPOSITORY_LANGUAGE         'D':U

/*----------------------------------------------------------------------------*/
/* Parameters                                                                 */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Defaults                                                                   */
/*----------------------------------------------------------------------------*/

&SCOPED-DEFINE K_DEFAULT_BUFFER_PATTERN              '&1':U
&SCOPED-DEFINE K_DEFAULT_DEFINE_BUFFER               no

&SCOPED-DEFINE K_DEFAULT_EXCLUSIVE_LOCK              no
&SCOPED-DEFINE K_DEFAULT_COMPANY_VIA_CLASS           yes
&SCOPED-DEFINE K_DEFAULT_NO_ERROR                    yes
&SCOPED-DEFINE K_DEFAULT_IF_STATEMENT                yes
&SCOPED-DEFINE K_DEFAULT_NOT                         no
&SCOPED-DEFINE K_DEFAULT_DO_BLOCK                    no
&SCOPED-DEFINE K_DEFAULT_DEFINE_VARIABLES            yes
&SCOPED-DEFINE K_DEFAULT_USE_VIRTUAL_INDEX_API       yes
&SCOPED-DEFINE K_DEFAULT_USE_VIRTUAL_INDEX_INCLUDES  no

&SCOPED-DEFINE K_DEFAULT_ON_ERROR                    yes
&SCOPED-DEFINE K_DEFAULT_ON_ERROR_PHRASE             ~{&K_ON_ERROR_PHRASE_THROW}
&SCOPED-DEFINE K_DEFAULT_BLOCK_PATTERN               '':U
&SCOPED-DEFINE K_DEFAULT_DEFINE_BLOCK                no
&SCOPED-DEFINE K_DEFAULT_RETRY_BLOCK                 no
&SCOPED-DEFINE K_DEFAULT_FINALLY_BLOCK               no

&SCOPED-DEFINE K_DEFAULT_QUERY_TYPE                  ~{&K_QUERYTYPE_FINDFIRST}

&SCOPED-DEFINE K_DEFAULT_INDENTATION                 0

&SCOPED-DEFINE K_DEFAULT_INSERT_MODE                 yes

/*----------------------------------------------------------------------------*/
/* Buffer-Buttons                                                             */
/*----------------------------------------------------------------------------*/

/* Use &1 as table name replacement and # as a counter replacement. Use ## to */
/* actually insert the # character                                            */

&SCOPED-DEFINE K_BUFFER_PATTERN_1                    'b#&1':U
&SCOPED-DEFINE K_BUFFER_PATTERN_LABEL_1              'b#':U

&SCOPED-DEFINE K_BUFFER_PATTERN_2                    'gb#&1':U
&SCOPED-DEFINE K_BUFFER_PATTERN_LABEL_2              'gb#':U

&SCOPED-DEFINE K_BUFFER_PATTERN_3                    'bx#&1':U
&SCOPED-DEFINE K_BUFFER_PATTERN_LABEL_3              'bx#':U

&SCOPED-DEFINE K_BUFFER_PATTERN_4                    'gbx#&1':U
&SCOPED-DEFINE K_BUFFER_PATTERN_LABEL_4              'gbx#':U

&SCOPED-DEFINE K_NUM_BUFFER_PATTERN_INDICES          5

/*----------------------------------------------------------------------------*/
/* Block-Buttons                                                              */
/*----------------------------------------------------------------------------*/

&SCOPED-DEFINE K_BLOCK_PATTERN_1                     'FE_&1':U
&SCOPED-DEFINE K_BLOCK_PATTERN_LABEL_1               'FE':U

&SCOPED-DEFINE K_BLOCK_PATTERN_2                     'Main':U
&SCOPED-DEFINE K_BLOCK_PATTERN_LABEL_2               'Main':U

&SCOPED-DEFINE K_BLOCK_PATTERN_3                     '':U
&SCOPED-DEFINE K_BLOCK_PATTERN_LABEL_3               '':U

&SCOPED-DEFINE K_BLOCK_PATTERN_4                     '':U
&SCOPED-DEFINE K_BLOCK_PATTERN_LABEL_4               '':U


/*----------------------------------------------------------------------------*/
/* Other constants                                                            */
/*----------------------------------------------------------------------------*/

&SCOPED-DEFINE K_Version                           '4.0.0 Dev 30':U
&GLOBAL-DEFINE xITCFramework_VERSION               40029

&IF proversion < '11.3':U &THEN
  
  /* The progress system constant PROCESS-ARCHITECTURE was introduced in      */
  /* progress version 11.3. To avoid compile errors in version prior to that  */
  /* we declare it as 32 bit. Chances are very slim that it is anything else  */
  /* in earlier progress versions.                                            */
  
  &GLOBAL-DEFINE PROCESS-ARCHITECTURE  32
  
&ENDIF

&SCOPED-DEFINE K_FIELD_TYPE_DB_FIELD               0
&SCOPED-DEFINE K_FIELD_TYPE_VIRTUAL_DB_FIELD       10

&SCOPED-DEFINE K_BASE_DB_NAME                      'basis':U

&SCOPED-DEFINE K_QG_WIKI_URL                       'https://paworld.proalpha.com/x/eFKjAg':U
&SCOPED-DEFINE K_QG_CUSTOMER_WIKI_URL              'https://b2b.proalpha.de/wiki/index.php?title=Query%20Generator':U
&SCOPED-DEFINE K_PLUGIN_WIKI_URL                   'https://paworld.proalpha.com/x/iFKjAg':U
&SCOPED-DEFINE K_PLUGIN_CUSTOMER_WIKI_URL          'https://b2b.proalpha.de/wiki/index.php?title=Query%20Generator%20(Eclipse%20Plugin)':U

&SCOPED-DEFINE K_COMPANY_FIELDS                    'Firma,Company':U
&SCOPED-DEFINE K_COMPANY_INCLUDE_BLACKLIST         '*dt_fir00.fir*':U
&SCOPED-DEFINE K_OBJECT_ID_DOMAIN                  'Object ID':U

&SCOPED-DEFINE K_QUERYRANGE_DEFAULT                1
&SCOPED-DEFINE K_QUERYRANGE_FIRST                  2
&SCOPED-DEFINE K_QUERYRANGE_LAST                   3

&SCOPED-DEFINE K_QUERYTYPE_FINDFIRST               1
&SCOPED-DEFINE K_QUERYTYPE_FOREACH                 2
&SCOPED-DEFINE K_QUERYTYPE_CANFIND                 3

&SCOPED-DEFINE K_ACCESS_MODE_PHYSICAL              0
&SCOPED-DEFINE K_ACCESS_MODE_VIRTUAL_INDEX_API     1
&SCOPED-DEFINE K_ACCESS_MODE_VIRTUAL_INDEX_INCLUDE 2

&SCOPED-DEFINE K_ON_ERROR_PHRASE_LEAVE             1
&SCOPED-DEFINE K_ON_ERROR_PHRASE_NEXT              2
&SCOPED-DEFINE K_ON_ERROR_PHRASE_RETRY             3
&SCOPED-DEFINE K_ON_ERROR_PHRASE_THROW             4

&SCOPED-DEFINE K_DISPLAYMODE_FIELD                 1
&SCOPED-DEFINE K_DISPLAYMODE_INDEX                 2
&SCOPED-DEFINE K_DISPLAYMODE_RELATION              3

&SCOPED-DEFINE K_EDITACTION_EDIT                   1
&SCOPED-DEFINE K_EDITACTION_CREATE                 2
&SCOPED-DEFINE K_EDITACTION_DUPLICATE              3

&SCOPED-DEFINE K_WINDOW_MAXIMIZED                  1
&SCOPED-DEFINE K_WINDOW_MINIMIZED                  2
&SCOPED-DEFINE K_WINDOW_NORMAL                     3
&SCOPED-DEFINE K_WINDOW_DELAYED_MINIMIZE           4

&SCOPED-DEFINE K_WINDOW_MAXIMIZED_STR              'maximized':U
&SCOPED-DEFINE K_WINDOW_MINIMIZED_STR              'minimized':U
&SCOPED-DEFINE K_WINDOW_NORMAL_STR                 'normal':U

&SCOPED-DEFINE K_CLASS_COMPANY_STATEMENT           pACConnectionSvc:prpcCompany

&SCOPED-DEFINE K_PARAM_SPLITTER                    chr(3)

&SCOPED-DEFINE K_EDITOR_INSERT_REQUEST_HANDLER     'EditorInsertRequestId':U
&SCOPED-DEFINE K_SAVE_PLUGIN_SETTING_HANDLER       'SavePluginSettingId':U
&SCOPED-DEFINE K_LOAD_PLUGIN_SETTING_HANDLER       'LoadPluginSettingId':U

&SCOPED-DEFINE K_WINDOW_MIN_WIDTH                  210
&SCOPED-DEFINE K_WINDOW_MIN_WIDTH_SLIM             85
&SCOPED-DEFINE K_WINDOW_MIN_HEIGHT                 24
&SCOPED-DEFINE K_WINDOW_MIN_HEIGHT_SLIM            22
&SCOPED-DEFINE K_SLIM_MODE_FACTOR                  (231 / 121)

&SCOPED-DEFINE K_COLOR_BLACK                       1
&SCOPED-DEFINE K_COLOR_DARK_RED                    4
&SCOPED-DEFINE K_COLOR_GREEN                       10
&SCOPED-DEFINE K_COLOR_RED                         12
&SCOPED-DEFINE K_COLOR_YELLOW                      14
&SCOPED-DEFINE K_COLOR_DARK_GREY                   7
&SCOPED-DEFINE K_COLOR_LIGHT_GREY                  8

&SCOPED-DEFINE K_WHERE_DATA_TYPE_BLACKLIST         'BLOB,CLOB':U

&SCOPED-DEFINE K_MAX_INT64_FORMAT                  '-z,zzz,zzz,zzz,zzz,zzz,zz9':U

&SCOPED-DEFINE K_PROGRESS_TTNAME                   'PROGRESST':U
&SCOPED-DEFINE K_PERSISTENT_TT_DBNAME              'Persistent':U
&SCOPED-DEFINE K_PERSISTENT_TT_PHYSICALNAME        '*** Virtual persistent temp-table database ***':T
&SCOPED-DEFINE K_SNAPSHOT_DBNAME                   'Snapshots':U
&SCOPED-DEFINE K_SNAPSHOT_PHYSICALNAME             '*** Virtual snapshot database ***':T

&SCOPED-DEFINE K_QUERY_SIZE_MODE_DEFAULT           0
&SCOPED-DEFINE K_QUERY_SIZE_MODE_DEFAULT_SPLITTER  1
&SCOPED-DEFINE K_QUERY_SIZE_MODE_SMALL             2
&SCOPED-DEFINE K_QUERY_SIZE_MODE_MINIMUM           3
&SCOPED-DEFINE K_QUERY_SIZE_MODE_BIG               4
&SCOPED-DEFINE K_RECORD_SIZE_MODE_DEFAULT          5

&SCOPED-DEFINE K_VALUE_MODE_DATA_TYPE              0
&SCOPED-DEFINE K_VALUE_MODE_DEFAULT_VALUE          1
&SCOPED-DEFINE K_VALUE_MODE_PARAMETER              2

&SCOPED-DEFINE K_WIN_CONST_VK_SCROLL               0x91
&SCOPED-DEFINE K_WIN_CONST_VK_NUMLOCK              0x90
&SCOPED-DEFINE K_WIN_CONST_VK_CAPITAL              0x14
&SCOPED-DEFINE K_WIN_CONST_VK_CTRL                 0x11
&SCOPED-DEFINE K_WIN_CONST_VK_ALT                  0x12
&SCOPED-DEFINE K_WIN_CONST_VK_SHIFT                0x10

&GLOBAL-DEFINE K_WIN_CONST_HKEY_CURRENT_USER       -2147483647
&GLOBAL-DEFINE K_WIN_CONST_HKEY_LOCAL_MACHINE      -2147483646
&GLOBAL-DEFINE K_WIN_CONST_HKEY_CURRENT_CONFIG     -2147483643
&GLOBAL-DEFINE K_WIN_CONST_HKEY_CLASSES_ROOT       -2147483648

&GLOBAL-DEFINE K_WIN_CONST_KEY_QUERY_VALUE         1

&GLOBAL-DEFINE K_WIN_CONST_GWL_STYLE               -16
&GLOBAL-DEFINE K_WIN_CONST_WS_BORDER               0x00800000
&GLOBAL-DEFINE K_WIN_CONST_WS_CHILD                0x40000000
&GLOBAL-DEFINE K_WIN_CONST_WS_CLIPCHILDREN         0x02000000
&GLOBAL-DEFINE K_WIN_CONST_WS_POPUP                0x80000000
&GLOBAL-DEFINE K_WIN_CONST_WS_TABSTOP              0x00010000
&GLOBAL-DEFINE K_WIN_CONST_WS_HSCROLL              0x00100000
&GLOBAL-DEFINE K_WIN_CONST_WS_VSCROLL              0x00200000

&GLOBAL-DEFINE K_WIN_CONST_SWP_NOSIZE              1
&GLOBAL-DEFINE K_WIN_CONST_SWP_FRAMECHANGED        32

&GLOBAL-DEFINE K_QUERY_WINDOW_MODE_QUERY           0
&GLOBAL-DEFINE K_QUERY_WINDOW_MODE_QUERY_STR       'query':U
&GLOBAL-DEFINE K_QUERY_WINDOW_MODE_RECORD          1
&GLOBAL-DEFINE K_QUERY_WINDOW_MODE_RECORD_STR      'record':U

&GLOBAL-DEFINE K_NAVIGATE_FIRST                    1
&GLOBAL-DEFINE K_NAVIGATE_PREV                     2
&GLOBAL-DEFINE K_NAVIGATE_NEXT                     3
&GLOBAL-DEFINE K_NAVIGATE_LAST                     4

&GLOBAL-DEFINE K_QUERY_WINDOW_LINK_MODE_FIX_ROWID  1
&GLOBAL-DEFINE K_QUERY_WINDOW_LINK_MODE_FIX_INDEX  2
&GLOBAL-DEFINE K_QUERY_WINDOW_LINK_MODE_LINKED     3

&SCOPED-DEFINE K_DIRECTION_UP                      0
&SCOPED-DEFINE K_DIRECTION_DOWN                    1
&SCOPED-DEFINE K_DIRECTION_LEFT                    2
&SCOPED-DEFINE K_DIRECTION_RIGHT                   3

&SCOPED-DEFINE K_QP_TOKEN_TYPE_UNDEFINED           0
&SCOPED-DEFINE K_QP_TOKEN_TYPE_EOF                 1
&SCOPED-DEFINE K_QP_TOKEN_TYPE_KEYWORD             2
&SCOPED-DEFINE K_QP_TOKEN_TYPE_STRING              3
&SCOPED-DEFINE K_QP_TOKEN_TYPE_COMMENT             4
&SCOPED-DEFINE K_QP_TOKEN_TYPE_OPERATOR            5
&SCOPED-DEFINE K_QP_TOKEN_TYPE_NUMBER              6
&SCOPED-DEFINE K_QP_TOKEN_TYPE_DATE                7
&SCOPED-DEFINE K_QP_TOKEN_TYPE_PUNCTUATION         8
&SCOPED-DEFINE K_QP_TOKEN_TYPE_PREPROCESSOR        9
&SCOPED-DEFINE K_QP_TOKEN_TYPE_BRACE_OPEN          10
&SCOPED-DEFINE K_QP_TOKEN_TYPE_BRACE_CLOSE         11
&SCOPED-DEFINE K_QP_TOKEN_TYPE_BRACKET_OPEN        12
&SCOPED-DEFINE K_QP_TOKEN_TYPE_BRACKET_CLOSE       13
&SCOPED-DEFINE K_QP_TOKEN_TYPE_PARENTHESE_OPEN     14
&SCOPED-DEFINE K_QP_TOKEN_TYPE_PARENTHESE_CLOSE    15
&SCOPED-DEFINE K_QP_TOKEN_TYPE_IDENTIFIER          16
&SCOPED-DEFINE K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE  17

&SCOPED-DEFINE K_QP_NODE_TYPE_NODE                 0
&SCOPED-DEFINE K_QP_NODE_TYPE_TOKEN                1

&SCOPED-DEFINE K_QP_COMPARATOR_OPERATORS ~
    'EQ,LT,LE,GT,GE,NE,BEGINS,MATCHES,CONTAINS,=,<,<=,>,>=,<>':U

&SCOPED-DEFINE K_QP_CONDITION_BREAK_KEYWORDS ~
      'FOR,EACH,FIRST,LAST,BREAK,BY,COLLATE,TRANSACTION,STOP-AFTER':U ~
    + ',ON,USE-INDEX,NO-LOCK,SHARE-LOCK,EXCLUSIVE-LOCK,NO-PREFETCH':U ~
    + ',LOOKAHEAD,NO-LOOKAHEAD,DEBUG,NO-DEBUG,SEPARATE-CONNECTION':U ~
    + ',NO-SEPARATE-CONNECTION,JOIN-BY-SQLDB,NO-JOIN-BY-SQLDB,BIND-WHERE':U ~
    + ',NO-BIND-WHERE,INDEX-HINT,NO-INDEX-HINT,SKIP-GROUP-DUPLICATES':U ~
    + ',TABLE-SCAN,USING':U

&SCOPED-DEFINE K_QP_KEYWORD_FUNCTIONS ~
      'TODAY,NOW,ETIME,ALIAS,ASC,AVAILABLE,CAN-DO,CAN-FIND,CAST,COUNT-OF':U ~
    + ',CURRENT-CHANGED,CURRENT-LANGUAGE,DATASERVERS,DBCODEPAGE,DBCOLLATION':U ~
    + ',DBNAME,DBPARAM,DBRESTRICTIONS,DBTASKID,DBTYPE,DBVERSION':U ~
    + ',DYNAMIC-function,ENCODE,ENTRY,ETIME,FILL,FIRST-OF,FRAME-COL':U ~
    + ',FRAME-DB,FRAME-DOWN,FRAME-FIELD,FRAME-FILE,FRAME-INDEX,FRAME-LINE':U ~
    + ',FRAME-NAME,FRAME-ROW,FRAME-VALUE,GET-BYTE,GET-CODEPAGES':U ~
    + ',GET-COLLATIONS,INDEX,INPUT,IS-ATTR-SPACE,KBLABEL,KEYCODE':U ~
    + ',KEYFUNCTION,KEYLABEL,KEYWORD,LAST-OF,LASTKEY,LDBNAME,LIBRARY':U ~
    + ',LINE-COUNTER,LOCKED,LOOKUP,MEMBER,MESSAGE-LINES,NEW,NUM-ALIASES':U ~
    + ',NUM-DBS,NUM-ENTRIES,OS-DRIVES,OS-ERROR,PAGE-NUMBER,PDBNAME':U ~
    + ',PROC-HANDLE,PROC-STATUS,PROGRAM-NAME,R-INDEX,RECID,RECORD-LENGTH':U ~
    + ',RETRY,RETURN-VALUE,SCREEN-LINES,SDBNAME,SEARCH,SEEK,SETUSERID,SUPER':U ~
    + ',TERMINAL,TIME,TRIM,USERID':U

&SCOPED-DEFINE K_CASEMODE_TABLE                    1
&SCOPED-DEFINE K_CASEMODE_FIELD                    2
&SCOPED-DEFINE K_CASEMODE_TABLE_FIELD              3
&SCOPED-DEFINE K_CASEMODE_TABLE_FIELD_LABEL        4
&SCOPED-DEFINE K_CASEMODE_TABLE_INDEX              5
&SCOPED-DEFINE K_CASEMODE_TABLE_RELATION           6

&SCOPED-DEFINE K_SNAPSHOT_SCOPE_RECORD             'rec':U
&SCOPED-DEFINE K_SNAPSHOT_SCOPE_ALL                'all':U

&SCOPED-DEFINE K_OVERLAY_TYPE_OBJ_STR              'obj':U

&SCOPED-DEFINE K_OBJECTID_OVERLAY_FGCOLOR          5
&SCOPED-DEFINE K_OBJECTID_OVERLAY_DEFAULT_WIDTH    35
&SCOPED-DEFINE K_OBJECTID_OVERLAY_FORMAT           'x(1024)':U
&SCOPED-DEFINE K_OBJECTID_OVERLAY_NAME_PATTERN     '$resolve( &1 )':U
&SCOPED-DEFINE K_OBJECTID_OVERLAY_LABEL_PATTERN    '&1 <resolved>':U

&SCOPED-DEFINE K_IMPORT_TYPE_DATASET               0
&SCOPED-DEFINE K_IMPORT_TYPE_TEMP_TABLE            1

/* Variables -----------------------------------------------------------------*/

define stream strExport.
define stream strClipboard.
define stream strSeTrigger.
define stream strTemp.

define new global shared variable pa-broker-hdl  as handle no-undo.

define variable gcCustomLevel               as character no-undo.

define variable gcBufferBaseName            as character no-undo.
define variable gcBufferPattern             as character no-undo.
define variable gcBlockPattern              as character no-undo.

define variable gcStatusText60              as character no-undo format 'x(60)':U.
define variable gcStatusText120             as character no-undo format 'x(120)':U.

define variable giQuerySeq                  as integer   no-undo.

define variable gcExportFilename            as character no-undo.
define variable gcQRScenarioFileName        as character no-undo.

define variable glShowHiddenTables          as logical   no-undo.

define variable glShowChildRelations        as logical   no-undo initial yes.
define variable glShowParentRelations       as logical   no-undo initial yes.

define variable giIndentation               as integer   no-undo.

define variable gcIDEProjectName            as character no-undo.

define variable glIDECanInsert              as logical   no-undo.
define variable glIDECanSaveSetting         as logical   no-undo.
define variable glIDECanLoadSetting         as logical   no-undo.

define variable glInsertMode                as logical   no-undo.

define variable gdOriginalWidth             as decimal   no-undo.
define variable gdMinWidth                  as decimal   no-undo initial {&K_WINDOW_MIN_WIDTH}.
define variable gdOriginalHeight            as decimal   no-undo.
define variable gdMinHeight                 as decimal   no-undo initial {&K_WINDOW_MIN_HEIGHT}.

define variable gcFieldDatatypeFilter       as character no-undo.

define variable gcSessionTitle              as character no-undo.
define variable gcTitlePrefix               as character no-undo.
define variable gcIconDir                   as character no-undo.

define variable giRecentQueriesSeq          as integer   no-undo.

define variable glBrowseFields              as logical   no-undo initial no.
define variable glRawValues                 as logical   no-undo initial no.
define variable glCopyRawValues             as logical   no-undo initial yes.
define variable glShowLinkedChildWindows    as logical   no-undo initial yes.

define variable gcPersitentTTProcedure      as character no-undo.

define variable gcTTWidgetPool              as character no-undo.

define variable gcCursorHand                as character no-undo.

define variable giQueryParserSeq            as integer   no-undo.

define variable gcQPQueryText               as character no-undo.
define variable giQPOffset                  as integer   no-undo.
define variable giQPTokenStart              as integer   no-undo.
define variable giQPTokenEnd                as integer   no-undo.
define variable gcQPToken                   as character no-undo.
define variable giQPTokenType               as integer   no-undo.

define variable glShowQueryTypeModifier     as logical   no-undo.
define variable glAlwaysUseFindFirst        as logical   no-undo.
define variable glAlwaysUseCanFindFirst     as logical   no-undo.
define variable glUseVirtualIndexApi        as logical   no-undo.
define variable glSlimMode                  as logical   no-undo.

define variable glUnicode                   as logical   no-undo.
define variable gcSpace                     as character no-undo.
define variable gcBulletChar1               as character no-undo.
define variable gcBulletChar1White          as character no-undo.
define variable gcBulletChar2               as character no-undo.
define variable gcBulletChar2White          as character no-undo.
define variable gcLineVertical              as character no-undo.
define variable gcLineUpAndRight            as character no-undo.
define variable gcLineVerticalAndRight      as character no-undo.

define variable giSessionTriggerSeq         as integer   no-undo.
define variable giSessionTriggerInstSeq     as integer   no-undo.

define variable ghSessionTriggersWindow     as handle    no-undo.
define variable ghSessionTriggersBrowse     as handle    no-undo.
define variable ghSessionTriggerShowMessage as handle    no-undo.
define variable ghSessionTriggerWriteLog    as handle    no-undo.
define variable ghSessionTriggerLogFileName as handle    no-undo.
define variable ghSessionTriggerIndexValues as handle    no-undo.
define variable ghSessionTriggerStackTrace  as handle    no-undo.

define variable glSessionTriggerShowMessage as logical   no-undo.
define variable glSessionTriggerWriteLog    as logical   no-undo.
define variable gcSessionTriggerLogFileName as character no-undo.
define variable glSessionTriggerIndexValues as logical   no-undo.
define variable glSessionTriggerStackTrace  as logical   no-undo.

define variable giRelationSeq               as integer   no-undo.
define variable giRelationViewSeq           as integer   no-undo.
define variable giRelationId                as integer   no-undo.
define variable glParentRelation            as logical   no-undo.
define variable gcRelationBufferName        as character no-undo.
define variable ghRelationWindow            as handle    no-undo.

define variable glRefreshFieldBrowse        as logical   no-undo.
define variable glRefreshIndexBrowse        as logical   no-undo.
define variable glRefreshRelationBrowse     as logical   no-undo.

define variable gchMerge                    as com-handle no-undo.
define variable gcBufferComparison1Tables   as character no-undo.
define variable gcBufferComparison1Buffers  as character no-undo.
define variable gcBufferComparison1RowIds   as character no-undo.
define variable gcBufferComparison2Tables   as character no-undo.
define variable gcBufferComparison2Buffers  as character no-undo.
define variable gcBufferComparison2RowIds   as character no-undo.

define variable giFilterSeq                 as integer   no-undo.

define variable gcRepositoryLanguage        as character no-undo initial {&K_DEFAULT_REPOSITORY_LANGUAGE}.

/* Work-/Temp-Tables ---------------------------------------------------------*/

define temp-table ttDatabase no-undo
  field DatabaseName            as character
    format 'x(30)':U
    label 'Database':T
  field PhysicalName            as character
    format 'x(255)':U
    label 'Physical name':T
  field DisplayPriority         as integer
  field DirectoryName           as character
  field HostName                as character
  field ServiceName             as integer /* = Port */
  field TempDB                  as logical
  field BasisDB                 as logical
  field BasisDBName             as character
  field PhysicalDB              as logical
  field SharedMemory            as logical
  field VirtualDBFieldsPossible as logical
  field VirtualIndicesPossible  as logical
  index Main is primary unique
    DatabaseName
  index PhysicalName is unique
    PhysicalName
    DatabaseName
  index TempDB
    TempDB
    DatabaseName
  index DirectoryBasisDB
    DirectoryName
    BasisDB
    DatabaseName
  index HostBasisDB
    HostName
    BasisDB
    ServiceName
    DatabaseName
  index DisplayPriority
    DisplayPriority
    DatabaseName
    .

define temp-table ttTable no-undo
  field DatabaseName            like ttDatabase.DatabaseName
  field TableName               as character
    format 'x(32)':U
    label 'Table':T
  field ShortDescription        as character
    format 'x(80)':U
    label 'Short Description':U
  field TableFilterMatches      as logical
  field TableFieldFilterMatches as logical
  field CreateTrigger           as character
  field CreateTriggerProcName   as character
    format 'x(32)':U
    label 'Create trigger':T
  field WriteTrigger            as character
  field WriteTriggerProcName    as character
    format 'x(32)':U
    label 'Write trigger':T
  field DeleteTrigger           as character
  field DeleteTriggerProcName   as character
    format 'x(32)':U
    label 'Delete trigger':T
  field CompanyInclude          as character
    format 'x(12)':U
    label 'Company include':T
  field KeyInclude              as character
    format 'x(12)':U
    label 'Key include':T
  field FillInclude              as character
    format 'x(12)':U
    label 'Key include':T
  field InternalIdentifier      as character
  field PrimaryIndexName        as character
  field DetailsLoaded           as logical
  field DescriptionLoaded       as logical
  field PhysicalTable           as logical
  field TableHandle             as handle
  field OriginalTableHandle     as handle
  field Snapshot                as logical
  field RepObjectId             as character
  field RepTableId              as character
  index Main is primary unique
    DatabaseName
    TableName
  index RepObjectId
    RepObjectId
    DatabaseName
    TableName
  index Filter
    DatabaseName
    TableFilterMatches
    TableFieldFilterMatches
    TableName
  index PhysicalTable
    PhysicalTable
    DatabaseName
    TableName
  index InternalId
    DatabaseName
    InternalIdentifier
    TableName
  index DescriptionLoaded
    DescriptionLoaded
    DatabaseName
    TableName
    .

define temp-table ttField no-undo
  field DatabaseName       like ttDatabase.DatabaseName
  field TableName          like ttTable.TableName
  field FieldName          as character
    format 'x(32)':U
    label 'Field':T
  field RepObjectId        as character
  field DataType           as character
    format 'x(13)':U
    label 'Data type':T
  field FieldFormat        as character
    format 'x(30)':U
    label 'Format':T
  field FieldExtent        as integer
    format '>>>9':U
    label 'Extent':T
  field FieldDecimals      as integer
    format '>>>9':U
    label 'Decimals':T
  field FieldInitialValue  as character
    format 'x(30)':U
    label 'Initial':U
  field FieldLabel         as character
    format 'x(30)':U
    label 'Label':T
  field FieldColumnLabel   as character
    format 'x(30)':U
    label 'Column-Label':T
  field IsMandatory        as logical
    format 'yes/no':U
    label 'Mandatory':T
    view-as toggle-box
  field Domain             as character
    format 'x(40)':U
    label 'Domain':T
  field FieldViewAs        as character
    format 'x(50)':U
    label 'View as':T
  field IsObjectId         as logical
  field IsVirtual          as logical
    format '*/':U
    label 'Virtual Field':T
    column-label 'V':T
  field FieldType          as integer
  field FieldFilterMatches as logical
  index Main is primary unique
    DatabaseName
    TableName
    FieldName
  index RepObjectId
    RepObjectId
    DatabaseName
    TableName
    FieldName
  index FieldName
    DatabaseName
    FieldName
    TableName
  index VirtualField
    DatabaseName
    TableName
    IsVirtual
    FieldType
    DataType
    FieldName
  index FieldLabel
    DatabaseName
    FieldLabel
    TableName
    FieldName
  index Filter
    DatabaseName
    TableName
    FieldFilterMatches
    FieldName
    .

define temp-table ttIndex no-undo
  field DatabaseName                   like ttDatabase.DatabaseName
  field TableName                      like ttTable.TableName
  field IndexName                      as character
    format 'x(32)':U
    label 'Index':T
  field IsPrimary                      as logical
    format '*/ ':U
    label 'P':T
  field IndexFields                    as character
    format 'x(255)':U
    label 'Fields':T
  field IndexFieldList                 as character
  field IsUnique                       as logical
    format '*/ ':U
    label 'U':T
  field IndexFilterMatches             as logical
  field IndexFieldFilterMatches        as logical
  field IsVirtual                      as logical
    format '*/':U
    label 'V':U
  field VirtualFieldList               as character
  field VirtualFieldDataTypes          as character
  field VirtualIndexDataFieldList      as character
  field VirtualIndexDataFieldLabels    as character
  field VirtualIndexDataUntaggedValues as character
  field VirtualIndexDataTaggedValues   as character
  index Main is primary unique
    DatabaseName
    TableName
    IndexName
  index IsPrimary
    DatabaseName
    TableName
    IsPrimary
    IndexName
  index IsUnique
    DatabaseName
    TableName
    IsUnique
    IndexName
  index Filter
    DatabaseName
    TableName
    IndexFilterMatches
    IndexFieldFilterMatches
    IndexName
    .

define temp-table ttIndexField no-undo
  field DatabaseName  like ttDatabase.DatabaseName
  field TableName     like ttTable.TableName
  field IndexName     as character
  field IndexSequence as integer
  field FieldName     like ttField.FieldName
  field DataType      as character
  field SortAscending as logical
  index Main is primary unique
    DatabaseName
    TableName
    IndexName
    IndexSequence
  index FieldName
    DatabaseName
    TableName
    IndexName
    FieldName
    IndexSequence
    .

define temp-table ttTableRelation no-undo
  field RelationId       as integer
  field DatabaseName     like ttDatabase.DatabaseName
  field ParentTableName  like ttTable.TableName
    label 'Parent table':T
  field ChildTableName   like ttTable.TableName
    label 'Child table':T
  field SequentialNumber as integer
  field RelationType     as character
  field ParentFields     as character
  field ChildFields      as character
  field ParentFieldList  as character
  field ChildFieldList   as character
  index Main is primary unique
    RelationId
  index ParentTableName is unique
    DatabaseName
    ParentTableName
    ChildTableName
    SequentialNumber
  index ChildTableName is unique
    DatabaseName
    ChildTableName
    ParentTableName
    SequentialNumber
    .

define temp-table ttTableRelationField no-undo
  field RelationId         as integer
  field Order              as integer
  field ParentFieldName    like ttField.FieldName
    label 'Parent field':U
  field ParentConstantData as character
  field ChildFieldName     like ttField.FieldName
    label 'Child field':U
  field ChildConstantData  as character
  field FieldRelationType  as character
  index Main is primary unique
    RelationId
    Order
  index ParentFieldName
    ParentFieldName
    RelationId
    Order
  index ChildFieldName
    ChildFieldName
    RelationId
    Order
    .

define temp-table ttTableRelationView no-undo
  field RelationViewId     as integer
  field RelationId         like ttTableRelation.RelationId
  field DatabaseName       like ttTableRelation.DatabaseName
  field ReferenceTableName like ttTable.TableName
  field RelatedTableName   like ttTable.TableName
  field RelationType       as character
    label 'Type':T
    format 'x(4)':U
  field ReferenceFields    as character
    label 'Fields':T
    format 'x(1024)':U
  field RelatedFields      as character
    label 'Fields':T
    format 'x(1024)':U
  field FieldDetails      as character
    label 'Field details':T
    format 'x(1024)':U
  field ParentRelation    as logical
    label 'Parent Relation':T
    column-label 'CP':U
    format 'P/C':U
  field ReferenceFieldList as character
  field RelatedFieldList   as character
  field TableFilterMatches as logical
  field FieldFilterMatches as logical
  field ParentRelationFilterMatches as logical
  index Main is primary unique
    RelationViewId
  index RelationId
    RelationId
    DatabaseName
    ReferenceTableName
    RelatedTableName
    RelationViewId
  index TableName
    DatabaseName
    ReferenceTableName
    RelatedTableName
    RelationId
    RelationViewId
    .

define temp-table ttBufferComparisonField no-undo
  field FieldName    as character
  field FieldIndex   as integer
  field BufferNo     as integer
  field DataType     as character
  field FieldFormat  as character
  field DatabaseName as character
  field TableName    as character
  field BufferName   as character
  field FieldValue   as clob
  field IsEqual      as logical initial ?
  field IsVirtual    as logical
  field FieldType    as integer
  index Main is primary unique
    FieldName
    FieldIndex
    BufferNo
  index BufferNo
    BufferNo
    FieldName
    FieldIndex
  index IsEqual
    IsEqual
    BufferNo
    FieldName
    FieldIndex
  index DataType
    DataType
    FieldName
    FieldIndex
    BufferNo
    .

define temp-table ttFilterMatch no-undo
  field FilterId as integer
  field RecordRowId as rowid
  field RecordMatches as logical
  index Main is primary unique
    FilterId
    RecordRowId
  index RecordMatch
    FilterId
    RecordMatches
    RecordRowId
    .

define temp-table ttQueryWindow no-undo
  field WindowHandle                 as handle
  field QuerySeq                     as integer
  field WindowMode                   as integer
  field QueryText                    as character
  field QueryHandle                  as handle
  field QueryFrameHandle             as handle
  field QueryMenuHandle              as handle
  field QueryTextEditorHandle        as handle
  field QueryFieldBrowseHandle       as handle
  field QueryFieldBrowseBufferHandle as handle
  field QueryFieldBrowseColHandles   as handle extent 4
  field QueryBrowseHandle            as handle
  field QueryBrowseSelectedColumn    as handle
  field RecordFrameHandle            as handle
  field RecordMenuHandle             as handle
  field RecordQueryHandle            as handle
  field RecordBrowseHandle           as handle
  field RecordBrowseColHandles       as handle extent 5
  field DisplayRawValues             as logical
  field ApplyColumnFormats           as logical
  field ObjSourceQuerySeq            as integer
  field ObjSourceBufferName          as character
  field ObjSourceFieldName           as character
  field ObjSourceFieldIndex          as integer
  field ObjTargetTableId             as character
  field ObjTargetTableName           as character
  field DeepResolveObjectIds         as logical
  field WindowTitle                  as character
    label 'Query window':T
    format 'x(255)':U
  field Updated                    as logical
  field MissingObjectIdFields      as character
  field LastMissingObjectIdRecords as character
  index Main is primary unique
    WindowHandle
  index QuerySeq is unique
    QuerySeq
    .

define temp-table ttQueryWindowQueryBrowseColumn no-undo
  field WindowHandle   as handle
  field ColumnHandle   as handle
  field OriginalFormat as character
  field RawFormat      as character
  index Main is primary unique
    ColumnHandle
  index WindowHandle is unique
    WindowHandle
    ColumnHandle
    .

define temp-table ttQueryWindowField no-undo
  field WindowHandle            as handle
  field BufferId                as integer
  field DatabaseName            like ttDatabase.DatabaseName
  field TableName               like ttTable.TableName
  field BufferName              like ttTable.TableName
    label 'Buffer':T
    column-label 'Buffer':T
  field FieldName               like ttField.FieldName
  field FieldIndex              as integer
    format '>>>9':U
    label 'Idx':T
  field IsOverlay               as logical
  field IsOverlayResolved       as logical
  field FieldLabel              as character
    format 'x(30)':U
    label 'Label':T
  field DisplayName             like ttField.FieldName
    format 'x(255)':U
  field DataType                like ttField.DataType
  field FieldFormat             like ttField.FieldFormat
  field FieldViewAs             like ttField.FieldViewAs
  field FieldType               like ttField.FieldType
  field IsVirtual               like ttField.IsVirtual
  field IsObjectId              like ttField.IsObjectId
  field BufferHandle            as handle
  field FieldHandle             as handle
  field OldFormattedValue       as clob
  field OldUnformattedValue     as clob
  field OldDisplayValue         as character
    format 'x(255)':U
    label 'Old value':U
  field CurrentFormattedValue   as clob
  field CurrentUnformattedValue as clob
  field CurrentDisplayValue     as character
    format 'x(255)':U
    label 'Current value':U
  field Order                   as integer
  index Main is primary unique
    WindowHandle
    BufferId
    FieldName
    FieldIndex
    IsOverlay
  index BufferName
    WindowHandle
    BufferName
    FieldName
    FieldIndex
    IsOverlay
  index Order
    WindowHandle
    Order
    BufferId
    FieldName
    FieldIndex
    IsOverlay
  index IsVirtual
    WindowHandle
    BufferId
    IsVirtual
    FieldName
    FieldIndex
    IsOverlay
    .

define temp-table ttQueryWindowFieldChanges no-undo like ttQueryWindowField.

define temp-table ttQueryWindowObjField no-undo
  field WindowHandle       as handle
  field DatabaseName       like ttDatabase.DatabaseName
  field TableName          like ttTable.TableName
  field BufferName         like ttTable.TableName
    label 'Buffer':T
    column-label 'Buffer':T
  field FieldName          like ttField.FieldName
  field FieldIndex         as integer
    format '>>>9':U
    label 'Idx':T
  field DisplayName        like ttField.FieldName
    format 'x(255)':U
  field IsObjectId         like ttField.IsObjectId
  field IsVirtual          like ttField.IsVirtual
  field FieldType          like ttField.FieldType
  field ContainsObj        as logical
  field TargetDatabaseName like ttDatabase.DatabaseName
    label 'Target database':T
    column-label 'Target db':T
  field TargetTableName    like ttTable.TableName
    label 'Target table':T
    column-label 'Target table':T
  field Priority           as integer
  index Main is primary unique
    WindowHandle
    BufferName
    FieldName
    FieldIndex
  index TableName
    WindowHandle
    DatabaseName
    TableName
    FieldName
    FieldIndex
  index Priority
    WindowHandle
    Priority
    DatabaseName
    TableName
    FieldName
    FieldIndex
    .

define temp-table ttFieldOverlay no-undo
  field OwnerHandle         as handle
  field DatabaseName        as character
  field BufferName          as character
  field FieldName           like ttField.FieldName
  field FieldIndex          as integer
  field ColumnHandle        as handle
  field FieldHandle         as handle
  field OverlayTableId      as character
  field OverlayBufferHandle as handle
  field OverlayColumnHandle as handle
  index Main is primary unique
    OwnerHandle
    BufferName
    FieldName
    FieldIndex
  index ColumnHandle
    OwnerHandle
    ColumnHandle
  index OverlayColumnHandle
    OwnerHandle
    OverlayColumnHandle
    .

define temp-table ttQueryWindowView no-undo
  field Id                 as integer
  field Root               as integer
  field ParentWindowHandle as handle
  field WindowHandle       as handle
  field WindowMode         as integer
  field Depth              as integer
  field LineText           as character
    label 'Query window':T
    format 'x(255)':U
  index Main is primary unique
    ParentWindowHandle
    WindowHandle
  index WindowHandle
    WindowHandle
    ParentWindowHandle
  index Id
    Id
  index Root
    Root
    Id
  index Depth
    Depth
    Root
    Id
    .

define temp-table ttSessionTrigger no-undo
  field Id                   as integer
  field TriggerEvent         as character
    label 'Trigger-Event':T 
    format 'x(6)':U
  field DatabaseName         like ttDatabase.DatabaseName
  field TableName            like ttTable.TableName
  field FieldName            like ttField.FieldName
  field ShowMessage          as logical initial yes
    label 'Show message':T
    column-label 'Msg':T
    view-as toggle-box
  field WriteLogfile         as logical initial yes
    label 'Write logfile':T
    column-label 'Log':T
    view-as toggle-box
  field LogfileName          as character
    label 'Logfile name':T
    column-label 'Logfile name':T
  field AddSnapshot          as logical
    label 'Add snapshot':T
    column-label 'Sn':T
    view-as toggle-box
  field SnapshotName         as character
    label 'Snapshot name':T
    column-label 'Snapshot name':T
    format 'x(32)':U
  field SnapshotScope        as character initial {&K_SNAPSHOT_SCOPE_RECORD}
    label 'Snapshot scope':T
    column-label 'SnSc':T
  field AdditionalInfoFields as character
    label 'Additional info fields':T
    format 'x(1024)':U
  field AdditionalInfo       as logical
  field AdditionalInfoText   as character
  field Condition            as logical
  field ConditionText        as character
  field CustomCode           as logical
  field CustomCodeText       as character
  field TriggerActive         as logical
    label 'Act':U
    view-as toggle-box
  field TriggerFileName      as character
  field ProcedureHandle      as handle
  index Main is primary unique
    Id
  index TriggerEvent
    TriggerEvent
    DatabaseName
    TableName
    FieldName
  index TriggerObject
    DatabaseName
    TableName
    FieldName
    TriggerEvent
    .

define temp-table ttRecentQuery no-undo
  field WindowHandle as handle
  field Order        as integer
  field QueryText    as character
  field OrderLabel   as integer
  field QueryLabel   as character
  index Main is primary unique
    WindowHandle
    QueryText
  index Order
    WindowHandle
    Order descending
    .

define temp-table ttRecentQueryBuffer no-undo
  field WindowHandle  as handle
  field RecentQueryId as integer
  field DatabaseName  as character
  field TableName     as character
  field BufferName    as character
  field Order         as integer
  
  .

define temp-table ttQueryLink no-undo
  field SourceSeq  as integer
  field TargetSeq  as integer
  field StartPos   as integer
  field EndPos     as integer
  field BufferName as character
  field FieldName  like ttField.FieldName
  field FieldIndex as integer
  index Main is primary unique
    TargetSeq
    SourceSeq
    StartPos
    EndPos
  index StartPos
    TargetSeq
    StartPos
    EndPos
    SourceSeq
    .

define temp-table ttExternalRecord no-undo
  field Id             as integer
  field DatabaseName   like ttDatabase.DatabaseName
  field TableName      like ttTable.TableName
  field BufferHandle   as handle
  field TableHandle    as handle
  field RecordRowId    as rowid
  field RecordKey      as character
    format 'x(32000)':U
    label 'Key':U
  index Main is primary unique
    Id
  index Record
    TableName
    RecordRowId
    .

define temp-table ttQueryBuffer no-undo
  field QuerySeq       as integer
    format 'zzzzz9':U
    label 'Id':T
  field BufferName     as character
    format 'x(50)':U
    label 'Buffer name':T
  field BufferHandle     as handle
  field DatabaseName     like ttDatabase.DatabaseName
  field TableName        like ttTable.TableName
  field TableDisplayName as character
    format 'x(1024)':U
    label 'Table':U
  field Order            as integer
  index Main is primary unique
    QuerySeq
    BufferName
  index Order
    QuerySeq
    Order
    BufferName
    .

define temp-table ttQueryBufferField no-undo
  field FieldHandle    as handle
  field FieldName      like ttField.FieldName
  field FieldIndex     as integer
  field DisplayName    as character
    format 'x(32)':U
    label 'Field name':T
  field IsVirtual      like ttField.IsVirtual
  index Main is primary unique
    FieldName
    FieldIndex
    .

define temp-table ttIDEHandler no-undo
  field HandlerName as character
  field HandlerId   as integer
  index Main is primary unique
    HandlerName
    .

define temp-table ttQueryWindowExport no-undo
  &IF proversion >= '11.2':U &THEN
    serialize-name 'QueryWindow':U
  &ELSE
    xml-node-name 'QueryWindow':U
  &ENDIF
  field QuerySeq             as integer
    &IF proversion >= '11.2':U &THEN
      serialize-name 'QueryId':U
    &ELSE
      xml-node-name 'QueryId':U
    &ENDIF
    column-label 'Id':T
  field WindowMode           as character
  field WindowState          as character
  field QueryText            as character
  field WindowWidth          as decimal
  field WindowHeight         as decimal
  field WindowColumn         as decimal
  field WindowRow            as decimal
  field BrowseColumns        as character initial ?
  field HideFieldList        as logical   initial ?
  field Splitter1Pos         as integer   initial ?
  field RecordBrowseColumns  as character initial ?
  field RecordBrowseFields   as character initial ?
  field DisplayRawValues     as logical   initial ?
  field ObjSourceQuerySeq    as integer
  field ObjSourceBufferName  as character
  field ObjSourceFieldName   as character
  field ObjSourceFieldIndex  as integer
  field DeepResolveObjectIds as logical
  field NewQuerySeq          as integer
    &IF proversion >= '11.2':U &THEN
      serialize-hidden
    &ELSE
      xml-node-type 'HIDDEN':U
    &ENDIF
  field WindowSelected       as logical
    initial yes
    column-label '':U
    &IF proversion >= '11.2':U &THEN
      serialize-hidden
    &ELSE
      xml-node-type 'HIDDEN':U
    &ENDIF
  field BufferList           as character
    format 'x(120)':U
    column-label 'Buffers':T
    &IF proversion >= '11.2':U &THEN
      serialize-hidden
    &ELSE
      xml-node-type 'HIDDEN':U
    &ENDIF
  index Main is primary unique
    QuerySeq
  index WindowSelected
    WindowSelected
    QuerySeq
    .

define temp-table ttQueryBufferExport no-undo
  &IF proversion >= '11.2':U &THEN
    serialize-name 'QueryBuffer':U
  &ELSE
    xml-node-name 'QueryBuffer':U
  &ENDIF
  field QuerySeq       as integer
    &IF proversion >= '11.2':U &THEN
      serialize-hidden
    &ELSE
      xml-node-type 'HIDDEN':U
    &ENDIF
  field BufferId       as integer
  field DatabaseName   like ttDatabase.DatabaseName
  field TableName      like ttTable.TableName
  field BufferName     as character
  index Main is primary unique
    QuerySeq
    BufferId
  index BufferName is unique
    QuerySeq
    BufferName
    .

define temp-table ttQueryFieldOverlayExport no-undo
  &IF proversion >= '11.2':U &THEN
    serialize-name 'FieldOverlay':U
  &ELSE
    xml-node-name 'FieldOverlay':U
  &ENDIF
  field QuerySeq    as integer
    &IF proversion >= '11.2':U &THEN
      serialize-hidden
    &ELSE
      xml-node-type 'HIDDEN':U
    &ENDIF
  field BufferId    as integer
    &IF proversion >= '11.2':U &THEN
      serialize-hidden
    &ELSE
      xml-node-type 'HIDDEN':U
    &ENDIF
  field FieldName   like ttField.FieldName
  field FieldIndex  as integer
  field OverlayType as character
    xml-node-type 'ATTRIBUTE':U
  index Main is primary unique
    QuerySeq
    BufferId
    FieldName
    FieldIndex
    .

define temp-table ttRecentQueryExport no-undo
  &IF proversion >= '11.2':U &THEN
    serialize-name 'QueryHistory':U
  &ELSE
    xml-node-name 'QueryHistory':U
  &ENDIF
  field QuerySeq   as integer
    &IF proversion >= '11.2':U &THEN
      serialize-name 'QueryId':U
    &ELSE
      xml-node-name 'QueryId':U
    &ENDIF
  field Order      as integer
  field QueryText  as character
  index Main is primary unique
    QuerySeq
    Order
    .

define dataset dsQueryWindowExport
  &IF proversion >= '11.2':U &THEN
    serialize-name 'QueryScenario':U
  &ELSE
    xml-node-name 'QueryScenario':U
  &ENDIF
  for ttQueryWindowExport, ttQueryBufferExport, ttQueryFieldOverlayExport,
    ttRecentQueryExport
  data-relation QueryBuffer for ttQueryWindowExport, ttQueryBufferExport
    relation-fields(QuerySeq, QuerySeq)
    nested
  data-relation FieldOverlay for ttQueryBufferExport, ttQueryFieldOverlayExport
    relation-fields(QuerySeq, QuerySeq, BufferId, BufferId)
    nested
  data-relation RecentQuery for ttQueryWindowExport, ttRecentQueryExport
    relation-fields(QuerySeq, QuerySeq)
    nested
    .

define temp-table ttPersistentProcedure no-undo
  field ProcedureName as character
    format 'x(255)':U
    column-label 'Procedure':T
  index Main is primary unique
    ProcedureName
    .

define temp-table ttPersistentTempTable no-undo
  field ProcedureName like ttPersistentProcedure.ProcedureName
  field TableHandle   as handle
  field TableName     like ttTable.TableName
  index Main is primary unique
    ProcedureName
    TableHandle
  index TableName
    ProcedureName
    TableName
    .

define temp-table ttQueryAST no-undo
  field Id           as integer
  field ParentId     as integer
  field TokenStart   as integer
  field TokenEnd     as integer
  field TokenType    as integer
  field NodeType     as integer
  field TokenText    as character
    format 'x(255)':U
  field Level        as integer
  index Main is primary unique
    Id
  index ParentId
    ParentId
    TokenStart
    TokenEnd
  index TokenType
    TokenType
    TokenStart
    TokenEnd
    TokenText
  index NodeType
    NodeType
    TokenStart
    TokenEnd
    TokenText
  index TokenStart
    TokenStart
    TokenEnd
    TokenType
    TokenText
    .

define temp-table ttQueryCondition no-undo
  field StartPos           as integer
  field EndPos             as integer
  field LeftStartPos       as integer
  field LeftEndPos         as integer
  field ComparatorStartPos as integer
  field ComparatorEndPos   as integer
  field RightStartPos      as integer
  field RightEndPos        as integer
  index Main is primary unique
    StartPos
  EndPos
  index LeftStartPos
    LeftStartPos
    LeftEndPos
  index LeftEndPos
    LeftEndPos
    LeftStartPos
  index ComparatorStartPos
    ComparatorStartPos
    ComparatorEndPos
  index ComparatorEndPos
    ComparatorEndPos
    ComparatorStartPos
  index RightStartPos
    RightStartPos
    RightEndPos
  index RightEndPos
    RightEndPos
    RightStartPos
    .

define temp-table ttQueryLine no-undo
  field LineNo          as integer
  field StartPos        as integer
  field EndPos          as integer
  field ExceedingToken  as logical
  field LineLevel       as integer
  field LineIndentation as integer
  index Main is primary unique
    LineNo.

{adecomm/oeideservice.i}


&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure SetForegroundWindow external 'user32.dll':U:
    define input  parameter hwnd    as int64 no-undo.
  end procedure.
&ELSE
  procedure SetForegroundWindow external 'user32.dll':U:
    define input  parameter hwnd    as long no-undo.
  end procedure.
&ENDIF

procedure GetKeyState external 'user32.dll':U:
    define input  parameter iVirtKey as long      no-undo.
    define return parameter iResult  as short     no-undo.
end procedure.

procedure ExpandEnvironmentStringsA external "kernel32.dll":
  define input  parameter cString        as character no-undo.
  define output parameter cRetString     as character no-undo.
  define input  parameter iStringSize    as long      no-undo.
  define return parameter iRetStringSize as long      no-undo.
end procedure.

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure RegOpenKeyExA external 'advapi32':U:
    define input  parameter iKey       as long      no-undo.
    define input  parameter cSubKey    as character no-undo.
    define input  parameter iOptions   as long      no-undo.
    define input  parameter iDesired   as long      no-undo.
    define output parameter iResult    as int64     no-undo.
    define return parameter iRetResult as int64     no-undo.
  end procedure.
&ELSE
  procedure RegOpenKeyExA external 'advapi32':U:
    define input  parameter iKey       as long      no-undo.
    define input  parameter cSubKey    as character no-undo.
    define input  parameter iOptions   as long      no-undo.
    define input  parameter iDesired   as long      no-undo.
    define output parameter iResult    as long      no-undo.
    define return parameter iRetResult as long      no-undo.
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure RegQueryValueExA external 'advapi32':U:
    define input  parameter ikey         as long      no-undo.
    define input  parameter iPValueName  as character no-undo.
    define input  parameter iPdwReserved as long      no-undo.
    define output parameter iPdwType     as long      no-undo.
    define input  parameter iPbData      as int64     no-undo.
    define output parameter iPcbData     as long      no-undo.
    define return parameter iPResult     as long      no-undo.
  end procedure.
&ELSE
  procedure RegQueryValueExA external 'advapi32':U:
    define input  parameter ikey         as long      no-undo.
    define input  parameter iPValueName  as character no-undo.
    define input  parameter iPdwReserved as long      no-undo.
    define output parameter iPdwType     as long      no-undo.
    define input  parameter iPbData      as long      no-undo.
    define output parameter iPcbData     as long      no-undo.
    define return parameter iPResult     as long      no-undo.
  end procedure.
&ENDIF

procedure RegCloseKey external 'advapi32':U:
  define input  parameter iKey     as long      no-undo.
  define return parameter iPResult as long      no-undo.
end procedure.

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure GetParent external 'user32.dll':U:
     define input  parameter plHWND    as int64     no-undo.
     define return parameter plWinLong as long      no-undo.
  end procedure.
&ELSE
  procedure GetParent external 'user32.dll':U:
     define input  parameter plHWND    as long      no-undo.
     define return parameter plWinLong as long      no-undo.
end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure GetWindowRect external 'user32.dll':U:
    define input  parameter hWnd    as int64     no-undo.
    define output parameter lpRect  as memptr    no-undo.
    define return parameter iResult as long      no-undo.
  end procedure.
&ELSE
  procedure GetWindowRect external 'user32.dll':U:
    define input  parameter hWnd    as long      no-undo.
    define output parameter lpRect  as memptr    no-undo.
    define return parameter iResult as long      no-undo.
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure GetWindowLongA external 'user32.dll':U:
    define input  parameter phwnd       as int64      no-undo.
    define input  parameter cindex      as long      no-undo.
    define return parameter ReturnValue as long      no-undo.
  end procedure.
&ELSE
  procedure GetWindowLongA external 'user32.dll':U:
    define input  parameter phwnd       as long      no-undo.
    define input  parameter cindex      as long      no-undo.
    define return parameter ReturnValue as long      no-undo.
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure SetWindowLongA external 'user32.dll':U:
    define input  parameter hWnd         as int64         no-undo.
    define input  parameter nIndex       as long          no-undo.
    define input  parameter dwNewLong    as unsigned-long no-undo.
    define return parameter ReturnValue  as long          no-undo.
  end procedure.
&ELSE
  procedure SetWindowLongA external 'user32.dll':U:
    define input  parameter hWnd         as long          no-undo.
    define input  parameter nIndex       as long          no-undo.
    define input  parameter dwNewLong    as unsigned-long no-undo.
    define return parameter ReturnValue  as long          no-undo.
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure SetWindowPos external 'user32.dll':U:
    define input  parameter hWnd            as int64         no-undo.
    define input  parameter hWndInsertAfter as int64         no-undo.
    define input  parameter X               as long          no-undo.
    define input  parameter Y               as long          no-undo.
    define input  parameter cx              as long          no-undo.
    define input  parameter cy              as long          no-undo.
    define input  parameter uFlags          as long          no-undo.
    define return parameter ReturnValue     as long          no-undo.
  end procedure.
&ELSE
  procedure SetWindowPos external 'user32.dll':U:
    define input  parameter hWnd            as long          no-undo.
    define input  parameter hWndInsertAfter as long          no-undo.
    define input  parameter X               as long          no-undo.
    define input  parameter Y               as long          no-undo.
    define input  parameter cx              as long          no-undo.
    define input  parameter cy              as long          no-undo.
    define input  parameter uFlags          as long          no-undo.
    define return parameter ReturnValue     as long          no-undo.
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure ShellExecuteA external 'shell32.dll':U:
    define input  parameter hwnd         as int64. /* Handle to parent window */
    define input  parameter lpOperation  as char.  /* Operation to perform: open, print */
    define input  parameter lpFile       as char.  /* Document or executable name */
    define input  parameter lpParameters as char.  /* Command line parameters to executable in lpFile */
    define input  parameter lpDirectory  as char.  /* Default directory */
    define input  parameter nShowCmd     as long.  /* whether shown when opened: */
                                                   /* 0 hidden, 1 normal, minimized 2, maximized 3, etc.*/
                                                   /* 0 if lpFile is a document */
    define return parameter hInstance    as long.  /* >32 -> Success ; <=32 -> Errorcode */
  end procedure.
&ELSE
  procedure ShellExecuteA external 'shell32.dll':U:
    define input  parameter hwnd         as long. /* Handle to parent window */
    define input  parameter lpOperation  as char. /* Operation to perform: open, print */
    define input  parameter lpFile       as char. /* Document or executable name */
    define input  parameter lpParameters as char. /* Command line parameters to executable in lpFile */
    define input  parameter lpDirectory  as char. /* Default directory */
    define input  parameter nShowCmd     as long. /* whether shown when opened: */
                                                  /* 0 hidden, 1 normal, minimized 2, maximized 3, etc.*/
                                                  /* 0 if lpFile is a document */
    define return parameter hInstance    as long. /* >32 -> Success ; <=32 -> Errorcode */
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure FindWindowA external "user32.dll":
    define input  parameter iClassName as long.
    define input  parameter cCaption   as character.
    define return parameter iHandle    as int64.
  end procedure.
&ELSE
  procedure FindWindowA external "user32.dll":
    define input  parameter iClassName as long.
    define input  parameter cCaption   as character.
    define return parameter iHandle    as long.
  end procedure.
&ENDIF

&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
  procedure SetFocus external "user32.dll":
    define input  parameter hWnd     as int64         no-undo.
    define return parameter hPrevWnd as long          no-undo.
  end procedure.
&ELSE
  procedure SetFocus external "user32.dll":
    define input  parameter hWnd as long          no-undo.
    define return parameter hPrevWnd as long          no-undo.
  end procedure.
&ENDIF

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-PREPROCESSOR-BLOCK 

/* ********************  Preprocessor Definitions  ******************** */

&Scoped-define PROCEDURE-TYPE Window
&Scoped-define DB-AWARE no

/* Name of designated FRAME-NAME and/or first browse and/or first query */
&Scoped-define FRAME-NAME fQuery
&Scoped-define BROWSE-NAME brDatabase

/* Internal Tables (found by Frame, Query & Browse Queries)             */
&Scoped-define INTERNAL-TABLES ttDatabase ttField ttIndex ~
ttTableRelationView ttTable

/* Definitions for BROWSE brDatabase                                    */
&Scoped-define FIELDS-IN-QUERY-brDatabase ttDatabase.DatabaseName ttDatabase.PhysicalName   
&Scoped-define ENABLED-FIELDS-IN-QUERY-brDatabase   
&Scoped-define SELF-NAME brDatabase
&Scoped-define QUERY-STRING-brDatabase FOR EACH ttDatabase WHERE true   NO-LOCK   BY ttDatabase.DisplayPriority BY ttDatabase.DatabaseName
&Scoped-define OPEN-QUERY-brDatabase OPEN QUERY brDatabase FOR EACH ttDatabase WHERE true   NO-LOCK   BY ttDatabase.DisplayPriority BY ttDatabase.DatabaseName.
&Scoped-define TABLES-IN-QUERY-brDatabase ttDatabase
&Scoped-define FIRST-TABLE-IN-QUERY-brDatabase ttDatabase


/* Definitions for BROWSE brField                                       */
&Scoped-define FIELDS-IN-QUERY-brField ttField.FieldName ttField.IsVirtual ttField.DataType ttField.FieldExtent ttField.FieldDecimals ttField.FieldInitialValue ttField.FieldFormat ttField.FieldLabel ttField.FieldColumnLabel ttField.IsMandatory ttField.Domain   
&Scoped-define ENABLED-FIELDS-IN-QUERY-brField   
&Scoped-define SELF-NAME brField
&Scoped-define QUERY-STRING-brField FOR EACH ttField WHERE true and ttField.DatabaseName = ttDatabase.DatabaseName and ttField.TableName = ttTable.TableName and ttField.FieldFilterMatches = yes and ( glShowVirtualFields    or ttField.IsVirtual <> yes )  NO-LOCK
&Scoped-define OPEN-QUERY-brField OPEN QUERY brField FOR EACH ttField WHERE true and ttField.DatabaseName = ttDatabase.DatabaseName and ttField.TableName = ttTable.TableName and ttField.FieldFilterMatches = yes and ( glShowVirtualFields    or ttField.IsVirtual <> yes )   NO-LOCK.
&Scoped-define TABLES-IN-QUERY-brField ttField
&Scoped-define FIRST-TABLE-IN-QUERY-brField ttField


/* Definitions for BROWSE brIndex                                       */
&Scoped-define FIELDS-IN-QUERY-brIndex ttIndex.IsPrimary ttIndex.IndexName ttIndex.IsUnique ttIndex.IsVirtual ttIndex.IndexFields   
&Scoped-define ENABLED-FIELDS-IN-QUERY-brIndex   
&Scoped-define SELF-NAME brIndex
&Scoped-define QUERY-STRING-brIndex FOR EACH ttIndex WHERE true   AND ttIndex.DatabaseName = ttDatabase.DatabaseName   and ttIndex.TableName = ttTable.TableName   AND ttIndex.IndexFilterMatches = yes   AND ttIndex.IndexFieldFilterMatches = yes  and ( glShowVirtualIndices    or ttIndex.IsVirtual <> yes )   NO-LOCK
&Scoped-define OPEN-QUERY-brIndex OPEN QUERY brIndex FOR EACH ttIndex WHERE true   AND ttIndex.DatabaseName = ttDatabase.DatabaseName   and ttIndex.TableName = ttTable.TableName   AND ttIndex.IndexFilterMatches = yes   AND ttIndex.IndexFieldFilterMatches = yes  and ( glShowVirtualIndices    or ttIndex.IsVirtual <> yes )   NO-LOCK.
&Scoped-define TABLES-IN-QUERY-brIndex ttIndex
&Scoped-define FIRST-TABLE-IN-QUERY-brIndex ttIndex


/* Definitions for BROWSE brRelation                                    */
&Scoped-define FIELDS-IN-QUERY-brRelation ttTableRelationView.RelatedTableName ttTableRelationView.RelationType ttTableRelationView.ParentRelation ttTableRelationView.RelatedFields ttTableRelationView.FieldDetails  
&Scoped-define ENABLED-FIELDS-IN-QUERY-brRelation   
&Scoped-define SELF-NAME brRelation
&Scoped-define QUERY-STRING-brRelation FOR EACH ttTableRelationView WHERE true   AND ttTableRelationView.DatabaseName = ttDatabase.DatabaseName   and ttTableRelationView.ReferenceTableName = ttTable.TableName   AND ttTableRelationView.TableFilterMatches = yes   AND ttTableRelationView.FieldFilterMatches = yes   NO-LOCK
&Scoped-define OPEN-QUERY-brRelation OPEN QUERY brRelation FOR EACH ttTableRelationView WHERE true   AND ttTableRelationView.DatabaseName = ttDatabase.DatabaseName   and ttTableRelationView.ReferenceTableName = ttTable.TableName   AND ttTableRelationView.TableFilterMatches = yes   AND ttTableRelationView.FieldFilterMatches = yes   AND ttTableRelationView.ParentRelationFilterMatches = yes   NO-LOCK.
&Scoped-define TABLES-IN-QUERY-brRelation ttTableRelationView
&Scoped-define FIRST-TABLE-IN-QUERY-brRelation ttTableRelationView


/* Definitions for BROWSE brTable                                       */
&Scoped-define FIELDS-IN-QUERY-brTable ttTable.TableName ttTable.ShortDescription  
&Scoped-define ENABLED-FIELDS-IN-QUERY-brTable   
&Scoped-define SELF-NAME brTable
&Scoped-define QUERY-STRING-brTable FOR EACH ttTable WHERE true   AND ttTable.DatabaseName = ttDatabase.DatabaseName   AND ttTable.TableFilterMatches = yes   AND ttTable.TableFieldFilterMatches = yes   AND (glShowHiddenTables     OR (  not can-do('sys*':U, ~
       ttTable.TableName)       and not can-do('_*':U, ~
       ttTable.TableName)))   NO-LOCK
&Scoped-define OPEN-QUERY-brTable OPEN QUERY brTable FOR EACH ttTable WHERE true   AND ttTable.DatabaseName = ttDatabase.DatabaseName   AND ttTable.TableFilterMatches = yes   AND ttTable.TableFieldFilterMatches = yes   AND (glShowHiddenTables     OR (  not can-do('sys*':U, ~
       ttTable.TableName)       and not can-do('_*':U, ~
       ttTable.TableName)))   NO-LOCK.
&Scoped-define TABLES-IN-QUERY-brTable ttTable
&Scoped-define FIRST-TABLE-IN-QUERY-brTable ttTable


/* Definitions for FRAME fQuery                                         */

/* Standard List Definitions                                            */
&Scoped-Define ENABLED-OBJECTS gdIndexUsage btnClearFieldLabelFilter ~
gcFieldLabelFilter gcFieldDummy brDatabase btnConnectDB btnDisconnectDB ~
btnRefresh gcTableFilter btnClearTableFilter gcTableFieldFilter ~
btnClearTableFieldFilter brTable giDisplayMode glInvertQuery gcFieldFilter ~
btnClearFieldFilter brField gcIndexFilter btnClearIndexFilter ~
gcIndexFieldFilter btnClearIndexFieldFilter brIndex gcBufferName ~
btnClearBufferPattern btnBuffer1 btnBuffer2 btnBuffer3 btnBuffer4 ~
glDefineBuffer glCompanyViaClass glExclusiveLock glNoError glIfStatement ~
glNot glDoBlock glOnError giOnErrorPhrase giQueryTypeModifier gcBlockName btnClearBlockName ~
btnBlock1 btnBlock2 btnBlock3 btnBlock4 glDefineBlock glRetryBlock ~
glFinallyBlock giQueryType btnCopyToClipboard btnExecuteQuery btnResetAll ~
btnIncreaseIndentation btnDecreaseIndentation btnResetIndentation btnOf ~
gcQueryText brRelation gcRelationFilter gcRelationFieldFilter ~
btnClearRelationFilter btnClearRelationFieldFilter glDefineVariables ~
glUseVirtualIndexIncludes
&Scoped-Define DISPLAYED-OBJECTS gdIndexUsage gcFieldLabelFilter ~
gcFieldDummy gcTableFilter gcTableFieldFilter giDisplayMode glInvertQuery gcFieldFilter ~
gcIndexFilter gcIndexFieldFilter gcBufferName glDefineBuffer ~
glCompanyViaClass glExclusiveLock glNoError glIfStatement glNot glDoBlock ~
giOnErrorPhrase glOnError giQueryTypeModifier gcBlockName glDefineBlock glRetryBlock ~
glFinallyBlock giQueryType gcQueryText gcRelationFilter ~
gcRelationFieldFilter glDefineVariables glUseVirtualIndexIncludes

/* Custom List Definitions                                              */
/* List-1,List-2,List-3,List-4,List-5,List-6                            */

/* _UIB-PREPROCESSOR-BLOCK-END */
&ANALYZE-RESUME


/* ************************  Function Prototypes ********************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cBeautifyQueryText hQueryWindow 
function qg_cBeautifyQueryText returns character
  ( pcQueryText as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cBrowseColumnList hQueryWindow 
function qg_cBrowseColumnList returns character
  ( phBrowse      as handle,
    plBuffernames as logical,
    plAllColumns  as logical,
    plColumnWidth as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_clBrowseValues hQueryWindow 
function qg_clBrowseValues returns longchar
  ( phBrowse    as handle,
    plRawValues as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cBufferCompare hQueryWindow 
function qg_cBufferCompare returns character
  ( phBuffer1 as handle,
    phBuffer2 as handle ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cColumnFieldName hQueryWindow 
function qg_cColumnFieldName returns character
  ( phColumn      as handle,
    plBuffernames as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cCreateQueryText hQueryWindow 
function qg_cCreateQueryText returns character
  ( pcFieldList as character,
    plAddTags   as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cCreateRelationValueList hQueryWindow 
function qg_cCreateRelationValueList returns character
  ( pcFieldList      as character,
    piRelationId     as integer,
    plParentRelation as logical,
    pcBufferName     as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cCreateRelatedWhereClause hQueryWindow 
function qg_cCreateRelatedWhereClause returns character
  ( buffer pbttTableRelation for ttTableRelation,
    plParent           as logical,
    pcBufferName       as character,
    pcParentBufferName as character,
    piParentQuerySeq   as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cCreateWhereClause hQueryWindow 
function qg_cCreateWhereClause returns character
  ( pcDatabaseName   as character,
    pcTableName      as character,
    pcBufferName     as character,
    pcFieldList      as character,
    pcFieldLabelList as character,
    plStartWithWhere as logical, 
    piValueMode      as integer,
    pcValueList      as character,
    piAccessMode     as integer,
    plAddTags        as logical,
    piIndentBlanks   as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cCurrentFieldList hQueryWindow 
function qg_cCurrentFieldList returns character
  (  ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cExtractFieldName hQueryWindow 
function qg_cExtractFieldName returns character
  ( pcFieldName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFieldAssignments hQueryWindow 
function qg_cFieldAssignments returns character
  ( plInsertMode as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFieldAssignStatement hQueryWindow 
function qg_cFieldAssignStatement returns character
  ( plInsertMode as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFieldValues hQueryWindow 
function qg_cFieldValues returns character
  ( phBuffer    as handle,
    phOldBuffer as handle,
    pcFieldList as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFileName hQueryWindow
function qg_cFileName returns character 
  (pcFilename as character) forward.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME



&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFilterEntryMatchcode hQueryWindow 
function qg_cFilterEntryMatchcode returns character
  ( pcFilterEntry as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFixQuerySeq hQueryWindow 
function qg_cFixQuerySeq returns character
  ( pcQuerytext as character,
    piQuerySeq  as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cFormattedFieldName hQueryWindow 
function qg_cFormattedFieldName returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcFieldName    as character,
    piIndex        as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetBufferBaseName hQueryWindow 
function qg_cGetBufferBaseName returns character
  ( plCustomBuffer as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetCompany hQueryWindow 
function qg_cGetCompany returns character
  ( pcTableName as character,
    pcCompany   as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetCompanyInclude hQueryWindow 
function qg_cGetCompanyInclude returns character
  ( pcTableName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetDefaultValue hQueryWindow 
function qg_cGetDefaultValue returns character
  ( pcDatatype as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetFieldAssignmentsStatement hQueryWindow 
function qg_cGetFieldAssignmentsStatement returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcBufferName   as character,
    pcFieldList    as character,
    piValueMode    as integer,
    pcValueList    as character,
    plAddTags      as logical,
    piIndentBlanks as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetPrimaryKeyValues hQueryWindow 
function qg_cGetPrimaryKeyValues returns character
  ( phBuffer            as handle,
    pcSplitter          as character,
    plResolveObjectIds  as logical,
    plIncludeFieldNames as logical,
    plIncludeCompany    as logical,
    plQuoteValues       as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetPutStatement hQueryWindow 
function qg_cGetPutStatement returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcBufferName   as character,
    pcFieldList    as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetRelationField hQueryWindow 
function qg_cGetRelationField returns character
  ( buffer pbttTableRelation      for ttTableRelation,
    buffer pbttTableRelationField for ttTableRelationField,
    pcBufferName    as character,
    plParentValue   as logical,
    plKeyAllowed    as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cGetSelectedFields hQueryWindow 
function qg_cGetSelectedFields returns character
  ( pcBufferName as character,
    pcSeparator  as character,
    plQuoted     as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cIndexFieldValues hQueryWindow 
function qg_cIndexFieldValues returns character
  ( phBuffer    as handle,
    pcIndexName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cMaximumDataTypeFormat hQueryWindow
function qg_cMaximumDataTypeFormat returns character 
  ( pcDataType as character,
    piDecimals as integer ) forward.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cModulePathByChar hQueryWindow
function qg_cModulePathByChar returns character 
  ( pcChar as character ) forward.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME



&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cOverlayFieldValue hQueryWindow 
function qg_cOverlayFieldValue returns character
  ( buffer pbttFieldOverlay for ttFieldOverlay,
    pcFieldValue as character,
    plDeep       as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cParamListReadValue hQueryWindow 
function qg_cParamListReadValue returns character
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cParamListWriteCharacter hQueryWindow 
function qg_cParamListWriteCharacter returns character
  ( pcParamList  as character,
    pcParamName  as character,
    pcParamValue as character,
    pcSplitter   as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cParamListWriteDecimal hQueryWindow 
function qg_cParamListWriteDecimal returns character
  ( pcParamList  as character,
    pcParamName  as character,
    pdParamValue as decimal,
    pcSplitter   as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cParamListWriteInteger hQueryWindow 
function qg_cParamListWriteInteger returns character
  ( pcParamList  as character,
    pcParamName  as character,
    piParamValue as integer,
    pcSplitter   as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cParamListWriteLogical hQueryWindow 
function qg_cParamListWriteLogical returns character
  ( pcParamList  as character,
    pcParamName  as character,
    plParamValue as logical,
    pcSplitter   as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cPutStatement hQueryWindow 
function qg_cPutStatement returns character
  ( plInsertMode as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cQueryIndexInfo hQueryWindow 
function qg_cQueryIndexInfo returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcQueryText    as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cQueryLabel hQueryWindow 
function qg_cQueryLabel returns character
  ( pcQueryText as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cQueryLabel hQueryWindow 
function qg_cQueryWindowFieldList returns character
  ( phWindow      as handle,
    plBuffernames as logical,
    plAllFields   as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cReadRegistryValue hQueryWindow 
function qg_cReadRegistryValue returns character
  ( piSection as integer,
    pcSubKey  as character,
    pcKeyName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cReadRegistryValue hQueryWindow 
function qg_cReplaceColumn returns character
  ( pcColumnList as character,
    pcColumn     as character,
    pcNewColumn  as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cResolveObjectId hQueryWindow 
function qg_cResolveObjectId returns character
  ( pcDatabaseName as character,
    pcFieldName    as character,
    pcObjectId     as character,
    plForceQuote   as logical,
    plDeep         as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cResolveObjectIdForBuffer hQueryWindow 
function qg_cResolveObjectIdForBuffer returns character
  ( pcObjectId   as character,
    phBuffer     as handle,
    plTable      as logical,
    plForceQuote as logical,
    plDeep       as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cSoundexCode hQueryWindow 
function qg_cSoundexCode returns character
  ( pcText as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cStacktrace hQueryWindow 
function qg_cStacktrace returns character
  (  )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cSubstituteChar hQueryWindow 
function qg_cSubstituteChar returns character
  ( pcString   as character,
    pcFromChar as character,
    pcToChar   as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cSubstituteLinkTokens hQueryWindow 
function qg_cSubstituteLinkTokens returns character
  ( pcText          as character,
    piTargetSeq     as integer,
    phLinkTempTable as handle ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cSubstituteQueryLinkTokens hQueryWindow 
function qg_cSubstituteQueryLinkTokens returns character
  ( phWindow as handle ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cTaggedValue hQueryWindow 
function qg_cTaggedValue returns character
  ( pcText   as character,
    plAddTag as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_cTTWidgetPool hQueryWindow 
function qg_cTTWidgetPool returns character
  (  ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_dIndexUsage hQueryWindow 
function qg_dIndexUsage returns decimal
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcIndexName    as character,
    pcFieldList    as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_dParamListReadValue hQueryWindow 
function qg_dParamListReadValue returns decimal
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_hGetWidgetByName hQueryWindow 
function qg_hGetWidgetByName returns handle
  ( phContainer  as handle,
    pcWidgetName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_hStartSessionTrigger hQueryWindow 
function qg_hStartSessionTrigger returns handle
  ( piTriggerId as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_iExtractIndex hQueryWindow 
function qg_iExtractIndex returns integer
  ( pcFieldName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_iFilterSeq hQueryWindow 
function qg_iFilterSeq returns integer
  (  ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_iGetHandlerId hQueryWindow 
function qg_iGetHandlerId returns integer
  ( pcHandlerName as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_iParamListReadValue hQueryWindow 
function qg_iParamListReadValue returns integer
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lcClipboardValue hQueryWindow 
function qg_lcClipboardValue returns longchar
  (  ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lCheckLinkReference hQueryWindow 
function qg_lCheckLinkReference returns logical
  ( piQuerySeq     as integer,
    pcQuerySeqList as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lIsHostReachable hQueryWindow 
function qg_lIsHostReachable returns logical
  ( pcHost    as character, 
    pcService as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lParamListReadValue hQueryWindow 
function qg_lParamListReadValue returns logical
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lQueryOpen hQueryWindow 
function qg_lQueryOpen returns logical
  ( phQuery        as handle,
    pcQueryText    as character,
    phParentWindow as handle ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lSelectNextQueryCondition hQueryWindow 
function qg_lSelectNextQueryCondition returns logical
  ( phEditor as handle,
    plNext   as logical ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lTestBits hQueryWindow 
function qg_lTestBits returns logical
  ( piTestValue as integer,
    piRefValue  as integer ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD qg_lUniqueQuery hQueryWindow 
function qg_lUniqueQuery returns logical
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcFieldList    as character ) FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


/* ***********************  Control Definitions  ********************** */

/* Define the widget handle for the window                              */
DEFINE VAR hQueryWindow AS WIDGET-HANDLE NO-UNDO.

/* Menu Definitions                                                     */
DEFINE SUB-MENU m_File 
       MENU-ITEM mi_SaveQueryScenario LABEL "Save query scenario"
       MENU-ITEM mi_LoadQueryScenario LABEL "Load query scenario"
       RULE
       MENU-ITEM mi_Exit        LABEL "Exit"          .

DEFINE SUB-MENU m_Edit 
       MENU-ITEM mi_CopyQueryText LABEL "Copy query text"
       MENU-ITEM mi_InsertQueryText LABEL "Insert query text"
       RULE
       MENU-ITEM mi_CopyQueryScenario LABEL "Copy query scenario"
       MENU-ITEM mi_PasteQueryScenario LABEL "Paste query scenario".

DEFINE SUB-MENU m_Tools 
       MENU-ITEM mi_ExecuteQuery LABEL "Execute query"  ACCELERATOR "F2"
       MENU-ITEM mi_FindObjectIdRecord LABEL "Find object id record"  ACCELERATOR "SHIFT-F2"
       RULE
       MENU-ITEM mi_AddPersistentTempTable LABEL "Add persistent temp table" ACCELERATOR "F9"
       MENU-ITEM mi_AddSnapshot LABEL "Add snpapshot"  ACCELERATOR "F10"
       RULE
       MENU-ITEM mi_ImportTDF LABEL "Import TDF as Snapshot"
       MENU-ITEM mi_ImportPDS LABEL "Import PDS as Snapshot"
       RULE
       MENU-ITEM mi_ImportDatasetFile LABEL "Import Dataset File"
       MENU-ITEM mi_ImportTempTableFile LABEL "Import Temp-Table File"
       RULE
       MENU-ITEM mi_CopyQueryGeneratorSourcefilePath LABEL "Copy Query Generator Sourcefile Path"
       MENU-ITEM mi_CopyQueryGeneratorSource LABEL "Copy Query Generator Source"
       RULE
       MENU-ITEM mi_ResetAll    LABEL "Reset"          ACCELERATOR "F12".

DEFINE SUB-MENU m_Options 
       MENU-ITEM mi_InsertMode  LABEL "Insert mode"   
              TOGGLE-BOX
       RULE
       MENU-ITEM mi_ShowQueryTypeModifier  LABEL "Show Query type modifier"
              TOGGLE-BOX
       MENU-ITEM mi_AlwaysUseFindFirst  LABEL "Always use 'find first'"
              TOGGLE-BOX
       MENU-ITEM mi_AlwaysUseCanFindFirst  LABEL "Always use 'can-find first'"
              TOGGLE-BOX
       MENU-ITEM mi_UseVirtualIndexApi  LABEL "Use virtual index API"
              TOGGLE-BOX
       RULE
       MENU-ITEM mi_OpenQueryWindowPersistentTT LABEL "Open query window for persistent temp-tables"
              TOGGLE-BOX
       MENU-ITEM mi_OpenQueryWindowSnapshotTT LABEL "Open query window for snapshots"
              TOGGLE-BOX
       RULE
       MENU-ITEM mi_RepositoryLanguage LABEL "Repository Language".

DEFINE SUB-MENU m_Window 
       MENU-ITEM mi_SlimMode    LABEL "Slim mode"     
              TOGGLE-BOX
       MENU-ITEM mi_RestoreDefaultWindowSize LABEL "Restore default window size"
       RULE
       MENU-ITEM mi_OpenQueryWindowListWindow LABEL "Query windows" ACCELERATOR "CTRL-F7"
       MENU-ITEM mi_CloseAllQueryWindows LABEL "Close all query windows"
       RULE
       MENU-ITEM mi_SessionTriggers LABEL "Session triggers".

DEFINE SUB-MENU m_Help 
       MENU-ITEM mi_OpenQGWiki     LABEL "pA-Wiki (Query Generator)".
       MENU-ITEM mi_OpenPluginWiki LABEL "pA-Wiki (Query Generator Plugin)".
       RULE
       MENU-ITEM mi_About          LABEL "About Query Generator".

DEFINE MENU MENU-BAR-hQueryWindow MENUBAR
       SUB-MENU  m_File         LABEL "File"          
       SUB-MENU  m_Edit         LABEL "Edit"          
       SUB-MENU  m_Tools        LABEL "Tools"         
       SUB-MENU  m_Options      LABEL "Options"       
       SUB-MENU  m_Window       LABEL "Window"        
       SUB-MENU  m_Help         LABEL "Help"          .

DEFINE MENU POPUP-MENU-brDatabase 
       MENU-ITEM mi_CopyDatabaseName LABEL "Copy name"     
       MENU-ITEM mi_CopyPhysicalName LABEL "Copy physical name"
       RULE
       MENU-ITEM mi_ReconcileDatabaseSchema LABEL "Incremental Dump && Reconcile of Database Schema"
       MENU-ITEM mi_LoadDataDefinitions LABEL "Load data definitions (.df)"
       RULE
       MENU-ITEM mi_DataDictionary LABEL "Data Dictionary"
       MENU-ITEM mi_DataAdministration LABEL "Data Administration"
       RULE
       MENU-ITEM mi_ExportJSON LABEL "Export Dataset as JSON"
       MENU-ITEM mi_ExportXML LABEL "Export Dataset as XML".

DEFINE SUB-MENU m_SelectedFields 
       MENU-ITEM mi_CopyFieldAssignStatement LABEL "Copy assign statement"
       MENU-ITEM mi_CopyFieldAssignments LABEL "Copy field assignments"
       MENU-ITEM mi_CopyPutStatement LABEL "Copy put statement"
       RULE
       MENU-ITEM mi_CopyFieldNamesCommaSeparated LABEL "Copy names (comma separated)"
       MENU-ITEM mi_CopyFieldNamesSpaceSeparated LABEL "Copy names (space separated)"
       MENU-ITEM mi_CopyFieldNamesLineSeparated LABEL "Copy names (line separated)"
       RULE
       MENU-ITEM mi_SessionTriggerAddFieldsAssign LABEL "Add session triggers (assign)"
       MENU-ITEM mi_SessionTriggerRemoveFieldsAssign LABEL "Remove session triggers (assign)"
       RULE
       MENU-ITEM mi_FindFieldIndex LABEL "Find index for selected fields"
       MENU-ITEM mi_FindFieldTables LABEL "Find tables containing selected fields".

DEFINE MENU POPUP-MENU-brField 
       MENU-ITEM mi_CopyFieldName LABEL "Copy name"     
       MENU-ITEM mi_CopyFullFieldName LABEL "Copy name"     
       RULE
       MENU-ITEM mi_SelectAllFields LABEL "Selected all"  
       SUB-MENU  m_SelectedFields LABEL "Selected fields"
       RULE
       MENU-ITEM mi_CopyFieldInitialValue LABEL "Copy initial value"
       MENU-ITEM mi_CopyFieldFormat LABEL "Copy format"   
       MENU-ITEM mi_CopyFieldLabel LABEL "Copy label"    
       MENU-ITEM mi_CopyFieldColumnLabel LABEL "Copy column label"
       MENU-ITEM mi_CopyFieldDomain LABEL "Copy Domain"   
       RULE
       MENU-ITEM mi_SessionTriggerFieldAssign LABEL "Add session trigger (assign)"
       RULE
       MENU-ITEM mi_VirtualFields LABEL "Show Virtual Fields"
              TOGGLE-BOX
       RULE
       MENU-ITEM mi_FilterDataypes LABEL "Dataype filter".

DEFINE MENU POPUP-MENU-brIndex 
       MENU-ITEM mi_CopyIndexName LABEL "Copy name"     
       RULE
       MENU-ITEM mi_CopyIndexFields LABEL "Copy fields"   
       RULE
       MENU-ITEM mi_ModifyIndexQueryFields LABEL "Modify query fields"
       RULE
       MENU-ITEM mi_VirtualIndices LABEL "Show Virtual Indices"
              TOGGLE-BOX.

DEFINE MENU POPUP-MENU-brRelation 
       MENU-ITEM mi_CopyRelationTable LABEL "Copy table"     
       RULE
       MENU-ITEM mi_CopyRelationFields LABEL "Copy fields"   
       RULE
       MENU-ITEM mi_SwitchToRelatedTable LABEL "Swtich to related table".
       MENU-ITEM mi_ModifyRelationQueryFields LABEL "Modify query fields".
       RULE
       MENU-ITEM mi_ShowChildRelations LABEL "Show child relations"
              TOGGLE-BOX.
       MENU-ITEM mi_ShowParentRelations LABEL "Show parent relations"
              TOGGLE-BOX.

DEFINE SUB-MENU m_TableCreateTrigger 
       MENU-ITEM mi_CopyTableCreateTrigger LABEL "Copy trigger name"
       MENU-ITEM mi_OpenTableCreateTrigger LABEL "Open trigger procedure".

DEFINE SUB-MENU m_TableWriteTrigger 
       MENU-ITEM mi_CopyTableWriteTrigger LABEL "Copy trigger name"
       MENU-ITEM mi_OpenTableWriteTrigger LABEL "Open trigger procedure".

DEFINE SUB-MENU m_TableDeleteTrigger 
       MENU-ITEM mi_CopyTableDeleteTrigger LABEL "Copy trigger name"
       MENU-ITEM mi_OpenTableDeleteTrigger LABEL "Open trigger procedure".

DEFINE SUB-MENU m_TableCompanyInclude 
       MENU-ITEM mi_CopyTableCompanyInclude LABEL "Copy include name"
       MENU-ITEM mi_OpenTableCompanyInclude LABEL "Open include file"
       RULE
       MENU-ITEM mi_CopyTableCompanyIncludeReference LABEL "Copy include reference".

DEFINE SUB-MENU m_TableKeyInclude 
       MENU-ITEM mi_CopyTableKeyInclude LABEL "Copy include name"
       MENU-ITEM mi_OpenTableKeyInclude LABEL "Open include file"
       RULE
       MENU-ITEM mi_CopyTableKeyIncludeReference LABEL "Copy include reference".

DEFINE SUB-MENU m_TableFillInclude 
       MENU-ITEM mi_CopyTableFillInclude LABEL "Copy include name"
       MENU-ITEM mi_OpenTableFillInclude LABEL "Open include file"
       RULE
       MENU-ITEM mi_CopyTableFillIncludeReference LABEL "Copy include reference".

DEFINE MENU POPUP-MENU-brTable 
       MENU-ITEM mi_CopyTableName LABEL "Copy name"     
       RULE
       MENU-ITEM mi_CopyTableDefineBuffer LABEL "Copy ~"define buffer~""
       RULE
       SUB-MENU  m_TableCreateTrigger LABEL "Create trigger"
       SUB-MENU  m_TableWriteTrigger LABEL "Write trigger" 
       SUB-MENU  m_TableDeleteTrigger LABEL "Delete trigger"
       RULE
       SUB-MENU  m_TableCompanyInclude LABEL "Company include"
       SUB-MENU  m_TableKeyInclude LABEL "Key include"   
       SUB-MENU  m_TableFillInclude LABEL "Fill include"  
       RULE
       MENU-ITEM mi_SessionTriggerCreate LABEL "Add session trigger (create)"
       MENU-ITEM mi_SessionTriggerWrite LABEL "Add session trigger (write)"
       MENU-ITEM mi_SessionTriggerDelete LABEL "Add session trigger (delete)"
       MENU-ITEM mi_SessionTriggerFind LABEL "Add session trigger (find)"
       RULE
       MENU-ITEM mi_AddSnapshotBtn LABEL "Add snapshot"  
       MENU-ITEM mi_RemoveTable LABEL "Remove table"  
       RULE
       MENU-ITEM mi_LoadAllTableDetails LABEL "Load all table details"
       MENU-ITEM mi_ShowHiddenTables LABEL "Show hidden tables"
              TOGGLE-BOX.

DEFINE MENU POPUP-MENU-btnCopyToClipboard 
       MENU-ITEM mi_InsertModeBtn LABEL "Insert mode"   
              TOGGLE-BOX.


/* Definitions of the field level widgets                               */
DEFINE BUTTON btnBlock1 
     LABEL "1" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBlock2 
     LABEL "2" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBlock3 
     LABEL "3" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBlock4 
     LABEL "4" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBuffer1 
     LABEL "1" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBuffer2 
     LABEL "2" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBuffer3 
     LABEL "3" 
     SIZE 7 BY 1.

DEFINE BUTTON btnBuffer4 
     LABEL "4" 
     SIZE 7 BY 1.

DEFINE BUTTON btnClearBlockName 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear blockname".

DEFINE BUTTON btnClearBufferPattern 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Reset buffername".

DEFINE BUTTON btnClearFieldFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear field filter".

DEFINE BUTTON btnClearFieldLabelFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear field label filter".

DEFINE BUTTON btnClearIndexFieldFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear index field filter".

DEFINE BUTTON btnClearIndexFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear index filter".

DEFINE BUTTON btnClearRelationFieldFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear relation field filter".

DEFINE BUTTON btnClearRelationFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear relation filter".

DEFINE BUTTON btnClearTableFieldFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear table field filter".

DEFINE BUTTON btnClearTableFilter 
     LABEL "" 
     SIZE 7 BY 1 TOOLTIP "Clear table filter".

DEFINE BUTTON btnConnectDB 
     LABEL "Connect" 
     SIZE 19 BY 1 TOOLTIP "Connect to existing database".

DEFINE BUTTON btnCopyToClipboard DEFAULT 
     LABEL "Copy" 
     SIZE 20 BY 2 TOOLTIP "Copy query text to clipboard".

DEFINE BUTTON btnDecreaseIndentation 
     LABEL "<<" 
     SIZE 7 BY 2 TOOLTIP "Decrease indentation".

DEFINE BUTTON btnDisconnectDB 
     LABEL "Disconnect" 
     SIZE 19 BY 1 TOOLTIP "Disconnect selected database".

DEFINE BUTTON btnExecuteQuery 
     LABEL "Execute" 
     SIZE 20 BY 2 TOOLTIP "Execute current query (F2)".

DEFINE BUTTON btnIncreaseIndentation 
     LABEL ">>" 
     SIZE 7 BY 2 TOOLTIP "Increase indentation".

DEFINE BUTTON btnOf 
     LABEL "..." 
     SIZE 7 BY 2 TOOLTIP "Select related table and buffer".

DEFINE BUTTON btnRefresh 
     LABEL "Refresh" 
     SIZE 19 BY 1 TOOLTIP "Reload schema information for all connected databases".

DEFINE BUTTON btnResetAll 
     LABEL "Reset" 
     SIZE 10 BY 2 TOOLTIP "Reset everything to default values (F12)".

DEFINE BUTTON btnResetIndentation 
     LABEL "|" 
     SIZE 7 BY 2 TOOLTIP "Reset indentation".

DEFINE VARIABLE gcFieldFilter AS CHARACTER 
     LABEL "Field filter" 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY 1 TOOLTIP "Filter for fields that match given name pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcFieldLabelFilter AS CHARACTER 
     VIEW-AS COMBO-BOX INNER-LINES 5
     DROP-DOWN
     SIZE 42 BY 1 TOOLTIP "Filter for fields that match given label pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcIndexFieldFilter AS CHARACTER 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY 1 TOOLTIP "Filter for indices that contain fields matching given name pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcIndexFilter AS CHARACTER 
     LABEL "Index filter" 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY 1 TOOLTIP "Filter for indices that match given name pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcRelationFieldFilter AS CHARACTER 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY .96 TOOLTIP "Filter for relations that contain fields matching given name pattern (comma sep" NO-UNDO.

DEFINE VARIABLE gcRelationFilter AS CHARACTER 
     LABEL "Relation filter" 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY .96 TOOLTIP "Filter for relations that match given name pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcTableFieldFilter AS CHARACTER 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY 1 TOOLTIP "Filter for tables that contain fields matching given name pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcTableFilter AS CHARACTER 
     LABEL "Table filter" 
     VIEW-AS COMBO-BOX INNER-LINES 8
     DROP-DOWN
     SIZE 42 BY 1 TOOLTIP "Filter for tables that match given name pattern (comma separated)" NO-UNDO.

DEFINE VARIABLE gcQueryText AS CHARACTER 
     VIEW-AS EDITOR NO-WORD-WRAP SCROLLBAR-HORIZONTAL SCROLLBAR-VERTICAL
     SIZE 93 BY 14.5
     FONT 0 NO-UNDO.

DEFINE VARIABLE gcBlockName AS CHARACTER FORMAT "X(60)":U 
     LABEL "Block" 
     VIEW-AS FILL-IN 
     SIZE 60 BY 1 NO-UNDO.

DEFINE VARIABLE gcBufferName AS CHARACTER FORMAT "X(256)":U 
     LABEL "Buffer" 
     VIEW-AS FILL-IN 
     SIZE 60 BY 1 NO-UNDO.

DEFINE VARIABLE gcDatabaseDummy AS CHARACTER FORMAT "X(1)":U 
     LABEL "Database" 
     VIEW-AS FILL-IN 
     SIZE 1 BY 1 NO-UNDO.

DEFINE VARIABLE gcFieldDummy AS CHARACTER FORMAT "X(256)":U 
     LABEL "Field" 
     VIEW-AS FILL-IN 
     SIZE 1 BY 1 NO-UNDO.

DEFINE VARIABLE gcIndexDummy AS CHARACTER FORMAT "X(1)":U 
     LABEL "Index" 
     VIEW-AS FILL-IN 
     SIZE 1 BY 1 NO-UNDO.

DEFINE VARIABLE gcRelationDummy AS CHARACTER FORMAT "X(1)":U 
     LABEL "Relation" 
     VIEW-AS FILL-IN 
     SIZE 1 BY 1 NO-UNDO.

DEFINE VARIABLE gcTableDummy AS CHARACTER FORMAT "X(1)":U 
     LABEL "Table" 
     VIEW-AS FILL-IN 
     SIZE 1 BY 1 NO-UNDO.

DEFINE VARIABLE gdIndexUsage AS DECIMAL FORMAT "zz9%":U INITIAL 0 
      VIEW-AS TEXT 
     SIZE 6 BY 1 TOOLTIP "Index Usage" NO-UNDO.

DEFINE VARIABLE giDisplayMode AS INTEGER INITIAL 2 
     VIEW-AS RADIO-SET HORIZONTAL
     RADIO-BUTTONS 
          "Fields", 1,
"Indices", 2,
"Relations", 3
     SIZE 45 BY 1 NO-UNDO.

DEFINE VARIABLE glInvertQuery AS LOGICAL INITIAL no 
     LABEL "Invert query" 
     VIEW-AS TOGGLE-BOX
     size 15 by 1 tooltip "Create Query for related table instead of selected table." no-undo.

DEFINE VARIABLE glOnError AS LOGICAL INITIAL no 
     LABEL "on error" 
     VIEW-AS TOGGLE-BOX
     SIZE 10 BY 1 NO-UNDO.

DEFINE VARIABLE giOnErrorPhrase AS INTEGER 
     VIEW-AS RADIO-SET VERTICAL
     RADIO-BUTTONS 
          "on error undo, leave", 1,
"on error undo, next", 2,
"on error undo, retry", 3,
"on error undo, throw", 4
     SIZE 28 BY 4 NO-UNDO.

DEFINE VARIABLE giQueryTypeModifier AS INTEGER 
     VIEW-AS RADIO-SET HORIZONTAL EXPAND
     RADIO-BUTTONS 
          "unique", 1,
"first", 2,
"last", 3
     SIZE 45 BY 1 NO-UNDO.

DEFINE VARIABLE giQueryType AS INTEGER 
     VIEW-AS RADIO-SET HORIZONTAL EXPAND 
     RADIO-BUTTONS 
          "find first", 1,
"for each", 2,
"can-find", 3
     SIZE 45 BY 1 NO-UNDO.

DEFINE VARIABLE glExclusiveLock AS LOGICAL 
     VIEW-AS RADIO-SET VERTICAL
     RADIO-BUTTONS 
          "no-lock", no,
"exclusive-lock", yes
     SIZE 20 BY 2 NO-UNDO.

DEFINE VARIABLE glCompanyViaClass AS LOGICAL INITIAL no 
     LABEL "" 
     VIEW-AS TOGGLE-BOX
     size 40 by 1 tooltip "Use {&K_CLASS_COMPANY_STATEMENT} instead of pa-Firma" no-undo.

DEFINE VARIABLE glDefineBlock AS LOGICAL INITIAL no 
     LABEL "define block" 
     VIEW-AS TOGGLE-BOX
     SIZE 21 BY 1 NO-UNDO.

DEFINE VARIABLE glDefineBuffer AS LOGICAL INITIAL no 
     LABEL "define buffer" 
     VIEW-AS TOGGLE-BOX
     SIZE 17 BY 1 NO-UNDO.

DEFINE VARIABLE glDoBlock AS LOGICAL INITIAL no 
     LABEL "do" 
     VIEW-AS TOGGLE-BOX
     SIZE 7 BY 1 NO-UNDO.

DEFINE VARIABLE glFinallyBlock AS LOGICAL INITIAL no 
     LABEL "finally block" 
     VIEW-AS TOGGLE-BOX
     SIZE 15 BY 1 NO-UNDO.

DEFINE VARIABLE glIfStatement AS LOGICAL INITIAL no 
     LABEL "if statement" 
     VIEW-AS TOGGLE-BOX
     SIZE 16 BY 1 NO-UNDO.

DEFINE VARIABLE glNoError AS LOGICAL INITIAL no 
     LABEL "no error" 
     VIEW-AS TOGGLE-BOX
     SIZE 11.83 BY 1 NO-UNDO.

DEFINE VARIABLE glNot AS LOGICAL INITIAL no 
     LABEL "not" 
     VIEW-AS TOGGLE-BOX
     SIZE 7 BY 1 NO-UNDO.

DEFINE VARIABLE glRetryBlock AS LOGICAL INITIAL no 
     LABEL "retry block" 
     VIEW-AS TOGGLE-BOX
     SIZE 15 BY 1 NO-UNDO.

DEFINE VARIABLE glDefineVariables AS LOGICAL INITIAL no 
     LABEL "define variables" 
     VIEW-AS TOGGLE-BOX
     SIZE 20 BY 1 NO-UNDO.

DEFINE VARIABLE glUseVirtualIndexIncludes AS LOGICAL INITIAL no 
     LABEL "Use virtual index includes" 
     VIEW-AS TOGGLE-BOX
     SIZE 30 BY 1 NO-UNDO.


/* Query definitions                                                    */
&ANALYZE-SUSPEND
DEFINE QUERY brDatabase FOR 
      ttDatabase SCROLLING.

DEFINE QUERY brField FOR 
      ttField SCROLLING.

DEFINE QUERY brIndex FOR 
      ttIndex SCROLLING.

DEFINE QUERY brRelation FOR 
      ttTableRelationView SCROLLING.

DEFINE QUERY brTable FOR 
      ttTable SCROLLING.
&ANALYZE-RESUME

/* Browse definitions                                                   */
DEFINE BROWSE brDatabase
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _DISPLAY-FIELDS brDatabase hQueryWindow _FREEFORM
  QUERY brDatabase NO-LOCK DISPLAY
      ttDatabase.DatabaseName width 12
      ttDatabase.PhysicalName
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME
    WITH NO-ASSIGN SIZE 80 BY 5.

DEFINE BROWSE brField
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _DISPLAY-FIELDS brField hQueryWindow _FREEFORM
  QUERY brField NO-LOCK DISPLAY
      ttField.FieldName
      ttField.IsVirtual
      ttField.DataType
      ttField.FieldExtent
      ttField.FieldDecimals
      ttField.FieldInitialValue width 7
      ttField.FieldFormat
      ttField.FieldLabel
      ttField.FieldColumnLabel
      ttField.IsMandatory
      ttField.Domain
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME
    WITH NO-ASSIGN MULTIPLE SIZE 100 BY 12.

DEFINE BROWSE brIndex
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _DISPLAY-FIELDS brIndex hQueryWindow _FREEFORM
  QUERY brIndex NO-LOCK DISPLAY
      ttIndex.IsPrimary
      ttIndex.IndexName
      ttIndex.IsUnique
      ttIndex.IsVirtual
      ttIndex.IndexFields
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME
    WITH NO-ASSIGN SIZE 100 BY 12.

DEFINE BROWSE brRelation
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _DISPLAY-FIELDS brRelation hQueryWindow _FREEFORM
  QUERY brRelation NO-LOCK DISPLAY
      ttTableRelationView.RelatedTableName
      ttTableRelationView.RelationType width 8
      ttTableRelationView.ParentRelation
      ttTableRelationView.RelatedFields
      ttTableRelationView.FieldDetails
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME
    WITH NO-ASSIGN SIZE 100 BY 12.

DEFINE BROWSE brTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _DISPLAY-FIELDS brTable hQueryWindow _FREEFORM
  QUERY brTable NO-LOCK DISPLAY
      ttTable.TableName
      ttTable.ShortDescription
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME
    WITH NO-ASSIGN SIZE 100 BY 10 FIT-LAST-COLUMN.


/* ************************  Frame Definitions  *********************** */

DEFINE FRAME fQuery
     gdIndexUsage AT ROW 32 COL 223 COLON-ALIGNED NO-LABEL
     gcDatabaseDummy AT ROW 1.5 COL 16 COLON-ALIGNED
     gcTableDummy AT ROW 8 COL 16 COLON-ALIGNED
     gcFieldDummy AT ROW 21 COL 16 COLON-ALIGNED
     gcIndexDummy AT ROW 21 COL 16 COLON-ALIGNED
     gcRelationDummy AT ROW 21 COL 16 COLON-ALIGNED
     brDatabase AT ROW 1.5 COL 18
     btnConnectDB AT ROW 1.5 COL 99
     btnDisconnectDB AT ROW 2.5 COL 99
     btnRefresh AT ROW 5.5 COL 99
     gcTableFilter AT ROW 7 COL 16 COLON-ALIGNED
     btnClearTableFilter AT ROW 7 COL 60
     gcTableFieldFilter AT ROW 7 COL 67 COLON-ALIGNED NO-LABEL
     btnClearTableFieldFilter AT ROW 7 COL 111
     brTable AT ROW 8 COL 18
     giDisplayMode AT ROW 18.5 COL 18 NO-LABEL
     glInvertQuery AT ROW 18.5 COL 65 NO-LABEL
     gcFieldFilter AT ROW 20 COL 16 COLON-ALIGNED
     btnClearFieldFilter AT ROW 20 COL 60
     gcFieldLabelFilter AT ROW 20 COL 67 COLON-ALIGNED NO-LABEL
     btnClearFieldLabelFilter AT ROW 20 COL 111
     brField AT ROW 21 COL 18
     gcIndexFilter AT ROW 20 COL 16 COLON-ALIGNED
     btnClearIndexFilter AT ROW 20 COL 60
     gcIndexFieldFilter AT ROW 20 COL 67 COLON-ALIGNED NO-LABEL
     btnClearIndexFieldFilter AT ROW 20 COL 111
     brIndex AT ROW 21 COL 18
     gcRelationFilter AT ROW 20 COL 16 COLON-ALIGNED
     btnClearRelationFilter AT ROW 20 COL 60
     gcRelationFieldFilter AT ROW 20 COL 67 COLON-ALIGNED NO-LABEL
     btnClearRelationFieldFilter AT ROW 20 COL 111
     brRelation AT ROW 21 COL 18
     gcBufferName AT ROW 1.5 COL 128 COLON-ALIGNED
     btnClearBufferPattern AT ROW 1.5 COL 190
     btnBuffer1 AT ROW 1.5 COL 199
     btnBuffer2 AT ROW 1.5 COL 207
     btnBuffer3 AT ROW 1.5 COL 215
     btnBuffer4 AT ROW 1.5 COL 223
     glDefineBuffer AT ROW 7 COL 178
     glDefineVariables AT ROW 8.5 COL 178
     glCompanyViaClass AT ROW 5.5 COL 178
     glExclusiveLock AT ROW 3 COL 130 NO-LABEL
     glNoError AT ROW 3 COL 178
     glIfStatement AT ROW 4 COL 181
     glNot AT ROW 4 COL 199
     glDoBlock AT ROW 4 COL 207
     glUseVirtualIndexIncludes AT ROW 9.5 COL 178
     glOnError AT ROW 5.5 COL 130
     giOnErrorPhrase AT ROW 6.5 COL 133 NO-LABEL
     giQueryTypeModifier AT ROW 17 COL 130 NO-LABEL
     gcBlockName AT ROW 11.5 COL 128 COLON-ALIGNED
     btnClearBlockName AT ROW 11.5 COL 190
     btnBlock1 AT ROW 11.5 COL 199
     btnBlock2 AT ROW 11.5 COL 207
     btnBlock3 AT ROW 11.5 COL 215
     btnBlock4 AT ROW 11.5 COL 223
     glDefineBlock AT ROW 13 COL 130
     glRetryBlock AT ROW 13 COL 160
     glFinallyBlock AT ROW 13 COL 178
     giQueryType AT ROW 16 COL 130 NO-LABEL
     btnCopyToClipboard AT ROW 16 COL 178
     btnExecuteQuery AT ROW 16 COL 199
     btnResetAll AT ROW 16 COL 220
     btnIncreaseIndentation AT ROW 18.5 COL 223
     btnDecreaseIndentation AT ROW 20.5 COL 223
     btnResetIndentation AT ROW 22.5 COL 223
     btnOf AT ROW 25 COL 223
     gcQueryText AT ROW 18.5 COL 130 NO-LABEL
    WITH 1 DOWN NO-BOX KEEP-TAB-ORDER OVERLAY 
         SIDE-LABELS NO-UNDERLINE THREE-D 
         AT COL 1 ROW 1
         SIZE 232 BY 32.5
         DEFAULT-BUTTON btnCopyToClipboard DROP-TARGET.


/* *********************** Procedure Settings ************************ */

&ANALYZE-SUSPEND _PROCEDURE-SETTINGS
/* Settings for THIS-PROCEDURE
   Type: Window
   Allow: Basic,Browse,DB-Fields,Window,Query
 */
&ANALYZE-RESUME _END-PROCEDURE-SETTINGS

/* *************************  Create Window  ************************** */

&ANALYZE-SUSPEND _CREATE-WINDOW
IF SESSION:DISPLAY-TYPE = "GUI":U THEN
  CREATE WINDOW hQueryWindow ASSIGN
         HIDDEN             = YES
         TITLE              = ""
         HEIGHT             = 32.5
         WIDTH              = 231
         MAX-HEIGHT         = 320
         MAX-WIDTH          = 320
         VIRTUAL-HEIGHT     = 320
         VIRTUAL-WIDTH      = 320
         RESIZE             = yes
         SCROLL-BARS        = no
         STATUS-AREA        = no
         BGCOLOR            = ?
         FGCOLOR            = ?
         KEEP-FRAME-Z-ORDER = yes
         THREE-D            = yes
         MESSAGE-AREA       = no
         SENSITIVE          = yes.
ELSE {&WINDOW-NAME} = CURRENT-WINDOW.

ASSIGN {&WINDOW-NAME}:MENUBAR    = MENU MENU-BAR-hQueryWindow:HANDLE.
/* END WINDOW DEFINITION                                                */
&ANALYZE-RESUME



/* ***********  Runtime Attributes and AppBuilder Settings  *********** */

&ANALYZE-SUSPEND _RUN-TIME-ATTRIBUTES
/* SETTINGS FOR WINDOW hQueryWindow
  VISIBLE,,RUN-PERSISTENT                                               */
/* SETTINGS FOR FRAME fQuery
   FRAME-NAME Custom                                                    */
/* BROWSE-TAB brDatabase gcIndexDummy fQuery */
/* BROWSE-TAB brTable btnClearTableFieldFilter fQuery */
/* BROWSE-TAB brField btnClearFieldFilter fQuery */
/* BROWSE-TAB brIndex btnClearIndexFieldFilter fQuery */
/* BROWSE-TAB brRelation gcQueryText fQuery */
ASSIGN 
       FRAME fQuery:PRIVATE-DATA     = 
                "WidthFactor=1,HeightFactor=1,SlimModeWidget=yes".

ASSIGN 
       brDatabase:POPUP-MENU IN FRAME fQuery             = MENU POPUP-MENU-brDatabase:HANDLE
       brDatabase:PRIVATE-DATA IN FRAME fQuery           = 
                "WidthFactor=0.5,SlimModeWidget=yes"
       brDatabase:COLUMN-RESIZABLE IN FRAME fQuery       = TRUE
       brDatabase:COLUMN-MOVABLE IN FRAME fQuery         = TRUE.

ASSIGN 
       brField:POPUP-MENU IN FRAME fQuery             = MENU POPUP-MENU-brField:HANDLE
       brField:NUM-LOCKED-COLUMNS IN FRAME fQuery     = 1
       brField:PRIVATE-DATA IN FRAME fQuery           = 
                "WidthFactor=0.5,HeightFactor=0.5,RowFactor=0.5,SlimModeWidget=yes"
       brField:COLUMN-RESIZABLE IN FRAME fQuery       = TRUE
       brField:COLUMN-MOVABLE IN FRAME fQuery         = TRUE.

ASSIGN 
       brIndex:POPUP-MENU IN FRAME fQuery             = MENU POPUP-MENU-brIndex:HANDLE
       brIndex:PRIVATE-DATA IN FRAME fQuery           = 
                "WidthFactor=0.5,HeightFactor=0.5,RowFactor=0.5,SlimModeWidget=yes"
       brIndex:COLUMN-RESIZABLE IN FRAME fQuery       = TRUE
       brIndex:COLUMN-MOVABLE IN FRAME fQuery         = TRUE.

ASSIGN 
       brRelation:POPUP-MENU IN FRAME fQuery             = MENU POPUP-MENU-brRelation:HANDLE
       brRelation:NUM-LOCKED-COLUMNS IN FRAME fQuery     = 1
       brRelation:PRIVATE-DATA IN FRAME fQuery           = 
                "WidthFactor=0.5,HeightFactor=0.5,RowFactor=0.5,SlimModeWidget=yes"
       brRelation:COLUMN-RESIZABLE IN FRAME fQuery       = TRUE
       brRelation:COLUMN-MOVABLE IN FRAME fQuery         = TRUE.

ASSIGN 
       brTable:POPUP-MENU IN FRAME fQuery             = MENU POPUP-MENU-brTable:HANDLE
       brTable:PRIVATE-DATA IN FRAME fQuery           = 
                "WidthFactor=0.5,HeightFactor=0.5,SlimModeWidget=yes"
       brTable:COLUMN-RESIZABLE IN FRAME fQuery       = TRUE
       brTable:COLUMN-MOVABLE IN FRAME fQuery         = TRUE.

ASSIGN 
       btnBlock1:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBlock2:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBlock3:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBlock4:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBuffer1:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBuffer2:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBuffer3:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnBuffer4:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnClearBlockName:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnClearBufferPattern:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1".

ASSIGN 
       btnClearFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearFieldLabelFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearIndexFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearIndexFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearRelationFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearRelationFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearTableFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnClearTableFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       btnConnectDB:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnCopyToClipboard:POPUP-MENU IN FRAME fQuery       = MENU POPUP-MENU-btnCopyToClipboard:HANDLE
       btnCopyToClipboard:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,WidthFactor=0.2".

ASSIGN 
       btnDecreaseIndentation:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1,HeightFactor=0.12,RowFactor=0.12,MaxHeight=2.0,MaxRow=20.5".

ASSIGN 
       btnDisconnectDB:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnExecuteQuery:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.7,WidthFactor=0.2".

ASSIGN 
       btnIncreaseIndentation:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1,HeightFactor=0.12,MaxHeight=2.0".

ASSIGN 
       btnOf:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1,HeightFactor=0.12,RowFactor=0.36,MaxHeight=2.0,MaxRow=25.0".

ASSIGN 
       btnRefresh:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       btnResetAll:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.9,WidthFactor=0.1".

ASSIGN 
       btnResetIndentation:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1,HeightFactor=0.12,RowFactor=0.24,MaxHeight=2.0,MaxRow=22.5".

ASSIGN 
       gcBlockName:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,WidthFactor=0.5".

ASSIGN 
       gcBufferName:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,WidthFactor=0.5".

/* SETTINGS FOR FILL-IN gcDatabaseDummy IN FRAME fQuery
   NO-DISPLAY NO-ENABLE                                                 */
ASSIGN 
       gcFieldDummy:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       gcFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,WidthFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       gcFieldLabelFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,RowFactor=0.5,WidthFactor=0.25,SlimModeWidget=yes".

/* SETTINGS FOR FILL-IN gcIndexDummy IN FRAME fQuery
   NO-DISPLAY NO-ENABLE                                                 */
ASSIGN 
       gcIndexDummy:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,SlimModeWidget=yes".

/* SETTINGS FOR FILL-IN gcRelationDummy IN FRAME fQuery
   NO-DISPLAY NO-ENABLE                                                 */
ASSIGN 
       gcRelationDummy:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       gcIndexFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,RowFactor=0.5,WidthFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       gcIndexFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,WidthFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       gcQueryText:READ-ONLY IN FRAME fQuery        = TRUE
       gcQueryText:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5,HeightFactor=1,WidthFactor=0.5".

ASSIGN 
       gcRelationFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,RowFactor=0.5,WidthFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       gcRelationFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,WidthFactor=0.25,SlimModeWidget=yes".

/* SETTINGS FOR FILL-IN gcTableDummy IN FRAME fQuery
   NO-DISPLAY NO-ENABLE                                                 */
ASSIGN 
       gcTableDummy:PRIVATE-DATA IN FRAME fQuery     = 
                "SlimModeWidget=yes".

ASSIGN 
       gcTableFieldFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.25,WidthFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       gcTableFilter:PRIVATE-DATA IN FRAME fQuery     = 
                "WidthFactor=0.25,SlimModeWidget=yes".

ASSIGN 
       gdIndexUsage:READ-ONLY IN FRAME fQuery        = TRUE
       gdIndexUsage:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=1,RowFactor=1".

ASSIGN 
       giDisplayMode:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       glInvertQuery:PRIVATE-DATA IN FRAME fQuery     = 
                "RowFactor=0.5,SlimModeWidget=yes".

ASSIGN 
       glOnError:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       giOnErrorPhrase:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       giQueryTypeModifier:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       giQueryType:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glCompanyViaClass:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glDefineBlock:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glDefineBuffer:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glDoBlock:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glExclusiveLock:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glFinallyBlock:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glIfStatement:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glNoError:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glNot:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glDefineVariables:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glUseVirtualIndexIncludes:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

ASSIGN 
       glRetryBlock:PRIVATE-DATA IN FRAME fQuery     = 
                "ColFactor=0.5".

IF SESSION:DISPLAY-TYPE = "GUI":U AND VALID-HANDLE(hQueryWindow)
THEN hQueryWindow:HIDDEN = no.

/* _RUN-TIME-ATTRIBUTES-END */
&ANALYZE-RESUME


/* Setting information for Queries and Browse Widgets fields            */

&ANALYZE-SUSPEND _QUERY-BLOCK BROWSE brDatabase
/* Query rebuild information for BROWSE brDatabase
     _START_FREEFORM
OPEN QUERY brDatabase FOR EACH ttDatabase WHERE true
  NO-LOCK
  BY ttDatabase.DisplayPriority BY ttDatabase.DatabaseName.
     _END_FREEFORM
     _Options          = "NO-LOCK"
     _Query            is NOT OPENED
*/  /* BROWSE brDatabase */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _QUERY-BLOCK BROWSE brField
/* Query rebuild information for BROWSE brField
     _START_FREEFORM
OPEN QUERY brField FOR EACH ttField WHERE true
and ttField.DatabaseName = ttDatabase.DatabaseName
and ttField.TableName = ttTable.TableName
and ttField.FieldFilterMatches = yes
and ( glShowVirtualFields
   or ttField.IsVirtual <> yes )
  NO-LOCK.
     _END_FREEFORM
     _Options          = "NO-LOCK"
     _Query            is NOT OPENED
*/  /* BROWSE brField */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _QUERY-BLOCK BROWSE brIndex
/* Query rebuild information for BROWSE brIndex
     _START_FREEFORM
OPEN QUERY brIndex FOR EACH ttIndex WHERE true
  AND ttIndex.DatabaseName = ttDatabase.DatabaseName
  and ttIndex.TableName = ttTable.TableName
  AND ttIndex.IndexFilterMatches = yes
  AND ttIndex.IndexFieldFilterMatches = yes
  AND ( glShowVirtualIndices
     or ttIndex.IsVirtual <> yes )
  NO-LOCK.
     _END_FREEFORM
     _Options          = "NO-LOCK"
     _Query            is NOT OPENED
*/  /* BROWSE brIndex */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _QUERY-BLOCK BROWSE brRelation
/* Query rebuild information for BROWSE brRelation
     _START_FREEFORM
OPEN QUERY brTableRelationView FOR EACH ttTableRelationView WHERE true
  AND ttTableRelationView.DatabaseName = ttDatabase.DatabaseName
  AND ttTableRelationView.ReferenceTableName = ttTable.TableName
  AND ttTableRelationView.TableFilterMatches = yes
  AND ttTableRelationView.FieldFilterMatches = yes
  AND ttTableRelationView.ParentRelationFilterMatches = yes
  NO-LOCK.
     _END_FREEFORM
     _Options          = "NO-LOCK"
     _Query            is NOT OPENED
*/  /* BROWSE brRelation */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _QUERY-BLOCK BROWSE brTable
/* Query rebuild information for BROWSE brTable
     _START_FREEFORM
OPEN QUERY brTable FOR EACH ttTable WHERE true
  AND ttTable.DatabaseName = ttDatabase.DatabaseName
  AND ttTable.TableFilterMatches = yes
  AND ttTable.TableFieldFilterMatches = yes
  AND (glShowHiddenTables
    OR (  not can-do('sys*':U, ttTable.TableName)
      and not can-do('_*':U, ttTable.TableName)))
  NO-LOCK.
     _END_FREEFORM
     _Options          = "NO-LOCK"
     _Query            is NOT OPENED
*/  /* BROWSE brTable */
&ANALYZE-RESUME

/* >>> Include: incl/core.df >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : core.df
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Mon Apr 11 08:19:37 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */

/* ************************  Function Prototypes ********************** */

function qg_cDataTypePrefix returns character 
  ( pcDataType as character ) forward.

function qg_cDatabaseNameForTableOrBuffer returns character 
  ( phBuffer as handle ) forward.

function qg_cDateStringFormUSFormat returns character 
  ( pcDateString as character ) forward.

function qg_cFieldValuesForObjectId returns character 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcObjectId     as character,
    pcFieldList    as character ) forward.

function qg_cIndexFieldValuesForObjectId returns character 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcObjectId     as character,
    pcIndexName    as character ) forward.

function qg_cObjectIdForBuffer returns character 
  ( phBuffer as handle ) forward.

function qg_lFieldExistsInDatabaseSchema returns logical 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcFieldName    as character ) forward.

function qg_lIsPhysicalDatabase returns logical 
  ( pcDatabaseName as character ) forward.

function qg_tDateDateFromUSFormat returns date 
  ( pcDateString as character ) forward.

function qg_tzDateDateTimeTzFromUSFormat returns datetime-tz 
  ( pcDateString as character ) forward.


/* ***************************  Main Block  *************************** */

/* <<< Include: incl/core.df <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/database_schema.df >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : database_schema.df
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Wed Apr 06 11:56:21 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */


/* ************************  Function Prototypes ********************** */

function qg_cCustomizedRepositoryValue returns character 
  ( pcBasisDBName as character,
    pcTableName   as character,
    pcFieldName   as character,
    pcOwning_Obj  as character ) forward.



/* <<< Include: incl/database_schema.df <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/query_window.df >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : database_schema.df
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Wed Apr 06 11:56:21 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */

define variable ghQueryWindowListWindowSeq  as integer   no-undo.

define variable ghQueryWindowListWindow     as handle    no-undo.
define variable ghQueryWindowListBrowse     as handle    no-undo.
define variable ghActiveQueryWindow         as handle    no-undo.

/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */

/* <<< Include: incl/query_window.df <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/virtual_fields.df >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
/*------------------------------------------------------------------------
    File        : virtual_fields.i
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Tue Apr 05 13:54:45 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ********************  Preprocessor Definitions  ******************** */

&GLOBAL-DEFINE K_VIRTUAL_DB_FIELD_FGCOLOR        3

/* ***************************  Definitions  ************************** */

define variable glShowVirtualFields                  as logical              no-undo initial yes.

define variable goVirtualDBFieldDataApiInstance      as Progress.Lang.Object no-undo.
define variable goVirtualDBFieldDataFieldApiInstance as Progress.Lang.Object no-undo.
define variable gcVirtualDBFieldReposFlagFieldName   as character            no-undo initial ?.

define temp-table ttVirtualFieldColumn no-undo
  field OwnerHandle         as handle
  field DatabaseName        as character
  field BufferName          as character
  field FieldName           like ttField.FieldName
  field FieldIndex          as integer
  field DataType            as character
  field FieldType           as integer
  field FieldFormat         as character
  field BufferHandle        as handle
  field ColumnHandle        as handle
  index Main is primary unique
    OwnerHandle
    BufferName
    FieldName
    FieldIndex
  index ColumnHandle
    OwnerHandle
    ColumnHandle
    .

/* ************************  Function Prototypes ********************** */

function qg_cBufferCompareVirtualFields returns character 
  ( phBuffer1 as handle,
    phBuffer2 as handle ) forward.

function qg_cGetFieldAssignmentsStatementForVirtualFields returns character 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcBufferName   as character,
    pcFieldList    as character,
    piValueMode    as integer,
    pcValueList    as character,
    plAddTags      as logical,
    piIndentBlanks as integer ) forward.

function qg_clVirtualDBFieldValueAsLongchar returns longchar 
  ( pcDataType      as character,
    pcFieldName     as character,
    pcObjectIdValue as character,
    pcFormat        as character ) forward.


function qg_clVirtualFieldValueAsLongchar returns longchar 
  ( piFieldType     as integer,
    pcDataType      as character,
    pcFieldName     as character,
    pcObjectIdValue as character,
    pcFormat        as character ) forward.

function qg_lBufferCompareSingleVirtualField returns logical 
  ( phBuffer1             as handle,
    plDatabase1IsPhysical as logical,
    pcObjectIdValue1      as character,
    phBuffer2             as handle,
    plDatabase2IsPhysical as logical,
    pcObjectIdValue2      as character,
    pcFieldName           as character,
    pcDataType            as character ) forward.

function qg_lVirtualDBFieldsPossible returns logical 
  ( buffer pbttDatabase for ttDatabase ) forward.

function qg_oVirtualDBFieldDataApiInstance returns class progress.lang.object 
  (  ) forward.

function qg_oVirtualDBFieldDataFieldApiInstance returns class progress.lang.object 
  (  ) forward.

/* <<< Include: incl/virtual_fields.df <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/virtual_indices.df >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : virtual_indices.df
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Wed Jun 01 14:36:40 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */

&GLOBAL-DEFINE K_VIRTUAL_INDEX_FGCOLOR        3

/* ***************************  Main Block  *************************** */

define variable glShowVirtualIndices             as logical                    no-undo initial yes.

define variable goVirtualIndexApiInstance        as class Progress.Lang.Object no-undo.
define variable goVirtualIndexDataApiInstance    as class Progress.Lang.Object no-undo.

define variable gcVirtualQueryApiPackageName     as character no-undo.
define variable gcVirtualQueryApiClassName       as character no-undo.

define variable gcVirtualIndexReposFlagFieldName as character                  no-undo initial ?.
define variable gcVirtualIndexDataTableName      as character                  no-undo initial ?.

/* ************************  Function Prototypes ********************** */

function qg_cVirtualIndexFieldVariableName returns character 
  ( pcFieldName as character,
    pcDataType  as character ) forward.

function qg_lVirtualIndexPossible returns logical 
  ( buffer pbttDatabase for ttDatabase ) forward.

function qg_oVirtualIndexApiInstance returns class progress.lang.object 
  (  ) forward.

function qg_oVirtualIndexDataApiInstance returns class progress.lang.object 
  (  ) forward.

function qg_oVirtualQueryApiInstance returns class progress.lang.object 
  (  ) forward.



/* <<< Include: incl/virtual_indices.df <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */


/* >>> Include: incl/core.i >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : core.i
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Mon Apr 11 08:19:37 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */



/* **********************  Internal Procedures  *********************** */


/* ************************  Function Implementations ***************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cDatabaseNameForTableOrBuffer Method-Library
function qg_cDatabaseNameForTableOrBuffer returns character 
  ( phDBObject as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Prio 1: get property from given handle. */

cDatabaseName = qg_cParamListReadValue( phDBObject:private-data,
                                        'DatabaseName':U,
                                        ',':U ).

if  ( cDatabaseName > '':U ) then
  
  return cDatabaseName.
  
case phDBObject:type:
  
  when 'BUFFER':U then
  do:
    
    if valid-handle( phDBObject:table-handle ) then
    do:
      
      /* Prio 2 for Buffers: read property from table handle */
      
      cDatabaseName = qg_cParamListReadValue( phDBObject:table-handle:private-data,
                                              'DatabaseName':U,
                                              ',':U ).
      
      if cDatabaseName > '':U then
        
        return cDatabaseName.
      
      if phDBObject <> phDBObject:table-handle:default-buffer-handle then
      do:
        
        /* Prio 3 for Buffers: read property form default buffer handle (but  */
        /* only if the default buffer handle differs from given handle.       */
        
        cDatabaseName = qg_cParamListReadValue( phDBObject:table-handle:default-buffer-handle:private-data,
                                                'DatabaseName':U,
                                                ',':U ).
        if cDatabaseName > '':U then
          
          return cDatabaseName.
        
      end. /* if phDBObject <> phDBObject:table-handle:default-buffer-handle */
      
    end. /* if valid-handle( phDBObject:table-handle ) */
    
    return phDBObject:dbname.
    
  end. /* when 'BUFFER':U */
  
  when 'TABLE':U then
  do:
    
    /* Prio 2 for tables: read property from default buffer handle. */
    
    cDatabaseName = qg_cParamListReadValue( phDBObject:default-buffer-handle:private-data,
                                            'DatabaseName':U,
                                            ',':U ).
    
    if cDatabaseName > '':U then
      
      return cDatabaseName.
    
    return phDBObject:default-buffer-handle:dbname.
    
  end. /* when 'TABLE':U */
  
end case. /* phDBObject:type */

return ?.

end function. /* qg_cDatabaseNameForTableOrBuffer */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

/* ************************  Function Prototypes ********************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cDataTypePrefix Method-Library
function qg_cDataTypePrefix returns character 
  ( pcDataType as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/    

case pcDataType:
  
  when 'character':U then
    
    return 'c':U.

  when 'integer':U
     or when 'int64':U then
    
    return 'i':U.
  
  when 'decimal':U then
    
    return 'd':U.
  
  when 'logical':U then
    
    return 'l':U.
  
  when 'date':U then
    
    return 't':U.
  
  when 'longchar':U then
    
    return 'cl':U.
  
  when 'datetime':U then
    
    return 'td':U.
  
  when 'datetime-tz':U then
    
    return 'tz':U.
  
  when 'handle':U then
    
    return 'h':U.
  
  when 'rowid':U then
    
    return 'r':U.
  
  when 'memptr':U then
    
    return 'm':U.
  
  when 'progress.lang.object':U then
    
    return 'o':U.
  
  otherwise
    return '':U.
  
end case. /* pcDataType */

end function. /* qg_cDataTypePrefix */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cDateStringFormUSFormat Method-Library
function qg_cDateStringFormUSFormat returns character 
  ( pcDateString as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns a date-string representing the given us date string in format of   */
/* the session date-format.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* pcDateString   date(time-tz) string in US format (mm/dd/yyyy)              */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/    

if lookup(pcDateString,'today,now':U) > 0 then
  
  return pcDateString.

else if length(pcDateString) > 10 then

  return string(qg_tzDateDateTimeTzFromUSFormat(pcDateString)).

else

  return string(qg_tDateDateFromUSFormat(pcDateString)).

end function. /* qg_cDateStringFormUSFormat */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFieldValuesForObjectId Method-Library
function qg_cFieldValuesForObjectId returns character 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcObjectId     as character,
    pcFieldList    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create buffer hBuffer for table substitute( '&1.&2':U,
                                            pcDatabaseName,
                                            pcTableName ).

hBuffer:find-first( substitute( 'where &1.&1_Obj = &2':U,
                                hBuffer:table,
                                quoter( pcObjectId ) ) ) no-error.

return ( if hBuffer:available then
           qg_cFieldValues( hBuffer, ?, pcFieldList )
         else
           ? ).

finally:
  
  if valid-handle( hBuffer ) then
    
    delete object hBuffer.
  
end finally.

end function. /* qg_cFieldValuesForObjectId */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cIndexFieldValuesForObjectId Method-Library
function qg_cIndexFieldValuesForObjectId returns character 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcObjectId     as character,
    pcIndexName    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/    

create buffer hBuffer for table substitute( '&1.&2':U,
                                            pcDatabaseName,
                                            pcTableName ).

hBuffer:find-first( substitute( 'where &1.&1_Obj = &2':U,
                                hBuffer:table,
                                quoter( pcObjectId ) ) ) no-error.

return ( if hBuffer:available then
           qg_cIndexFieldValues( hBuffer, pcIndexName )
         else
           ? ).

finally:
  
  if valid-handle( hBuffer ) then
    
    delete object hBuffer.
  
end finally.

end function. /* qg_cIndexFieldValuesForObjectId */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cObjectIdForBuffer Method-Library
function qg_cObjectIdForBuffer returns character 
  ( phBuffer as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hObjectIdField as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

hObjectIdField = phBuffer:buffer-field( substitute( '&1_Obj':U, phBuffer:table ) ).

return hObjectIdField:buffer-value.

catch oError as class progress.lang.error:
  return ?.
end catch.

end function. /* qg_cObjectIdForBuffer */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lFieldExistsInDatabaseSchema Method-Library
function qg_lFieldExistsInDatabaseSchema returns logical 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcFieldName    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFileBuffer  as handle    no-undo.
define variable hFieldBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create buffer hFileBuffer for table substitute( '&1.&2':U,
                                                pcDatabaseName,
                                                '_File':U ).

hFileBuffer:find-first( substitute( 'where _File._File-Name = &1':U,
                                    quoter( pcTableName ) ),
                        no-lock ) no-error.

if not hFileBuffer:available then
  
  return no.

create buffer hFieldBuffer for table substitute( '&1.&2':U,
                                                 pcDatabaseName,
                                                 '_Field':U ).

hFieldBuffer:find-first( substitute(            'where _Field._File-recid = &1':U
                                     + '~n':U + '  and _Field._Field-Name = &2':U,
                                     quoter( hFileBuffer:recid ),
                                     quoter( pcFieldName ) ),
                         no-lock ) no-error.

return hFieldBuffer:available.

finally:
  
  if valid-handle( hFileBuffer ) then
    
    delete object hFileBuffer.
  
  if valid-handle( hFieldBuffer ) then
    
    delete object hFieldBuffer.
  
end finally.

end function. /* qg_lFieldExistsInDatabaseSchema */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lIsPhysicalDatabase Method-Library
function qg_lIsPhysicalDatabase returns logical 
  ( pcDatabaseName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if pcDatabaseName = {&K_PROGRESS_TTNAME} then
  
  return no.

if can-find( first ttDatabase
               where ttDatabase.DatabaseName = pcDatabaseName
                 and ttDatabase.PhysicalDB   = yes ) then
  
  return yes.

return no.

end function. /* qg_lIsPhysicalDatabase */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_tDateDateFromUSFormat Method-Library
function qg_tDateDateFromUSFormat returns date 
  ( pcDateString as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the date for a given date string in US format                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDateString   date(time-tz) string in US format (mm/dd/yyyy)              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

return date(qg_tzDateDateTimeTzFromUSFormat(pcDateString)).

end function. /* qg_tDateDateFromUSFormat */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_tzDateDateTimeTzFromUSFormat Method-Library
function qg_tzDateDateTimeTzFromUSFormat returns datetime-tz 
  ( pcDateString as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the datetime-tz for a given date string in US format               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDateString   date(time-tz) string in US format (mm/dd/yyyy)              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDateFormat as character     no-undo.
define variable tzInitDate  as datetime-tz   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/    

if    pcDateString = ?
   or pcDateString = '?':U
   or pcDateString = 'now':U then

  tzInitDate = datetime-tz(pcDateString).

else if pcDateString = 'today':U then

  tzInitDate = datetime-tz(today).

else

  assign
    cDateFormat         = session:date-format
    session:date-format = 'mdy':U
    tzInitDate          = datetime-tz(pcDateString)
    session:date-format = cDateFormat
    .

return tzInitDate.

catch oErr as Progress.Lang.Error :

  return ?.

end catch.

finally:
  
  if cDateFormat > '':U then
    
    session:date-format = cDateFormat.
  
end finally.
  
end function. /* qg_tzDateDateTimeTzFromUSFormat */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

/* <<< Include: incl/core.i <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/database_schema.i >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : database_schema.i
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Wed Apr 06 11:56:21 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */



/* **********************  Internal Procedures  *********************** */

PROCEDURE qg_AddDatabase :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add database to cache.                                                     */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = logical name of database that should be   */
/*                                  added.                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabase as character no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cSchemaDatabaseName as character no-undo.
define variable hTableBuffer        as handle    no-undo.

define variable cDBParams           as character no-undo.
define variable iDBParamCounter     as integer   no-undo.
define variable cDBParamEntry       as character no-undo.
define variable iPortRangeStart     as integer   no-undo.
define variable iPortRangeEnd       as integer   no-undo.


/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase  for temp-table ttDatabase.
define buffer b2ttDatabase for temp-table ttDatabase.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create bttDatabase.

assign
  cSchemaDatabaseName                 = sdbname( pcDatabase )
  bttDatabase.DatabaseName            = ldbname(pcDatabase)
  bttDatabase.PhysicalName            = trim(pdbname(pcDatabase), '/\':U)
  
  /* We assume that if the database is connected via shared mameory the       */
  /* pyhsical name contains a path.                                           */
  
  bttDatabase.SharedMemory            =    index(bttDatabase.PhysicalName, '/':U) > 0
                                        or index(bttDatabase.PhysicalName, '\':U) > 0
  bttDatabase.DirectoryName           = (if r-index(bttDatabase.PhysicalName, '\':U) > r-index(bttDatabase.PhysicalName, '/':U) then
                                           substring(bttDatabase.PhysicalName, 1, r-index(bttDatabase.PhysicalName, '\':U))
                                         else
                                           substring(bttDatabase.PhysicalName, 1, r-index(bttDatabase.PhysicalName, '/':U)))
  bttDatabase.DirectoryName           = replace(bttDatabase.DirectoryName, '/':U, '\':U)
  bttDatabase.PhysicalDB              = yes
  bttDatabase.DisplayPriority         = 1000.
  .

cDBParams = dbparam( bttDatabase.DatabaseName ).

do iDBParamCounter = 1 to num-entries( cDBParams ):
  
  cDBParamEntry = entry( iDBParamCounter, cDBParams ).
  
  case entry( 1, cDBParamEntry, ' ':U ):
    
    when '-H':U then
      
      bttDatabase.HostName = entry( 2, cDBParamEntry, ' ':U ).
  
    when '-S':U then
      
      bttDatabase.ServiceName = integer( entry( 2, cDBParamEntry, ' ':U ) ) no-error.
    
  end case. /* entry( 1, cDBParamEntry, ' ':U ) */
  
end. /* do iDBParamCounter = 1 to num-entries( cDBParams ) */

/* Check if this database contains repository information. */

create buffer hTableBuffer for table substitute( '&1._File':U, cSchemaDatabaseName ).

hTableBuffer:find-first(substitute('where &1._File._File-Name = "DRC_Table"':U,
                                   bttDatabase.DatabaseName),
                        no-lock) no-error.

bttDatabase.BasisDB = hTableBuffer:available.

if bttDatabase.BasisDB then
do:
  
  bttDatabase.BasisDBName = bttDatabase.DatabaseName.
  
  if bttDatabase.DirectoryName > '':U then
    
    for each b2ttDatabase
      where b2ttDatabase.DirectoryName = bttDatabase.DirectoryName
        and b2ttDatabase.BasisDBName  = '':U
      on error undo, throw:
      
      b2ttDatabase.BasisDBName = b2ttDatabase.DatabaseName.
      
    end. /* for each b2ttDatabase */
    
  else if bttDatabase.HostName > '':U then
  do:
    
    assign
      iPortRangeStart = truncate( bttDatabase.ServiceName / 10, 0 ) * 10
      iPortRangeEnd   = iPortRangeStart + 9
      .
    
    for each b2ttDatabase
      where b2ttDatabase.HostName     = bttDatabase.HostName
        and b2ttDatabase.ServiceName >= iPortRangeStart
        and b2ttDatabase.ServiceName <= iPortRangeEnd
        and b2ttDatabase.BasisDBName  = '':U
      on error undo, throw:
      
      b2ttDatabase.BasisDBName = b2ttDatabase.DatabaseName.
      
    end. /* for each b2ttDatabase */
    
  end.
  
end. /* if bttDatabase.BasisDB */

else
do:
  
  if bttDatabase.DirectoryName > '':U then
  do:
    
    find first b2ttDatabase
      where b2ttDatabase.DirectoryName = bttDatabase.DirectoryName
        and b2ttDatabase.BasisDB       = yes
      no-lock no-error.
    
    if available b2ttDatabase then
      
      bttDatabase.BasisDBName = b2ttDatabase.DatabaseName.
    
  end. /* if bttDatabase.DirectoryName > '':U */
  
  else if bttDatabase.HostName > '':U then
  do:
    
    assign
      iPortRangeStart = truncate( bttDatabase.ServiceName / 10, 0 ) * 10
      iPortRangeEnd   = iPortRangeStart + 9
      .
    
    find first b2ttDatabase
      where b2ttDatabase.HostName     = bttDatabase.HostName
        and b2ttDatabase.ServiceName >= iPortRangeStart
        and b2ttDatabase.ServiceName <= iPortRangeEnd
        and b2ttDatabase.BasisDB      = yes
      no-lock no-error.
    
    if available b2ttDatabase then
      
      bttDatabase.BasisDBName = b2ttDatabase.DatabaseName.
    
  end. /* else: if bttDatabase.HostName > '':U */
  
end. /* else: if bttDatabase.BasisDB */

if not bttDatabase.BasisDB then
do:
  
  if bttDatabase.DatabaseName = 'temp-db':U then
    bttDatabase.TempDB = yes.
  
  else
  do:
    
    hTableBuffer:find-first(substitute( 'where &1._File._File-Name begins "TD_"':U,
                                        cSchemaDatabaseName ),
                            no-lock) no-error.
  
    bttDatabase.TempDB = hTableBuffer:available.
    
  end. /* if bttDatabase.DatabaseName = 'temp-db':U */
  
end. /* if not bttDatabase.BasisDB */

assign
  bttDatabase.VirtualDBFieldsPossible = qg_lVirtualDBFieldsPossible( buffer bttDatabase )
  bttDatabase.VirtualIndicesPossible  = qg_lVirtualIndexPossible( buffer bttDatabase )
  .

validate bttDatabase.

finally:
  
  delete object hTableBuffer no-error.
  
  hide frame fStatus.
  
end finally.
  
end procedure. /* qg_AddDatabase */

procedure qg_AddDatasetRelations :
/* Description ---------s------------------------------------------------------*/
/*                                                                            */
/* Adds relations from a dataset handle                                       */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter phDataset      as handle    no-undo.

/* Variables -----------------------------------------------------------------*/

define variable iRelationCounter       as integer   no-undo.
define variable hRelation              as handle    no-undo.
define variable iRelationFieldCounter  as integer   no-undo.
define variable cRelParentFieldDetails as character no-undo.
define variable cRelChildFieldDetails  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelation       for temp-table ttTableRelation.
define buffer bttTableRelationView-1 for temp-table ttTableRelationView.
define buffer bttTableRelationView-2 for temp-table ttTableRelationView.
define buffer bttTableRelationField  for temp-table ttTableRelationField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do iRelationCounter = 1 to phDataset:num-relations:
  
  hRelation = phDataset:get-relation( iRelationCounter ).
  
  find bttTableRelation
    where bttTableRelation.DatabaseName     = pcDatabaseName
      and bttTableRelation.ParentTableName  = hRelation:parent-buffer:table
      and bttTableRelation.ChildTableName   = hRelation:child-buffer:table
      and bttTableRelation.SequentialNumber = iRelationCounter
    no-error.

  create bttTableRelation.
  
  assign
    giRelationSeq                     = giRelationSeq + 1
    bttTableRelation.RelationId       = giRelationSeq
    bttTableRelation.DatabaseName     = pcDatabaseName
    bttTableRelation.ParentTableName  = hRelation:parent-buffer:table
    bttTableRelation.ChildTableName   = hRelation:child-buffer:table
    bttTableRelation.SequentialNumber = iRelationCounter
    bttTableRelation.RelationType     = '1:cn':U
    .
  
  create bttTableRelationView-1.
  
  assign
    cRelParentFieldDetails                    = '':U
    giRelationViewSeq                         = giRelationViewSeq + 1
    bttTableRelationView-1.RelationViewId     = giRelationViewSeq
    bttTableRelationView-1.RelationId         = bttTableRelation.RelationId
    bttTableRelationView-1.DatabaseName       = bttTableRelation.DatabaseName
    bttTableRelationView-1.ReferenceTableName = bttTableRelation.ParentTableName
    bttTableRelationView-1.RelatedTableName   = bttTableRelation.ChildTableName
    bttTableRelationView-1.RelationType       = bttTableRelation.RelationType
    .
  
  create bttTableRelationView-2.
  
  assign
    cRelChildFieldDetails                     = '':U
    giRelationViewSeq                         = giRelationViewSeq + 1
    bttTableRelationView-2.RelationViewId     = giRelationViewSeq
    bttTableRelationView-2.RelationId         = bttTableRelation.RelationId
    bttTableRelationView-2.DatabaseName       = bttTableRelation.DatabaseName
    bttTableRelationView-2.ReferenceTableName = bttTableRelation.ChildTableName
    bttTableRelationView-2.RelatedTableName   = bttTableRelation.ParentTableName
    bttTableRelationView-2.RelationType       = (if num-entries(bttTableRelation.RelationType, ':':U) = 2 then
                                                  substitute('&1:&2':U,
                                                             entry(2, bttTableRelation.RelationType, ':':U),
                                                             entry(1, bttTableRelation.RelationType, ':':U))
                                                else
                                                  '?':U)
    bttTableRelationView-2.ParentRelation     = yes
    .
  
  do iRelationFieldCounter = 1 to num-entries( hRelation:relation-fields ) by 2:
    
    create bttTableRelationField.
    
    bttTableRelationField.RelationId = bttTableRelation.RelationId.
    
    assign
      bttTableRelationField.Order              = iRelationFieldCounter / 2
      bttTableRelationField.ParentConstantData = '':U
      bttTableRelationField.ChildConstantData  = '':U
      bttTableRelationField.FieldRelationType  = 'DB-Field':U
      bttTableRelationField.ParentFieldName    = entry( iRelationFieldCounter, hRelation:relation-fields )
      bttTableRelationField.ChildFieldName     = entry( iRelationFieldCounter + 1, hRelation:relation-fields )
      .
    
    validate bttTableRelationField.
    
    assign
      bttTableRelation.ParentFields         = substitute('&1, &2':U,
                                                         bttTableRelation.ParentFields,
                                                         (if bttTableRelationField.ParentFieldName > '':U then
                                                            bttTableRelationField.ParentFieldName
                                                          else
                                                            bttTableRelationField.ParentConstantData) )
      cRelParentFieldDetails                = substitute('&1   [ &2 = &3 ]':U,
                                                         cRelParentFieldDetails,
                                                         (if bttTableRelationField.ParentFieldName > '':U then
                                                            bttTableRelationField.ParentFieldName
                                                          else
                                                            bttTableRelationField.ParentConstantData),
                                                         (if bttTableRelationField.ChildFieldName > '':U then
                                                            bttTableRelationField.ChildFieldName
                                                          else
                                                            bttTableRelationField.ChildConstantData))
      bttTableRelation.ChildFields          = substitute('&1, &2':U,
                                                         bttTableRelation.ChildFields,
                                                         (if bttTableRelationField.ChildFieldName > '':U then
                                                            bttTableRelationField.ChildFieldName
                                                          else
                                                            bttTableRelationField.ChildConstantData))
      cRelChildFieldDetails                 = substitute('&1   [ &2 = &3 ]':U,
                                                         cRelChildFieldDetails,
                                                         (if bttTableRelationField.ChildFieldName > '':U then
                                                            bttTableRelationField.ChildFieldName
                                                          else
                                                            bttTableRelationField.ChildConstantData),
                                                         (if bttTableRelationField.ParentFieldName > '':U then
                                                            bttTableRelationField.ParentFieldName
                                                          else
                                                            bttTableRelationField.ParentConstantData))
      .
    
    if bttTableRelationField.ParentFieldName > '':U then
      bttTableRelation.ParentFieldList = substitute('&1,&2':U,
                                                    bttTableRelation.ParentFieldList,
                                                    bttTableRelationField.ParentFieldName).
    
    if bttTableRelationField.ChildFieldName > '':U then
      bttTableRelation.ChildFieldList = substitute('&1,&2':U,
                                                   bttTableRelation.ChildFieldList,
                                                   bttTableRelationField.ChildFieldName).
    
  end. /* do iRelationFieldCounter = 1 to num-entries( hRelation:relation-fields ) by 2 */
  
  assign
    bttTableRelationView-1.ReferenceFields    = trim(bttTableRelation.ParentFields, ' ,':U)
    bttTableRelationView-1.RelatedFields      = trim(bttTableRelation.ChildFields, ' ,':U)
    bttTableRelationView-1.FieldDetails       = trim(cRelParentFieldDetails)
    bttTableRelationView-1.ReferenceFieldList = trim(bttTableRelation.ParentFieldList, ',':U)
    bttTableRelationView-1.RelatedFieldList   = trim(bttTableRelation.ChildFieldList, ',':U)
    bttTableRelationView-2.ReferenceFields    = trim(bttTableRelation.ChildFields, ' ,':U)
    bttTableRelationView-2.RelatedFields      = trim(bttTableRelation.ParentFields, ' ,':U)
    bttTableRelationView-2.FieldDetails       = trim(cRelChildFieldDetails)
    bttTableRelationView-2.RelatedFieldList   = trim(bttTableRelation.ParentFieldList, ',':U)
    bttTableRelationView-2.ReferenceFieldList = trim(bttTableRelation.ChildFieldList, ',':U)
    .

  validate bttTableRelationView-1.
  validate bttTableRelationView-2.
  
  validate bttTableRelation.
  
end. /* do iRelationCounter = 1 to phDataset:num-relations */

end procedure. /* qg_AddDatasetRelations */


PROCEDURE qg_AddIndices :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add Indices of given Table to cache.                                       */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = Database that contains the Table of the   */
/*                                  indices that should be added.             */
/* pcTable                        = Table that contains the indices that      */
/*                                  should be added.                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabase as character no-undo.
define input parameter pcTable    as character no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cSchemaDatabaseName  as character no-undo.

define variable hFileBuffer          as handle    no-undo.
define variable hFieldBuffer         as handle    no-undo.

define variable cIndexQueryText      as character no-undo.
define variable hIndexQuery          as handle    no-undo.
define variable hIndexBuffer         as handle    no-undo.

define variable cIndexFieldQueryText as character no-undo.
define variable hIndexFieldQuery     as handle    no-undo.
define variable hIndexFieldBuffer    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndex      for temp-table ttIndex.
define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    pcDatabase > '':U
  and pcTable    > '':U then
do:
  
  cSchemaDatabaseName = sdbname( pcDatabase ).
  
  create buffer hFileBuffer       for table substitute('&1._File':U, cSchemaDatabaseName).
  create buffer hIndexBuffer      for table substitute('&1._Index':U, cSchemaDatabaseName).
  create buffer hIndexFieldBuffer for table substitute('&1._Index-Field':U, cSchemaDatabaseName).
  create buffer hFieldBuffer      for table substitute('&1._Field':U, cSchemaDatabaseName).
  
  hFileBuffer:find-first(substitute('where _File._File-Name = &1':U,
                                    quoter(pcTable)),
                         no-lock) no-error.
  
  if not hFileBuffer:available then
    leave.
  
  assign
    cIndexQueryText      =            'for each _Index':U
                           + '~n':U + '  where _Index._File-recid = &1':U
                           + '~n':U + '  no-lock':U
    cIndexFieldQueryText =            'for each _Index-Field':U
                           + '~n':U + '  where _Index-Field._Index-recid = &1':U
                           + '~n':U + '  no-lock':U
    .
  
  create query hIndexQuery.
  create query hIndexFieldQuery.
  
  hIndexQuery:set-buffers(hIndexBuffer).
  hIndexFieldQuery:set-buffers(hIndexFieldBuffer).
  
  hIndexQuery:query-prepare(substitute(cIndexQueryText, quoter(hFileBuffer:recid))).
  hIndexQuery:query-open().
  
  hIndexQuery:get-first().
  
  do while not hIndexQuery:query-off-end:
    
    create bttIndex.
    
    assign
      bttIndex.DatabaseName = pcDatabase
      bttIndex.TableName    = pcTable
      bttIndex.IndexName    = hIndexBuffer::_Index-Name
      bttIndex.IsPrimary    = (hIndexBuffer:recid = hFileBuffer::_Prime-Index)
      bttIndex.IsUnique     = hIndexBuffer::_Unique
      .
    
    hIndexFieldQuery:query-prepare(substitute(cIndexFieldQueryText, quoter(hIndexBuffer:recid))).
    hIndexFieldQuery:query-open().
    
    hIndexFieldQuery:get-first().
    
    do while not hIndexFieldQuery:query-off-end:
      
      hFieldBuffer:find-first(substitute('where recid(_Field) = &1':U,
                                         quoter(hIndexFieldBuffer::_Field-recid)),
                              no-lock) no-error.
      
      if not hFieldBuffer:available then
        next.
      
      create bttIndexField.
    
      assign
        bttIndexField.DatabaseName  = pcDatabase
        bttIndexField.TableName     = pcTable
        bttIndexField.IndexName     = hIndexBuffer::_Index-Name
        bttIndexField.FieldName     = hFieldBuffer::_Field-Name
        bttIndexField.IndexSequence = hIndexFieldBuffer::_Index-Seq
        bttIndexField.DataType      = hFieldBuffer::_Data-Type
        bttIndexField.SortAscending = hIndexFieldBuffer::_Ascending
        bttIndex.IndexFieldList     = substitute('&1,&2':U,
                                                 bttIndex.IndexFieldList,
                                                 bttIndexField.FieldName)
        bttIndex.IndexFields        = substitute('&1 &2&3':U,
                                                 bttIndex.IndexFields,
                                                 string(bttIndexField.SortAscending, '+/-':U),
                                                 bttIndexField.FieldName)
        .
      
      hIndexFieldQuery:get-next().
      
    end. /* do while not hIndexFieldQuery:query-off-end */
    
    assign
      bttIndex.IndexFieldList = trim(bttIndex.IndexFieldList, ',':U)
      bttIndex.IndexFields    = trim(bttIndex.IndexFields)
      .
    
    hIndexQuery:get-next().
    
  end. /* do while not hIndexQuery:query-off-end */
  
end. /* if pcDBName > '':U */

finally:
  
  if valid-handle (hFileBuffer) then
    delete object hFileBuffer.
  
  if valid-handle(hIndexQuery) then
    delete object hIndexQuery.
  
  if valid-handle (hIndexBuffer) then
    delete object hIndexBuffer.
  
  if valid-handle(hIndexFieldQuery) then
    delete object hIndexFieldQuery.
  
  if valid-handle (hIndexFieldBuffer) then
    delete object hIndexFieldBuffer.
  
  if valid-handle (hFieldBuffer) then
    delete object hFieldBuffer.
  
end finally.

end procedure. /* qg_AddIndices */


PROCEDURE qg_AddTableDetails :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Load additional information for the given table.                           */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Name of the database that contains the    */
/*                                  table.                                    */
/* pcTableName                    = Table name for which to load the          */
/*                                  additional information.                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cBasisDBName           as character no-undo.
define variable cRepTableName          as character no-undo.

define variable cQueryText             as character no-undo.
define variable hQuery                 as handle    no-undo.

define variable hRepFieldBuffer        as handle    no-undo.
define variable hRepDomainBuffer       as handle    no-undo.
define variable cCustomized_DomainObj  as character no-undo.

define variable cRepRelQueryText       as character no-undo.
define variable hRepRelQuery           as handle    no-undo.
define variable hRepRelBuffer          as handle    no-undo.

define variable cRepRelFieldQueryText  as character no-undo.
define variable hRepRelFieldQuery      as handle    no-undo.
define variable hRepRelFieldBuffer     as handle    no-undo.
define variable hRepField1Buffer       as handle    no-undo.
define variable hRepField2Buffer       as handle    no-undo.

define variable cRelParentFieldDetails as character no-undo.
define variable cRelChildFieldDetails  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase           for temp-table ttDatabase.
define buffer bttTable              for temp-table ttTable.
define buffer bttField              for temp-table ttField.
define buffer bttTableRelation      for temp-table ttTableRelation.
define buffer bttTableRelationField for temp-table ttTableRelationField.
define buffer b1ttTableRelationView for temp-table ttTableRelationView.
define buffer b2ttTableRelationView for temp-table ttTableRelationView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttDatabase
  where bttDatabase.DatabaseName = pcDatabaseName
  no-error.

if not available bttDatabase then
  leave.

find first bttTable
  where bttTable.TableName = pcTableName
  no-error.

if not available bttTable then
  leave.

/* Add table repository information. */

if not bttTable.DescriptionLoaded then
  run qg_AddTableRepositoryInfo(bttTable.DatabaseName, bttTable.TableName).

/* Add indices if necessary. */

if not can-find(first ttIndex
                  where ttIndex.DatabaseName = bttTable.DatabaseName
                    and ttIndex.TableName    = bttTable.TableName) then
  
  run qg_AddIndices(bttTable.DatabaseName, bttTable.TableName).

cBasisDBName = bttDatabase.BasisDBName.

if    cBasisDBName > '':U
  and connected(cBasisDBName) then
do:

  /* Add proALPHA repository information. */
  
  create query hQuery.
  
  create buffer hRepFieldBuffer  for table substitute('&1.DRC_Field':U, cBasisDBName) no-error.
  
  if not valid-object( hRepFieldBuffer ) then
    return.
  
  create buffer hRepDomainBuffer for table substitute('&1.DRC_Domain':U, cBasisDBName) no-error.
  
  if not valid-handle( hRepDomainBuffer ) then
    return.
  
  hQuery:set-buffers(hRepFieldBuffer).
  
  cQueryText =            'for each DRC_Field':U
               + '~n':U + '  where DRC_Field.DRC_Table_Obj = &1':U
               + '~n':U + '  no-lock':U.
  
  hQuery:query-prepare(substitute(cQueryText,
                                  quoter(bttTable.RepObjectId))).
  hQuery:query-open().
  
  hQuery:get-first().
  
  do while not hQuery:query-off-end:
    
    find first bttField
      where bttField.DatabaseName = pcDatabaseName
        and bttField.TableName    = pcTableName
        and bttField.FieldName    = hRepFieldBuffer::DRC_Field_ID
      no-error.
    
    if available bttField then
    do:
      
      assign
        bttField.RepObjectId = hRepFieldBuffer::DRC_Field_Obj
        bttField.IsObjectId =  (     bttField.IsObjectId
                                  or lookup(bttField.Domain, {&K_OBJECT_ID_DOMAIN}) > 0 )
        .
      
      if gcCustomLevel > '':U then
        cCustomized_DomainObj = qg_cCustomizedRepositoryValue( bttField.DatabaseName,
                                                               'DRC_Field':U,
                                                               'DRC_Domain_Obj':U,
                                                               bttField.RepObjectId ).
      
      hRepDomainBuffer:find-first( substitute( 'where DRC_Domain.DRC_Domain_Obj = &1':U,
                                               quoter( ( if cCustomized_DomainObj > '':U then
                                                           cCustomized_DomainObj
                                                         else
                                                           hRepFieldBuffer::DRC_Domain_Obj ) ) ),
                                   no-lock ) no-error.
      
      bttField.Domain = ( if hRepDomainBuffer:available then
                            hRepDomainBuffer::DRC_Domain_ID
                          else
                            '':U ).
      
    end. /* if available bttField */
    
    hQuery:get-next().
    
  end. /* do while not hQuery:query-off-end */
  
  if bttDatabase.VirtualDBFieldsPossible then
    
    run qg_AddTableVirtualDBFields( buffer bttDatabase,
                                    buffer bttTable ).
    
  if bttDatabase.VirtualIndicesPossible then
     
    run qg_AddTableVirtualIndices( buffer bttDatabase,
                                   buffer bttTable ).
    
  create query hRepRelQuery.
  create query hRepRelFieldQuery.
  
  create buffer hRepRelBuffer for table substitute('&1.DRC_Relation':U, cBasisDBName) no-error.
  
  if valid-handle(hRepRelBuffer) then
    create buffer hRepRelFieldBuffer for table substitute('&1.DRC_RelationField':U, cBasisDBName) no-error.
  
  else
  do:
    
    create buffer hRepRelBuffer for table substitute('&1.D_Rel':U, cBasisDBName) no-error.
    
    if valid-handle(hRepRelBuffer) then
      create buffer hRepRelFieldBuffer for table substitute('&1.D_RelSpalte':U, cBasisDBName) no-error.
    
  end. /* if valid-handle(hRepRelBuffer) then */
  
  if    valid-handle(hRepRelBuffer)
    and valid-handle(hRepRelFieldBuffer) then
  do:
    
    hRepRelQuery:set-buffers(hRepRelBuffer).
    
    if hRepRelBuffer:name = 'DRC_Relation':U then
    do:
      
      create buffer hRepField1Buffer for table 'DRC_Field':U buffer-name 'b1DRC_Field':U.
      create buffer hRepField2Buffer for table 'DRC_Field':U buffer-name 'b2DRC_Field':U.
      
      hRepRelFieldQuery:set-buffers(hRepRelFieldBuffer, hRepField1Buffer, hRepField2Buffer).
      
      assign
        cRepRelQueryText      =            'for each DRC_Relation':U
                                + '~n':U + '  where ( DRC_Relation.Parent_DRC_Table_Obj = &1':U
                                + '~n':U + '     or   DRC_Relation.Child_DRC_Table_Obj  = &1 )':U
                                + '~n':U + '  no-lock':U
        cRepRelFieldQueryText =            'for each DRC_RelationField':U
                                + '~n':U + '  where DRC_RelationField.DRC_Relation_Obj  = &1':U
                                + '~n':U + '  no-lock,':U
                                + '~n':U + 'first b1DRC_Field':U
                                + '~n':U + '  where b1DRC_Field.DRC_Field_Obj = DRC_RelationField.Parent_DRC_Field_Obj':U
                                + '~n':U + '  left outer-join':U
                                + '~n':U + '  no-lock,':U
                                + '~n':U + 'first b2DRC_Field':U
                                + '~n':U + '  where b2DRC_Field.DRC_Field_Obj = DRC_RelationField.Child_DRC_Field_Obj':U
                                + '~n':U + '  left outer-join':U
                                + '~n':U + '  no-lock':U
        .
      
      hRepRelQuery:query-prepare(substitute(cRepRelQueryText,
                                            quoter(bttTable.RepObjectId))).
      hRepRelQuery:query-open().
      
      hRepRelQuery:get-first().
      
      do while not hRepRelQuery:query-off-end:
      
        find bttTableRelation
          where bttTableRelation.DatabaseName     = pcDatabaseName
            and bttTableRelation.ParentTableName  = hRepRelBuffer::Parent_DRC_Table_ID
            and bttTableRelation.ChildTableName   = hRepRelBuffer::Child_DRC_Table_ID
            and bttTableRelation.SequentialNumber = hRepRelBuffer::DRC_Relation_ID
          no-error.
        
        if not available bttTableRelation then
        do:
          
          create bttTableRelation.
          
          assign
            giRelationSeq                     = giRelationSeq + 1
            bttTableRelation.RelationId       = giRelationSeq
            bttTableRelation.DatabaseName     = pcDatabaseName
            bttTableRelation.ParentTableName  = hRepRelBuffer::Parent_DRC_Table_ID
            bttTableRelation.ChildTableName   = hRepRelBuffer::Child_DRC_Table_ID
            bttTableRelation.SequentialNumber = hRepRelBuffer::DRC_Relation_ID
            bttTableRelation.RelationType     = hRepRelBuffer::RelationType
            .
          
          create b1ttTableRelationView.
          
          assign
            cRelParentFieldDetails                   = '':U
            giRelationViewSeq                        = giRelationViewSeq + 1
            b1ttTableRelationView.RelationViewId     = giRelationViewSeq
            b1ttTableRelationView.RelationId         = bttTableRelation.RelationId
            b1ttTableRelationView.DatabaseName       = bttTableRelation.DatabaseName
            b1ttTableRelationView.ReferenceTableName = bttTableRelation.ParentTableName
            b1ttTableRelationView.RelatedTableName   = bttTableRelation.ChildTableName
            b1ttTableRelationView.RelationType       = bttTableRelation.RelationType
            .
          
          create b2ttTableRelationView.
          
          assign
            cRelChildFieldDetails                    = '':U
            giRelationViewSeq                        = giRelationViewSeq + 1
            b2ttTableRelationView.RelationViewId     = giRelationViewSeq
            b2ttTableRelationView.RelationId         = bttTableRelation.RelationId
            b2ttTableRelationView.DatabaseName       = bttTableRelation.DatabaseName
            b2ttTableRelationView.ReferenceTableName = bttTableRelation.ChildTableName
            b2ttTableRelationView.RelatedTableName   = bttTableRelation.ParentTableName
            b2ttTableRelationView.RelationType       = (if num-entries(bttTableRelation.RelationType, ':':U) = 2 then
                                                          substitute('&1:&2':U,
                                                                     entry(2, bttTableRelation.RelationType, ':':U),
                                                                     entry(1, bttTableRelation.RelationType, ':':U))
                                                        else
                                                          '?':U)
            b2ttTableRelationView.ParentRelation     = yes
            .
          
          hRepRelFieldQuery:query-prepare(substitute(cRepRelFieldQueryText,
                                                     quoter(hRepRelBuffer::DRC_Relation_Obj))).
          hRepRelFieldQuery:query-open().
          
          hRepRelFieldQuery:get-first().
    
          do while not hRepRelFieldQuery:query-off-end:
    
            find bttTableRelationField
              where bttTableRelationField.RelationId = bttTableRelation.RelationId
                and bttTableRelationField.Order      = hRepRelFieldBuffer::DRC_RelationField_ID
              no-error.
            
            if not available bttTableRelationField then
            do:
      
              create bttTableRelationField.
              
              bttTableRelationField.RelationId = bttTableRelation.RelationId.
              
              assign
                bttTableRelationField.Order              = hRepRelFieldBuffer::DRC_RelationField_ID
                bttTableRelationField.ParentConstantData = hRepRelFieldBuffer::Parent_Constant_Data
                bttTableRelationField.ChildConstantData  = hRepRelFieldBuffer::Child_Constant_Data
                bttTableRelationField.FieldRelationType  = hRepRelFieldBuffer::ColumnInfoType
                .
              
              if hRepField1Buffer:available then
                bttTableRelationField.ParentFieldName = hRepField1Buffer::DRC_Field_ID.
              
              if hRepField2Buffer:available then
                bttTableRelationField.ChildFieldName = hRepField2Buffer::DRC_Field_ID.
              
              validate bttTableRelationField.
              
              assign
                bttTableRelation.ParentFields         = substitute('&1, &2':U,
                                                                   bttTableRelation.ParentFields,
                                                                   (if bttTableRelationField.ParentFieldName > '':U then
                                                                      bttTableRelationField.ParentFieldName
                                                                    else
                                                                      bttTableRelationField.ParentConstantData) )
                cRelParentFieldDetails                = substitute('&1   [ &2 = &3 ]':U,
                                                                   cRelParentFieldDetails,
                                                                   (if bttTableRelationField.ParentFieldName > '':U then
                                                                      bttTableRelationField.ParentFieldName
                                                                    else
                                                                      bttTableRelationField.ParentConstantData),
                                                                   (if bttTableRelationField.ChildFieldName > '':U then
                                                                      bttTableRelationField.ChildFieldName
                                                                    else
                                                                      bttTableRelationField.ChildConstantData))
                bttTableRelation.ChildFields          = substitute('&1, &2':U,
                                                                   bttTableRelation.ChildFields,
                                                                   (if bttTableRelationField.ChildFieldName > '':U then
                                                                      bttTableRelationField.ChildFieldName
                                                                    else
                                                                      bttTableRelationField.ChildConstantData))
                cRelChildFieldDetails                 = substitute('&1   [ &2 = &3 ]':U,
                                                                   cRelChildFieldDetails,
                                                                   (if bttTableRelationField.ChildFieldName > '':U then
                                                                      bttTableRelationField.ChildFieldName
                                                                    else
                                                                      bttTableRelationField.ChildConstantData),
                                                                   (if bttTableRelationField.ParentFieldName > '':U then
                                                                      bttTableRelationField.ParentFieldName
                                                                    else
                                                                      bttTableRelationField.ParentConstantData))
                .
              
              if bttTableRelationField.ParentFieldName > '':U then
                bttTableRelation.ParentFieldList = substitute('&1,&2':U,
                                                              bttTableRelation.ParentFieldList,
                                                              bttTableRelationField.ParentFieldName).
              
              if bttTableRelationField.ChildFieldName > '':U then
                bttTableRelation.ChildFieldList = substitute('&1,&2':U,
                                                             bttTableRelation.ChildFieldList,
                                                             bttTableRelationField.ChildFieldName).
              
            end. /* if not available bttTableRelationField */
            
            hRepRelFieldQuery:get-next().
            
          end. /* do while not hRepRelFieldQuery:query-off-end: */
          
          assign
            b1ttTableRelationView.ReferenceFields    = trim(bttTableRelation.ParentFields, ' ,':U)
            b1ttTableRelationView.RelatedFields      = trim(bttTableRelation.ChildFields, ' ,':U)
            b1ttTableRelationView.FieldDetails       = trim(cRelParentFieldDetails)
            b1ttTableRelationView.ReferenceFieldList = trim(bttTableRelation.ParentFieldList, ',':U)
            b1ttTableRelationView.RelatedFieldList   = trim(bttTableRelation.ChildFieldList, ',':U)
            b2ttTableRelationView.ReferenceFields    = trim(bttTableRelation.ChildFields, ' ,':U)
            b2ttTableRelationView.RelatedFields      = trim(bttTableRelation.ParentFields, ' ,':U)
            b2ttTableRelationView.FieldDetails       = trim(cRelChildFieldDetails)
            b2ttTableRelationView.RelatedFieldList   = trim(bttTableRelation.ParentFieldList, ',':U)
            b2ttTableRelationView.ReferenceFieldList = trim(bttTableRelation.ChildFieldList, ',':U)
            .
    
          validate b1ttTableRelationView.
          validate b2ttTableRelationView.
          
          validate bttTableRelation.
          
        end. /* if not available bttTableRelation */
        
        hRepRelQuery:get-next().
        
      end. /* do while not hRepRelQuery:query-off-end */
      
    end. /* if hRepRelBuffer:name = 'DRC_Relation':U */
    
    else
    do:
      
      hRepRelFieldQuery:set-buffers(hRepRelFieldBuffer).
      
      assign
        cRepRelQueryText      =            'for each D_Rel':U
                                + '~n':U + '  where ( D_Rel.Tabellenname_1 = &1':U
                                + '~n':U + '     or   D_Rel.Tabellenname_2 = &1 )':U
                                + '~n':U + '  no-lock':U
        cRepRelFieldQueryText =            'for each D_RelSpalte':U
                                + '~n':U + '  where D_RelSpalte.Tabellenname_1 = &1':U
                                + '~n':U + '    and D_RelSpalte.TabellenName_2 = &2':U
                                + '~n':U + '    and D_RelSpalte.lfdNr          = &3':U
                                + '~n':U + '  no-lock':U
        .
      
      hRepRelQuery:query-prepare(substitute(cRepRelQueryText,
                                            quoter(bttTable.RepTableId))).
      
      hRepRelQuery:query-open().
      
      hRepRelQuery:get-first().
      
      do while not hRepRelQuery:query-off-end:
        
        find bttTableRelation
          where bttTableRelation.DatabaseName     = pcDatabaseName
            and bttTableRelation.ParentTableName  = hRepRelBuffer::Tabellenname_1
            and bttTableRelation.ChildTableName   = hRepRelBuffer::Tabellenname_2
            and bttTableRelation.SequentialNumber = hRepRelBuffer::lfdNr
          no-error.
        
        if not available bttTableRelation then
        do:
          
          create bttTableRelation.
          
          assign
            giRelationSeq                     = giRelationSeq + 1
            bttTableRelation.RelationId       = giRelationSeq
            bttTableRelation.DatabaseName     = pcDatabaseName
            bttTableRelation.ParentTableName  = hRepRelBuffer::Tabellenname_1
            bttTableRelation.ChildTableName   = hRepRelBuffer::Tabellenname_2
            bttTableRelation.SequentialNumber = hRepRelBuffer::lfdNr
            bttTableRelation.RelationType     = hRepRelBuffer::Rel_Art
            .
          
          create b1ttTableRelationView.
          
          assign
            cRelParentFieldDetails                   = '':U
            giRelationViewSeq                        = giRelationViewSeq + 1
            b1ttTableRelationView.RelationViewId     = giRelationViewSeq
            b1ttTableRelationView.RelationId         = bttTableRelation.RelationId
            b1ttTableRelationView.DatabaseName       = bttTableRelation.DatabaseName
            b1ttTableRelationView.ReferenceTableName = bttTableRelation.ParentTableName
            b1ttTableRelationView.RelatedTableName   = bttTableRelation.ChildTableName
            b1ttTableRelationView.RelationType       = bttTableRelation.RelationType
            .
          
          create b2ttTableRelationView.
          
          assign
            cRelChildFieldDetails                    = '':U
            giRelationViewSeq                        = giRelationViewSeq + 1
            b2ttTableRelationView.RelationViewId     = giRelationViewSeq
            b2ttTableRelationView.RelationId         = bttTableRelation.RelationId
            b2ttTableRelationView.DatabaseName       = bttTableRelation.DatabaseName
            b2ttTableRelationView.ReferenceTableName = bttTableRelation.ChildTableName
            b2ttTableRelationView.RelatedTableName   = bttTableRelation.ParentTableName
            b2ttTableRelationView.RelationType       = (if num-entries(bttTableRelation.RelationType, ':':U) = 2 then
                                                          substitute('&1:&2':U,
                                                                     entry(2, bttTableRelation.RelationType, ':':U),
                                                                     entry(1, bttTableRelation.RelationType, ':':U))
                                                        else
                                                          '?':U)
            b2ttTableRelationView.ParentRelation     = yes
            .
  
          hRepRelFieldQuery:query-prepare(substitute(cRepRelFieldQueryText,
                                                     quoter(hRepRelBuffer::Tabellenname_1),
                                                     quoter(hRepRelBuffer::Tabellenname_2),
                                                     quoter(hRepRelBuffer::lfdNr))).
          hRepRelFieldQuery:query-open().
          
          hRepRelFieldQuery:get-first().
  
          do while not hRepRelFieldQuery:query-off-end:
            
            find bttTableRelationField
              where bttTableRelationField.RelationId = bttTableRelation.RelationId
                and bttTableRelationField.Order      = hRepRelFieldBuffer::Position
              no-error.
            
            if not available bttTableRelationField then
            do:
      
              create bttTableRelationField.
              
              assign
                bttTableRelationField.RelationId         = bttTableRelation.RelationId
                bttTableRelationField.Order              = hRepRelFieldBuffer::Position
                bttTableRelationField.FieldRelationType  = (if hRepRelFieldBuffer::SpaltenInfo > '':U then
                                                              hRepRelFieldBuffer::SpaltenInfo
                                                            else
                                                              'DB-Field':U)
                .
              
              if hRepRelFieldBuffer::SpaltenInfo = '':U then
                assign
                  bttTableRelationField.ParentFieldName = hRepRelFieldBuffer::SpaltenName_1
                  bttTableRelationField.ChildFieldName  = hRepRelFieldBuffer::SpaltenName_2
                  .
              
              else
              do:
                
                if can-find(ttField
                              where ttField.DatabaseName = pcDatabaseName
                                and ttField.TableName    = bttTableRelation.ParentTableName
                                and ttField.FieldName    = hRepRelFieldBuffer::SpaltenName_1) then
                  bttTableRelationField.ParentFieldName  = hRepRelFieldBuffer::SpaltenName_1.
                
                else
                  bttTableRelationField.ParentConstantData = hRepRelFieldBuffer::SpaltenName_1.
                
                if can-find(ttField
                              where ttField.DatabaseName = pcDatabaseName
                                and ttField.TableName    = bttTableRelation.ChildTableName
                                and ttField.FieldName    = hRepRelFieldBuffer::SpaltenName_2) then
                  bttTableRelationField.ChildFieldName   = hRepRelFieldBuffer::SpaltenName_2.
               
               else
                  bttTableRelationField.ChildConstantData = hRepRelFieldBuffer::SpaltenName_2.
                
              end. /* if hRepRelFieldBuffer::SpaltenInfo = '':U */
            
              validate bttTableRelationField.
              
              assign
                bttTableRelation.ParentFields = substitute('&1, &2':U,
                                                           bttTableRelation.ParentFields,
                                                           (if bttTableRelationField.ParentFieldName > '':U then
                                                              bttTableRelationField.ParentFieldName
                                                            else
                                                              bttTableRelationField.ParentConstantData) )
                cRelParentFieldDetails        = substitute('&1   [&2 = &3]':U,
                                                           cRelParentFieldDetails,
                                                           (if bttTableRelationField.ParentFieldName > '':U then
                                                              bttTableRelationField.ParentFieldName
                                                            else
                                                              bttTableRelationField.ParentConstantData),
                                                           (if bttTableRelationField.ChildFieldName > '':U then
                                                              bttTableRelationField.ChildFieldName
                                                            else
                                                              bttTableRelationField.ChildConstantData))
                bttTableRelation.ChildFields  = substitute('&1, &2':U,
                                                           bttTableRelation.ChildFields,
                                                           (if bttTableRelationField.ChildFieldName > '':U then
                                                              bttTableRelationField.ChildFieldName
                                                            else
                                                              bttTableRelationField.ChildConstantData))
                cRelChildFieldDetails         = substitute('&1   [&2 = &3]':U,
                                                           cRelChildFieldDetails,
                                                           (if bttTableRelationField.ChildFieldName > '':U then
                                                              bttTableRelationField.ChildFieldName
                                                            else
                                                              bttTableRelationField.ChildConstantData),
                                                           (if bttTableRelationField.ParentFieldName > '':U then
                                                              bttTableRelationField.ParentFieldName
                                                            else
                                                              bttTableRelationField.ParentConstantData))
                .
              
              if bttTableRelationField.ParentFieldName > '':U then
                bttTableRelation.ParentFieldList = substitute('&1,&2':U,
                                                              bttTableRelation.ParentFieldList,
                                                              bttTableRelationField.ParentFieldName).
              
              if bttTableRelationField.ChildFieldName > '':U then
                bttTableRelation.ChildFieldList = substitute('&1,&2':U,
                                                             bttTableRelation.ChildFieldList,
                                                             bttTableRelationField.ChildFieldName).
  
            end. /* if not available bttTableRelationField */
            
            hRepRelFieldQuery:get-next().
            
          end. /* do while not hRepRelFieldQuery:query-off-end */
          
          assign
            b1ttTableRelationView.ReferenceFields    = trim(bttTableRelation.ParentFields, ' ,':U)
            b1ttTableRelationView.RelatedFields      = trim(bttTableRelation.ChildFields, ' ,':U)
            b1ttTableRelationView.FieldDetails       = trim(cRelParentFieldDetails)
            b1ttTableRelationView.ReferenceFieldList = trim(bttTableRelation.ParentFieldList, ' ,':U)
            b1ttTableRelationView.RelatedFieldList   = trim(bttTableRelation.ChildFieldList, ' ,':U)
            b2ttTableRelationView.ReferenceFields    = trim(bttTableRelation.ChildFields, ' ,':U)
            b2ttTableRelationView.RelatedFields      = trim(bttTableRelation.ParentFields, ' ,':U)
            b2ttTableRelationView.FieldDetails       = trim(cRelChildFieldDetails)
            b2ttTableRelationView.RelatedFieldList   = trim(bttTableRelation.ParentFieldList, ' ,':U)
            b2ttTableRelationView.ReferenceFieldList = trim(bttTableRelation.ChildFieldList, ' ,':U)
            .
    
          validate b1ttTableRelationView.
          validate b2ttTableRelationView.
          
          validate bttTableRelation.
  
        end. /* if not available bttTableRelation */
          
        hRepRelQuery:get-next().
        
      end. /* do while not hRepRelQuery:query-off-end */
      
    end. /* else: if hRepRelBuffer:name = 'DRC_Relation':U */
    
  end. /* if    valid-handle(hRepRelBuffer) */
  
end. /* if    cBasisDBName > '':U ... */

bttTable.DetailsLoaded = yes.

finally:
  
  if valid-handle(hQuery) then
    delete object hQuery.
  
  if valid-handle(hRepDomainBuffer) then
    delete object hRepDomainBuffer.
  
  if valid-handle(hRepFieldBuffer) then
    delete object hRepFieldBuffer.
  
  if valid-handle(hRepRelQuery) then
    delete object hRepRelQuery.
  
  if valid-handle(hRepRelFieldQuery) then
    delete object hRepRelFieldQuery.
  
  if valid-handle(hRepRelBuffer) then
    delete object hRepRelBuffer.
  
  if valid-handle(hRepRelFieldBuffer) then
    delete object hRepRelFieldBuffer.

  if valid-handle(hRepField1Buffer) then
    delete object hRepField1Buffer.

  if valid-handle(hRepField2Buffer) then
    delete object hRepField2Buffer.

end finally.
  
end procedure. /* qg_AddTableDetails */


PROCEDURE qg_AddTableRepositoryInfo :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add table repository information.                                          */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cBasisDBName        as character no-undo.
define variable cRepTableName       as character no-undo.

define variable hRepTableBuffer     as handle    no-undo.
define variable hRepTableDescBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.
define buffer bttTable    for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttDatabase
  where bttDatabase.DatabaseName = pcDatabaseName
  no-error.

if not available bttDatabase then
  leave.

find first bttTable
  where bttTable.TableName = pcTableName
  no-error.

if not available bttTable then
  leave.

cBasisDBName = bttDatabase.BasisDBName.

if    cBasisDBName > '':U
  and connected(cBasisDBName) then
do:

  /* Add proALPHA repository information. */
  
  cRepTableName = pcTableName.
  
  if    bttDatabase.TempDB
    and cRepTableName begins 'TD_':U then
    overlay(cRepTableName, 1, 3) = 'TT_':U. 
  
  create buffer hRepTableBuffer for table substitute('&1.DRC_Table':U,
                                                     cBasisDBName) no-error.
  
  if not valid-handle(hRepTableBuffer) then
    leave.
  
  hRepTableBuffer:find-first(substitute('where DRC_Table.DRC_Table_ID = &1':U,
                                        quoter(cRepTableName)),
                             no-lock) no-error.
  
  if not hRepTableBuffer:available then
    leave.
  
  create buffer hRepTableDescBuffer for table substitute('&1.DBM_ShortDescription':U,
                                                         cBasisDBName).
  
  assign
    bttTable.InternalIdentifier = hRepTableBuffer::InternalIdentifier
    bttTable.CompanyInclude     = hRepTableBuffer::CompanyInclude
    bttTable.KeyInclude         = hRepTableBuffer::KeyInclude
    bttTable.RepTableId         = hRepTableBuffer::DRC_Table_ID
    bttTable.RepObjectId        = hRepTableBuffer::DRC_Table_Obj
    .

  if valid-handle(hRepTableDescBuffer) then
  do:
    
    hRepTableDescBuffer:find-first( substitute(   'where DBM_ShortDescription.Owning_Obj = &1':U
                                                + '  and DBM_ShortDescription.Sprache    = &2':U,
                                                quoter( hRepTableBuffer::DRC_Table_Obj ),
                                                quoter( gcRepositoryLanguage ) ),
                                    no-lock ) no-error.
    
    if hRepTableDescBuffer:available then
      assign
        bttTable.ShortDescription  = hRepTableDescBuffer::ShortDesc1
        bttTable.DescriptionLoaded = yes
        .
    
  end. /* if valid-handle(hRepTableDescBuffer) */

end. /* if    cBasisDBName > '':U ... */

finally:
  
  if valid-handle(hRepTableBuffer) then
    delete object hRepTableBuffer.
  
  if valid-handle(hRepTableDescBuffer) then
    delete object hRepTableDescBuffer.
  
end finally.

end procedure. /* qg_AddTableRepositoryInfo */


PROCEDURE qg_AddTables :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add Tables of given Database to cache.                                     */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = Database that contains the tables that    */
/*                                  should be added.                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabase as character no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cSchemaDatabaseName    as character no-undo.

define variable cTableQueryText        as character no-undo.
define variable cFieldQueryText        as character no-undo.
define variable hTableQuery            as handle    no-undo.
define variable hFieldQuery            as handle    no-undo.

define variable cTableName             as character no-undo.

define variable hFileBuffer            as handle    no-undo.
define variable hFieldBuffer           as handle    no-undo.

define variable cTriggerQueryText      as character no-undo.
define variable hTriggerQuery          as handle    no-undo.
define variable cTriggerEvent          as character no-undo.

define variable hFileTrigBuffer        as handle    no-undo.


/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.
define buffer bttTable    for temp-table ttTable.
define buffer bttField    for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

display unless-hidden
  substitute('Loading database &1 ...':T,
             pcDatabase)
    @ gcStatusText60
  with frame fStatus
    no-labels
    overlay
    color messages
    centered
    view-as dialog-box
    width 65
    .
process events.

find bttDatabase
  where bttDatabase.DatabaseName = pcDatabase
  no-error.

if not available bttDatabase then
  leave.

cSchemaDatabaseName = sdbname( pcDatabase ).

create query hTableQuery.
create query hTriggerQuery.
create query hFieldQuery.

assign
  hTableQuery:forward-only   = yes
  hTriggerQuery:forward-only = yes
  hFieldQuery:forward-only   = yes
  .

create buffer hFileBuffer     for table substitute('&1._File':U, cSchemaDatabaseName).
create buffer hFileTrigBuffer for table substitute('&1._File-Trig':U, cSchemaDatabaseName).
create buffer hFieldBuffer    for table substitute('&1._Field':U, cSchemaDatabaseName).

hTableQuery:set-buffers(hFileBuffer).
hTriggerQuery:set-buffers(hFileTrigBuffer).
hFieldQuery:set-buffers(hFieldBuffer).

/* For some odd reason the queries are much faster, when no fields option is  */
/* present - thus the fields option has been removed. Joins somehow perform   */
/* very bad on dynamic queries as well. For this reason a separate query is   */
/* used for every table.                                                      */

assign
  cTableQueryText   =            'for each _File':U
                      + '~n':U + '  no-lock':U
  cFieldQueryText   =            'for each _Field':U
                      + '~n':U + '  where _Field._File-recid = &1':U
                      + '~n':U + '  no-lock':U
  cTriggerQueryText =            'for each _File-Trig':U
                      + '~n':U + '  where _File-Trig._File-Recid = &1':U
                      + '~n':U + '  no-lock':U
  .

hTableQuery:query-prepare(cTableQueryText).
hTableQuery:query-open().

hTableQuery:get-first().

do while not hTableQuery:query-off-end:
  
  create bttTable.
  
  assign
    bttTable.DatabaseName  = pcDatabase
    bttTable.TableName     = hFileBuffer::_File-Name
    cTableName             = bttTable.TableName
    bttTable.FillInclude   = substitute('&1.fld':U,
                                        hFileBuffer::_Dump-name)
    bttTable.PhysicalTable = yes
    .
  
  hTriggerQuery:query-prepare(substitute(cTriggerQueryText, string(hFileBuffer:recid))).
  hTriggerQuery:query-open().
  
  hTriggerQuery:get-first().
  
  do while not hTriggerQuery:query-off-end:
    
    cTriggerEvent = hFileTrigBuffer::_Event.
    
    case cTriggerEvent:
      
      when 'CREATE':U then
        assign
          bttTable.CreateTrigger         = hFileTrigBuffer::_Proc-Name
          bttTable.CreateTriggerProcName = substring(bttTable.CreateTrigger,
                                                     max(r-index(bttTable.CreateTrigger, '/':U),
                                                         r-index(bttTable.CreateTrigger, '\':U)) + 1)
          .
      
      when 'WRITE':U then
        assign
          bttTable.WriteTrigger         = hFileTrigBuffer::_Proc-Name
          bttTable.WriteTriggerProcName = substring(bttTable.WriteTrigger,
                                                     max(r-index(bttTable.WriteTrigger, '/':U),
                                                         r-index(bttTable.WriteTrigger, '\':U)) + 1)
          .
      
      when 'DELETE':U then
        assign
          bttTable.DeleteTrigger         = hFileTrigBuffer::_Proc-Name
          bttTable.DeleteTriggerProcName = substring(bttTable.DeleteTrigger,
                                                     max(r-index(bttTable.DeleteTrigger, '/':U),
                                                         r-index(bttTable.DeleteTrigger, '\':U)) + 1)
          .
      
    end case. /* case hFileTrigBuffer::_Event */
    
    hTriggerQuery:get-next().
    
  end. /* do while not hTriggerQuery:query-off-end */
  
  hFieldQuery:query-prepare(substitute(cFieldQueryText, string(hFileBuffer:recid))).
  hFieldQuery:query-open().
  
  hFieldQuery:get-first().
  
  do while not hFieldQuery:query-off-end:
    
    create bttField.
    
    assign
      bttField.DatabaseName      = pcDatabase
      bttField.TableName         = hFileBuffer::_File-Name
      bttField.FieldName         = hFieldBuffer::_Field-Name
      bttField.DataType          = substitute('&1&2':U,
                                              caps(substring(hFieldBuffer::_Data-Type, 1, 1)),
                                              lc(substring(hFieldBuffer::_Data-Type, 2)))
      bttField.FieldExtent       = hFieldBuffer::_Extent
      bttField.FieldInitialValue = hFieldBuffer::_Initial
      bttField.FieldLabel        = (if hFieldBuffer::_Label = ? then
                                      '':U
                                    else
                                      hFieldBuffer::_Label)
      bttField.FieldColumnLabel  = (if hFieldBuffer::_Col-label = ? then
                                      '':U
                                    else
                                      hFieldBuffer::_Col-label)
      bttField.FieldDecimals     = hFieldBuffer::_Decimals
      bttField.FieldFormat       = hFieldBuffer::_Format
      bttField.IsMandatory       = hFieldBuffer::_Mandatory
      bttField.FieldViewAs       = hFieldBuffer::_View-As
      bttField.IsObjectId        = ( bttField.FieldName matches '*_Obj':U )
      .
    
    hFieldQuery:get-next().
    
  end. /* do while not hFieldQuery:query-off-end */
  
  /* Some tables have to be in the cache completely from the start. */
  if    bttTable.TableName = 'DRC_Table':U
     or bttTable.TableName = 'DRC_Field':U
     or bttTable.TableName = 'DRC_Domain':U then
    
    run qg_AddTableDetails( bttTable.DatabaseName, bttTable.TableName ).
  
  hTableQuery:get-next().
  
end. /* do while not hTableQuery:query-off-end */

finally:
  
  if valid-handle(hTableQuery) then
    delete object hTableQuery.
  
  if valid-handle (hFileBuffer) then
    delete object hFileBuffer.
  
  if valid-handle(hTriggerQuery) then
    delete object hTriggerQuery.
  
  if valid-handle (hFileTrigBuffer) then
    delete object hFileTrigBuffer.
  
  if valid-handle(hFieldQuery) then
    delete object hFieldQuery.
  
  if valid-handle (hFieldBuffer) then
    delete object hFieldBuffer.
  
end finally.
  
end procedure. /* qg_AddTables */


procedure qg_LoadAllTableDetailsOfSingleDatabase :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

display unless-hidden
  'Loading table details ...':T
    @ gcStatusText60
  with frame fStatus
    no-labels
    overlay
    color messages
    centered
    view-as dialog-box
    width 65
    in window {&WINDOW-NAME}
    .

process events.

for each bttTable
  where bttTable.DatabaseName  = pcDatabaseName
    and bttTable.DetailsLoaded = no
  on error undo, throw:
  
  run qg_AddTableDetails( bttTable.DatabaseName,
                          bttTable.TableName ).
  
end. /* for each bttTable */

finally:
  
  hide frame fStatus.
  
end finally.

end procedure. /* qg_LoadAllTableDetailsOfSingleDatabase */


/* ************************  Function Implementations ***************** */

function qg_cCustomizedRepositoryValue returns character 
  ( pcBasisDBName   as character,
    pcTableName     as character,
    pcFieldName     as character,
    pcOwning_Obj    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcBasisDBName                                                              */
/* pcTableName                                                                */
/* pcFieldName                                                                */
/* pcOwning_Obj                                                               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable hRepCustObjBuffer as handle    no-undo.

define buffer bttField for temp-table ttField.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create buffer hRepCustObjBuffer for table substitute( '&1.DRC_CustomizedObject':U, pcBasisDBName ) no-error.

if not valid-handle( hRepCustObjBuffer ) then
  return ?.

find bttField
  where bttField.DatabaseName = pcBasisDBName
    and bttField.TableName    = pcTableName
    and bttField.FieldName    = pcFieldName
  no-error.

if not available bttField then
  return ?.

hRepCustObjBuffer:find-last( substitute(   'where DRC_CustomizedObject.Owning_Obj    = &1':U
                                         + '  and DRC_CustomizedObject.CustomLevel  <= &2':U
                                         + '  and DRC_CustomizedObject.DRC_Field_Obj = &3':U
                                         + 'use-index Own':U,
                                         quoter( pcOwning_Obj ),
                                         quoter( gcCustomLevel ),
                                         quoter( bttField.RepObjectId ) ),
                              no-lock ) no-error.

return ( if hRepCustObjBuffer:available then
           hRepCustObjBuffer::CustomFieldValueChar
         else
           ? ).

end function. /* qg_cCustomizedRepositoryValue */

/* <<< Include: incl/database_schema.i <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/query_window.i >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : database_schema.i
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Wed Apr 06 11:56:21 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */



/* **********************  Internal Procedures  *********************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddFieldToQueryBufferFieldsTempTable Method-Library
procedure qg_AddFieldToQueryBufferFieldsTempTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryBuffer for temp-table ttQueryBuffer.

define input        parameter phField            as handle    no-undo.
define input        parameter pcFieldName        as character no-undo.
define input        parameter piFieldIndex       as integer   no-undo.
define input        parameter plIsVirtual        as logical   no-undo.

define input        parameter pcFieldNameToMatch as character no-undo.
define input-output parameter ioprMatch          as rowid     no-undo extent 4.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryBufferField for temp-table ttQueryBufferField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create bttQueryBufferField.

assign
  bttQueryBufferField.FieldHandle = phField
  bttQueryBufferField.FieldName   = pcFieldName
  bttQueryBufferField.FieldIndex  = piFieldIndex
  bttQueryBufferField.DisplayName = qg_cFormattedFieldName(?,
                                                           ?,
                                                           bttQueryBufferField.FieldName,
                                                           bttQueryBufferField.FieldIndex)
  bttQueryBufferField.IsVirtual   = plIsVirtual
  .

validate bttQueryBufferField.

if pcFieldNameToMatch > '':U then
do:
  
  if    ioprMatch[1]                  = ?
    and bttQueryBufferField.FieldName = pcFieldNameToMatch then
    
    ioprMatch[1] = rowid(bttQueryBufferField).
  
  else if ioprMatch[2]                       = ?
    and   bttQueryBufferField.FieldName begins pcFieldNameToMatch then
    
    ioprMatch[2] = rowid(bttQueryBufferField).
  
  else if ioprMatch[3]                        = ?
    and   pcFieldNameToMatch            matches '*_Obj':U
    and   bttQueryBufferField.FieldName       = substitute('&1_Obj':U,
                                                           pbttQueryBuffer.BufferHandle:table) then
    ioprMatch[3] = rowid(bttQueryBufferField).
  
  else if ioprMatch[4]                        = ?
    and   pcFieldNameToMatch            matches '*_Obj':U
    and   bttQueryBufferField.FieldName matches '*_Obj':U then
    
    ioprMatch[4] = rowid(bttQueryBufferField).
  
end. /* if pcFieldNameToMatch > '':U */

end procedure. /* qg_AddFieldToQueryBufferFieldsTempTable */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddFieldToQueryWindowObjFieldTempTable Method-Library
procedure qg_AddFieldToQueryWindowObjFieldTempTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow for temp-table ttQueryWindow.

define input parameter pcDatabaseName as character no-undo.
define input parameter pcBufferName   as character no-undo.
define input parameter pcTableName    as character no-undo.
define input parameter pcFieldName    as character no-undo.
define input parameter piFieldIndex   as integer   no-undo.
define input parameter pcFieldValue   as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindowObjField for temp-table ttQueryWindowObjField.

define buffer bttField               for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create bttQueryWindowObjField.

assign
  bttQueryWindowObjField.WindowHandle = pbttQueryWindow.WindowHandle
  bttQueryWindowObjField.DatabaseName = pcDatabaseName
  bttQueryWindowObjField.TableName    = pcTableName
  bttQueryWindowObjField.BufferName   = pcBufferName
  bttQueryWindowObjField.FieldName    = pcFieldName
  bttQueryWindowObjField.FieldIndex   = piFieldIndex
  bttQueryWindowObjField.DisplayName  = qg_cFormattedFieldName(?,
                                                               ?,
                                                               bttQueryWindowObjField.FieldName,
                                                               bttQueryWindowObjField.FieldIndex)
  .

find bttField
  where bttField.DatabaseName = bttQueryWindowObjField.DatabaseName
    and bttField.TableName    = bttQueryWindowObjField.TableName
    and bttField.FieldName    = bttQueryWindowObjField.FieldName
  no-error.

assign
  bttQueryWindowObjField.IsObjectId = (     bttQueryWindowObjField.FieldName matches '*_Obj':U
                                         or ( available bttField
                                          and bttField.Domain = {&K_OBJECT_ID_DOMAIN}) )
  bttQueryWindowObjField.IsVirtual  = ( if available bttField then
                                          bttField.IsVirtual
                                        else
                                          no )
  bttQueryWindowObjField.FieldType  = ( if available bttField then
                                          bttField.FieldType
                                        else
                                          {&K_FIELD_TYPE_DB_FIELD} )
  .



bttQueryWindowObjField.ContainsObj  =     pcFieldValue                    <> ?
                                      and num-entries(pcFieldValue, ':':U) = 3
                                      and length(pcFieldValue)            >= 10.

if bttQueryWindowObjField.ContainsObj then
  
  run qg_GetObjectIdTable( pcDatabaseName,
                           pcFieldValue,
                           output bttQueryWindowObjField.TargetDatabaseName,
                           output bttQueryWindowObjField.TargetTableName ).
  
bttQueryWindowObjField.Priority = (if bttQueryWindowObjField.FieldName = substitute('&1_Obj':U, bttQueryWindowObjField.TableName) then
                                     3
                                   else if    bttQueryWindowObjField.IsObjectId
                                          and bttQueryWindowObjField.ContainsObj then
                                     1
                                   else if bttQueryWindowObjField.IsObjectId then
                                     2
                                   else if bttQueryWindowObjField.ContainsObj then
                                     4
                                   else
                                     5).

validate bttQueryWindowObjField.

end procedure. /* qg_AddFieldToQueryWindowObjFieldTempTable */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_FillQueryBufferFieldsTempTable Method-Library
procedure qg_FillQueryBufferFieldsTempTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryBuffer for temp-table ttQueryBuffer.

define input        parameter pcFieldNameToMatch as character no-undo.
define input        parameter plAddVirtualFields as logical   no-undo.

define input-output parameter ioprMatch          as rowid     no-undo extent 4.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBufferfield       as handle    no-undo.
define variable cDatabaseName      as character no-undo.
define variable iFieldCounter      as integer   no-undo.
define variable iFieldIndexCounter as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

empty temp-table ttQueryBufferField.

/* Add physical fields. */

do iFieldCounter = 1 to pbttQueryBuffer.BufferHandle:num-fields:
  
  hBufferField = pbttQueryBuffer.BufferHandle:buffer-field(iFieldCounter).
  
  do iFieldIndexCounter = integer(hBufferField:extent > 0) to hBufferField:extent:
    
    run qg_AddFieldToQueryBufferFieldsTempTable( buffer pbttQueryBuffer,
                                                 hBufferField,
                                                 hBufferField:name,
                                                 iFieldIndexCounter,
                                                 no,
                                                 pcFieldNameToMatch,
                                                 input-output ioprMatch ).
    
  end. /* do iFieldIndexCounter = integer(hBufferField:extent > 0) to hBufferField:extent */
  
end. /* do iFieldCounter = 1 to pbttQueryBuffer.BufferHandle:num-fields */

/* Add virtual fields. */

if plAddVirtualFields then
do:
  
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( pbttQueryBuffer.BufferHandle ).
  
  if qg_lIsPhysicalDatabase( cDatabaseName ) then
    
    for each bttField
      where bttField.DatabaseName = cDatabaseName
        and bttField.TableName    = pbttQueryBuffer.BufferHandle:table
        and bttField.IsVirtual    = yes
      on error undo, throw:
      
      run qg_AddFieldToQueryBufferFieldsTempTable( buffer pbttQueryBuffer,
                                                   ?,
                                                   bttField.FieldName,
                                                   0,
                                                   bttField.IsVirtual,
                                                   pcFieldNameToMatch,
                                                   input-output ioprMatch ).
      
    end. /* for each bttField */
    
end. /* if plAddVirtualFields */

end procedure. /* qg_FillQueryBufferFieldsTempTable */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_GetOverlayColumnValue Method-Library
procedure qg_GetOverlayColumnValue :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttFieldOverlay for temp-table ttFieldOverlay.

define input  parameter plDeepResolve   as logical   no-undo.
define input parameter  plRawValues     as logical   no-undo.

define output parameter opcOverlayValue as character no-undo.
define output parameter oplResolved     as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldValue        as character no-undo.
define variable cKeyValues         as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle( pbttFieldOverlay.FieldHandle ) then
  
  cFieldValue = pbttFieldOverlay.FieldHandle:buffer-value( pbttFieldOverlay.FieldIndex ).

else
do:
  
  find bttVirtualFieldColumn
    where bttVirtualFieldColumn.OwnerHandle  = pbttFieldOverlay.OwnerHandle
      and bttVirtualFieldColumn.ColumnHandle = pbttFieldOverlay.ColumnHandle
    no-error.
  
  if not available bttVirtualFieldColumn then
    
    cFieldValue = ?.
  
  else
    
    cFieldValue = string( qg_clVirtualFieldValueAsLongchar( bttVirtualFieldColumn.FieldType,
                                                            bttVirtualFieldColumn.DataType,
                                                            bttVirtualFieldColumn.FieldName,
                                                            qg_cObjectIdForBuffer( bttVirtualFieldColumn.BufferHandle ),
                                                            ? ) ).
  
end. /* else: if valid-handle( pbttFieldOverlay.FieldHandle ) */

opcOverlayValue = cFieldValue.

if    cFieldValue > '':U
  and num-entries( cFieldValue, ':':U ) = 3 then
do:
  
  cKeyValues = qg_cOverlayFieldValue( buffer pbttFieldOverlay,
                                      cFieldValue,
                                      plDeepResolve ).

  if cKeyValues <> ? then
    
    assign
      opcOverlayValue = cKeyValues
      oplResolved     = yes
      .
  
end. /* if    cFieldValue > '':U ... */

end procedure. /* qg_GetOverlayColumnValue */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowAddSnapshot hQueryWindow 
PROCEDURE qg_QueryWindowAddSnapshot :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add snapshot of current query.                                             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow        as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(1).

run qg_AddTableSnapshot(hBuffer,
                        bttQueryWindow.QueryHandle:prepare-string,
                        bttQueryWindow.WindowHandle).

apply 'entry' to bttQueryWindow.WindowHandle.

end procedure. /* qg_QueryWindowAddSnapshot */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowAddSortFields hQueryWindow 
PROCEDURE qg_QueryWindowAddSortFields :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add sort phrase for given field list.                                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcSortFieldList                = List of fields to insert.                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow        as handle    no-undo.
define input parameter pcSortFieldList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i              as integer   no-undo.

define variable hEditor        as handle    no-undo.
define variable cQuerytext     as character no-undo.
define variable iOffset        as integer   no-undo.
define variable iLineEndOffset as integer   no-undo.
define variable cInsertText    as character no-undo.
define variable iLine          as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.
define buffer bttQueryAST       for temp-table ttQueryAST.
define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/*----------------------------------------------------------------------------*/
/* Get selection info                                                         */
/*----------------------------------------------------------------------------*/

assign
  hEditor    = bttQueryWindow.QueryTextEditorHandle
  cQueryText = hEditor:input-value
  iOffset    = (if hEditor:selection-end = ? then
                  hEditor:cursor-offset
                else
                  hEditor:selection-end - 1)
  .

/*----------------------------------------------------------------------------*/
/* Analyze selection and query text                                           */
/*----------------------------------------------------------------------------*/

run qg_ParseQueryConditions(cQueryText).

find last bttQueryCondition
  no-error.

if    available bttQueryCondition
  and bttQueryCondition.RightEndPos > iOffset then
  iOffset = bttQueryCondition.RightEndPos.

find first bttQueryAST
  where bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
    and lookup(bttQueryAST.TokenText, 'BREAK,BY':U) > 0
  no-error.

if    available bttQueryAST
  and bttQueryAST.TokenStart > iOffset then
do:
  
  iLineEndOffset = r-index(cQueryText, '~n':U, bttQueryAST.TokenStart).

  iOffset = (if iLineEndOffset > 0 then
               iLineEndOffset
             else
               1).
  
end. /* if    available bttQueryAST ... */

find last bttQueryAST
  where bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
    and lookup(bttQueryAST.TokenText, 'BREAK,BY':U) > 0
  no-error.

if    available bttQueryAST
  and bttQueryAST.TokenEnd < iOffset then
  iOffset = bttQueryAST.TokenEnd.

iLineEndOffset = index(cQueryText, '~n':U, iOffset).

if iLineEndOffset > 0 then
  iOffset = iLineEndOffset.

/*----------------------------------------------------------------------------*/
/* Generate line text.                                                        */
/*----------------------------------------------------------------------------*/

do i = 1 to num-entries(pcSortFieldList):
  
  cInsertText = substitute('&1  by &2~n':U,
                           cInsertText,
                           entry(i, pcSortFieldList)).
  
end. /* do i = 1 to num-entries(pcSortFieldList) */

cInsertText = trim(cInsertText, '~n':U).

/*----------------------------------------------------------------------------*/
/* Insert text lines.                                                         */
/*----------------------------------------------------------------------------*/

run qg_InsertTextLines(cInsertText,
                       iOffset,
                       input-output cQueryText,
                             output iLine).

/*----------------------------------------------------------------------------*/
/* Update editor                                                              */
/*----------------------------------------------------------------------------*/

cQueryText = qg_cBeautifyQueryText(cQueryText).

run qg_UpdateEditor(hEditor,
                    cQueryText,
                    iLine,
                    iLine + max(0, num-entries(cInsertText, '~n':U) - 1)).

apply 'entry':U to hEditor.

end procedure. /* qg_QueryWindowAddSortFields */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowAddSortOption hQueryWindow 
PROCEDURE qg_QueryWindowAddSortOption :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add selected fields as sort phrase.                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plDescending                   = Add sort option as descending sort.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow     as handle    no-undo.
define input parameter plDescending as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer                as handle    no-undo.
define variable cDatabaseName          as character no-undo.
define variable lPhysicalDatabase      as logical   no-undo.

define variable i                      as integer   no-undo.
define variable iFieldCount            as integer   no-undo.

define variable hFieldSelectionBuffer  as handle    no-undo.
define variable cSortFieldList         as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

hFieldSelectionBuffer = bttQueryWindow.QueryFieldBrowseBufferHandle.

assign
  hBuffer           = bttQueryWindow.QueryBrowseHandle:query:get-buffer-handle(1)
  cDatabaseName     = qg_cDatabaseNameForTableOrBuffer( hBuffer )
  lPhysicalDatabase = qg_lIsPhysicalDatabase( cDatabaseName )
  .

  
do i = 1 to bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows:
  
  bttQueryWindow.QueryFieldBrowseHandle:fetch-selected-row (i).
  
  if    lPhysicalDatabase
    and hFieldSelectionBuffer::IsVirtual then
    
    message
      substitute( 'Virtual field &1 can not be used in the query!':T,
                  quoter( hFieldSelectionBuffer::FieldName ) ) skip
      view-as alert-box
      warning
      buttons ok
      in window bttQueryWindow.WindowHandle.
  
  else
    
    assign
      cSortFieldList = substitute('&1,&2&3':U,
                                  cSortFieldList,
                                  qg_cFormattedFieldName(?,
                                                         hFieldSelectionBuffer::BufferName,
                                                         hFieldSelectionBuffer::FieldName,
                                                         hFieldSelectionBuffer::FieldIndex),
                                  (if plDescending then
                                     ' descending':U
                                   else
                                     '':U))
      iFieldCount   = iFieldCount + 1
      .
  
end. /* i = 1 to bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows */

if iFieldCount = 0 then
  
  return.

cSortFieldList = trim(cSortFieldList, ',':U).

if num-entries(cSortFieldList, ',':U) > 0 then
  run qg_QueryWindowAddSortFields(phWindow,
                                  cSortFieldList).

end procedure. /* qg_QueryWindowAddSortOption */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowBeautify hQueryWindow 
PROCEDURE qg_QueryWindowBeautify :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Beautify query text.                                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

assign
  cQueryText = bttQueryWindow.QueryTextEditorHandle:input-value
  cQueryText = qg_cBeautifyQueryText(cQueryText)
  bttQueryWindow.QueryTextEditorHandle:screen-value = cQueryText
  .

return no-apply.

end procedure. /* qg_QueryWindowBeautify */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowBufferComparisonStartMerge hQueryWindow 
PROCEDURE qg_QueryWindowBufferComparisonStartMerge :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plAllFields     as logical   no-undo.
define input parameter pcFieldName     as character no-undo.
define input parameter piFieldIndex    as integer   no-undo.
define input parameter plCaseSensitive as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i             as integer   no-undo.

define variable cLabel        as character no-undo.
define variable iLongestLabel as integer   no-undo.

define variable clFieldValue1 as longchar  no-undo.
define variable clCompText1   as longchar  no-undo.
define variable cTitle1       as character no-undo.

define variable clFieldValue2 as longchar  no-undo.
define variable clCompText2   as longchar  no-undo.
define variable cTitle2       as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttBufferComparisonField  for temp-table ttBufferComparisonField.
define buffer b2ttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttBufferComparisonField
  on error undo, throw:
  
  if    ( pcFieldName                            > '':U
      and ( bttBufferComparisonField.FieldName  <> pcFieldName
         or bttBufferComparisonField.FieldIndex <> piFieldIndex ) )
     or bttBufferComparisonField.DataType     = 'blob':U
     or ( not plAllFields
      and bttBufferComparisonField.IsEqual    = yes ) then
    next.
  
  assign
    cLabel        = qg_cFormattedFieldName(?,
                                           ?,
                                           bttBufferComparisonField.FieldName,
                                           bttBufferComparisonField.FieldIndex)
    iLongestLabel = maximum(length(cLabel), iLongestLabel)
    .
  
end. /* for each bttBufferComparisonField */

for each bttBufferComparisonField
  on error undo, throw:
  
  if    ( pcFieldName                            > '':U
      and ( bttBufferComparisonField.FieldName  <> pcFieldName
         or bttBufferComparisonField.FieldIndex <> piFieldIndex ) )
     or bttBufferComparisonField.DataType     = 'blob':U
     or ( not plAllFields
      and bttBufferComparisonField.IsEqual   <> no )
     or ( bttBufferComparisonField.BufferNo  = 2
      and can-find(ttBufferComparisonField
                     where ttBufferComparisonField.BufferNo   = 1
                       and ttBufferComparisonField.FieldName  = bttBufferComparisonField.FieldName
                       and ttBufferComparisonField.FieldIndex = bttBufferComparisonField.FieldIndex) ) then
    next.
  
  release b2ttBufferComparisonField.
  
  if bttBufferComparisonField.BufferNo = 1 then
  do:
    
    copy-lob bttBufferComparisonField.FieldValue to clFieldValue1.
    
    if clFieldValue1 = ? then
      clFieldValue1 = '?':U.
    
    assign
      cLabel      = qg_cFormattedFieldName(?,
                                           ?,
                                           bttBufferComparisonField.FieldName,
                                           bttBufferComparisonField.FieldIndex)
      clCompText1 =   clCompText1 + '~n':U
                    + (if pcFieldName > '':U then
                         clFieldValue1
                       else
                           cLabel
                         + fill(' ':U, iLongestLabel - length(cLabel))
                         + ': ':U
                         + quoter(string(clFieldValue1)))
      .
    
    if cTitle1 = '':U then
      cTitle1 = (if pcFieldName > '':U then
                   substitute('&1.&2.&3':U,
                              bttBufferComparisonField.DatabaseName,
                              bttBufferComparisonField.BufferName,
                              cLabel)
                 else
                   substitute('&1.&2':U,
                              bttBufferComparisonField.DatabaseName,
                              bttBufferComparisonField.BufferName)).
    
  end. /* if bttBufferComparisonField.BufferNo = 1 */
  
  find b2ttBufferComparisonField
    where b2ttBufferComparisonField.BufferNo   = 2
      and b2ttBufferComparisonField.FieldName  = bttBufferComparisonField.FieldName
      and b2ttBufferComparisonField.FieldIndex = bttBufferComparisonField.FieldIndex
    no-error.
  
  if available b2ttBufferComparisonField then
  do:
    
    copy-lob b2ttBufferComparisonField.FieldValue to clFieldValue2.
    
    if clFieldValue2 = ? then
      clFieldValue2 = '?':U.
    
    assign
      cLabel      = qg_cFormattedFieldName(?,
                                           ?,
                                           b2ttBufferComparisonField.FieldName,
                                           b2ttBufferComparisonField.FieldIndex)
      clCompText2 =   clCompText2 + '~n':U
                    + (if pcFieldName > '':U then
                         clFieldValue2
                       else
                           cLabel
                         + fill(' ':U, iLongestLabel - length(cLabel))
                         + ': ':U
                         + quoter(string(clFieldValue2)))
      .
    
    if cTitle2 = '':U then
      cTitle2 = (if pcFieldName > '':U then
                   substitute('&1.&2.&3':U,
                              b2ttBufferComparisonField.DatabaseName,
                              b2ttBufferComparisonField.BufferName,
                              cLabel)
                 else
                   substitute('&1.&2':U,
                              b2ttBufferComparisonField.DatabaseName,
                              b2ttBufferComparisonField.BufferName)).
    
  end. /* if available b2ttBufferComparisonField */
  
end. /* for each bttBufferComparisonField */

assign
  clCompText1 = trim(clCompText1, '~n':U)
  clCompText2 = trim(clCompText2, '~n':U)
  .

run qg_CompareText((if cTitle1 > '':U then
                      cTitle1
                    else
                      '<Undefined>':T),
                   clCompText1,
                   (if cTitle2 > '':U then
                      cTitle2
                    else
                      '<Undefined>':T),
                   clCompText2,
                   plCaseSensitive,
                   yes).

end procedure. /* qg_QueryWindowBufferComparisonStartMerge */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowBufferComparisonSelectFirstDifference hQueryWindow 
PROCEDURE qg_QueryWindowBufferComparisonSelectFirstDifference :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plCaseSensitive as logical   no-undo.
define input parameter phField1        as handle    no-undo.
define input parameter phField2        as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable clFieldValue1   as longchar  no-undo.
define variable iField1Length   as integer   no-undo.
define variable cChar1          as character no-undo.

define variable clFieldValue2   as longchar  no-undo.
define variable iField2Length   as integer   no-undo.
define variable cChar2          as character no-undo.

define variable i               as integer   no-undo.
define variable iBufferNo       as integer   no-undo.
define variable iTemp           as integer   no-undo.
define variable iIndex1         as integer   no-undo.
define variable iIndex2         as integer   no-undo.
define variable iSelectionStart1 as integer   no-undo.
define variable iSelectionEnd1   as integer   no-undo.
define variable iSelectionStart2 as integer   no-undo.
define variable iSelectionEnd2   as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttBufferComparisonField  for temp-table ttBufferComparisonField.
define buffer b2ttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  clFieldValue1 = phField1:input-value
  iField1Length = length(clFieldValue1)
  clFieldValue2 = phField2:input-value
  iField2Length = length(clFieldValue2)
  .

do i = 1 to maximum(iField1Length, iField2Length):
  
  if    iIndex1 > 0
    and i       > iIndex1
    and iIndex2 > 0
    and i       > iIndex2 then
    leave.
  
  assign
    cChar1 = substring(clFieldValue1, i, 1)
    cChar2 = substring(clFieldValue2, i, 1)
    .
  
  if compare(cChar1,
             'NE':U,
             cChar2,
             (if plCaseSensitive then
                'CASE-SENSITIVE':U
              else
                'CASE-INSENSITIVE':U)) then
  do:
    
    if iSelectionStart1 = 0 then
      iSelectionStart1 = i.
      
    if iSelectionStart2 = 0 then
      iSelectionStart2 = i.
    
  end. /* if cChar1 <> cChar2 */
  
  if    iSelectionStart1 > 0
    and cChar1           > '':U then
  do:
    
    iTemp = 0.
    
    do while yes:
      
      iTemp = index(clFieldValue2,
                    cChar1,
                    maximum(iSelectionStart1, iTemp + 1)).
      
      if iTemp = 0 then
        leave.
      
      if not compare(cChar1,
                     'EQ':U,
                     substring(clFieldValue2, iTemp, 1),
                     (if plCaseSensitive then
                        'CASE-SENSITIVE':U
                      else
                        'CASE-INSENSITIVE':U)) then
        next.
      
      if    iIndex1 = 0
         or iTemp   < iIndex1 then
      do:
        
        assign
          iIndex1        = iTemp
          iSelectionEnd1 = i
          .
        
        leave.
        
      end. /* if    iIndex1 = 0 */
      
    end. /* do while yes */
    
  end. /* if iSelectionStart1 > 0 */
  
  if    iSelectionStart2 > 0
    and cChar2           > '':U then
  do:
    
    iTemp = 0.
    
    do while yes:
      
      iTemp = index(clFieldValue1,
                    cChar2,
                    maximum(iSelectionStart2, iTemp + 1)).
      
      if iTemp = 0 then
        leave.
      
      if not compare(cChar2,
                     'EQ':U,
                     substring(clFieldValue1, iTemp, 1),
                     (if plCaseSensitive then
                        'CASE-SENSITIVE':U
                      else
                        'CASE-INSENSITIVE':U)) then
        next.
      
      if    iIndex2 = 0
         or iTemp   < iIndex2 then
      do:
        
        assign
          iIndex2        = iTemp
          iSelectionEnd2 = i
          .
        
        leave.
        
      end. /* if    iIndex2 = 0 */
      
    end. /* do while yes */
    
  end. /* if iSelectionStart2 > 0 */
  
end. /* do i = 1 to length(clFieldValue1) */

if iIndex2 > 0 then
do:
  
  iTemp = 0.
  
  do while yes:
  
    iTemp = index(clFieldValue1,
                  substring(clFieldValue1, iIndex2, 1),
                  maximum(iSelectionStart1, iTemp + 1)).
    
    if    iTemp > 0
      and not compare(substring(clFieldValue1, iIndex2, 1),
                      'EQ':U,
                      substring(clFieldValue1, iTemp, 1),
                      (if plCaseSensitive then
                         'CASE-SENSITIVE':U
                       else
                         'CASE-INSENSITIVE':U)) then
      next.
    
    if    iSelectionEnd1 > 0
      and iTemp          < iSelectionEnd1 then
      iSelectionEnd1 = iTemp.
    
    leave.
    
  end. /* do while yes */
  
end. /* if iIndex2 > 0 */

if iIndex1 > 0 then
do:
  
  iTemp = index(clFieldValue2,
                substring(clFieldValue2, iIndex1, 1),
                iSelectionStart2).
  
  if    iSelectionEnd2 > 0
    and iTemp          > iSelectionEnd2 then
    iSelectionEnd2 = iTemp.
  
end. /* if iIndex1 > 0 */

/* Line feeds count as one character in progress but are two        */
/* characters in the editor widget.                                 */

do i = 1 to iSelectionEnd1 - 1:
  
  if substring(clFieldValue1, i, 1) = '~n':U then
  do:
    
    if i < iSelectionStart1 then
      iSelectionStart1 = iSelectionStart1 + 1.
    
    iSelectionEnd1 = iSelectionEnd1 + 1.
    
  end. /* if substring(clFieldValue1, i, 1) = '~n':U */
  
end. /* do i = 1 to iSelectionEnd1 */

do i = 1 to iSelectionEnd2 - 1:
  
  if substring(clFieldValue2, i, 1) = '~n':U then
  do:
    
    if i < iSelectionStart2 then
      iSelectionStart2 = iSelectionStart2 + 1.
    
    iSelectionEnd2 = iSelectionEnd2 + 1.
    
  end. /* if substring(clFieldValue2, i, 1) = '~n':U */
  
end. /* do i = 1 to iSelectionEnd2 */

if iSelectionStart1 > 0 then
  phField1:set-selection(iSelectionStart1, iSelectionEnd1).

if iSelectionStart2 > 0 then
  phField2:set-selection(iSelectionStart2, iSelectionEnd2).

end procedure. /* qg_QueryWindowBufferComparisonSelectFirstDifference */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCalculateSum hQueryWindow 
PROCEDURE qg_QueryWindowCalculateSum :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Calculate Sum for currently selected field.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow            as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable dDecimalSum           as decimal   no-undo.
define variable iIntegerSum           as int64     no-undo.

define variable hQuery                as handle    no-undo.
define variable hFieldBuffer          as handle    no-undo.
define variable hField                as handle    no-undo.
define variable cBufferName           as character no-undo.
define variable iFieldType            as integer   no-undo.
define variable cDataType             as character no-undo.
define variable cFieldName            as character no-undo.
define variable iFieldIndex           as integer   no-undo.
define variable iDecimals             as integer   no-undo.
define variable iBufferCounter        as integer   no-undo.
define variable rCurrentRecords       as rowid     no-undo extent.
define variable lRestoreQueryPosition as logical   no-undo.

define variable cFormat               as character no-undo.

define variable cFieldSumLabel as character no-undo
  format 'x(255)':U
  view-as text
  size 56 by 1
  .

define variable cFieldSum as character no-undo
  format 'x(255)':U
  view-as fill-in
  size 45 by 1
  .

define button btnCopy
  label 'Copy':T
  size 10 by 1
  .

define button btnClose
  label 'Close':T
  size 20 by 1.14
  auto-go.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow        for temp-table ttQueryWindow.

define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.
define buffer bttField              for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fFieldSum
  cFieldSumLabel at row 1.5 col 3 no-label
  cFieldSum at row 3 col 3 no-label
  btnCopy at row 3 col 49
  btnClose at row 5 col 20
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 61 by 6.83
    title gcTitlePrefix + 'Field Sum':T
    default-button btnClose
    cancel-button btnClose.

on window-close of frame fFieldSum
  apply 'end-error' to self.

on choose of btnCopy in frame fFieldSum
  clipboard:value = cFieldSum.

if not valid-handle(phWindow) then
  return.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if    not available bttQueryWindow
   or not valid-handle( bttQueryWindow.QueryFieldBrowseHandle ) then
  return.

if not valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then
  
  message
    'No field selected':T skip
    view-as alert-box
    error
    buttons ok
    in window bttQueryWindow.WindowHandle.

assign
  hQuery = bttQueryWindow.QueryHandle
  hField = bttQueryWindow.QueryBrowseSelectedColumn:buffer-field.

if valid-handle( hField ) then
  
  assign
    hFieldBuffer = hField:buffer-handle
    cBufferName  = hFieldBuffer:name
    iFieldType   = {&K_FIELD_TYPE_DB_FIELD}
    cDataType    = hField:data-type
    cFieldName   = hField:name
    iDecimals    = hField:decimals
    .

else
do:
  
  find first bttVirtualFieldColumn
    where bttVirtualFieldColumn.OwnerHandle  = hQuery
      and bttVirtualFieldColumn.ColumnHandle = bttQueryWindow.QueryBrowseSelectedColumn
    no-error.
  
  if not available bttVirtualFieldColumn then
    
    return.
  
  assign
    hFieldBuffer  = bttVirtualFieldColumn.BufferHandle
    cBufferName   = bttVirtualFieldColumn.BufferName
    iFieldType    = bttVirtualFieldColumn.FieldType
    cDataType     = bttVirtualFieldColumn.DataType
    cFieldName    = bttVirtualFieldColumn.FieldName
    iDecimals     = 0
    .
  
end.

assign
  iFieldIndex               = bttQueryWindow.QueryBrowseSelectedColumn:index
  extent( rCurrentRecords ) = hQuery:num-buffers
  .

if lookup( bttQueryWindow.QueryBrowseSelectedColumn:data-type, 'DECIMAL,INTEGER,INT64':U ) = 0 then
do:
  
  message
    'Sums can only be calculated for decimal, inter or int64 fields':T skip
    view-as alert-box
    error
    buttons ok
    in window bttQueryWindow.WindowHandle.
  
  return.
  
end. /* if lookup( bttQueryWindow.QueryBrowseSelectedColumn:data-type, 'DECIMAL,INTEGER,INT64':U ) = 0 */

lRestoreQueryPosition = (     hQuery:num-buffers > 0
                          and hQuery:get-buffer-handle( 1 ):available ).

do iBufferCounter = 1 to hQuery:num-buffers:
  rCurrentRecords[iBufferCounter] = hQuery:get-buffer-handle( iBufferCounter ):rowid.
end. /* do iBufferCounter = 1 to hQuery:num-buffers */

do on error undo, throw:
  
  hQuery:get-first().
  
  do while not hQuery:query-off-end:
    
    case string( bttQueryWindow.QueryBrowseSelectedColumn:data-type ):
      
      when 'DECIMAL':U then

        dDecimalSum =   dDecimalSum
                      + ( if valid-handle( hField ) then
                            decimal( hField:buffer-value( iFieldIndex ) )
                          else
                            decimal( qg_clVirtualFieldValueAsLongchar( iFieldType,
                                                                       cDataType,
                                                                       cFieldName,
                                                                       qg_cObjectIdForBuffer( hFieldBuffer ),
                                                                       ? ) ) ).
      
      otherwise
        
        iIntegerSum =   iIntegerSum
                      + ( if valid-handle( hField ) then
                            integer( hField:buffer-value( iFieldIndex ) )
                          else
                            integer( qg_clVirtualFieldValueAsLongchar( iFieldType,
                                                                       cDataType,
                                                                       cFieldName,
                                                                       qg_cObjectIdForBuffer( hFieldBuffer ),
                                                                       ? ) ) ).
      
    end case. /* string( hFieldSelectionBuffer::DataType ) */
    
    hQuery:get-next().
    
  end. /* do while not hQuery:query-off-end */
  
  assign
    cFieldSumLabel = substitute( 'Sum of Field &1:':T,
                                  qg_cFormattedFieldName( ?,
                                                          cBufferName,
                                                          cFieldName,
                                                          iFieldIndex ) )
    cFieldSum:read-only in frame fFieldSum = yes
    .
  
  case string( cDataType ):
    
    when 'DECIMAL':U then
    do:
      
      cFormat = substitute( '&1zz9':U, fill( 'zzz,':U, 17 ) ).
      
      if iDecimals > 0 then
        
        cFormat = substitute( '&1.&2':U, cFormat, fill( '9':U, iDecimals ) ).
      
      else
        
        cFormat = substitute( '&1.&2':U, cFormat, fill( '9':U, 10 ) ).
      
      cFieldSum = trim( string( dDecimalSum, cFormat ) ).
      
    end. /* when 'DECIMAL':U */
    
    otherwise
      
      assign
        cFormat   = '-z,zzz,zzz,zzz,zzz,zzz,zz9':U
        cFieldSum = trim( string( iIntegerSum, cFormat ) )
        .
    
  end case. /* string( hFieldSelectionBuffer::DataType ) */
  
  update unless-hidden
    cFieldSumLabel
    cFieldSum
    btnCopy
    btnClose
    with frame fFieldSum
      in window bttQueryWindow.WindowHandle.
  
  finally:
    
    if lRestoreQueryPosition then
      hQuery:reposition-to-rowid(rCurrentRecords).
    
  end finally.
  
end.

end procedure. /* qg_QueryWindowCalculateSum */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowClose hQueryWindow 
PROCEDURE qg_QueryWindowClose :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Close query window (and clean up dynamically created widgets).             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* phQuery                        = Query of the Query window.                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow            as handle    no-undo.
define input parameter plCloseChildWindows as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer          as handle    no-undo.
define variable rQueryWindowView as rowid     no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow                  for temp-table ttQueryWindow.
define buffer bttFieldOverlay                 for temp-table ttFieldOverlay.
define buffer bttQueryWindowQueryBrowseColumn for temp-table ttQueryWindowQueryBrowseColumn.
define buffer bttQueryWindowView              for temp-table ttQueryWindowView.
define buffer bttQueryLink                    for temp-table ttQueryLink.
define buffer bttRecentQuery                  for temp-table ttRecentQuery.
define buffer bttQueryWindowField             for temp-table ttQueryWindowField.
define buffer bttQueryWindowObjField          for temp-table ttQueryWindowObjField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if available bttQueryWindow then
do:
  
  if    plCloseChildWindows = ?
    and can-find(first ttQueryLink
                   where ttQueryLink.SourceSeq = bttQueryWindow.QuerySeq) then
    message
      'Do you want to close all linked child windows as well?':T
      view-as alert-box
      question
      buttons yes-no
      update plCloseChildWindows
      in window bttQueryWindow.WindowHandle.
    
  if plCloseChildWindows then
    run qg_QueryWindowCloseChildWindows(bttQueryWindow.QuerySeq).
  
  if valid-handle(bttQueryWindow.QueryBrowseHandle) then
    
    bttQueryWindow.QueryBrowseHandle:visible = no.
  
  run qg_RemoveAllVirtualFieldColums( buffer bttQueryWindow ).
  
  for each bttFieldOverlay
    where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
    on error undo, throw:
    
    run qg_DeleteFieldOverlay(bttFieldOverlay.OwnerHandle,
                              bttFieldOverlay.BufferName,
                              bttFieldOverlay.FieldName,
                              bttFieldOverlay.FieldIndex).
    
  end. /* for each bttFieldOverlay */
  
  for each bttQueryWindowQueryBrowseColumn
    where bttQueryWindowQueryBrowseColumn.WindowHandle = bttQueryWindow.WindowHandle:
    
    delete bttQueryWindowQueryBrowseColumn.
    
  end. /* for each bttQueryWindowQueryBrowseColumn */
  
  for each bttRecentQuery
    where bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
    on error undo, throw:
    
    delete bttRecentQuery.
    
  end. /* for each bttRecentQuery */
  
  for each bttQueryLink
    where bttQueryLink.TargetSeq = bttQueryWindow.QuerySeq
    on error undo, throw:
    
    delete bttQueryLink.
    
  end. /* for each bttQueryLink */
  
  for each bttQueryWindowField
    where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
    on error undo, throw:
    
    delete bttQueryWindowField.
    
  end. /* for each bttQueryWindowField */

  for each bttQueryWindowObjField
    where bttQueryWindowObjField.WindowHandle = bttQueryWindow.WindowHandle
    on error undo, throw:
    
    delete bttQueryWindowObjField.
    
  end. /* for each bttQueryWindowObjField */
  
  if valid-handle(ghQueryWindowListWindow) then
  do:
    
    hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).
    
    if hBuffer:available then
    do:
      
      if hBuffer::WindowHandle <> bttQueryWindow.WindowHandle then
        rQueryWindowView = hBuffer:rowid.
      
      else
      do:
        
        find last bttQueryWindowView
          where bttQueryWindowView.Id < hBuffer::Id
          no-error.
        
        if available bttQueryWindowView then
          rQueryWindowView = rowid(bttQueryWindowView).
        
      end. /* if hBuffer:WindowHandle <> bttQueryWindow:WindowHandle */
      
    end. /* if hBuffer:available */
    
  end. /* if valid-handle(ghQueryWindowListWindow) */
  
  for each bttQueryWindowView
    where bttQueryWindowView.ParentWindowHandle = bttQueryWindow.WindowHandle
    on error undo, throw:
    
    bttQueryWindowView.ParentWindowHandle = ?.
    
  end. /* for each bttQueryWindowView */
  
  for each bttQueryWindowView
    where bttQueryWindowView.WindowHandle = bttQueryWindow.WindowHandle
    on error undo, throw:
    
    delete bttQueryWindowView.
    
  end. /* for each bttQueryWindowView */
  
  delete bttQueryWindow.
  
end. /* if available bttQueryWindow */

/* Clean up all dynamically created objects. */

run qg_DeleteWidgetTree(phWindow, yes).

run qg_QueryWindowUpdateAll('':U).

run qg_QueryWindowListRefresh.

if    valid-handle(ghQueryWindowListWindow)
  and rQueryWindowView <> ? then
do:
  
  find bttQueryWindowView
    where rowid(bttQueryWindowView) = rQueryWindowView
    no-error.
  
  if available bttQueryWindowView then
    ghQueryWindowListBrowse:query:reposition-to-rowid(rowid(bttQueryWindowView)).
  
end. /* if    valid-handle(ghQueryWindowListWindow) */

if valid-handle(ghQueryWindowListWindow) then
  run qg_ActivateWindow(ghQueryWindowListWindow, ghQueryWindowListBrowse).

end procedure. /* qg_QueryWindowClose */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCloseChildWindows hQueryWindow 
PROCEDURE qg_QueryWindowCloseChildWindows :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piSourceSeq as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.
define buffer bttQueryLink    for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryLink
  where bttQueryLink.SourceSeq = piSourceSeq,
first bttQueryWindow
  where bttQueryWindow.QuerySeq = bttQueryLink.TargetSeq
  on error undo, throw:
  
  run qg_QueryWindowCloseChildWindows(bttQueryWindow.QuerySeq).
  
  if valid-handle(bttQueryWindow.WindowHandle) then
    run qg_QueryWindowClose(bttQueryWindow.WindowHandle, no).
  
end. /* for each bttQueryLink */

end procedure. /* qg_QueryWindowCloseChildWindows */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCompareSelectedRecords hQueryWindow 
PROCEDURE qg_QueryWindowCompareSelectedRecords :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phParentWindow  as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lCaseSensitive   as logical   no-undo.

define variable iDifferentFields as integer   no-undo.
define variable dColOffset       as decimal   no-undo.

define variable cBufferLabel1    as character no-undo.
define variable hColLabel1       as handle    no-undo.
define variable cBufferLabel2    as character no-undo.
define variable hColLabel2       as handle    no-undo.

define variable hScrollBox       as handle    no-undo.

define variable lAllFields as logical no-undo
  format 'yes/no':U
  view-as radio-set
    radio-buttons
      'Different fields':T, no,
      'All fields':T, yes
    horizontal
  size 35 by 1.

define variable cCaseSensitive as character no-undo
  view-as text
  size 5 by 1 .

define rectangle rectCaseSensitive
  no-fill
  edge-pixels 2
  graphic-edge
  tooltip 'Switch to case sensitive mode':U
  size 7 by 1.5.

define button btnMerge
  label 'Merge':T
  tooltip 'Compare field values in Araxis Merge':T
  size 20 by 1.14.

define button btnCancel
  label 'Close':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttBufferComparisonField  for temp-table ttBufferComparisonField.
define buffer b2ttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fBufferComparison
    lAllFields at row 2 col 1 no-label
    rectCaseSensitive at row 1.75 col 1
    cCaseSensitive at row 2 col 1 no-label
    btnMerge at row 5 col 1
    btnCancel at row 5 col 1
  with 1 down keep-tab-order overlay
    view-as dialog-box
    side-labels no-underline three-d 
    size 170 by 6.94
    title gcTitlePrefix + 'Buffer comparison':T
    cancel-button btnCancel.

on window-close of frame fBufferComparison
  apply 'end-error' to self.

on choose of btnMerge
  run qg_QueryWindowBufferComparisonStartMerge(input frame fBufferComparison lAllFields,
                                               ?,
                                               ?,
                                               lCaseSensitive).

on value-changed of lAllFields in frame fBufferComparison
do:
  
  define variable iX as integer   no-undo.
  define variable iY as integer   no-undo.
  
  /* Update comparison field widgets. */
  
  if valid-handle(hScrollBox) then
    run qg_DeleteWidgetTree(hScrollBox:handle, yes).
  
  lAllFields = input frame fBufferComparison lAllFields.
  
  run qg_QueryWindowCreateBufferComparisonFrame(input-output hScrollBox,
                                                lCaseSensitive,
                                                lAllFields,
                                                      output iDifferentFields,
                                                      output dColOffset).
  
  
  /* Set dialog size. */
  
  assign
    iX                                               = frame fBufferComparison:x
    iY                                               = frame fBufferComparison:y
    frame fBufferComparison:title                    = substitute('&1Buffer comparison (&2&3 &4)':T,
                                                                  gcTitlePrefix,
                                                                  (if lCaseSensitive then
                                                                     'case sensitive, ':L
                                                                   else
                                                                     '':U),
                                                                  string(iDifferentFields),
                                                                  (if iDifferentFields = 1 then
                                                                     'difference':T
                                                                   else
                                                                     'differences':T))
    frame fBufferComparison:width-chars              = hScrollBox:width-chars  + 5
    frame fBufferComparison:virtual-width-chars      = frame fBufferComparison:width-chars
    frame fBufferComparison:height-chars             = hScrollBox:height-chars + 8
    frame fBufferComparison:virtual-height-chars     = frame fBufferComparison:height-chars
    frame fBufferComparison:x                        = iX
    frame fBufferComparison:y                        = iY
    lAllFields:col in frame fBufferComparison        =   ( frame fBufferComparison:width-chars
                                                       - lAllFields:width-chars in frame fBufferComparison )
                                                       / 2
    rectCaseSensitive:col in frame fBufferComparison =   frame fBufferComparison:width
                                                       - rectCaseSensitive:width in frame fBufferComparison
                                                       - 5
    cCaseSensitive:col in frame fBufferComparison   =   rectCaseSensitive:col in frame fBufferComparison
                                                      + (   rectCaseSensitive:width in frame fBufferComparison
                                                          - cCaseSensitive:width in frame fBufferComparison )
                                                      / 2
    btnMerge:row in frame fBufferComparison         = frame fBufferComparison:height-chars - 1.94
    btnCancel:row in frame fBufferComparison        = frame fBufferComparison:height-chars - 1.94
      .

  /* Hide merge button if araxis merge is not available. */

  if valid-handle(gchMerge) then
    assign
      btnMerge:col in frame fBufferComparison  = (frame fBufferComparison:width-chars / 2)
                                                   - btnMerge:width-chars in frame fBufferComparison 
      btnCancel:col in frame fBufferComparison = (frame fBufferComparison:width-chars / 2)
      .
  
  else
    btnCancel:col in frame fBufferComparison =   frame fBufferComparison:width-chars / 2
                                               - btnCancel:width-chars in frame fBufferComparison / 2.

  process events.
  
  assign
    hScrollBox:frame                             = frame fBufferComparison:handle
    hScrollBox:hidden                            = no
    hScrollBox:visible                           = yes
    .
  
  /* Remove horizontal scrollbar if necessary. */
  
  if hScrollBox:virtual-height-chars > hScrollBox:height-chars then
  do:
    
    display unless-hidden
      with frame fBufferComparison
        in window phParentWindow.
    
    run qg_SetScrollbars(hScrollBox:handle, no, ?).
    
  end. /* if hScrollBox:virtual-height-chars > hScrollBox:height-chars */

end. /* on value-changed of lAllFields in frame fBufferComparison */

on mouse-select-click of rectCaseSensitive in frame fBufferComparison
do:
  
  if lCaseSensitive then
  do:
    
    assign
      lCaseSensitive            = no
      rectCaseSensitive:filled  = no
      rectCaseSensitive:bgcolor = ?
      rectCaseSensitive:tooltip = 'Switch to case sensitive mode':T
      cCaseSensitive:bgcolor    = ?
      .
    
  end. /* if lCaseSensitive */
  
  else
  do:
    
    assign
      lCaseSensitive            = yes
      rectCaseSensitive:filled  = yes
      rectCaseSensitive:bgcolor = {&K_COLOR_YELLOW}
      rectCaseSensitive:tooltip = 'Switch to case insensitive mode':T
      cCaseSensitive:bgcolor    = {&K_COLOR_YELLOW}
      .
    
  end. /* else: if lCaseSensitive */
  
  process events.
  
  apply 'value-changed':U to lAllFields in frame fBufferComparison.
  
end. /* on mouse-select-click of rectCaseSensitive in frame fBufferComparison */

run qg_QueryWindowCreateBufferComparisonFrame(input-output hScrollBox,
                                              lCaseSensitive,
                                              no,
                                                    output iDifferentFields,
                                                    output dColOffset).

if iDifferentFields = 0 then
  message
    'The Records are identical':T skip
    view-as alert-box
    information
    in window phParentWindow.
  

/* Set dialog size. */

assign
  frame fBufferComparison:title                          = substitute('&1 (&2&3 differences)':U,
                                                                      frame fBufferComparison:title,
                                                                      (if lCaseSensitive then
                                                                         'case sensitive, ':L
                                                                       else
                                                                         '':U),
                                                                      string(iDifferentFields),
                                                                      (if iDifferentFields = 1 then
                                                                         'difference':T
                                                                       else
                                                                         'differences':T))
  frame fBufferComparison:width-chars                    = hScrollBox:width-chars  + 5
  frame fBufferComparison:height-chars                   = hScrollBox:height-chars + 8
  lAllFields:col in frame fBufferComparison              =   ( frame fBufferComparison:width-chars
                                                           - lAllFields:width-chars in frame fBufferComparison )
                                                           / 2
  rectCaseSensitive:col in frame fBufferComparison       =   frame fBufferComparison:width
                                                           - rectCaseSensitive:width in frame fBufferComparison
                                                           - 5
  rectCaseSensitive:sensitive in frame fBufferComparison = yes
  cCaseSensitive                                         = 'Aa':T
  cCaseSensitive:width in frame fBufferComparison        = font-table:get-text-width-chars(cCaseSensitive,
                                                                                          cCaseSensitive:font in frame fBufferComparison)
  cCaseSensitive:height in frame fBufferComparison       = font-table:get-text-height-chars(cCaseSensitive:font in frame fBufferComparison)
  cCaseSensitive:col in frame fBufferComparison          =   rectCaseSensitive:col in frame fBufferComparison
                                                           + (   rectCaseSensitive:width in frame fBufferComparison
                                                               - cCaseSensitive:width in frame fBufferComparison )
                                                           / 2
  cCaseSensitive:row in frame fBufferComparison          =   rectCaseSensitive:row in frame fBufferComparison
                                                           + (   rectCaseSensitive:height in frame fBufferComparison
                                                               - cCaseSensitive:height in frame fBufferComparison )
                                                           / 2
  btnMerge:row in frame fBufferComparison                = frame fBufferComparison:height-chars - 1.94
  btnCancel:row in frame fBufferComparison               = frame fBufferComparison:height-chars - 1.94
  .
  
  if valid-handle(gchMerge) then
    assign
      btnMerge:col in frame fBufferComparison  = (frame fBufferComparison:width-chars / 2)
                                                   - btnMerge:width-chars in frame fBufferComparison 
      btnCancel:col in frame fBufferComparison = (frame fBufferComparison:width-chars / 2)
      .
  
  else
    assign
      btnMerge:visible in frame fBufferComparison = no
      btnCancel:col in frame fBufferComparison    =   frame fBufferComparison:width-chars / 2
                                                    - btnCancel:width-chars in frame fBufferComparison / 2
      .

  hScrollBox:frame = frame fBufferComparison:handle.

/* Create column labels. */

find first bttBufferComparisonField
  where bttBufferComparisonField.BufferNo  = 1
  no-error.

if available bttBufferComparisonField then
do:
  
  cBufferLabel1 = substitute('&1.&2':U,
                             bttBufferComparisonField.DatabaseName,
                             bttBufferComparisonField.BufferName).
  
  create text hColLabel1
    assign
      format        = substitute('x(&1)':U, length(cBufferLabel1))
      screen-value  = cBufferLabel1
      frame         = frame fBufferComparison:handle
      width         = font-table:get-text-width-chars(cBufferLabel1)
      row           = 3.5
      height        = 1
      col           = dColOffset + 3 + (76 - hColLabel1:width-chars) / 2
      .
  
end. /* if available bttBufferComparisonField */

find first bttBufferComparisonField
  where bttBufferComparisonField.BufferNo  = 2
  no-error.

if available bttBufferComparisonField then
do:

  cBufferLabel2 = substitute('&1.&2':U,
                             bttBufferComparisonField.DatabaseName,
                             bttBufferComparisonField.BufferName).
    .
  
  create text hColLabel2
    assign
      format        = substitute('x(&1)':U, length(cBufferLabel2))
      screen-value  = cBufferLabel2
      frame         = frame fBufferComparison:handle
      width         = font-table:get-text-width-chars(cBufferLabel2)
      row           = 3.5
      height        = 1
      col           = dColOffset + 3 + 76 + (76 - hColLabel2:width-chars) / 2
      .
    
end. /* if available bttBufferComparisonField */

/* Remove horizontal scrollbar if necessary. */

if hScrollBox:virtual-height-chars > hScrollBox:height-chars then
do:
  
  display unless-hidden
    with frame fBufferComparison
      in window phParentWindow.
  
  run qg_SetScrollbars(hScrollBox:handle, no, ?).
  
end. /* if hScrollBox:virtual-height-chars > hScrollBox:height-chars */

/* Show dialog. */

update unless-hidden
  lAllFields
  rectCaseSensitive
  cCaseSensitive
  btnMerge
    when valid-handle(gchMerge)
  btnCancel
  with frame fBufferComparison
    in window phParentWindow.

finally:
  
  if valid-handle(hColLabel1) then
    delete object hColLabel1 no-error.
  
  if valid-handle(hColLabel2) then
    delete object hColLabel2 no-error.
  
  if valid-handle(hScrollBox) then
    run qg_DeleteWidgetTree(hScrollBox:handle, yes).
  
end finally.

end procedure. /* qg_QueryWindowCompareSelectedRecords */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCopyQueryText hQueryWindow 
PROCEDURE qg_QueryWindowCopyQueryText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Copy actual query text with resolved external tokens to clipboard.         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

clipboard:value = bttQueryWindow.QueryHandle:prepare-string.

end procedure. /* qg_QueryWindowCopyQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCopyRecid hQueryWindow 
PROCEDURE qg_QueryWindowCopyRecid :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Copy recid/rowid of the current query window record.                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plRecid                        = If yes then the recid will be copied. If  */
/*                                  no then the rowid will be copied.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter plRecid  as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i       as integer   no-undo.
define variable hBuffer as handle    no-undo.
define variable cList   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
  
  assign
    hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(i)
    cList   = substitute('&1,&2':U,
                         cList,
                         (if plRecid then
                            string(hBuffer:recid)
                          else
                            string(hBuffer:rowid)))
    .

end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers */

clipboard:value = trim(cList, ',':U).

end procedure. /* qg_QueryWindowCopyRecid */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCopyRecordValues hQueryWindow 
PROCEDURE qg_QueryWindowCopyRecordValues :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Copy record values.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plRawValues                    = Copy raw values.                          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lRawValues as logical no-undo
  format 'yes/no':U
  view-as radio-set
    radio-buttons
      'Raw values':T, yes,
      'Formatted values':T, no
  size 30 by 2.

define button btnOk
  label 'Ok':T
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.


/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fCopyRecordValues
  lRawValues at row 1.5 col 10 no-label
  btnOk at row 4.5 col 5
  btnCancel at row 4.5 col 25
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 49 by 6.5
    title gcTitlePrefix + 'Copy record values':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fCopyRecordValues
  apply 'end-error' to self.

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

lRawValues = glCopyRawValues.

update unless-hidden
  lRawValues
  btnOk
  btnCancel
  with frame fCopyRecordValues
    in window bttQueryWindow.WindowHandle. 

glCopyRawValues = lRawValues.

clipboard:value = qg_clBrowseValues(bttQueryWindow.QueryBrowseHandle,
                                    glCopyRawValues).

end procedure. /* qg_QueryWindowCopyRecordValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSelectForComparison hQueryWindow 
PROCEDURE qg_QueryWindowSelectForComparison :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow   as handle    no-undo.
define input parameter piBufferNo as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hQuery        as handle    no-undo.
define variable hBuffer       as handle    no-undo.
define variable cDatabaseName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hQuery = bttQueryWindow.QueryHandle.

if hQuery:num-buffers = 1 then
  hBuffer = hQuery:get-buffer-handle(1).

else
  run qg_SelectQueryBuffer(hQuery, output hBuffer).

if valid-handle(hBuffer) then
do:
  
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
  
  run qg_SetBufferComparisonBuffer(cDatabaseName, hBuffer, piBufferNo).
  
end. /* if valid-handle(hBuffer) */

end procedure. /* qg_QueryWindowSelectForComparison */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowUpdateQuery hQueryWindow 
PROCEDURE qg_QueryWindowUpdateQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.
define input parameter pcTables    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lRebuild      as logical   no-undo.
define variable lHidden       as logical   no-undo.
define variable hOldBuffers   as handle    no-undo extent.

define variable hBuffer       as handle    no-undo.
define variable hQuery        as handle    no-undo.

define variable i             as integer   no-undo.

define variable cTableEntry   as character no-undo.
define variable cDatabaseName as character no-undo.
define variable cTableName    as character no-undo.
define variable cBufferName   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

define buffer bttTable       for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hQuery = bttQueryWindow.QueryHandle.

/* Create new (if necessary). */ 

if not valid-handle(hQuery) then
do:
  
  create query hQuery.
  
  bttQueryWindow.QueryHandle = hQuery.

end. /* if not valid-handle(hQuery) */

/* Check if current query buffers match the tables parameter. If that is the  */
/* case no changes have to be made. Otherwise all buffers have to be rebuilt. */

if num-entries(pcTables) <> hQuery:num-buffers then
  lRebuild = yes.

else
do:
  
  do i = 1 to num-entries(pcTables):
    
    if i > hQuery:num-buffers then
    do:
      
      lRebuild = yes.
      leave.
    
    end. /* if i > hQuery:num-buffers */
    
    assign
      cTableEntry   = entry(i, pcTables)
      cDatabaseName = entry(1, cTableEntry, '.':U)
      cTableEntry   = entry(2, cTableEntry, '.':U)
      cTableName    = entry(1, cTableEntry, ':':U)
      cBufferName   = (if num-entries(cTableEntry, ':':U) > 1 then
                         entry(2, cTableEntry, ':':U)
                       else
                         cTableName)
      hBuffer       = hQuery:get-buffer-handle(i)
      .
    
    if    cTableName    <> hBuffer:table
       or cDatabaseName <> qg_cDatabaseNameForTableOrBuffer( hBuffer ) then
    do:
      
      lRebuild = yes.
      leave.
      
    end. /* if    cTableName    <> hBuffer:table */
    
    if hBuffer:name <> cBufferName then
      hBuffer:name = cBufferName.
    
  end. /* do i = 1 to hQuery:num-buffers */
  
end. /* else: if num-entries(pcTables) <> hQuery:num-buffers */

if lRebuild then
do on error undo, throw:
  
  if valid-handle(bttQueryWindow.QueryBrowseHandle) then
    assign
      lHidden = bttQueryWindow.QueryBrowseHandle:hidden
      bttQueryWindow.QueryBrowseHandle:hidden = yes
      .
  
  /* Delete all currently assigned buffers. Deleting one buffer will also     */
  /* remove all other buffers from the query. Due to this we have to store    */
  /* all buffers in an extent field prior to deletion.                        */
  
  if hQuery:num-buffers > 0 then
  do:
    
    extent(hOldBuffers) = hQuery:num-buffers.
    
    do i = hQuery:num-buffers to 1 by -1:
      hOldBuffers[i] = hQuery:get-buffer-handle(i).
    end. /* do i = 1 to hQuery:num-buffers */ 
    
    do i = 1 to extent(hOldBuffers):
      delete object hOldBuffers[i].
    end. /* do i = 1 to extent(hOldBuffers) */
    
  end. /* if hQuery:num-buffers > 0 */
  
  /* Create and assign new buffers */
  
  do i = 1 to num-entries(pcTables):
    
    assign
      cTableEntry   = entry(i, pcTables)
      cDatabaseName = entry(1, cTableEntry, '.':U)
      cTableEntry   = entry(2, cTableEntry, '.':U)
      cTableName    = entry(1, cTableEntry, ':':U)
      cBufferName   = (if num-entries(cTableEntry, ':':U) > 1 then
                         entry(2, cTableEntry, ':':U)
                       else
                         cTableName)
      .
    
    find bttTable
      where bttTable.DatabaseName = cDatabaseName
        and bttTable.TableName    = cTableName
      no-error.
  
    if   not available bttTable
      or (  not bttTable.PhysicalTable
        and not valid-handle(bttTable.TableHandle)) then
      next.
  
    if not bttTable.DetailsLoaded then
      run qg_AddTableDetails(bttTable.DatabaseName,
                             bttTable.TableName).
    
    if not bttTable.PhysicalTable then
      create buffer hBuffer for table bttTable.TableHandle /* code checked by mth 30.07.2015 */
        buffer-name cBufferName.
    
    else
      create buffer hBuffer for table substitute('&1.&2':U, /* code checked by mth 30.07.2015 */
                                                 bttTable.DatabaseName,
                                                 bttTable.TableName)
        buffer-name cBufferName.
    
    hBuffer:private-data = qg_cParamListWriteCharacter(hBuffer:private-data,
                                                       'DatabaseName':U,
                                                       bttTable.DatabaseName,
                                                       ',':U).
  
    hQuery:add-buffer(hBuffer).
    
  end. /* do i = 1 to num-entries(pcTables) */
  
  run qg_QueryWindowUpdateFieldTempTable( bttQueryWindow.QueryHandle,
                                          bttQueryWindow.WindowHandle,
                                          '':U ).

  if valid-handle(bttQueryWindow.QueryFrameHandle) then
  do:
    
    /* For some reason deleting query buffers also removes the query from the */
    /* query browse handle. Due to this we have to set it again.              */
    
    bttQueryWindow.QueryBrowseHandle:query = hQuery.
  
    run qg_QueryWindowRefreshBrowseColumns(bttQueryWindow.WindowHandle).
    
    run qg_QueryWindowQueryOpenFieldQuery(bttQueryWindow.WindowHandle).
    
  end. /* if valid-handle(bttQueryWindow.QueryFrameHandle) */
  
  if valid-handle(bttQueryWindow.RecordFrameHandle) then
    run qg_QueryWindowRecordOpenQuery(bttQueryWindow.WindowHandle).
  
  /* Update window title. Since for a record window the title is updated with */
  /* every record data refresh this has only to be done for query windows at  */
  /* this point.                                                              */
  
  if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
    run qg_QueryWindowQueryUpdateTitle(bttQueryWindow.WindowHandle).
  
  finally:
    
    if valid-handle(bttQueryWindow.QueryBrowseHandle) then
      bttQueryWindow.QueryBrowseHandle:hidden = lHidden.
    
  end finally.
  
end. /* if lRebuild */

validate bttQueryWindow.

end procedure. /* qg_QueryWindowUpdateQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCreateBufferComparisonFrame hQueryWindow 
PROCEDURE qg_QueryWindowCreateBufferComparisonFrame :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input-output parameter iophFrame          as handle    no-undo.
define input        parameter plCaseSensitive    as logical   no-undo.
define input        parameter plAllFields        as logical   no-undo.
define       output parameter opiDifferentFields as integer   no-undo.
define       output parameter opdColOffset       as decimal   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                as integer   no-undo.
define variable dHeightDelta     as decimal   no-undo.

define variable lEditor          as logical   no-undo.

define variable clFieldValue1    as longchar  no-undo.
define variable clFieldValue2    as longchar  no-undo.

define variable hColLabel1       as handle    no-undo.
define variable hColLabel2       as handle    no-undo.
define variable hField1          as handle    no-undo.
define variable hField2          as handle    no-undo.
define variable hButton          as handle    no-undo.
define variable hTemp            as handle    no-undo.
define variable cPrivateData     as character no-undo.

define variable cLabel           as character no-undo.
define variable iLongestLabel    as integer   no-undo.
define variable dLongestLabel    as decimal   no-undo.

define variable iFlags           as integer   no-undo.
define variable iDummy           as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttBufferComparisonField  for temp-table ttBufferComparisonField.
define buffer b2ttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttBufferComparisonField
  where bttBufferComparisonField.DataType <> 'blob':U
  on error undo, throw:
  
  if    bttBufferComparisonField.BufferNo  = 2
    and can-find(ttBufferComparisonField
                   where ttBufferComparisonField.BufferNo   = 1
                     and ttBufferComparisonField.FieldName  = bttBufferComparisonField.FieldName
                     and ttBufferComparisonField.FieldIndex = bttBufferComparisonField.FieldIndex) then
    next.
  
  release b2ttBufferComparisonField.
  
  if bttBufferComparisonField.BufferNo = 1 then
  do:
    
    find b2ttBufferComparisonField
      where b2ttBufferComparisonField.BufferNo   = 2
        and b2ttBufferComparisonField.FieldName  = bttBufferComparisonField.FieldName
        and b2ttBufferComparisonField.FieldIndex = bttBufferComparisonField.FieldIndex
      no-error.
    
    if available b2ttBufferComparisonField then
    do:
      
      copy-lob bttBufferComparisonField.FieldValue to clFieldValue1.
      copy-lob b2ttBufferComparisonField.FieldValue to clFieldValue2.
      
      assign
        bttBufferComparisonField.IsEqual  = compare(clFieldValue1,
                                                    'EQ':U,
                                                    clFieldValue2,
                                                    (if plCaseSensitive then
                                                       'CASE-SENSITIVE':U
                                                     else
                                                       'CASE-INSENSITIVE':U))
        b2ttBufferComparisonField.IsEqual = bttBufferComparisonField.IsEqual
        .
      
    end. /* if available b2ttBufferComparisonField */
    
  end. /* if b2ttBufferComparisonField.BufferNo = 1 */
  

  if    plAllFields
     or bttBufferComparisonField.IsEqual = no then
    assign
      i                  = i + 1
      opiDifferentFields = opiDifferentFields + 1
          when bttBufferComparisonField.IsEqual = no
      lEditor            =    bttBufferComparisonField.DataType  = 'clob':U
                           or (  bttBufferComparisonField.BufferNo = 1
                             and available b2ttBufferComparisonField
                             and b2ttBufferComparisonField.DataType = 'clob':U )
                           or length(clFieldValue1) > 30000
                           or length(clFieldValue2) > 30000
                           or index(clFieldValue1, '~n':U) > 0
                           or index(clFieldValue2, '~n':U) > 0
      dHeightDelta       = dHeightDelta + (if lEditor then
                                             5
                                           else
                                             1)
      cLabel             = qg_cFormattedFieldName
                             (?,
                              ?,
                              bttBufferComparisonField.FieldName,
                              bttBufferComparisonField.FieldIndex)
      iLongestLabel      = maximum(iLongestLabel,
                                   length(cLabel))
      dLongestLabel      = maximum(dLongestLabel,
                                   font-table:get-text-width-chars(cLabel))
      .
  
end. /* for each bttBufferComparisonField */

opdColOffset = dLongestLabel + 3.

if valid-handle(iophFrame) then
  run qg_DeleteWidgetTree(iophFrame:first-child, no).

else
  create frame iophFrame
    assign
      name                 = 'fScrollBox':U
      box                  = no
      three-d              = yes
      width-chars          = 165 + dLongestLabel
      virtual-width-chars  = 165 + dLongestLabel
      height               = 0.25 + minimum(30, dHeightDelta)
      virtual-height       = 0.25 + dHeightDelta
      row                  = 5
      col                  = 3
      sensitive            = yes
      scrollable           = yes
      careful-paint        = no
      .

assign
  dHeightDelta = 0
  i            = 0
  .

for each bttBufferComparisonField
  where bttBufferComparisonField.DataType <> 'blob':U
  on error undo, throw:
  
  if    ( not plAllFields
      and bttBufferComparisonField.IsEqual <> no )
     or ( bttBufferComparisonField.BufferNo  = 2
      and can-find(ttBufferComparisonField
                     where ttBufferComparisonField.BufferNo   = 1
                       and ttBufferComparisonField.FieldName  = bttBufferComparisonField.FieldName
                       and ttBufferComparisonField.FieldIndex = bttBufferComparisonField.FieldIndex) ) then
    next.
  
  i = i + 1.
  
  release b2ttBufferComparisonField.
  
  if bttBufferComparisonField.BufferNo = 1 then
  do:
    
    copy-lob bttBufferComparisonField.FieldValue to clFieldValue1.
    
    if clFieldValue1 = ? then
      clFieldValue1 = '?':U.
    
    find b2ttBufferComparisonField
      where b2ttBufferComparisonField.BufferNo   = 2
        and b2ttBufferComparisonField.FieldName  = bttBufferComparisonField.FieldName
        and b2ttBufferComparisonField.FieldIndex = bttBufferComparisonField.FieldIndex
      no-error.
  
    if available b2ttBufferComparisonField then
      copy-lob b2ttBufferComparisonField.FieldValue to clFieldValue2.
    
    else
      clFieldValue2 = '':U.
    
    if clFieldValue2 = ? then
      clFieldValue2 = '?':U.
    
  end. /* if bttBufferComparisonField.BufferNo = 1 */
  
  else
  do:
    
    copy-lob bttBufferComparisonField.FieldValue to clFieldValue2.
    
    clFieldValue1 = '':U.
    
  end. /* else: if bttBufferComparisonField.BufferNo = 1 */
  
  lEditor =    bttBufferComparisonField.DataType  = 'clob':U
            or (  bttBufferComparisonField.BufferNo = 1
              and available b2ttBufferComparisonField
              and b2ttBufferComparisonField.DataType = 'clob':U )
            or length(clFieldValue1) > 30000
            or length(clFieldValue2) > 30000
            or index(clFieldValue1, '~n':U) > 0
            or index(clFieldValue2, '~n':U) > 0.
  
  create editor hField1
    assign
      name                 = substitute('&1_1':U, bttBufferComparisonField.FieldName)
      frame                = iophFrame
      width                = 76
      height               = (if lEditor then
                                5
                              else
                                1)
      row                  = dHeightDelta + 1
      col                  = dLongestLabel + 5
      word-wrap            = no
      scrollbar-horizontal = (if lEditor then
                                yes
                              else
                                no)
      scrollbar-vertical   = (if lEditor then
                                yes
                              else
                                no)
      return-inserted      = (if lEditor then
                                yes
                              else
                                no)
      bgcolor              = (if    plAllFields
                                and bttBufferComparisonField.IsEqual = ?
                                and ( bttBufferComparisonField.BufferNo = 2 ) then
                                {&K_COLOR_LIGHT_GREY}
                              else if plAllFields
                                and bttBufferComparisonField.IsEqual = no then
                                {&K_COLOR_YELLOW}
                              else
                                ?)
      fgcolor              = ( if    bttBufferComparisonField.IsVirtual
                                 and bttBufferComparisonField.FieldType = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
                                 {&K_VIRTUAL_DB_FIELD_FGCOLOR}
                               else
                                 ? )
      sensitive            = yes
      read-only            = yes
      .
  
  assign
    hField1:screen-value = clFieldValue1
    cLabel               = qg_cFormattedFieldName(?,
                                                  ?,
                                                  bttBufferComparisonField.FieldName,
                                                  bttBufferComparisonField.FieldIndex)
    .
  
  create text hTemp
    assign
      format        = substitute('x(&1)':U, length(cLabel))
      screen-value  = cLabel
      frame         = iophFrame
      width         = font-table:get-text-width-chars(cLabel)
      row           = dHeightDelta + 1
      height        = 1
      col           = 1
      fgcolor       = ( if    ( available bttBufferComparisonField
                            and bttBufferComparisonField.IsVirtual
                            and bttBufferComparisonField.FieldType  = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} )
                          or ( available b2ttBufferComparisonField
                            and b2ttBufferComparisonField.IsVirtual
                            and b2ttBufferComparisonField.FieldType = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} ) then
                          {&K_VIRTUAL_DB_FIELD_FGCOLOR}
                        else
                          ? )
      .
  
  assign
    hTemp:col                 = hField1:col - hTemp:width - 1
    hField1:side-label-handle = hTemp
    .
  
  create editor hField2
    assign
      name                 = substitute('&1_2':U, bttBufferComparisonField.FieldName)
      frame                = iophFrame
      width                = 76
      height               = (if lEditor then
                                5
                              else
                                1)
      row                  = dHeightDelta + 1
      col                  = dLongestLabel + 5 + 76
      word-wrap            = no
      scrollbar-horizontal = (if lEditor then
                                yes
                              else
                                no)
      scrollbar-vertical   = (if lEditor then
                                yes
                              else
                                no)
      return-inserted      = (if lEditor then
                                yes
                              else
                                no)
      bgcolor              = (if    plAllFields
                                and bttBufferComparisonField.IsEqual = ?
                                and bttBufferComparisonField.BufferNo = 1
                                and not available b2ttBufferComparisonField then
                                {&K_COLOR_LIGHT_GREY}
                              else if plAllFields
                                and bttBufferComparisonField.IsEqual = no then
                                {&K_COLOR_YELLOW}
                              else
                                ?)
      fgcolor              = ( if    available b2ttBufferComparisonField
                                 and b2ttBufferComparisonField.IsVirtual
                                 and b2ttBufferComparisonField.FieldType = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
                                 {&K_VIRTUAL_DB_FIELD_FGCOLOR}
                               else
                                 ? )
      sensitive            = yes
      read-only            = yes
      .
  
  
  hField2:screen-value = clFieldValue2.
  
  if bttBufferComparisonField.IsEqual = no then
  do:
    
    create button hButton
      assign
        name                 = substitute('btnCompare&1':U, bttBufferComparisonField.FieldName)
        frame                = iophFrame
        width                = 5
        height               = 1
        row                  = dHeightDelta + 1
        col                  = dLongestLabel + 5 + 152
        label                = '>':T
        tooltip              = 'Show first difference':T
        sensitive            =  yes
      triggers:
        
        on choose
          persistent run qg_QueryWindowBufferComparisonSelectFirstDifference in target-procedure
                           (plCaseSensitive,
                            hField1,
                            hField2).
        
      end triggers.
    
    if valid-handle(gchMerge) then
    do:
      
      create menu hTemp
        assign
          name       = substitute('m_PopupMenu':U)
          popup-only = yes
          sensitive  = yes
          .
      
      hButton:popup-menu = hTemp.
      
      create menu-item hTemp
        assign
          name         = 'mi_MergeFields':U
          parent       = hButton:popup-menu
          label        = 'Merge field':T
          sensitive    = yes
        triggers:
          on choose
            persistent run qg_QueryWindowBufferComparisonStartMerge in target-procedure
                             (plAllFields,
                              bttBufferComparisonField.FieldName,
                              bttBufferComparisonField.FieldIndex,
                              plCaseSensitive).
        end triggers
        .
      
    end. /* if valid-handle(gchMerge) */

  end. /* if bttBufferComparisonField.IsEqual = no */
  
  dHeightDelta  = dHeightDelta + (if lEditor then
                                    5
                                  else
                                    1).
  
end. /*for each bttBufferComparisonField  */

end procedure. /* qg_QueryWindowCreateBufferComparisonFrame */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCreateFieldTempTableOverlayEntries hQueryWindow 
PROCEDURE qg_QueryWindowCreateFieldTempTableOverlayEntries :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.
define input parameter pcFieldList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow       for temp-table ttQueryWindow.

define buffer bttFieldOverlay      for temp-table ttFieldOverlay.
define buffer bttQueryWindowField  for temp-table ttQueryWindowField.
define buffer b2ttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttFieldOverlay
  where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
  on error undo, throw:
  
  find bttQueryWindowField
    where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
      and bttQueryWindowField.BufferName   = bttFieldOverlay.BufferName 
      and bttQueryWindowField.FieldName    = bttFieldOverlay.FieldName 
      and bttQueryWindowField.FieldIndex   = bttFieldOverlay.FieldIndex
    no-error. 
  
  if    not available bttQueryWindowField
     or can-find(ttQueryWindowField
                   where ttQueryWindowField.WindowHandle = bttQueryWindowField.WindowHandle
                     and ttQueryWindowField.BufferId     = bttQueryWindowField.BufferId
                     and ttQueryWindowField.FieldName    = bttQueryWindowField.FieldName
                     and ttQueryWindowField.FieldIndex   = bttQueryWindowField.FieldIndex
                     and ttQueryWindowField.IsOverlay    = yes) then
    next.
  
  create b2ttQueryWindowField.
  
  buffer-copy bttQueryWindowField
    to b2ttQueryWindowField
    assign
     b2ttQueryWindowField.DisplayName = substitute({&K_OBJECTID_OVERLAY_LABEL_PATTERN},
                                                   bttQueryWindowField.FieldLabel)
     b2ttQueryWindowField.IsOverlay   = yes
     b2ttQueryWindowField.Order       = (if pcFieldList > '':U then
                                           lookup(substitute({&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                                             qg_cFormattedFieldName(?,
                                                                                    b2ttQueryWindowField.BufferName,
                                                                                    b2ttQueryWindowField.FieldName,
                                                                                    b2ttQueryWindowField.FieldIndex)),
                                                  pcFieldList)
                                         else
                                           1)
     .
  
  validate b2ttQueryWindowField.
  
end. /* for each bttFieldOverlay */
  
end procedure. /* qg_QueryWindowCreateFieldTempTableOverlayEntries */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCreateQueryFrame hQueryWindow 
PROCEDURE qg_QueryWindowCreateQueryFrame :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hTemp                      as handle    no-undo.

define variable hFrame                     as handle    no-undo.

define variable hMenuBar                   as handle    no-undo.
define variable hMenu                      as handle    no-undo.

define variable hCopyObjectIdSubMenu       as handle    no-undo.

define variable hQueryTextEditor           as handle    no-undo.
define variable hFieldSelectionBrowse      as handle    no-undo.
define variable hFieldSelectionBuffer      as handle    no-undo.
define variable hFieldSelectionQuery       as handle    no-undo.
define variable cFieldSelectionQueryText   as character no-undo.
define variable hQueryBrowse               as handle    no-undo.

define variable i                          as integer   no-undo.
define variable hField                     as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

define buffer bttTable       for temp-table ttTable.
define buffer bttField       for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/*----------------------------------------------------------------------------*/
/* Create Menu                                                                */
/*----------------------------------------------------------------------------*/

create menu hMenuBar.

/* File menu */

create sub-menu hMenu
  assign
    name      = 'm_File':U
    label     = 'File':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_Close':U
    label       = 'Close':T
    accelerator = 'CTRL-W':U
    sensitive   = yes
    parent      = hMenu
  triggers:
  
    on choose
      persistent run qg_QueryWindowClose in target-procedure
                       (bttQueryWindow.WindowHandle,
                        ?).  
    
  end triggers.

/* Edit menu */

create sub-menu hMenu
  assign
    name      = 'm_Edit':U
    label     = 'Edit':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name         = 'mi_CopyQueryText':U
    parent       = hMenu
    label        = 'Copy query text':T
    sensitive    = yes
  triggers:
    on choose
      persistent run qg_QueryWindowCopyQueryText in target-procedure
                       (bttQueryWindow.WindowHandle).
  end triggers
  .

/* Tools menu */

create sub-menu hMenu
  assign
    name      = 'm_Tools':U
    label     = 'Tools':T
    sensitive = yes
    parent    = hMenuBar
  triggers:
    
    on menu-drop
      persistent run qg_QueryWindowQueryToolsMenuDrop in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_Execute':U
    label       = 'Execute query':T
    accelerator = 'F2':U
    sensitive   = yes
    parent      = hMenu
  triggers:
  
    on choose
      persistent run qg_QueryWindowExecute in target-procedure
                       (bttQueryWindow.WindowHandle,
                        ?,
                        yes).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name        = 'mi_OpenRelatedQuery':U
    label       = 'Open related query':T
    accelerator = 'CTRL-R':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenRelatedQuery in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_ObjectFieldValues':U
    label       = 'Open Object field values':T
    accelerator = 'CTRL-O':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenObjectFieldValues in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_FindMissingObjectIds':U
    label       = 'Find missing Object IDs':T
    accelerator = 'CTRL-ALT-J':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowFindMissingObjectIds in target-procedure
                       ( bttQueryWindow.WindowHandle ).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_FindNextMissingObjectIds':U
    label       = 'Find next missing Object ID':T
    accelerator = 'CTRL-J':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowFindNextMissingObjectId in target-procedure
                       ( bttQueryWindow.WindowHandle ).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name        = 'mi_OpenRecordWindowFixRowId':U
    label       = 'Open record window (fix / rowid)':T
    accelerator = 'SHIFT-F8':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenRecordWindow in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_QUERY_WINDOW_LINK_MODE_FIX_ROWID}).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_OpenRecordWindowFixIndex':U
    label       = 'Open record window (fix / index)':T
    accelerator = 'ALT-SHIFT-F8':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenRecordWindow in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_QUERY_WINDOW_LINK_MODE_FIX_INDEX}).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_OpenRecordWindowLinked':U
    label       = 'Open record window (linked)':T
    accelerator = 'CTRL-SHIFT-F8':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenRecordWindow in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_QUERY_WINDOW_LINK_MODE_LINKED}).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name         = 'mi_ShowQueryText':U
    parent       = hMenu
    label        = 'Show query text':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowShowQueryText in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_ExecCurrentQueryText':U
    parent       = hMenu
    label        = 'Execute query text':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowExecCurrentQuery in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_ShowIndexInformation':U
    parent       = hMenu
    label        = 'Show index information':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowShowIndexInformation in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name        = 'mi_AddSnapshot':U
    label       = 'Add snapshot':T
    accelerator = 'F10':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowAddSnapshot in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

/* Options menu */

create sub-menu hMenu
  assign
    name      = 'm_Options':U
    label     = 'Options':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_SelectQueryBuffers':U
    label       = 'Query buffers':T
    accelerator = 'CTRL-B':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowEditQueryBuffers in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name       = 'mi_ObjectIdOveray':U
    label      = 'Object id overlay':T
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowObjectIdOverlay in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    name       = 'mi_DeepResolveObjectIds':U
    label      = 'Deep resolve object ids':T
    toggle-box = yes
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on value-changed
      persistent run qg_QueryWindowToggleDeepResolve in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

/* View menu */

create sub-menu hMenu
  assign
    name      = 'm_View':U
    label     = 'View':T
    sensitive = yes
    parent    = hMenuBar
  triggers:
  
    on menu-drop
      persistent run qg_QueryWindowViewMenuDrop in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  
  end triggers.

create menu-item hTemp
  assign
    name       = 'mi_FieldList':U
    label      = 'Field list':T
    toggle-box = yes
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on value-changed
      persistent run qg_QueryWindowToggleFieldList in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name       = 'mi_RawValues':U
    label      = 'Raw Values':T
    toggle-box = yes
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on value-changed
      persistent run qg_QueryWindowToggleRawValues in target-procedure
                       ( bttQueryWindow.WindowHandle ).
    
  end triggers.

create sub-menu hMenu
  assign
    name      = 'm_Window':U
    label     = 'Window':T
    sensitive = yes
    parent    = hMenuBar
  triggers:
  
    on menu-drop
      persistent run qg_QueryWindowWindowMenuDrop in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_RecordMode':U
    label       = 'Switch to record mode':T
    toggle-box  = no
    accelerator = 'F8':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowSetWindowMode in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_QUERY_WINDOW_MODE_RECORD},
                        ?,
                        ?).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name      = 'mi_WindowSizeDefault':U
    label     = 'Restore default window size':T
    sensitive = yes
    parent    = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowSetSize in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_QUERY_SIZE_MODE_DEFAULT}).
    
  end triggers.

run qg_AddHelpMenu(hMenuBar).

/*----------------------------------------------------------------------------*/
/* Create Frame                                                               */
/*----------------------------------------------------------------------------*/

create frame hFrame
  assign
    name           = 'fQuery':U
    box            = no
    three-d        = yes
    width          = 235
    virtual-width  = 235
    height         = 32
    virtual-height = 32
    sensitive      = yes
    parent         = bttQueryWindow.WindowHandle
  triggers:
    
    on f3 anywhere /* Show all */
      persistent run qg_QueryWindowShowAll in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on f4 anywhere /* Show index */
      persistent run qg_QueryWindowShowIndex in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on f5 anywhere /* Recent queries */
      persistent run qg_QueryWindowRecentQueries in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on shift-f2 anywhere /* Set focus to query text editor */
      persistent run qg_QueryWindowSetFocus in target-procedure
                       (bttQueryWindow.WindowHandle,
                        'cQueryText':U).
    
    on shift-f8 anywhere /* Toggle field list */
      persistent run qg_QueryWindowToggleFieldList in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on shift-f4 anywhere /* Set focus to query browse */
      persistent run qg_QueryWindowSetFocus in target-procedure
                       (bttQueryWindow.WindowHandle,
                        'brQuery':U).
    
    on ctrl-n anywhere
      persistent run qg_QueryWindowEdit in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_EDITACTION_CREATE}).
    
    on ctrl-p anywhere
      persistent run qg_QueryWindowEdit in target-procedure 
                       (bttQueryWindow.WindowHandle,
                        {&K_EDITACTION_DUPLICATE}).
    
    on ctrl-d anywhere
      persistent run qg_QueryWindowDelete in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

bttQueryWindow.QueryFrameHandle = hFrame.

/* Create Query text Editor */

create editor hQueryTextEditor
  assign
    name                 = 'cQueryText':U
    frame                = hFrame
    width                = 162
    height               = 6
    row                  = 1
    col                  = 1
    word-wrap            = no
    font                 = 0
    large                = yes
    return-inserted      = yes
    auto-indent          = yes
    scrollbar-horizontal = yes
    scrollbar-vertical   = yes
    read-only            = (bttQueryWindow.ObjSourceQuerySeq > 0)
    sensitive            = yes
  triggers:
    
    on ctrl-d
      persistent run qg_QueryWindowQueryTextEditorDeleteLines in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on alt-up
      persistent run qg_QueryWindowQueryTextEditorMoveLines in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
    on alt-down
      persistent run qg_QueryWindowQueryTextEditorMoveLines in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
    on ctrl-alt-cursor-up
      persistent run qg_QueryWindowQueryTextEditorDuplicateLines in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
    on ctrl-alt-cursor-down
      persistent run qg_QueryWindowQueryTextEditorDuplicateLines in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
    on ctrl-ins
      persistent run qg_QueryWindowInsertExternalReference in target-procedure
                       (bttQueryWindow.WindowHandle,
                        hQueryTextEditor,
                        yes).
    
    on ctrl-shift-ins
      persistent run qg_QueryWindowInsertExternalReference in target-procedure
                       (bttQueryWindow.WindowHandle,
                        hQueryTextEditor,
                        no).
    
    on tab
      persistent run qg_QueryWindowSelectNextCondition in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
    on shift-tab
      persistent run qg_QueryWindowSelectNextCondition in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
    on ctrl-enter
      persistent run qg_QueryWindowSelectNextCondition in target-procedure
                       (bttQueryWindow.WindowHandle,
                        ?).
    
    on mouse-extend-click
      persistent run qg_QueryWindowSelectNextCondition in target-procedure
                       (bttQueryWindow.WindowHandle,
                        ?).
    
    on ctrl-tab
      persistent run qg_QueryWindowSetFocus in target-procedure
                       (bttQueryWindow.WindowHandle,
                        'brFieldSelection':U).
    
    /* TODO: Anderer Shortcut
    on ctrl-i
      persistent run qg_QueryWindowBeautify in target-procedure
                       (bttQueryWindow.WindowHandle).
    */
    
  end triggers
  .

/* Create field selection browse. */

create buffer hFieldSelectionBuffer for table 'ttQueryWindowField':U. /* code checked by mth 30.07.2015 */

create query hFieldSelectionQuery.
hFieldSelectionQuery:set-buffers(hFieldSelectionBuffer).

create browse hFieldSelectionBrowse
  assign
    name                   = 'brFieldSelection':U
    frame                  = hFrame
    width                  = 50
    height                 = 6
    row                    = 1
    col                    = 183
    read-only              = yes
    row-markers            = no
    allow-column-searching = no
    multiple               = yes
    fit-last-column        = yes
  triggers:
    
    on default-action
      persistent run qg_QueryWindowFieldSelectionBrowseDefaultAction in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on ctrl-ins
      persistent run qg_QueryWindowQueryTextEditorAddCondition in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on ctrl-home
      persistent run qg_QueryWindowMoveColumn in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
    on ctrl-end
      persistent run qg_QueryWindowMoveColumn in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
    on ctrl-page-up
      persistent run qg_QueryWindowAddSortOption in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
    on ctrl-page-down
      persistent run qg_QueryWindowAddSortOption in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
    on row-display
      persistent run qg_QueryWindowQueryFieldBrowseRowDisplay in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

/* Create field selection browse toggle button. */

create button hTemp
  assign
    name                 = 'btnToggleFieldBrowse':U
    frame                = hFrame
    width                = 3
    height               = 6
    row                  = 1
    col                  = 163
    label                = '>':T
    tooltip              = 'Hide field List':T
    flat-button          = yes
    sensitive            = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowToggleFieldList in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

if gcCursorHand > '':U then
  hTemp:load-mouse-pointer(gcCursorHand).

/* Create Buttons. */

create button hTemp
  assign
    name                 = 'btnExecute':U
    frame                = hFrame
    width                = 20
    height               = 2
    row                  = 1
    col                  = 215
    label                = 'Execute':T
    tooltip              = 'Execute current query and refresh browse (F2)':T
    sensitive            = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowExecute in target-procedure
                       (bttQueryWindow.WindowHandle,
                        ?,
                        yes).
    
  end triggers.

create button hTemp
  assign
    name      = 'btnEdit':U
    frame     = hFrame
    width     = 20
    height    = 1
    row       = 3
    col       = 215
    &IF {&K_EDITMODE_ENABLED} &THEN
      label   = 'Edit Record':T
      tooltip = 'Edit currently selected record.':T
    &ELSE
      label   = 'Record':T
      tooltip = 'Show record details for currently selected record':T
    &ENDIF
    sensitive = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowEdit in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_EDITACTION_EDIT}).
    
  end triggers
  .

&IF {&K_EDITMODE_ENABLED} &THEN
  
  create button hTemp
    assign
      name      = 'btnDelete':U
      frame     = hFrame
      width     = 20
      height    = 1
      row       = 4
      col       = 215
      label     = 'Delete Record':T
      tooltip   = 'Delete currently selected record (CTRL+D)':T
      sensitive = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowDelete in target-procedure
                         (bttQueryWindow.WindowHandle).
      
    end triggers
    .
  
  create button hTemp
    assign
      name      = 'btnCreate':U
      frame     = hFrame
      width     = 20
      height    = 1
      row       = 5
      col       = 215
      label     = 'Create Record':T
      tooltip   = 'Create new record (CTRL-N)':T
      sensitive = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowEdit in target-procedure
                         (bttQueryWindow.WindowHandle,
                          {&K_EDITACTION_CREATE}).
      
    end triggers
    .
  
  create button hTemp
    assign
      name      = 'btnDuplicate':U
      frame     = hFrame
      width     = 20
      height    = 1
      row       = 6
      col       = 215
      label     = 'Duplicate Record':T
      tooltip   = 'Create new record by duplicating currently selected record (CTRL-P)':T
      sensitive = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowEdit in target-procedure 
                         (bttQueryWindow.WindowHandle,
                          {&K_EDITACTION_DUPLICATE}).
      
    end triggers
    .
  
&ENDIF

/* Create Splitter button. */

create button hTemp
  assign
    name        = 'btnSplitter1':U
    frame       = hFrame
    width       = 10
    height      = 0.25
    row         = 7
    col         = 1
    label       = '':U
    no-focus    = yes
    flat-button = yes
    movable     = yes
    sensitive   = yes
  triggers:
    
    on end-move
      persistent run qg_QueryWindowResize in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

hTemp:load-mouse-pointer ('SIZE-N':U).

/* Create query browse. */

create browse hQueryBrowse
  assign
    name                 = 'brQuery':U
    frame                = hFrame
    width                = 10
    height               = 10
    row                  = 7.25
    col                  = 1
    read-only            = yes
    row-markers          = no
    allow-column-searching = yes
  triggers:
    
    on value-changed
      persistent run qg_QueryWindowUpdateAll in target-procedure
                       ('':U).
    
    on row-display
      persistent run qg_QueryWindowQueryBrowseRowDisplay in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on default-action
      persistent run qg_QueryWindowQueryBrowseDefaultAction in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on mouse-select-click
      persistent run qg_QueryWindowQueryBrowseSelectColumn in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on mouse-menu-down
      persistent run qg_QueryWindowQueryBrowseSelectColumn in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on start-search
      persistent run qg_QueryWindowQueryBrowseStartSearch in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on mouse-select-dblclick
      persistent run qg_QueryWindowQueryBrowseStartSearch in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on mouse-extend-dblclick
      persistent run qg_QueryWindowQueryBrowseStartSearch in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on ctrl-c
      persistent run qg_QueryWindowQueryBrowseCopy in target-procedure
                           (bttQueryWindow.WindowHandle).
    
    on ' ':U
      persistent run qg_QueryWindowEdit in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_EDITACTION_EDIT}).
    
  end triggers.

/* Create query text editor popup menu. */

if bttQueryWindow.ObjSourceQuerySeq = 0 then
do:
  
  create menu hTemp
    assign
      name       = 'm_QueryTextPopupMenu':U
      popup-only = yes
      sensitive  = yes
    triggers:
      
      on menu-drop
        persistent run qg_QueryWindowQueryTextEditorPopupMenuDrop in target-procedure
                         (bttQueryWindow.WindowHandle).
      
    end triggers.
  
  hQueryTextEditor:popup-menu = hTemp.
  
  create menu-item hTemp
    assign
      name         = 'mi_ShowAll':U
      parent       = hQueryTextEditor:popup-menu
      label        = 'Show all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowShowAll in target-procedure
                         (bttQueryWindow.WindowHandle).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'm_ShowIndex':U
      parent    = hQueryTextEditor:popup-menu
      label     = 'Show index':T
      sensitive = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowShowIndex in target-procedure
                         (bttQueryWindow.WindowHandle).
      
    end triggers.
  
  create menu-item hTemp
    assign
      name      = 'm_SortByIndex':U
      parent    = hQueryTextEditor:popup-menu
      label     = 'Sort by Index':T
      sensitive = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSortByIndex in target-procedure
                         (bttQueryWindow.WindowHandle).
      
    end triggers.
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hQueryTextEditor:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_InsertExternalFieldReference':U
      parent       = hQueryTextEditor:popup-menu
      label        = 'Insert external field reference':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowInsertExternalReference in target-procedure
                         (bttQueryWindow.WindowHandle,
                          hQueryTextEditor,
                          yes).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_InsertExternalTableReference':U
      parent       = hQueryTextEditor:popup-menu
      label        = 'Insert external table reference':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowInsertExternalReference in target-procedure
                         (bttQueryWindow.WindowHandle,
                          hQueryTextEditor,
                          no).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hQueryTextEditor:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_Equal':U
      parent       = hQueryTextEditor:popup-menu
      label        = '= (eqal)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          '=':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_NotEqual':U
      parent       = hQueryTextEditor:popup-menu
      label        = '<> (not equal)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          '<>':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Greater':U
      parent       = hQueryTextEditor:popup-menu
      label        = '> (greater than)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          '>':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_GreaterEqual':U
      parent       = hQueryTextEditor:popup-menu
      label        = '>= (greater or equal)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          '>=':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Lower':U
      parent       = hQueryTextEditor:popup-menu
      label        = '< (lower than)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          '<':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_LowerEqual':U
      parent       = hQueryTextEditor:popup-menu
      label        = '<= (lower or queal)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          '<=':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Begins':U
      parent       = hQueryTextEditor:popup-menu
      label        = 'begins':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          'begins':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Matches':U
      parent       = hQueryTextEditor:popup-menu
      label        = 'matches':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          'matches':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Contains':U
      parent       = hQueryTextEditor:popup-menu
      label        = 'contains':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowSetComparator in target-procedure
                         (bttQueryWindow.WindowHandle,
                          'contains':U).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hQueryTextEditor:popup-menu
      .
  
  create menu-item hTemp
    assign
      name        = 'mi_BeautifyQueryText':U
      parent      = hQueryTextEditor:popup-menu
      label       = 'Beautify query text':T
      sensitive   = yes
    triggers:
      
      on choose persistent run qg_QueryWindowBeautify in target-procedure
                                 (bttQueryWindow.WindowHandle).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hQueryTextEditor:popup-menu
      .
  
  create menu-item hTemp
    assign
      name        = 'mi_RecentQueries':U
      parent      = hQueryTextEditor:popup-menu
      label       = 'Recent queries':T
      sensitive   = yes
    triggers:
      
      on choose persistent run qg_QueryWindowRecentQueries in target-procedure
                                 (bttQueryWindow.WindowHandle).
      
    end triggers
    .
  
end. /* if bttQueryWindow.ObjSourceQuerySeq = 0 */

/* Create field selection browse popup menu. */

create menu hTemp
  assign
    name       = 'm_PopupMenu':U
    popup-only = yes
    sensitive  = yes
    .

hFieldSelectionBrowse:popup-menu = hTemp.

create menu-item hTemp
  assign
    name         = 'mi_MoveToFirstColumn':U
    parent       = hFieldSelectionBrowse:popup-menu
    label        = 'Move to first column':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowMoveColumn in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_MoveToLastColumn':U
    parent       = hFieldSelectionBrowse:popup-menu
    label        = 'Move to last column':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowMoveColumn in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
  end triggers
  .

if bttQueryWindow.ObjSourceQuerySeq = 0 then
do:
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hFieldSelectionBrowse:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_AddCondition':U
      parent       = hFieldSelectionBrowse:popup-menu
      label        = 'Add condition':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowQueryTextEditorAddCondition in target-procedure
                         (bttQueryWindow.WindowHandle).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_AddSortPhrase':U
      parent       = hFieldSelectionBrowse:popup-menu
      label        = 'Add sort option':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowAddSortOption in target-procedure
                         (bttQueryWindow.WindowHandle,
                          no).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_AddSortPhrase':U
      parent       = hFieldSelectionBrowse:popup-menu
      label        = 'Add sort option (descending)':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowAddSortOption in target-procedure
                         (bttQueryWindow.WindowHandle,
                          yes).
      
    end triggers
    .
  
end. /* if bttQueryWindow.ObjSourceQuerySeq = 0 */

run qg_InitBrowse(hFieldSelectionBrowse).

/* Create query browse popup menu. */

create menu hTemp
  assign
    name       = 'm_PopupMenu':U
    popup-only = yes
    sensitive  = yes
  triggers:
    
    on menu-drop
      persistent run qg_QueryWindowQueryBrowsePopupMenuDrop in target-procedure
                      (bttQueryWindow.WindowHandle).
    
  end triggers.

hQueryBrowse:popup-menu = hTemp.

create menu-item hTemp
  assign
    name         = 'mi_CopySelectedColumnValueRaw':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Copy raw value':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowQueryBrowseCopySelectedColumnValue in target-procedure
                       ( bttQueryWindow.WindowHandle,
                         yes ).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_CopySelectedColumnValueFormatted':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Copy formatted value':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowQueryBrowseCopySelectedColumnValue in target-procedure
                       ( bttQueryWindow.WindowHandle,
                         no ).
    
  end triggers
  .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hQueryBrowse:popup-menu
    .

create menu-item hTemp
  assign
    name         = 'mi_CopyRecordValuesRaw':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Copy record values':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowCopyRecordValues in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hQueryBrowse:popup-menu
    .

create menu-item hTemp
  assign
    name         = 'mi_CopyRecid':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Copy recid':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowCopyRecid in target-procedure
                       (bttQueryWindow.WindowHandle,
                        yes).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_CopyRowid':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Copy rowid':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowCopyRecid in target-procedure
                       (bttQueryWindow.WindowHandle,
                        no).
    
  end triggers
  .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hQueryBrowse:popup-menu
    .

create menu-item hTemp
  assign
    name         = 'mi_CalculateSum':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Calculate Sum':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowCalculateSum in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hQueryBrowse:popup-menu
    .

create menu-item hTemp
  assign
    name         = 'mi_SelectForComparison1':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Select for comparison 1':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowSelectForComparison in target-procedure
                       (bttQueryWindow.WindowHandle,
                        1).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_SelectForComparison2':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Select for comparison 2':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowSelectForComparison in target-procedure
                       (bttQueryWindow.WindowHandle,
                        2).
    
  end triggers
  .

create menu-item hTemp
  assign
    name         = 'mi_CompareSelectedRecords':U
    parent       = hQueryBrowse:popup-menu
    label        = 'Compare selected records':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowCompareSelectedRecords in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

run qg_InitBrowse(hQueryBrowse).

hQueryBrowse:column-movable = no.

hQueryBrowse:query = bttQueryWindow.QueryHandle.

assign
  bttQueryWindow.QueryFrameHandle                      = hFrame
  bttQueryWindow.QueryMenuHandle                       = hMenuBar
  bttQueryWindow.QueryTextEditorHandle                 = hQueryTextEditor
  bttQueryWindow.QueryFieldBrowseHandle                = hFieldSelectionBrowse
  bttQueryWindow.QueryFieldBrowseBufferHandle          = hFieldSelectionBuffer
  bttQueryWindow.QueryBrowseHandle                     = hQueryBrowse
  hFieldSelectionBrowse:query                          = hFieldSelectionQuery
  bttQueryWindow.QueryFieldBrowseColHandles[1]         = hFieldSelectionBrowse:add-like-column('ttQueryWindowField.FieldName':U)
  bttQueryWindow.QueryFieldBrowseColHandles[1]:visible = no
  bttQueryWindow.QueryFieldBrowseColHandles[2]         = hFieldSelectionBrowse:add-like-column('ttQueryWindowField.DisplayName':U)
  bttQueryWindow.QueryFieldBrowseColHandles[2]:width   = 32
  bttQueryWindow.QueryFieldBrowseColHandles[3]         = hFieldSelectionBrowse:add-like-column('ttQueryWindowField.IsVirtual':U)
  bttQueryWindow.QueryFieldBrowseColHandles[4]         = hFieldSelectionBrowse:add-like-column('ttQueryWindowField.DataType':U)
  hFieldSelectionBrowse:labels                         = no
  .

validate bttQueryWindow.

end procedure. /* qg_QueryWindowCreateQueryFrame */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowCreateRecordFrame hQueryWindow 
PROCEDURE qg_QueryWindowCreateRecordFrame :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hMenuBar         as handle    no-undo.
define variable hMenu            as handle    no-undo.

define variable hFrame           as handle    no-undo.
define variable hBrowse          as handle    no-undo.
define variable hBuffer          as handle    no-undo.
define variable hQuery           as handle    no-undo.

define variable hTemp            as handle    no-undo.

define variable iIndex           as integer   no-undo.

define variable cIconDown        as character no-undo.
define variable cIconFirst       as character no-undo.
define variable cIconPrev        as character no-undo.
define variable cIconRefresh     as character no-undo.
define variable cIconNext        as character no-undo.
define variable cIconLast        as character no-undo.
define variable cIconPreferences as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/*----------------------------------------------------------------------------*/
/* Create Menu                                                                */
/*----------------------------------------------------------------------------*/

cIconDown = search('bmp/icon_down.bmp':U).

if cIconDown = ? then
  cIconDown = search('bmp/btndown.bmp':U).

cIconRefresh = search('bmp/icon_refresh.bmp':U).

if cIconRefresh = ? then
  cIconRefresh = search('bmp/btnrefru.bmp':U).

cIconFirst = search('bmp/icon_first.bmp':U).

if cIconFirst = ? then
  cIconFirst = search('bmp/btnfirsu.bmp':U).

cIconPrev = search('bmp/icon_prev.bmp':U).

if cIconPrev = ? then
  cIconPrev = search('bmp/btnprevu.bmp':U).

cIconNext = search('bmp/icon_next.bmp':U).

if cIconNext = ? then
  cIconNext = search('bmp/btnnextu.bmp':U).

cIconLast = search('bmp/icon_last.bmp':U).

if cIconLast = ? then
  cIconLast = search('bmp/btnlastu.bmp':U).

cIconPreferences = search('bmp/icon_preferences.bmp':U).

create menu hMenuBar.

create sub-menu hMenu
  assign
    name      = 'm_File':U
    label     = 'File':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_Close':U
    label       = 'Close':T
    accelerator = 'CTRL-W':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowClose in target-procedure
                       (bttQueryWindow.WindowHandle,
                        ?).  
    
  end triggers.

create sub-menu hMenu
  assign
    name      = 'm_Edit':U
    label     = 'Edit':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_CopyValue':U
    label       = 'Copy value':T
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowRecordCopyValue in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create sub-menu hMenu
  assign
    name      = 'm_Tools':U
    label     = 'Tools':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_Refresh':U
    label       = 'Refresh':T
    accelerator = 'F5':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowRecordRefresh in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .

create menu-item hTemp
  assign
    name        = 'mi_OpenRelatedQuery':U
    label       = 'Open related query':T
    accelerator = 'CTRL-R':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenRelatedQuery in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    name        = 'mi_ObjectFieldValues':U
    label       = 'Open Object field values':T
    accelerator = 'CTRL-O':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowOpenObjectFieldValues in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

/* Options menu */

create sub-menu hMenu
  assign
    name      = 'm_Options':U
    label     = 'Options':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name       = 'mi_ObjectIdOveray':U
    label      = 'Object id overlay':T
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowObjectIdOverlay in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create menu-item hTemp
  assign
    name       = 'mi_DeepResolveObjectIds':U
    label      = 'Deep resolve object ids':T
    toggle-box = yes
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on value-changed
      persistent run qg_QueryWindowToggleDeepResolve in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

create sub-menu hMenu
  assign
    name      = 'm_View':U
    label     = 'View':T
    sensitive = yes
    parent    = hMenuBar
  triggers:
    
    on menu-drop
      persistent run qg_QueryWindowRecordViewMenuDrop in target-procedure
                      (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    name       = 'mi_RawValues':U
    label      = 'Raw values':T
    toggle-box = yes
    sensitive  = yes
    parent     = hMenu
  triggers:
    
    on value-changed
      persistent run qg_QueryWindowToggleRawValues in target-procedure
                      ( bttQueryWindow.WindowHandle ).
    
  end triggers.

create sub-menu hMenu
  assign
    name      = 'm_Window':U
    label     = 'Window':T
    sensitive = yes
    parent    = hMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_QueryMode':U
    label       = 'Switch to query mode':T
    accelerator = 'F8':U
    sensitive   = yes
    parent      = hMenu
  triggers:
    
    on choose
      persistent run qg_QueryWindowSetWindowMode in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_QUERY_WINDOW_MODE_QUERY},
                        ?,
                        ?).
    
  end triggers.

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hMenu
    .
  
create menu-item hTemp
  assign
    name      = 'mi_WindowSizeDefault':U
    label     = 'Restore default window size':T
    sensitive = yes
    parent    = hMenu
  triggers:
    on choose
      persistent run qg_QueryWindowSetSize in target-procedure
                       (bttQueryWindow.WindowHandle,
                        {&K_RECORD_SIZE_MODE_DEFAULT}).
  end triggers.


run qg_AddHelpMenu(hMenuBar).

/*----------------------------------------------------------------------------*/
/* Create Frame                                                               */
/*----------------------------------------------------------------------------*/

create frame hFrame
  assign
    name           = 'fQuery':U
    box            = no
    three-d        = yes
    width          = 235
    virtual-width  = 235
    height         = 32
    virtual-height = 32
    sensitive      = yes
    parent         = bttQueryWindow.WindowHandle
  triggers:
    
    on ctrl-f7 anywhere /* Show query window */
      persistent run qg_OpenQueryWindowListWindow in target-procedure.
    
  end triggers.

create browse hBrowse
  assign
    name                   = 'brRecord':U
    frame                  = hFrame
    width                  = 91
    height                 = 18.44
    row                    = 3
    col                    = 1
    read-only              = yes
    row-markers            = no
    allow-column-searching = no
    multiple               = no
  triggers:
    
    on row-display
      persistent run qg_QueryWindowRecordBrowseRowDisplay in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on default-action
      persistent run qg_QueryWindowRecordFieldDetails in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on ' ':U /* Value details */
      persistent run qg_QueryWindowRecordFieldDetails in target-procedure
                       (bttQueryWindow.WindowHandle).
    
    on ctrl-c /* Copy value */
      persistent run qg_QueryWindowRecordCopyValue in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers.

/* Create browse popup menu. */

create menu hTemp
  assign
    name       = 'm_RecordBrowsePopupMenu':U
    popup-only = yes
    sensitive  = yes
    .

hBrowse:popup-menu = hTemp.

create menu-item hTemp
  assign
    name         = 'mi_CopyValue':U
    parent       = hBrowse:popup-menu
    label        = 'Copy value':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowRecordCopyValue in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
  .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hBrowse:popup-menu
    .

create menu-item hTemp
  assign
    name         = 'mi_FieldDetails':U
    parent       = hBrowse:popup-menu
    label        = 'Field details':T
    sensitive    = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowRecordFieldDetails in target-procedure
                       (bttQueryWindow.WindowHandle).
    
  end triggers
    .

create menu-item hTemp
  assign
    subtype = 'RULE':U
    parent  = hBrowse:popup-menu
    .

create menu-item hTemp
  assign
    name         = 'mi_SelectFields':U
    parent       = hBrowse:popup-menu
    label        = 'Select fields':T
    sensitive    = yes
  triggers:
    on choose
      persistent run qg_QueryWindowRecordSelectFields in target-procedure
                       (bttQueryWindow.WindowHandle).
  end triggers.

create button hTemp
  assign
    name                 = 'btnRefresh':U
    frame                = hFrame
    width                = 6
    height               = 1.5
    row                  = 1.25
    col                  = 45
    label                = '*':T
    tooltip              = 'Refresh current record values':T
    flat-button          = yes
    sensitive            = yes
  triggers:
    
    on choose
      persistent run qg_QueryWindowRecordRefresh in target-procedure
                      (bttQueryWindow.WindowHandle).
  
  end triggers.

if cIconRefresh > '':U then
  hTemp:load-image(cIconRefresh) no-error.
  
if bttQueryWindow.ObjSourceQuerySeq > 0 then
do:
  
  create text hTemp
    assign
      name      = 'cObjField':U
      frame     = hFrame
      data-type = 'character':U
      format    = 'x(255)':U
      width     = 65
      height    = 1
      row       = 1.5
      col       = 3
      sensitive = yes
      read-only = yes
      tab-stop  = no
      .
  
  create button hTemp
    assign
      name                 = 'btnSelectObjField':U
      frame                = hFrame
      width                = 6
      height               = 1.5
      row                  = 1.25
      col                  = 68
      label                = '...':T
      tooltip              = 'Select object id field':T
      flat-button          = yes
      sensitive            = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowObjSelectObjField in target-procedure
                        (bttQueryWindow.WindowHandle).
    
    end triggers.

  if cIconPreferences > '':U then
    hTemp:load-image(cIconPreferences) no-error.

end. /* if bttQueryWindow.ObjSourceQuerySeq > 0 */

else
do:
  
  create radio-set hTemp
    assign
      name          = 'lRawValues':U
      frame         = hFrame
      width         = 40
      height        = 1
      row           = 1.5
      col           = 3
      sensitive     = yes
      radio-buttons = 'Formatted values,no,Raw values,yes':T
      horizontal    = yes
    triggers:
      
      on value-changed
        persistent run qg_QueryWindowToggleRawValues in target-procedure
                         ( bttQueryWindow.WindowHandle ).
      
    end triggers
    .
  
  create button hTemp
    assign
      name                 = 'btnFirstRecord':U
      frame                = hFrame
      width                = 6
      height               = 1.5
      row                  = 1.25
      col                  = 46
      label                = '<<':T
      tooltip              = 'Select first record':T
      flat-button          = yes
      sensitive            = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowRecordNavigate in target-procedure
                        (bttQueryWindow.WindowHandle,
                         {&K_NAVIGATE_FIRST}).
    
    end triggers.
  
  if cIconFirst > '':U then
    hTemp:load-image(cIconFirst) no-error.
  
  create button hTemp
    assign
      name                 = 'btnPrevRecord':U
      frame                = hFrame
      width                = 6
      height               = 1.5
      row                  = 1.25
      col                  = 52
      label                = '<':T
      tooltip              = 'Select previous record':T
      flat-button          = yes
      sensitive            = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowRecordNavigate in target-procedure
                        (bttQueryWindow.WindowHandle,
                         {&K_NAVIGATE_PREV}).
    
    end triggers.
  
  if cIconPrev > '':U then
    hTemp:load-image(cIconPrev) no-error.
  
  create button hTemp
    assign
      name                 = 'btnNextRecord':U
      frame                = hFrame
      width                = 6
      height               = 1.5
      row                  = 1.25
      col                  = 64
      label                = '>':T
      tooltip              = 'Select next record':T
      flat-button          = yes
      sensitive            = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowRecordNavigate in target-procedure
                        (bttQueryWindow.WindowHandle,
                         {&K_NAVIGATE_NEXT}).
    
    end triggers.
  
  if cIconNext > '':U then
    hTemp:load-image(cIconNext) no-error.
  
  create button hTemp
    assign
      name                 = 'btnLastRecord':U
      frame                = hFrame
      width                = 6
      height               = 1.5
      row                  = 1.25
      col                  = 70
      label                = '>>':T
      tooltip              = 'Select last record':T
      flat-button          = yes
      sensitive            = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowRecordNavigate in target-procedure
                        (bttQueryWindow.WindowHandle,
                         {&K_NAVIGATE_LAST}).
    
    end triggers.
  
  if cIconLast > '':U then
    hTemp:load-image(cIconLast) no-error.
  
end. /* else: if bttQueryWindow.ObjSourceQuerySeq > 0 */

create buffer hBuffer for table 'ttQueryWindowField':U. /* code checked by mth 30.07.2015 */

create query hQuery.
hQuery:set-buffers(hBuffer).

hBrowse:query = hQuery.

assign
  bttQueryWindow.RecordFrameHandle         = hFrame
  bttQueryWindow.RecordMenuHandle          = hMenuBar
  bttQueryWindow.RecordQueryHandle         = hQuery
  bttQueryWindow.RecordBrowseHandle        = hBrowse
  bttQueryWindow.RecordBrowseColHandles[1] = hBrowse:add-like-column('ttQueryWindowField.FieldName':U)
  bttQueryWindow.RecordBrowseColHandles[2] = hBrowse:add-like-column('ttQueryWindowField.FieldIndex':U)
  bttQueryWindow.RecordBrowseColHandles[3] = hBrowse:add-like-column('ttQueryWindowField.DisplayName':U)
  bttQueryWindow.RecordBrowseColHandles[4] = hBrowse:add-like-column('ttQueryWindowField.FieldLabel':U)
  bttQueryWindow.RecordBrowseColHandles[5] = hBrowse:add-like-column('ttQueryWindowField.CurrentDisplayValue':U)
  .

/* Hide field name, label and index column. */

assign
  bttQueryWindow.RecordBrowseColHandles[1]:visible = no
  bttQueryWindow.RecordBrowseColHandles[2]:visible = no
  bttQueryWindow.RecordBrowseColHandles[3]:width   = 32
  bttQueryWindow.RecordBrowseColHandles[4]:visible = no
  .

run qg_InitBrowse(hBrowse).

validate bttQueryWindow.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  run qg_QueryWindowObjUpdateObjFieldText(bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowCreateRecordFrame */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowDelete hQueryWindow 
PROCEDURE qg_QueryWindowDelete :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Delete current record.                                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lOk              as logical   no-undo.
define variable lDisableTriggers as logical   no-undo.

define variable hBuffer     as handle    no-undo.
define variable hLockBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

define buffer bttTable       for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if   not valid-handle(bttQueryWindow.QueryHandle)
  or bttQueryWindow.QueryHandle:num-buffers = 0 then
  leave.

hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(1).

if not hBuffer:available then
do:
  
  message /* code checked by mth */
    'No record is selected!':T
    view-as alert-box
    error
    buttons ok
    in window bttQueryWindow.WindowHandle.
  
  leave.

end. /* if not hBuffer:available */

Main:
do transaction
  on error undo, throw:
  
  create buffer hLockBuffer for table hBuffer.
  
  find bttTable
    where bttTable.DatabaseName = hLockBuffer:dbname
      and bttTable.TableName    = hLockBuffer:table
    no-error.
  
  hLockBuffer:find-by-rowid(hBuffer:rowid, exclusive-lock).
  
  lDisableTriggers =     available bttTable
                     and bttTable.DeleteTrigger         > '':U
                     and search(bttTable.DeleteTrigger) = ?.
  
  run qg_ConfirmTriggerChanges(substitute('Confirm deletion of &1 record (&2)':T,
                                          hLockBuffer:table,
                                          string(hLockBuffer:rowid)),
                               'WARNING: You are about to delete the current record. Please confirm deletion of this record!':T,
                               'Delete':T,
                               (    available bttTable
                                and search(bttTable.DeleteTrigger) <> ?),
                               bttQueryWindow.WindowHandle,
                                     output lOk,
                               input-output lDisableTriggers).
  
  if lOk then
  do:
    
    
    if lDisableTriggers then
    do:
      
      run qg_DeleteVirtualFieldRecordsForRecord( hLockBuffer:dbname,
                                                 hLockBuffer,
                                                 lDisableTriggers ).
      
      hLockBuffer:disable-load-triggers(no).
      
    end. /* if lDisableTriggers */
    
    hLockBuffer:buffer-delete().
    
    qg_lQueryOpen(bttQueryWindow.QueryHandle, ?, bttQueryWindow.WindowHandle).
    
  end. /* if lOk */
  
  finally:
    
    if valid-handle(hLockBuffer) then
      delete object hLockBuffer.
    
  end finally.
  
end. /* Main */

end procedure. /* qg_QueryWindowDelete */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowDock hQueryWindow 
PROCEDURE qg_QueryWindowDock :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Dock query window to closest other query window.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* piDirection                    = Direction to search for other query       */
/*                                  windows.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.
define input parameter piDirection as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hWindow       as handle    no-undo.

define variable iX1 as integer   no-undo.
define variable iY1 as integer   no-undo.
define variable iX2 as integer   no-undo.
define variable iY2 as integer   no-undo.

define variable iX1Temp as integer   no-undo.
define variable iY1Temp as integer   no-undo.
define variable iX2Temp as integer   no-undo.
define variable iY2Temp as integer   no-undo.

define variable dDistance      as decimal   no-undo.
define variable dDockDistanceX as decimal   no-undo init ?.
define variable dDockDistanceY as decimal   no-undo init ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.
define buffer b2ttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/* The size that progress returns for window:width-pixels and window:height-  */
/* pixels does not include the borders. So in order to get the true window    */
/* size and position we need the windows api.                                 */

run qg_GetWindowRect(phWindow,
                     output iX1,
                     output iY1,
                     output iX2,
                     output iY2).

for each b2ttQueryWindow
  on error undo, throw:
  
  hWindow = b2ttQueryWindow.WindowHandle.
  
  if    not valid-handle(hWindow)
     or hWindow = bttQueryWindow.WindowHandle then
    next.
  
  run qg_GetWindowRect(hWindow,
                       output iX1Temp,
                       output iY1Temp,
                       output iX2Temp,
                       output iY2Temp).
  
  if    ( ( piDirection = {&K_DIRECTION_UP}
         or piDirection = {&K_DIRECTION_DOWN} )
      and iX1 <= iX2Temp
      and iX2 >= iX1Temp )
     or ( ( piDirection = {&K_DIRECTION_LEFT}
         or piDirection = {&K_DIRECTION_RIGHT} )
      and iY1 <= iY2Temp
      and iY2 >= iY1Temp ) then
  do:
    
    case piDirection:
      
      when {&K_DIRECTION_UP} then
      do:
        
        dDistance = iY1 - iY2Temp.
        
        if    dDistance > 0
          and ( dDockDistanceY = ?
             or dDistance      < dDockDistanceY ) then
          assign
            dDockDistanceX = iX1 - iX1Temp
            dDockDistanceY = dDistance
            .
        
      end. /* when {&K_DIRECTION_UP} */
      
      when {&K_DIRECTION_DOWN} then
      do:
        
        dDistance = iY2 - iY1Temp.
        
        if    dDistance < 0
          and ( dDockDistanceY = ?
             or dDistance      > dDockDistanceY ) then
          assign
            dDockDistanceX = iX1 - iX1Temp
            dDockDistanceY = dDistance
            .
        
      end. /* when {&K_DIRECTION_DOWN} */
      
      when {&K_DIRECTION_LEFT} then
      do:
        
        dDistance = iX1 - iX2Temp.
        
        if    dDistance > 0
          and ( dDockDistanceX = ?
             or dDistance      < dDockDistanceX ) then
          assign
            dDockDistanceX = dDistance
            dDockDistanceY = iY1 - iY1Temp
            .
        
      end. /* when {&K_DIRECTION_LEFT} */
      
      when {&K_DIRECTION_RIGHT} then
      do:
        
        dDistance = iX2 - iX1Temp.
        
        if    dDistance < 0
          and ( dDockDistanceX = ?
             or dDistance      > dDockDistanceX ) then
          assign
            dDockDistanceX = dDistance
            dDockDistanceY = iY1 - iY1Temp
            .
        
      end. /* when {&K_DIRECTION_RIGHT} */
      
    end case. /* piDirection */
    
  end. /* if    ( ( piDirection = {&K_DIRECTION_UP} */
  
end. /* for each b2ttQueryWindow */

if    dDockDistanceX <> ?
  and dDockDistanceY <> ? then
  assign
    bttQueryWindow.WindowHandle:x = bttQueryWindow.WindowHandle:x - dDockDistanceX
    bttQueryWindow.WindowHandle:y = bttQueryWindow.WindowHandle:y - dDockDistanceY
    .

end procedure. /* qg_QueryWindowDock */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowEdit hQueryWindow 
PROCEDURE qg_QueryWindowEdit :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Edit current record.                                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* piEditAction                   = Action that should be performed:          */
/*                                  - {&K_EDITACTION_EDIT}                    */
/*                                  - {&K_EDITACTION_CREATE}                  */
/*                                  - {&K_EDITACTION_DUPLICATE}               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow       as handle    no-undo.
define input parameter piEditAction   as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable rRowid  as rowid     no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if   not valid-handle(bttQueryWindow.QueryHandle)
  or bttQueryWindow.QueryHandle:num-buffers = 0 then
  leave.

hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(1).
  
if   ( piEditAction = {&K_EDITACTION_EDIT}
    or piEditAction = {&K_EDITACTION_DUPLICATE})
  and not hBuffer:available then
do:
  
  message /* code checked by mth */
    'No record is selected!':T
    view-as alert-box
    error
    buttons ok
    in window bttQueryWindow.WindowHandle.
  
  leave.
  
end. /* if not phBuffer:available */

run qg_EditRecord(hBuffer,
                  piEditAction,
                  {&K_EDITMODE_ENABLED},
                  bttQueryWindow.WindowHandle,
                  (if valid-handle(bttQueryWindow.QueryBrowseHandle) then
                     qg_cBrowseColumnList(bttQueryWindow.QueryBrowseHandle,
                                          yes,
                                          no,
                                          no)
                   else
                     ?),
                  output rRowid).

&IF {&K_EDITMODE_ENABLED} &THEN

  case piEditAction:
    
    when {&K_EDITACTION_EDIT} then
    do:
      
      if valid-handle(bttQueryWindow.QueryBrowseHandle) then 
        bttQueryWindow.QueryBrowseHandle:refresh().
      
      run qg_QueryWindowUpdateAll('':U).
      
    end. /* when {&K_EDITACTION_EDIT} */
    
    otherwise
    do:
      
      qg_lQueryOpen(bttQueryWindow.QueryHandle, ?, bttQueryWindow.WindowHandle).

      if rRowid <> ? then
        bttQueryWindow.QueryHandle:reposition-to-rowid(rRowid) no-error.
      
/*      bttQueryWindow.QueryBrowseHandle:scroll-to-current-row().*/
      
    end. /* otherwise */
    
  end case. /* piEditAction */
  
&ENDIF

end procedure. /* qg_QueryWindowEdit */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_queryWindowEntry hQueryWindow 
PROCEDURE qg_queryWindowEntry :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow     for temp-table ttQueryWindow.
define buffer bttQueryWindowView for temp-table ttQueryWindowView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

ghActiveQueryWindow = bttQueryWindow.WindowHandle.

run qg_QueryWindowListSelectQueryWindow(ghActiveQueryWindow).

end procedure. /* qg_queryWindowEntry */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowExecCurrentQuery hQueryWindow 
PROCEDURE qg_QueryWindowExecCurrentQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Executes the current query text in a new query window.                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow       as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i             as integer   no-undo.
define variable hBuffer       as handle    no-undo.
define variable cDatabaseName as character no-undo.
define variable cTables       as character no-undo.
define variable iQuerySeq     as integer   no-undo init ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow     for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if   not valid-handle(bttQueryWindow.QueryHandle)
  or bttQueryWindow.QueryHandle:num-buffers = 0 then
  leave.

do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
  
  assign
    hBuffer       = bttQueryWindow.QueryHandle:get-buffer-handle(i)
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer )
    cTables       = substitute('&1.&2:&3':U,
                               cDatabaseName,
                               hBuffer:table,
                               hBuffer:name)
    .
  
end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers */

if bttQueryWindow.QueryHandle:prepare-string > '':U then
  run qg_ExecQuery({&K_QUERY_WINDOW_MODE_QUERY},
                   {&K_QUERY_SIZE_MODE_DEFAULT},
                   cTables,
                   bttQueryWindow.QueryHandle:prepare-string,
                   no,  /* Init mode */
                   '':U,
                   input-output iQuerySeq).

end procedure. /* qg_QueryWindowExecCurrentQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowExecute hQueryWindow 
PROCEDURE qg_QueryWindowExecute :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Execute query of given query window.                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcQueryText                    = Query text that should be executed. If    */
/*                                  empty or "?" then the query text will be  */
/*                                  be determined by the window mode.         */
/* plFocusBrowse                  = Focus browse if the browse contains hits. */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow      as handle    no-undo.
define input parameter pcQueryText   as character no-undo.
define input parameter plFocusBrowse as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo.
define variable i          as integer   no-undo.
define variable cButtons   as character no-undo init 'btnExecute,btnEdit,btnDelete,btnCreate,btnDuplicate':U.
define variable hTemp      as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/* Additional do block to ensure that bttQueryWindow will be available in     */
/* finally block.                                                             */

do on error undo, throw:
  
  phWindow:title = substitute('&1 (executing ...)':U, bttQueryWindow.WindowTitle).
  
  if   not valid-handle(bttQueryWindow.QueryHandle)
    or bttQueryWindow.QueryHandle:num-buffers = 0 then
    leave.
  
  case bttQueryWindow.WindowMode:
    
    when {&K_QUERY_WINDOW_MODE_QUERY} then
    do:
      
      do i = 1 to num-entries(cButtons):
        
        hTemp = qg_hGetWidgetByName(bttQueryWindow.WindowHandle,
                                    entry(i, cButtons)).
        
        if valid-handle(hTemp) then
          hTemp:sensitive = no. /* code checked by mth 30.07.2015 */
        
      end. /* do i = 1 to num-entries(i) */
      
      cQueryText = (if pcQueryText > '':U then
                      pcQueryText
                    else
                      bttQueryWindow.QueryTextEditorHandle:input-value).
      
    end. /* when {&K_QUERY_WINDOW_MODE_QUERY} */
    
    when {&K_QUERY_WINDOW_MODE_RECORD} then
      cQueryText = (if pcQueryText > '':U then
                      pcQueryText
                    else
                      bttQueryWindow.QueryText).
    
  end case. /* case bttQueryWindow.WindowMode */
  
  process events.
  
  if cQueryText <> bttQueryWindow.QueryText then
    run qg_QueryWindowSetQueryText(bttQueryWindow.WindowHandle, cQueryText).
  
  run qg_QueryWindowUpdateAll(string(bttQueryWindow.WindowHandle)).
  
  case bttQueryWindow.WindowMode:
    
    when {&K_QUERY_WINDOW_MODE_QUERY} then
      if    plFocusBrowse
        and bttQueryWindow.QueryHandle:num-results > 0 then
        apply 'entry':U to bttQueryWindow.QueryBrowseHandle.
    
    when {&K_QUERY_WINDOW_MODE_RECORD} then
      if    plFocusBrowse
        and bttQueryWindow.RecordQueryHandle:num-results > 0 then
        apply 'entry':U to bttQueryWindow.RecordBrowseHandle.
    
  end case. /* case bttQueryWindow.WindowMode */
  
  finally:
    
    if valid-handle(phWindow) then
      phWindow:title = bttQueryWindow.WindowTitle.
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
    do:
      
      do i = 1 to num-entries(cButtons):
        
        hTemp = qg_hGetWidgetByName(bttQueryWindow.WindowHandle,
                                    entry(i, cButtons)).
      
        if valid-handle(hTemp) then
          hTemp:sensitive = yes. /* code checked by mth 30.07.2015 */
        
      end. /* do i = 1 to num-entries(i) */
      
    end. /* if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} */
    
  end finally.
  
end.

end procedure. /* qg_QueryWindowExecute */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowFieldSelectionBrowseDefaultAction hQueryWindow 
PROCEDURE qg_QueryWindowFieldSelectionBrowseDefaultAction :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Default action trigger of field selection browse.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iKeyState             as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

bttQueryWindow.QueryFieldBrowseHandle:deselect-rows().
bttQueryWindow.QueryFieldBrowseHandle:select-focused-row().

run GetKeyState({&K_WIN_CONST_VK_ALT}, output iKeyState).

if iKeyState < 0 then
do:
  
  run GetKeyState({&K_WIN_CONST_VK_SHIFT}, output iKeyState).
  
  run qg_QueryWindowAddSortOption(bttQueryWindow.WindowHandle,
                                  (iKeyState < 0)).

end. /* else: if iKeyState >= 0 */

else
do:
  
  run GetKeyState({&K_WIN_CONST_VK_CTRL}, output iKeyState).
  
  if iKeyState < 0 then
    run qg_QueryWindowMoveColumn(bttQueryWindow.WindowHandle, yes).
  
  else
    run qg_QueryWindowQueryTextEditorAddCondition(bttQueryWindow.WindowHandle).

end. /* else: if iKeyState < 0 */

end procedure. /* qg_QueryWindowFieldSelectionBrowseDefaultAction */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowFindMissingObjectIds hQueryWindow 
PROCEDURE qg_QueryWindowFindMissingObjectIds :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Default action trigger of field selection browse.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lSelected               as logical   no-undo.
define variable cField_Key              as character no-undo.
define variable cField_Label            as character no-undo.
define variable cAvailableColumn_Keys   as character no-undo.
define variable cAvailableColumn_Labels as character no-undo.
define variable cSelectedColumn_Keys    as character no-undo.
define variable lOk                     as logical   no-undo.

define variable i                       as integer   no-undo.
define variable hQuery                  as handle    no-undo.
define variable hBuffer                 as handle    no-undo.
define variable cDatabaseNames          as character no-undo extent.
define variable cBufferNames            as character no-undo extent.
define variable cFieldNames             as character no-undo extent.
define variable iFieldIndices           as integer   no-undo extent.
define variable hBufferFields           as handle    no-undo extent.
define variable cObjectId               as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
    and bttQueryWindowField.IsOverlay    = no
  on error undo, throw:
  
  if lookup(bttQueryWindowField.DataType, 'CHARACTER,LONGCHAR':U) = 0 then
    next.
  
  assign
    lSelected               =   (     bttQueryWindowField.FieldName matches '*_Obj':U
                                   or bttQueryWindowField.isObjectId )
                              and not bttQueryWindowField.FieldName matches substitute('&1_Obj':U, bttQueryWindowField.TableName)
    cField_Key              = qg_cFormattedFieldName(?,
                                                     bttQueryWindowField.BufferName,
                                                     bttQueryWindowField.FieldName,
                                                     bttQueryWindowField.FieldIndex)
    cAvailableColumn_Keys   = substitute('&1,&2':U, cAvailableColumn_Keys, cField_Key)
    cField_Label            = qg_cFormattedFieldName(?,
                                                     (if    valid-handle(bttQueryWindow.QueryBrowseHandle)
                                                        and bttQueryWindow.QueryHandle:num-buffers > 1 then
                                                        bttQueryWindowField.BufferName
                                                      else
                                                        ?),
                                                     bttQueryWindowField.FieldName,
                                                     bttQueryWindowField.FieldIndex)
    cAvailableColumn_Labels = substitute('&1,&2':U,
                                         cAvailableColumn_Labels,
                                          cField_Label)
    .
  
  if lSelected then
    cSelectedColumn_Keys = substitute('&1,&2':U, cSelectedColumn_Keys, cField_Key).
  
end. /* for each bttQueryWindowField */

assign
  cAvailableColumn_Keys   = trim(cAvailableColumn_Keys, ',':U)
  cAvailableColumn_Labels = trim(cAvailableColumn_Labels, ',':U)
  cSelectedColumn_Keys    = ( if bttQueryWindow.MissingObjectIdFields > '':U then
                                bttQueryWindow.MissingObjectIdFields
                              else
                                trim( cSelectedColumn_Keys, ',':U ) )
  .

do while yes
  on error undo, throw:
  
  run qg_SelectionDialog( cAvailableColumn_Keys,
                          cAvailableColumn_Labels,
                          input-output cSelectedColumn_Keys,
                          'Select Fields to check':T,
                          bttQueryWindow.WindowHandle,
                          no,
                          output lOk ).
  
  if not lOk then
    return.
  
  if num-entries( cSelectedColumn_Keys ) > 0 then
  do:
    
    if cSelectedColumn_Keys <> bttQueryWindow.MissingObjectIdFields then
      assign
        bttQueryWindow.MissingObjectIdFields      = cSelectedColumn_Keys
        bttQueryWindow.LastMissingObjectIdRecords = '':U
        .
    
    if    valid-handle( bttQueryWindow.QueryHandle )
      and bttQueryWindow.QueryHandle:is-open
      and bttQueryWindow.QueryHandle:num-results > 0 then
      run qg_QueryWindowFindNextMissingObjectId( bttQueryWindow.WindowHandle ).
    
    leave.
    
  end. /* if num-entries( cSelectedColumn_Keys ) > 0 */
  
  message
    'At least one field has to be selected':T skip
    view-as alert-box
    error
    buttons ok.
  
end.

end procedure. /* qg_QueryWindowFindMissingObjectIds */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowFindNextMissingObjectId hQueryWindow 
PROCEDURE qg_QueryWindowFindNextMissingObjectId :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Default action trigger of field selection browse.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                  as integer   no-undo.
define variable rCurrentRecords    as rowid     no-undo extent.
define variable hQuery             as handle    no-undo.
define variable hBuffers           as handle    no-undo extent.
define variable cDatabaseNames     as character no-undo extent.
define variable cBufferNames       as character no-undo extent.
define variable cFieldNames        as character no-undo extent.
define variable iFieldIndices      as integer   no-undo extent.
define variable hBufferFields      as handle    no-undo extent.
define variable cFieldDataTypes    as character no-undo extent.
define variable lIsVirtual         as logical   no-undo extent.
define variable iFieldTypes        as integer   no-undo extent.
define variable cObjectId          as character no-undo.

define variable lOmitCurrentRecord as logical   no-undo initial yes.

define variable iRecordCount       as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttField            for temp-table ttField.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.MissingObjectIdFields = '':U then
do:
  
  run qg_QueryWindowFindMissingObjectIds( bttQueryWindow.WindowHandle ).
  return.
  
end. /* if bttQueryWindow.MissingObjectIdFields = '':U */

assign
  hQuery = bttQueryWindow.QueryHandle
  extent( rCurrentRecords ) = hQuery:num-buffers.
  .

assign
  extent( hBuffers )        = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( cDatabaseNames )  = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( cBufferNames )    = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( cFieldNames )     = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( iFieldIndices )   = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( hBufferFields )   = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( cFieldDataTypes ) = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( lIsVirtual )      = num-entries( bttQueryWindow.MissingObjectIdFields )
  extent( iFieldTypes )     = num-entries( bttQueryWindow.MissingObjectIdFields )
  .

do i = 1 to num-entries( bttQueryWindow.MissingObjectIdFields ):
  
  run qg_SplitFieldName( entry( i, bttQueryWindow.MissingObjectIdFields ),
                         output cDatabaseNames[i],
                         output cBufferNames[i],
                         output cFieldNames[i],
                         output iFieldIndices[i] ).
  
  assign
    hBuffers[i]       = hQuery:get-buffer-handle( cBufferNames[i] )
    cDatabaseNames[i] = qg_cDatabaseNameForTableOrBuffer( hBuffers[i] )
    .
  
  hBufferFields[i]  = hBuffers[i]:buffer-field( cFieldNames[i] ) no-error.
  
  if   ( error-status:error
       or not valid-handle( hBufferFields[i] ) )
     and qg_lIsPhysicalDatabase( hBuffers[i]:dbname ) then
  do:
    
    find bttField
      where bttField.DatabaseName = cDatabaseNames[i]
        and bttField.TableName    = hBuffers[i]:table
        and bttField.FieldName    = cFieldNames[i]
      no-error.
    
    if available bttField then
      
      assign
        cFieldDataTypes[i] = bttField.DataType
        lIsVirtual[i]      = bttField.IsVirtual
        iFieldTypes[i]     = bttField.FieldType
        .
    
  end. /* if    error-status:error */
  
end. /* do i = 1 to num-entries( bttQueryWindow.MissingObjectIdFields ) */

do i = 1 to hQuery:num-buffers:
  
  rCurrentRecords[i] = hQuery:get-buffer-handle(i):rowid.
  
  if    num-entries( bttQueryWindow.LastMissingObjectIdRecords ) < i
     or to-rowid( entry( i, bttQueryWindow.LastMissingObjectIdRecords ) ) <> rCurrentRecords[i] then
    lOmitCurrentRecord = no.
  
end. /* do i = 1 to hQuery:num-buffers */

if lOmitCurrentRecord then
  hQuery:get-next().

do on error undo, throw:
  
  do while not hQuery:query-off-end:
    
    iRecordCount = iRecordCount + 1.
    
    if   iRecordCount = 50
      or iRecordCount mod 500 = 0 then
    do:
      
      display unless-hidden
        substitute( 'Searching for missing object ids (&1 records checked) ...':T,
                    trim(string( iRecordCount, {&K_MAX_INT64_FORMAT} ) ) )
          @ gcStatusText60
        with frame fStatus
          no-labels
          overlay
          color messages
          centered
          view-as dialog-box
          width 65
          in window bttQueryWindow.WindowHandle
          .
      
      process events.
      
    end. /* if iRecordCount mod 500 = 0 */
    
    do i = 1 to num-entries( bttQueryWindow.MissingObjectIdFields ):
      
      cObjectId = ( if lIsVirtual[i] then
                      string( qg_clVirtualFieldValueAsLongchar( iFieldTypes[i],
                                                                cFieldDataTypes[i],
                                                                cFieldNames[i],
                                                                qg_cObjectIdForBuffer( hBuffers[i] ),
                                                                ? ) )
                    else if valid-handle( hBufferFields[i] ) then
                      hBufferFields[i]:buffer-value( iFieldIndices[i] )
                    else
                      '':U ).
        
      if cObjectId > '':U then
      do:
        
        if qg_cResolveObjectId( cDatabaseNames[i],
                                cFieldNames[i],
                                cObjectId,
                                no,
                                no ) = ? then
        do:
          
          bttQueryWindow.LastMissingObjectIdRecords = '':U.
          
          do i = 1 to hQuery:num-buffers:
            
            rCurrentRecords[i] = hQuery:get-buffer-handle(i):rowid.
            
            if bttQueryWindow.LastMissingObjectIdRecords > '':U then
              bttQueryWindow.LastMissingObjectIdRecords
                  = bttQueryWindow.LastMissingObjectIdRecords + ',':U.
            
            bttQueryWindow.LastMissingObjectIdRecords
                = bttQueryWindow.LastMissingObjectIdRecords + string( rCurrentRecords[i] ).
            
          end. /* do i = 1 to hQuery:num-buffers */
          
          return.
          
        end. /* if cObjectId > '':U */
        
      end. /* if cObjectId > '':U */
      
    end. /* do i = 1 to num-entries( bttQueryWindow.MissingObjectIdFields ) */
    
    hQuery:get-next().
    
  end. /* do while not hQuery:query-off-end */

  finally:
    
    hQuery:reposition-to-rowid(rCurrentRecords).
    
  end finally.
  
end.

hide frame fStatus.

message
  'No more missing Object IDs have been found!':T skip
  view-as alert-box
  information
  buttons ok
    in window bttQueryWindow.WindowHandle.

finally:
  
  hide frame fStatus.
  
end finally.

end procedure. /* qg_QueryWindowFindNextMissingObjectId */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowInsertExternalReference hQueryWindow 
PROCEDURE qg_QueryWindowInsertExternalReference :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert external value token into query text.                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* phEditor                       = Handle of editor into which the external  */
/*                                  reference should be inserted.             */
/* plFieldReference               = Flag to indicate wether a field reference */
/*                                  or a table reference should be inserted.  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow         as handle    no-undo.
define input parameter phEditor         as handle    no-undo.
define input parameter plFieldReference as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                    as integer   no-undo.
define variable j                    as integer   no-undo.

define variable iStartPos            as integer   no-undo.
define variable iFieldRefPos         as integer   no-undo.
define variable iMaxFieldPos         as integer   no-undo.
define variable hQuery               as handle    no-undo.
define variable hBuffer              as handle    no-undo.
define variable hField               as handle    no-undo.
define variable cReferenceText       as character no-undo init ?.
define variable cEditorText          as character no-undo.
define variable iSelectionStart      as integer   no-undo.
define variable iSelectionEnd        as integer   no-undo.

define variable cTableName           as character no-undo init ?.
define variable cFieldName           as character no-undo init ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*---------------------------------------------------------------o-------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if    bttQueryWindow.ObjSourceQuerySeq > 0
   or not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

if plFieldReference then
do:
  
  assign
    hQuery      = bttQueryWindow.QueryHandle
    cEditorText = phEditor:input-value
    iStartPos   = max(r-index(cEditorText,
                              '=':U,
                              phEditor:cursor-offset),
                      r-index(cEditorText,
                              '<':U,
                              phEditor:cursor-offset),
                      r-index(cEditorText,
                              '>':U,
                              phEditor:cursor-offset))
    iStartPos   = (if iStartPos = 0 then
                     phEditor:cursor-offset
                   else
                     iStartPos)
    .
  
  /* Try to guess the field name for wich an external reference should be     */
  /* inserted.                                                                */
  
  do i = 1 to hQuery:num-buffers:
    
    hBuffer = hQuery:get-buffer-handle(i).
    
    do j = 1 to hBuffer:num-fields:
      
      hField = hBuffer:buffer-field(j).
      
      iFieldRefPos = r-index(cEditorText,
                             substitute('&1.&2':U, hBuffer:name, hField:name),
                             iStartPos).
      
      if    iFieldRefPos > 0
        and iFieldRefPos > iMaxFieldPos then
        assign
          cTableName   = hBuffer:table
          cFieldName   = hField:name
          iMaxFieldPos = iFieldRefPos
          .
      
    end. /* do j = 1 to hBuffer:num-fields */
    
  end. /* do i = 1 to hQuery:num-buffers */
  
end. /* if plFieldReference */

run qg_GetExternalReference(cTableName,
                            cFieldName,
                            plFieldReference,
                            substitute('!&1,*':U, bttQueryWindow.WindowHandle),
                            bttQueryWindow.WindowHandle,
                            output cReferenceText).

if cReferenceText > '':U then
do:
  
  assign
    iSelectionStart = (if phEditor:selection-start <> ? then
                         phEditor:selection-start
                       else
                         phEditor:cursor-offset)
    iSelectionEnd   = (if phEditor:selection-end <> ? then
                         phEditor:selection-end
                       else
                         phEditor:cursor-offset)
    .
  
  if cEditorText > '':U then
  do:
  
    if    iSelectionStart > 1
      and index('~'"':U, substring(cEditorText, iSelectionStart - 1, 1)) > 0 then
      iSelectionStart = iSelectionStart - 1.
    
    if index('~'"':U, substring(cEditorText, iSelectionEnd, 1)) > 0 then
      iSelectionEnd = iSelectionEnd + 1.
    
    if    iSelectionStart > 0
      and iSelectionEnd  >= iSelectionStart then
      phEditor:set-selection(iSelectionStart, iSelectionEnd).
  
  end. /* if cEditorText > '':U */
  
  if phEditor:selection-text > '':U then
    phEditor:replace-selection-text(cReferenceText).
  else
    phEditor:insert-string(cReferenceText).
  
end. /* cReferenceText */

end procedure. /* qg_QueryWindowInsertExternalReference */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListActivateQueryWindow hQueryWindow 
PROCEDURE qg_QueryWindowListActivateQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable hWindow as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).

if    hBuffer:available
  and hBuffer::WindowHandle:visible then
do:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = hBuffer::WindowHandle
    no-lock no-error.
  
  run qg_QueryWindowShowChildWindows(bttQueryWindow.QuerySeq).
  
  run qg_ActivateWindow(bttQueryWindow.WindowHandle, bttQueryWindow.QueryBrowseHandle).
  
end. /* if hBuffer:available */

end procedure. /* qg_QueryWindowListActivateQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListBrowseOnRowDisplay hQueryWindow 
PROCEDURE qg_QueryWindowListBrowseOnRowDisplay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phColumn as handle    no-undo.
define input parameter phBuffer as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

phColumn:fgcolor = (if not phBuffer:available then
                      ?
                    else if not phBuffer::WindowHandle:visible then
                      {&K_COLOR_LIGHT_GREY}
                    else
                      ?).

end procedure. /* qg_QueryWindowListBrowseOnRowDisplay */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListBrowsePopupMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowListBrowsePopupMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer                        as handle    no-undo.

define variable hMenu                          as handle    no-undo.

define variable hActivateMenuItem              as handle    no-undo.
define variable hMinimizeMenuItem              as handle    no-undo.
define variable hHideMenuItem                  as handle    no-undo.
define variable hCloseMenuItem                 as handle    no-undo.
define variable hMinimizeBranchMenuItem        as handle    no-undo.
define variable hHideBranchMenuItem            as handle    no-undo.
define variable hCloseBranchMenuItem           as handle    no-undo.
define variable hCloseAllMenuItem              as handle    no-undo.
define variable hOpenRelatedQueryMenuItem      as handle    no-undo.
define variable hAlwaysOnTopMenuItem           as handle    no-undo.

define variable lQueryWindowsExist             as logical   no-undo.
define variable lHasChildren                   as logical   no-undo.
define variable lIsVisible                     as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

assign
  lQueryWindowsExist = temp-table ttQueryWindow:has-records
  hBuffer            = ghQueryWindowListBrowse:query:get-buffer-handle(1)
  lHasChildren
      = (if hBuffer:available then
           can-find(first ttQueryWindowView
                      where ttQueryWindowView.ParentWindowHandle = hBuffer::WindowHandle)
         else
           no)
  lIsVisible
      = (if hBuffer:available then
           hBuffer::WindowHandle:visible
         else
           no)
  hMenu   = ghQueryWindowListBrowse:popup-menu
  hActivateMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_Activate':U)
  hActivateMenuItem:sensitive
      = lIsVisible
  hMinimizeMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_Minimize':U)
  hHideMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_Hide':U)
  hCloseMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_Close':U)
  hMinimizeBranchMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_MinimizeBranch':U)
  hHideBranchMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_HideBranch':U)
  hCloseBranchMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_CloseBranch':U)
  hCloseAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_CloseAll':U)
  hCloseAllMenuItem:sensitive
      = lQueryWindowsExist
  hOpenRelatedQueryMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_OpenRelatedQuery':U)
  hOpenRelatedQueryMenuItem:sensitive
      = hBuffer:available
  hAlwaysOnTopMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_AlwaysOnTop':U)
  hAlwaysOnTopMenuItem:sensitive
      = hBuffer:available
  .

if hBuffer:available then
  assign
    hMinimizeMenuItem:sensitive
        = lIsVisible
    hMinimizeMenuItem:label
        = (if hBuffer::WindowHandle:window-state = {&K_WINDOW_MINIMIZED} then
             'Restore':T
           else
             'Minimize':T)
    hHideMenuItem:sensitive
        = yes
    hHideMenuItem:label
        = (if hBuffer::WindowHandle:visible then
             'Hide':T
           else
             'Show':T)
    hCloseMenuItem:sensitive
        = yes
    hMinimizeBranchMenuItem:sensitive
        = lHasChildren
    hMinimizeBranchMenuItem:label
        = (if hBuffer::WindowHandle:window-state = {&K_WINDOW_MINIMIZED} then
             'Restore branch':T
           else
             'Minimize branch':T)
    hHideBranchMenuItem:sensitive
        = lHasChildren
    hHideBranchMenuItem:label
        = (if hBuffer::WindowHandle:visible then
             'Hide branch':T
           else
             'Show branch':T)
    hCloseBranchMenuItem:sensitive
        = lHasChildren
    hAlwaysOnTopMenuItem:checked
        = hBuffer::WindowHandle:always-on-top
    .
  
else
  assign
    hMinimizeMenuItem:sensitive
        = no
    hMinimizeMenuItem:label
        = 'Minimize':T
    hHideMenuItem:sensitive
        = no
    hHideMenuItem:label
        = 'Hide':T
    hCloseMenuItem:sensitive
        = no
    hMinimizeBranchMenuItem:sensitive
        = no
    hMinimizeBranchMenuItem:label
        = 'Minimize branch':U
    hHideBranchMenuItem:sensitive
        = no
    hHideBranchMenuItem:label
        = 'Hide branch':T
    hCloseBranchMenuItem:sensitive
        = no
    hAlwaysOnTopMenuItem:checked
        = no
    .

end procedure. /* qg_QueryWindowListBrowsePopupMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListCloseAllQueryWindows hQueryWindow 
PROCEDURE qg_QueryWindowListCloseAllQueryWindows :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/


/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryWindow
  on error undo, throw:
  
  if valid-handle(bttQueryWindow.WindowHandle) then
    run qg_QueryWindowClose(bttQueryWindow.WindowHandle, no).
  
  else
    delete bttQueryWindow.
  
end. /* for each bttQueryWindow */

end procedure. /* qg_QueryWindowListCloseAllQueryWindows */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListCloseQueryWindow hQueryWindow 
PROCEDURE qg_QueryWindowListCloseQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plCloseChildWindows as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable hWindow as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).

if hBuffer:available then
  run qg_QueryWindowClose(hBuffer::WindowHandle, plCloseChildWindows).
  
end procedure. /* qg_QueryWindowListCloseQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListCopyQueryScenario hQueryWindow 
PROCEDURE qg_QueryWindowListCopyQueryScenario :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

apply 'choose':U to menu-item mi_CopyQueryScenario in menu m_Edit.

end procedure. /* qg_QueryWindowListCopyQueryScenario */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListDropFileNotify hQueryWindow 
PROCEDURE qg_QueryWindowListDropFileNotify :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame    as handle    no-undo.
define variable i         as integer   no-undo.
define variable cFileName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hFrame = qg_hGetWidgetByName(ghQueryWindowListWindow, 'fQueryWindows':U).

do i = 1 to hFrame:num-dropped-files:
  
  cFileName = hFrame:get-dropped-file(i).

  if cFileName matches '*.qsc':U then
    run qg_LoadQueryScenario(cFileName, (i = 1)).

end. /* do i = 1 to hFrame:num-dropped-files */

finally:
  
  if valid-handle(hFrame) then
    hFrame:end-file-drop().
  
end finally.

end procedure. /* qg_QueryWindowListDropFileNotify */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListEditMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowListEditMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window close event of query window list window.      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hMenu                       as handle    no-undo.
define variable hCopyQueryScenarioMenuItem  as handle    no-undo.
define variable hPasetQueryScenarioMenuItem as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

assign
  hMenu                 = ghQueryWindowListWindow:menu-bar
  hCopyQueryScenarioMenuItem
      = qg_hGetWidgetByName(hMenu, 'mi_CopyQueryScenario':U)
  hCopyQueryScenarioMenuItem:sensitive
      = can-find(first ttQueryWindow)
  hPasetQueryScenarioMenuItem
      = qg_hGetWidgetByName(hMenu, 'mi_PasteQueryScenario':U)
  hPasetQueryScenarioMenuItem:sensitive
      = lookup('PRO_TEXT':U, clipboard:available-formats) > 0
  .

end procedure. /* qg_QueryWindowListEditMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListFileMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowListFileMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hMenu                      as handle    no-undo.
define variable hSaveQueryScenarioMenuItem as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

assign
  hMenu                 = ghQueryWindowListWindow:menu-bar
  hSaveQueryScenarioMenuItem
      = qg_hGetWidgetByName(hMenu, 'mi_SaveQueryScenario':U)
  hSaveQueryScenarioMenuItem:sensitive
      = can-find(first ttQueryWindow)
  .

end procedure. /* qg_QueryWindowListFileMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListHideQueryWindow hQueryWindow 
PROCEDURE qg_QueryWindowListHideQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plUpdateChildren as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable hWindow as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).

if hBuffer:available then
do:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = hBuffer::WindowHandle
    no-error.
  
  if available bttQueryWindow then
  do:
    
    run qg_QueryWindowSetVisibleState(bttQueryWindow.QuerySeq,
                                      not bttQueryWindow.WindowHandle:visible,
                                      plUpdateChildren).
    
    run qg_UpdateQueryWindowView.
    
    if ghQueryWindowListBrowse:query:num-results > 0 then
      ghQueryWindowListBrowse:refresh().
    
  end. /* if available bttQueryWindow */

end. /* if hBuffer:available */

end procedure. /* qg_QueryWindowListHideQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListLoadQueryScenario hQueryWindow 
PROCEDURE qg_QueryWindowListLoadQueryScenario :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

apply 'choose':U to menu-item mi_LoadQueryScenario in menu m_File.

end procedure. /* qg_QueryWindowListLoadQueryScenario */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListSetVisibleStates hQueryWindow 
PROCEDURE qg_QueryWindowListSetVisibleStates :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plVisible as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryWindow
  on error undo, throw:
  
  if bttQueryWindow.WindowHandle:visible <> plVisible then
    run qg_QueryWindowSetVisibleState(bttQueryWindow.QuerySeq,
                                      plVisible,
                                      no).
  
end. /* for each bttQueryWindow */

run qg_UpdateQueryWindowView.

if    valid-handle(ghQueryWindowListWindow)
  and ghQueryWindowListBrowse:query:num-results > 0 then
  ghQueryWindowListBrowse:refresh().

end procedure. /* qg_QueryWindowListSetVisibleStates */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListSetWindowStates hQueryWindow 
PROCEDURE qg_QueryWindowListSetWindowStates :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piWindowState as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable hWindow as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryWindow
  on error undo, throw:
  
  if    ( piWindowState = {&K_WINDOW_MINIMIZED}
      and bttQueryWindow.WindowHandle:window-state <> {&K_WINDOW_MINIMIZED} )
     or
        ( piWindowState <> {&K_WINDOW_MINIMIZED}
      and bttQueryWindow.WindowHandle:window-state = {&K_WINDOW_MINIMIZED} ) then
  run qg_QueryWindowSetWindowState(bttQueryWindow.QuerySeq,
                                   piWindowState,
                                   no).
  
end. /* for each bttQueryWindow */

end procedure. /* qg_QueryWindowListSetWindowStates */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListMinimizeQueryWindow hQueryWindow 
PROCEDURE qg_QueryWindowListMinimizeQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plUpdateChildren as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable hWindow as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).

if hBuffer:available then
do:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = hBuffer::WindowHandle
    no-error.
  
  if available bttQueryWindow then
    run qg_QueryWindowSetWindowState(bttQueryWindow.QuerySeq,
                                     (if bttQueryWindow.WindowHandle:window-state = {&K_WINDOW_MINIMIZED} then
                                        {&K_WINDOW_NORMAL}
                                      else
                                        {&K_WINDOW_MINIMIZED}),
                                     plUpdateChildren).
    
end. /* if hBuffer:available */

end procedure. /* qg_QueryWindowListMinimizeQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListOpenRelatedQuery hQueryWindow 
PROCEDURE qg_QueryWindowListOpenRelatedQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).

if hBuffer:available then
  run qg_QueryWindowOpenRelatedQuery(hBuffer::WindowHandle).

end procedure. /* qg_QueryWindowListOpenRelatedQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListPasteQueryScenario hQueryWindow 
PROCEDURE qg_QueryWindowListPasteQueryScenario :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

apply 'choose':U to menu-item mi_PasteQueryScenario in menu m_Edit.

end procedure. /* qg_QueryWindowListPasteQueryScenario */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListQueryWindowAlwaysOnTop hQueryWindow 
PROCEDURE qg_QueryWindowListQueryWindowAlwaysOnTop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).

if hBuffer:available then
do:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = hBuffer::WindowHandle
    no-lock no-error.
  
  bttQueryWindow.WindowHandle:always-on-top = not bttQueryWindow.WindowHandle:always-on-top.
  
end. /* if hBuffer:available */

end procedure. /* qg_QueryWindowListQueryWindowAlwaysOnTop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListRefresh hQueryWindow 
PROCEDURE qg_QueryWindowListRefresh :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hQuery        as handle    no-undo.
define variable hBuffer       as handle    no-undo.

define variable rLine         as rowid     no-undo.
define variable hWindow       as handle    no-undo.
define variable hParentWindow as handle    no-undo.


/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow     for temp-table ttQueryWindow.
define buffer bttQueryWindowView for temp-table ttQueryWindowView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_UpdateQueryWindowView.

if valid-handle(ghQueryWindowListWindow) then
do:
  
  assign
    hQuery      = ghQueryWindowListBrowse:query
    hBuffer     = hQuery:get-buffer-handle(1)
    .
  
  if hBuffer:available then
    assign
      rLine         = hBuffer:rowid
      hWindow       = hBuffer::windowHandle
      hParentWindow = hBuffer::ParentWindowHandle
      .
  
  qg_lQueryOpen(hQuery, 'for each ttQueryWindowView by Id':U, ghQueryWindowListWindow).
  
  if hWindow <> ? then
  do:
    
    find bttQueryWindowView
      where rowid(bttQueryWindowView) = rLine
      no-error.
    
    if not available bttQueryWindowView then
    do:
      
      find first bttQueryWindowView
        where bttQueryWindowView.ParentWindowHandle = hParentWindow
          and bttQueryWindowView.WindowHandle       = hWindow
        no-error.
      
      if not available bttQueryWindowView then
        find first bttQueryWindowView
          where bttQueryWindowView.WindowHandle = hWindow
          no-error.
      
    end. /* if not available bttQueryWindowView */
    
    if available bttQueryWindowView then
      hQuery:reposition-to-rowid(rowid(bttQueryWindowView)) no-error.
    
  end. /* if hWindow <> ? */
  
end. /* if valid-handle(ghQueryWindowListWindow) */

end procedure. /* qg_QueryWindowListRefresh */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListSaveQueryScenario hQueryWindow 
PROCEDURE qg_QueryWindowListSaveQueryScenario :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

apply 'choose':U to menu-item mi_SaveQueryScenario in menu m_File.

end procedure. /* qg_QueryWindowListSaveQueryScenario */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListSelectQueryWindow hQueryWindow 
PROCEDURE qg_QueryWindowListSelectQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindowView for temp-table ttQueryWindowView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    valid-handle(ghQueryWindowListWindow)
  and valid-handle(phWindow) then
do:
  
  hBuffer = ghQueryWindowListBrowse:query:get-buffer-handle(1).
  
  if   not hBuffer:available
    or hBuffer::WindowHandle <> phWindow then
  do:
    
    find first bttQueryWindowView
      where bttQueryWindowView.WindowHandle = phWindow
      no-error.
    
    if available bttQueryWindowView then
      ghQueryWindowListBrowse:query:reposition-to-rowid(rowid(bttQueryWindowView)) no-error.
    
  end. /* if   not hBuffer:available ... */
  
end. /* if valid-handle(ghQueryWindowListWindow) ... */

end procedure. /* qg_QueryWindowListSelectQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListToggleAlwaysOnTop hQueryWindow 
PROCEDURE qg_QueryWindowListToggleAlwaysOnTop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

ghQueryWindowListWindow:always-on-top = not ghQueryWindowListWindow:always-on-top.

end procedure. /* qg_QueryWindowListToggleAlwaysOnTop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListToolsMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowListToolsMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer                        as handle    no-undo.

define variable hMenu                          as handle    no-undo.

define variable hMinimizeAllMenuItem           as handle    no-undo.
define variable hRestoreAllMenuItem            as handle    no-undo.
define variable hHideAllMenuItem               as handle    no-undo.
define variable hShowAllMenuItem               as handle    no-undo.
define variable hCloseAllMenuItem              as handle    no-undo.

define variable lQueryWindowsExist             as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

assign
  lQueryWindowsExist = temp-table ttQueryWindow:has-records
  hBuffer            = ghQueryWindowListBrowse:query:get-buffer-handle(1)
  hMenu              = ghQueryWindowListWindow:menu-bar
  hMinimizeAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_MinimizeAll':U)
  hMinimizeAllMenuItem:sensitive
      = lQueryWindowsExist
  hRestoreAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_RestoreAll':U)
  hRestoreAllMenuItem:sensitive
      = lQueryWindowsExist
  hHideAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_HideAll':U)
  hHideAllMenuItem:sensitive
      = lQueryWindowsExist
  hShowAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_ShowAll':U)
  hShowAllMenuItem:sensitive
      = lQueryWindowsExist
  hCloseAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_CloseAll':U)
  hCloseAllMenuItem:sensitive
      = lQueryWindowsExist
  .

end procedure. /* qg_QueryWindowListToolsMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListWindowClose hQueryWindow 
PROCEDURE qg_QueryWindowListWindowClose :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window close event of query window list window.      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/


/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghQueryWindowListWindow) then
  run qg_DeleteWidgetTree(ghQueryWindowListWindow, yes).

end procedure. /* qg_QueryWindowListWindowClose */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListWindowMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowListWindowMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window close event of query window list window.      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hMenu                as handle    no-undo.
define variable hAlwaysOnTopMenuItem as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

assign
  hMenu                 = ghQueryWindowListWindow:menu-bar
  hAlwaysOnTopMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_AlwaysOnTop':U)
  hAlwaysOnTopMenuItem:checked
      = ghQueryWindowListWindow:always-on-top
  .

end procedure. /* qg_QueryWindowListWindowMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowListWindowResize hQueryWindow 
PROCEDURE qg_QueryWindowListWindowResize :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window resize event of query window list window.     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghQueryWindowListWindow) then
  leave.

assign
  ghQueryWindowListWindow:width     = max(20, ghQueryWindowListWindow:width)
  ghQueryWindowListWindow:height    = max(3, ghQueryWindowListWindow:height)
  hFrame                            = qg_hGetWidgetByName(ghQueryWindowListWindow,
                                                          'fQueryWindows':U)
  hFrame:width                      = ghQueryWindowListWindow:width
  hFrame:virtual-width              = ghQueryWindowListWindow:width
  hFrame:height                     = ghQueryWindowListWindow:height
  hFrame:virtual-height             = ghQueryWindowListWindow:height
  ghQueryWindowListBrowse:width     = hFrame:width
  ghQueryWindowListBrowse:height    = hFrame:height
  .

end procedure. /* qg_QueryWindowListWindowResize */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowMoveColumn hQueryWindow 
PROCEDURE qg_QueryWindowMoveColumn :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Move field column to first column.                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plFirst                        = If yes the field will be moved to the     */
/*                                  first column. Otherwise it will be moved  */
/*                                  to the last column.                       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter plFirst  as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFieldSelectionBuffer as handle    no-undo.
define variable hColumn               as handle    no-undo.
define variable iSelection            as integer   no-undo.
define variable iColumn               as integer   no-undo.

define variable cFieldName            as character no-undo.
define variable cColumnName           as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

define buffer bttFieldOverlay for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hFieldSelectionBuffer = bttQueryWindow.QueryFieldBrowseBufferHandle.

if plFirst then
do:

  do iSelection = bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows to 1 by -1:
    
    bttQueryWindow.QueryFieldBrowseHandle:fetch-selected-row(iSelection).
    
    cFieldName = qg_cFormattedFieldName(?,
                                        hFieldSelectionBuffer::BufferName,
                                        hFieldSelectionBuffer::FieldName,
                                        hFieldSelectionBuffer::FieldIndex).
    
    do iColumn = 1 to bttQueryWindow.QueryBrowseHandle:num-columns:
      
      hColumn = bttQueryWindow.QueryBrowseHandle:get-browse-column(iColumn).
      
      find first bttFieldOverlay
        where bttFieldOverlay.OwnerHandle         = bttQueryWindow.QueryHandle
          and bttFieldOverlay.OverlayColumnHandle = hColumn
        no-error.
      
      if    available bttFieldOverlay
        and valid-handle(bttFieldOverlay.ColumnHandle)
        and not bttFieldOverlay.ColumnHandle:visible then
        hColumn = bttFieldOverlay.ColumnHandle.

      cColumnName = qg_cColumnFieldName(hColumn, yes).
        
      if cColumnName = cFieldName then
      do:
        
        bttQueryWindow.QueryBrowseHandle:move-column(iColumn, 1).
        leave.
        
      end. /* if cColumnName = cFieldName */
      
    end. /* do iColumn = 1 to bttQueryWindow.QueryBrowseHandle:num-columns */
      
  end. /* do iSelection = bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows to 1 by -1 */

end. /* if plFirst */

else
do:
  
  do iSelection = 1 to bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows:
    
    bttQueryWindow.QueryFieldBrowseHandle:fetch-selected-row(iSelection).
    
    cFieldName = qg_cFormattedFieldName(?,
                                        hFieldSelectionBuffer::BufferName,
                                        hFieldSelectionBuffer::FieldName,
                                        hFieldSelectionBuffer::FieldIndex).
    
    do iColumn = 1 to bttQueryWindow.QueryBrowseHandle:num-columns:
      
      hColumn = bttQueryWindow.QueryBrowseHandle:get-browse-column(iColumn).
      
      find first bttFieldOverlay
        where bttFieldOverlay.OwnerHandle         = bttQueryWindow.QueryHandle
          and bttFieldOverlay.OverlayColumnHandle = hColumn
        no-error.
      
      if    available bttFieldOverlay
        and valid-handle(bttFieldOverlay.ColumnHandle)
        and not bttFieldOverlay.ColumnHandle:visible then
        hColumn = bttFieldOverlay.ColumnHandle.

      cColumnName = qg_cColumnFieldName(hColumn, yes).
        
      if cColumnName = cFieldName then
      do:
        
        bttQueryWindow.QueryBrowseHandle:move-column(iColumn, bttQueryWindow.QueryBrowseHandle:num-columns).
        leave.
        
      end. /* if cColumnName = cFieldName */
      
    end. /* do iColumn = 1 to bttQueryWindow.QueryBrowseHandle:num-columns */
    
  end. /* do iSelection = bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows to 1 by -1 */
  
end. /* else: if plFirst */

end procedure. /* qg_QueryWindowMoveColumn */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjectIdOverlay hQueryWindow 
PROCEDURE qg_QueryWindowObjectIdOverlay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lHidden                 as logical   no-undo.
define variable lSuggestions            as logical   no-undo.
define variable lSelected               as logical   no-undo.

define variable cField_Key              as character no-undo.
define variable cField_Label            as character no-undo.
define variable cAvailableColumn_Keys   as character no-undo.
define variable cAvailableColumn_Labels as character no-undo.
define variable cSelectedColumn_Keys    as character no-undo.
define variable lOk                     as logical   no-undo.

define variable i                       as integer   no-undo.

define variable cDatabaseName           as character no-undo.
define variable cBufferName             as character no-undo.
define variable cFieldName              as character no-undo.
define variable iFieldIndex             as integer   no-undo.
define variable cNewOverlayFields       as character no-undo.

define variable cOverlayFieldName       as character no-undo.
define variable cFieldOrder             as character no-undo.
define variable cColumns                as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttField            for temp-table ttField.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.
define buffer bttFieldOverlay     for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if    not available bttQueryWindow
   or not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

/* Show field overlay selection dialog. */

lSuggestions = not can-find(first ttFieldOverlay
                              where ttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle).

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
    and bttQueryWindowField.IsOverlay    = no
  on error undo, throw:
  
  if lookup(bttQueryWindowField.DataType, 'CHARACTER,LONGCHAR':U) = 0 then
    next.
  
  assign
    lSelected               = (if not lSuggestions then
                                 can-find(ttFieldOverlay
                                            where ttFieldOverlay.OwnerHandle  = bttQueryWindow.QueryHandle
                                              and ttFieldOverlay.BufferName   = bttQueryWindowField.BufferName
                                              and ttFieldOverlay.FieldName    = bttQueryWindowField.FieldName
                                              and ttFieldOverlay.FieldIndex   = bttQueryWindowField.FieldIndex)
                               else
                                       ( bttQueryWindowField.FieldName matches '*_Obj':U
                                      or bttQueryWindowField.isObjectId )
                                   and not bttQueryWindowField.FieldName matches substitute('&1_Obj':U, bttQueryWindowField.TableName))
    cField_Key              = qg_cFormattedFieldName(?,
                                                     bttQueryWindowField.BufferName,
                                                     bttQueryWindowField.FieldName,
                                                     bttQueryWindowField.FieldIndex)
    cAvailableColumn_Keys   = substitute('&1,&2':U, cAvailableColumn_Keys, cField_Key)
    cField_Label            = qg_cFormattedFieldName(?,
                                                     (if    valid-handle(bttQueryWindow.QueryBrowseHandle)
                                                        and bttQueryWindow.QueryHandle:num-buffers > 1 then
                                                        bttQueryWindowField.BufferName
                                                      else
                                                        ?),
                                                     bttQueryWindowField.FieldName,
                                                     bttQueryWindowField.FieldIndex)
    cAvailableColumn_Labels = substitute('&1,&2':U,
                                         cAvailableColumn_Labels,
                                         (if   lSuggestions
                                            and lSelected then
                                            substitute('&1 *':U, cField_Label)
                                          else
                                            cField_Label))
    .
  
  if lSelected then
    cSelectedColumn_Keys = substitute('&1,&2':U, cSelectedColumn_Keys, cField_Key).
  
end. /* for each bttQueryWindowField */

assign
  cAvailableColumn_Keys   = trim(cAvailableColumn_Keys, ',':U)
  cAvailableColumn_Labels = trim(cAvailableColumn_Labels, ',':U)
  cSelectedColumn_Keys    = trim(cSelectedColumn_Keys, ',':U)
  .

run qg_SelectionDialog(cAvailableColumn_Keys,
                       cAvailableColumn_Labels,
                       input-output cSelectedColumn_Keys,
                       'Select overlay columns':T,
                       bttQueryWindow.WindowHandle,
                       no,
                       output lOk).

if lOk then
do on error undo, throw:
  
  cFieldOrder = qg_cQueryWindowFieldList(bttQueryWindow.WindowHandle,
                                         yes,
                                         no).
  
  if valid-handle(bttQueryWindow.QueryFrameHandle) then
    assign
      lHidden                                 = bttQueryWindow.QueryBrowseHandle:hidden
      bttQueryWindow.QueryBrowseHandle:hidden = yes
      cColumns                                = qg_cBrowseColumnList( bttQueryWindow.QueryBrowseHandle,
                                                                      yes,
                                                                      no,
                                                                      yes )
      .
  
  /* Remove field overlay entries that are no longer selected. */
  
  for each bttFieldOverlay
    where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
    no-lock
    on error undo, throw:
    
    if lookup(qg_cFormattedFieldName(?,
                                     bttFieldOverlay.BufferName,
                                     bttFieldOverlay.FieldName,
                                     bttFieldOverlay.FieldIndex),
              cSelectedColumn_Keys) > 0 then
      next.
    
    assign
      cFieldName        = qg_cFormattedFieldName(?,
                                                 bttFieldOverlay.BufferName,
                                                 bttFieldOverlay.FieldName,
                                                 bttFieldOverlay.FieldIndex)
      cOverlayFieldName = substitute({&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                     cFieldName)
      cFieldOrder       = qg_cReplaceColumn(cFieldOrder,
                                            cOverlayFieldName,
                                            cFieldName)
      .
    
    if    valid-handle(bttQueryWindow.QueryFrameHandle)
      and valid-handle(bttFieldOverlay.ColumnHandle)
      and valid-handle(bttFieldOverlay.OverlayColumnhandle)
      and not bttFieldOverlay.ColumnHandle:visible then
      
      cColumns = qg_cReplaceColumn(cColumns,
                                   cFieldName,
                                   cOverlayFieldName).
    
    run qg_DeleteFieldOverlay(bttFieldOverlay.OwnerHandle,
                              bttFieldOverlay.BufferName,
                              bttFieldOverlay.FieldName,
                              bttFieldOverlay.FieldIndex).
      
  end. /* for each bttFieldOverlay */
  
  /* Create field overlay entries for all selected fields. */
  
  do i = 1 to num-entries(cSelectedColumn_Keys):
    
    run qg_SplitFieldName(entry(i, cSelectedColumn_Keys),
                          output cDatabaseName,
                          output cBufferName,
                          output cFieldName,
                          output iFieldIndex).
    
    find bttQueryWindowField
      where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
        and bttQueryWindowField.BufferName   = cBufferName
        and bttQueryWindowField.FieldName    = cFieldName
        and bttQueryWindowField.FieldIndex   = iFieldIndex
      no-error.
    
    if not available bttQueryWindowField then
      next.
    
    find bttFieldOverlay
      where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
        and bttFieldOverlay.BufferName  = bttQueryWindowField.BufferName
        and bttFieldOverlay.FieldName   = bttQueryWindowField.FieldName
        and bttFieldOverlay.FieldIndex  = bttQueryWindowField.FieldIndex
      no-error.
    
    if not available bttFieldOverlay then
    do:
      
      create bttFieldOverlay.
      
      assign
        bttFieldOverlay.OwnerHandle  = bttQueryWindow.QueryHandle
        bttFieldOverlay.DatabaseName = bttQueryWindowField.DatabaseName
        bttFieldOverlay.BufferName   = bttQueryWindowField.BufferName
        bttFieldOverlay.FieldName    = bttQueryWindowField.FieldName
        bttFieldOverlay.FieldIndex   = bttQueryWindowField.FieldIndex
        .
      
      validate bttFieldOverlay.
      
      cNewOverlayFields = substitute('&1,&2':U,
                                     cNewOverlayFields,
                                     string(rowid(bttFieldOverlay))).
      
    end. /* if not available bttFieldOverlay */
    
  end. /* do i = 1 to num-entries(cSelectedColumn_Keys) */
  
  cNewOverlayFields = trim(cNewOverlayFields, ',':U).
  
  /* Update window field temp-table. */
  
  do i = 1 to num-entries(cNewOverlayFields):
    
    find bttFieldOverlay
      where rowid(bttFieldOverlay) = to-rowid(entry(i, cNewOverlayFields))
      no-error.
    
    if not available bttFieldOverlay then
      next.
    
    assign
      cFieldName        = qg_cFormattedFieldName(?,
                                                 bttFieldOverlay.BufferName,
                                                 bttFieldOverlay.FieldName,
                                                 bttFieldOverlay.FieldIndex)
      cOverlayFieldName = substitute({&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                     cFieldName)
      cFieldOrder       = qg_cReplaceColumn(cFieldOrder,
                                            cFieldName,
                                            cOverlayFieldName)
      .
    
    if valid-handle(bttQueryWindow.QueryFrameHandle) then
      cColumns = qg_cReplaceColumn(cColumns,
                                   cFieldName,
                                   cOverlayFieldName).
    
  end. /* for each bttFieldOverlay */
  
  run qg_QueryWindowUpdateFieldTempTable(bttQueryWindow.QueryHandle,
                                         bttQueryWindow.WindowHandle,
                                         cFieldOrder).

  /* Update browse columns (if necessary). */
  
  if valid-handle(bttQueryWindow.QueryFrameHandle) then
  do:
    
    /* For some reason deleting query buffers also removes the query from the */
    /* query browse handle. Due to this we have to set it again.              */
    
    bttQueryWindow.QueryBrowseHandle:query = bttQueryWindow.QueryHandle.

    run qg_QueryWindowQueryOpenFieldQuery(bttQueryWindow.WindowHandle).

    run qg_QueryWindowRefreshBrowseColumns(bttQueryWindow.WindowHandle).
    run qg_SetBrowseColumns(bttQueryWindow.QueryBrowseHandle, cColumns).
    
  end. /* if valid-handle(bttQueryWindow.QueryFrameHandle) */
  
  if valid-handle(bttQueryWindow.RecordFrameHandle) then
  do:
    
    run qg_QueryWindowRecordOpenQuery(bttQueryWindow.WindowHandle).
    run qg_QueryWindowRecordRefresh(bttQueryWindow.WindowHandle).
    
  end. /* if valid-handle(bttQueryWindow.RecordFrameHandle) */
  
  finally:
    
    if valid-handle(bttQueryWindow.QueryFrameHandle) then
      bttQueryWindow.QueryBrowseHandle:hidden = lHidden.
    
  end finally.
  
end. /* if lOk */

end procedure. /* qg_QueryWindowObjectIdOverlay */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjSelectionBrowseClick hQueryWindow 
PROCEDURE qg_QueryWindowObjSelectionBrowseClick :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hCurrentWindow as handle    no-undo.

define variable hBrowse        as handle    no-undo.
define variable hBuffer        as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow:parent
  no-error.

if not available bttQueryWindow then
  leave.

assign
  hCurrentWindow = current-window
  current-window = bttQueryWindow.WindowHandle
  hBrowse        = qg_hGetWidgetByName(phWindow, 'brObjField':U)
  .

if not valid-handle(hBrowse) then
  leave.

hBuffer = hBrowse:query:get-buffer-handle(1).

if    valid-handle(hBuffer)
  and hBuffer:available then
do:
  
  assign
    bttQueryWindow.ObjSourceBufferName = hBuffer::BufferName
    bttQueryWindow.ObjSourceFieldName  = hBuffer::FieldName
    bttQueryWindow.ObjSourceFieldIndex = hBuffer::FieldIndex
    .
  
  run qg_QueryWindowObjUpdateObjFieldText(bttQueryWindow.WindowHandle).
  
  run qg_QueryWindowObjUpdateQuery(bttQueryWindow.WindowHandle).
  
  run qg_QueryWindowUpdateAll('':U).
  
end. /* if    valid-handle(hBuffer) */

apply 'window-close':U to phWindow.

finally:
  
  if valid-handle(hCurrentWindow) then
    current-window = hCurrentWindow.
  
end finally.

end procedure. /* qg_QueryWindowObjSelectionBrowseClick */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjSelectionBrowseRowDisplay hQueryWindow 
PROCEDURE qg_QueryWindowObjSelectionBrowseRowDisplay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBrowse  as handle    no-undo.
define variable hBuffer  as handle    no-undo.

define variable i        as integer   no-undo.
define variable cColList as character no-undo.
define variable hColumn  as handle    no-undo.
define variable iColor   as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow:parent
  no-error.

if not available bttQueryWindow then
  leave.

hBrowse = qg_hGetWidgetByName(phWindow, 'brObjField':U).

if not valid-handle(hBrowse) then
  leave.

assign
  cColList = qg_cParamListReadValue(hBrowse:private-data,
                                    'ColList':U,
                                    ',':U)
  hBuffer  = handle(qg_cParamListReadValue(hBrowse:private-data,
                                           'Buffer':U,
                                           ',':U))
  .

iColor = (if    not valid-handle(hBuffer)
             or not hBuffer:available then
            {&K_COLOR_LIGHT_GREY}
          /*
          else if hBuffer::IsVirtual then
            {&K_VIRTUAL_DB_FIELD_FGCOLOR}
          */
          else if hBuffer::ContainsObj then
            ?
          else if hBuffer::IsObjectId then
            {&K_COLOR_DARK_GREY}
          else
            {&K_COLOR_LIGHT_GREY}).

do i = 1 to num-entries(cColList, '|':U):
  
  assign
    hColumn         = handle(entry(i, cColList, '|':U))
    hColumn:fgcolor = iColor
    .
  
end. /* do i = 1 to num-entries(cColList, '|':U) */

end procedure. /* qg_QueryWindowObjSelectionBrowseRowDisplay */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjSelectionWindowClose hQueryWindow 
PROCEDURE qg_QueryWindowObjSelectionWindowClose :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hParentWindow as handle    no-undo.
define variable hButton       as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  hParentWindow = phWindow:parent
  hButton       = qg_hGetWidgetByName(hParentWindow,
                                      'btnSelectObjField':U)
  .

run qg_DeleteWidgetTree(phWindow, yes).

if valid-handle(hButton) then
  hButton:sensitive = yes.

apply 'entry':U to hParentWindow.

end procedure. /* qg_QueryWindowObjSelectionWindowClose */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjSelectObjField hQueryWindow 
PROCEDURE qg_QueryWindowObjSelectObjField :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hTemp      as handle    no-undo.
define variable hButton    as handle    no-undo.

define variable hWindow    as handle    no-undo.
define variable hFrame     as handle    no-undo.
define variable hBrowse    as handle    no-undo.

define variable hQuery     as handle    no-undo.
define variable hBuffer    as handle    no-undo.

define variable cQueryText as character no-undo.

define variable i          as integer   no-undo.
define variable cColList   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow         for temp-table ttQueryWindow.

define buffer bttQueryWindowObjField for temp-table ttQueryWindowObjField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hButton = qg_hGetWidgetByName(bttQueryWindow.RecordFrameHandle,
                              'btnSelectObjField':U).

if not valid-handle(hButton) then
  leave.

create window hWindow
  assign
    hidden          = yes
    width           = 64
    max-width       = 1024
    height          = 15
    max-height      = 1024
    scroll-bars     = no
    status-area     = no
    three-d         = yes
    message-area    = no
    control-box     = no
    small-title     = yes
    show-in-taskbar = no
    top-only        = yes
    sensitive       = yes
    resize          = no
    parent          = bttQueryWindow.WindowHandle
    title           = substitute('&1Select object id field':U, gcTitlePrefix)
  triggers:
    
    on leave
      persistent run qg_QueryWindowObjSelectionWindowClose in target-procedure
                       (hWindow).
    
    on window-close
      persistent run qg_QueryWindowObjSelectionWindowClose in target-procedure
                       (hWindow).
    
  end triggers
  .

create frame hFrame
  assign
    name           = 'fObjField':U
    box            = no
    three-d        = yes
    width          = hWindow:width
    virtual-width  = hWindow:width
    height         = hWindow:height
    virtual-height = hWindow:height
    sensitive      = yes
    parent         = hWindow
    .

create browse hBrowse
  assign
    name                   = 'brObjField':U
    frame                  = hFrame
    width                  = hFrame:width - 2
    height                 = hFrame:height - 0.5
    row                    = 1.25
    col                    = 2
    read-only              = yes
    row-markers            = no
    allow-column-searching = no
  triggers:
    
    on mouse-select-click
      persistent run qg_QueryWindowObjSelectionBrowseClick in target-procedure
                       (hWindow).
    
    on row-display
      persistent run qg_QueryWindowObjSelectionBrowseRowDisplay in target-procedure
                       (hWindow).
      
    
  end triggers
  .

run qg_InitBrowse(hBrowse).

run qg_DropDownWindow(hWindow, hButton, {&K_DIRECTION_RIGHT}).

create query hQuery.

create buffer hBuffer for table 'ttQueryWindowObjField':U.

hQuery:set-buffers(hBuffer).

run qg_QueryWindowObjUpdateFieldList(bttQueryWindow.WindowHandle).

assign
  cQueryText =            'for each ttQueryWindowObjField':U
               + '~n':U + '  where ttQueryWindowObjField.WindowHandle = &1':U
               + '~n':U + '  use-index priority':U
  cQueryText = substitute(cQuerytext, quoter(bttQueryWindow.WindowHandle))
  .

assign
  hButton:sensitive = no
  hWindow:hidden    = no
  hFrame:hidden     = no
  .

hBrowse:query = hQuery.

assign
  hTemp       = hBrowse:add-like-column('ttQueryWindowObjField.BufferName':U)
  hTemp:width = 25
  cColList    = string(hTemp) 
  hTemp       = hBrowse:add-like-column('ttQueryWindowObjField.DisplayName':U)
  hTemp:width = 32
  cColList    = substitute('&1|&2':U, cColList, string(hTemp))
  hTemp       = hBrowse:add-like-column('ttQueryWindowObjField.TargetTableName':U)
  hTemp:width = 25
  cColList    = substitute('&1|&2':U, cColList, string(hTemp))
  .

assign
  hBrowse:labels          = no
  hBrowse:fit-last-column = yes
  hBrowse:private-data    = qg_cParamListWriteCharacter(hBrowse:private-data,
                                                        'ColList':U,
                                                        cColList,
                                                        ',':U)
  hBrowse:private-data    = qg_cParamListWriteCharacter(hBrowse:private-data,
                                                        'Buffer':U,
                                                        string(hBuffer),
                                                        ',':U)
  .

qg_lQueryOpen(hQuery, cQueryText, hWindow).

find bttQueryWindowObjField
  where bttQueryWindowObjField.WindowHandle = bttQueryWindow.WindowHandle
    and bttQueryWindowObjField.BufferName   = bttQueryWindow.ObjSourceBufferName
    and bttQueryWindowObjField.FieldName    = bttQueryWindow.ObjSourceFieldName
    and bttQueryWindowObjField.FieldIndex   = bttQueryWindow.ObjSourceFieldIndex
  no-error.

if available bttQueryWindowObjField then
  hQuery:reposition-to-rowid(rowid(bttQueryWindowObjField)).

apply 'value-changed':U to hBrowse.
apply 'entry':U to hBrowse.

end procedure. /* qg_QueryWindowObjSelectObjField */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjUpdateObjFieldText hQueryWindow 
PROCEDURE qg_QueryWindowObjUpdateObjFieldText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cObjFieldLabel as character no-undo.

define variable hObjFieldText  as handle    no-undo.
define variable hRefreshButton as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  hRefreshButton             = qg_hGetWidgetByName(bttQueryWindow.RecordFrameHandle,
                                                   'btnRefresh':U)
  hObjFieldText              = qg_hGetWidgetByName(bttQueryWindow.RecordFrameHandle,
                                                   'cObjField':U)
  cObjFieldLabel             = qg_cFormattedFieldName(?,
                                                      bttQueryWindow.ObjSourceBufferName,
                                                      bttQueryWindow.ObjSourceFieldName,
                                                      bttQueryWindow.ObjSourceFieldIndex)
  hObjFieldText:screen-value = cObjFieldLabel
  hObjFieldText:width        = max(10, font-table:get-text-width-chars(cObjFieldLabel))
  hRefreshButton:col         = hObjFieldText:col + hObjFieldText:width + 5
  no-error.

end procedure. /* qg_QueryWindowObjUpdateObjFieldText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjUpdateQuery hQueryWindow 
PROCEDURE qg_QueryWindowObjUpdateQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer            as handle    no-undo.
define variable hField             as handle    no-undo.
define variable cDatabaseName      as character no-undo.
define variable cTableName         as character no-undo.
define variable lObjectId          as logical   no-undo.
define variable cFieldValue        as character no-undo.
define variable cTableRef          as character no-undo.
define variable cTables            as character no-undo.

define variable hObFieldText       as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow         for temp-table ttQueryWindow.
define buffer bttQueryWindowObjField for temp-table ttQueryWindowObjField.

define buffer b2ttQueryWindow        for temp-table ttQueryWindow.
define buffer bttDatabase            for temp-table ttDatabase.
define buffer bttTable               for temp-table ttTable.
define buffer bttField               for temp-table ttField.

define buffer bttQueryLink           for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

find b2ttQueryWindow
  where b2ttQueryWindow.QuerySeq = bttQueryWindow.ObjSourceQuerySeq
  no-error.

if   not available b2ttQueryWindow
  or not valid-handle(b2ttQueryWindow.QueryHandle) then
  leave.

hBuffer = b2ttQueryWindow.QueryHandle:get-buffer-handle(bttQueryWindow.ObjSourceBufferName) no-error.

if valid-handle(hBuffer) then
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).

else
do:
  
  run qg_QueryWindowObjUpdateFieldList(bttQueryWindow.WindowHandle).
  
  find first bttQueryWindowObjField
    where bttQueryWindowObjField.WindowHandle = bttQueryWindow.WindowHandle
    use-index Priority
    no-error.
  
  if not available bttQueryWindowObjField then
    leave.
  
  hBuffer = b2ttQueryWindow.QueryHandle:get-buffer-handle(bttQueryWindowObjField.BufferName) no-error.
  
  if not valid-handle(hBuffer) then
    
    leave.
  
  assign
    cDatabaseName                      = bttQueryWindowObjField.DatabaseName
    bttQueryWindow.ObjSourceBufferName = bttQueryWindowObjField.BufferName
    bttQueryWindow.ObjSourceFieldName  = bttQueryWindowObjField.FieldName
    bttQueryWindow.ObjSourceFieldIndex = bttQueryWindowObjField.FieldIndex
    bttQueryWindow.ObjTargetTableId    = '':U
    bttQueryWindow.ObjTargetTableName  = '':U
    .
    
  if valid-handle(bttQueryWindow.RecordFrameHandle) then
    
    run qg_QueryWindowObjUpdateObjFieldText(bttQueryWindow.WindowHandle).

end. /* else: if valid-handle(hBuffer) */

find bttDatabase
  where bttDatabase.DatabaseName = cDatabaseName
  no-error.

if not available bttDatabase then
  find bttDatabase
    where bttDatabase.DatabaseName = hBuffer:dbname
    no-error.

if not available bttDatabase then
  leave.

if hBuffer:available then
do:
  
  hField = hBuffer:buffer-field( bttQueryWindow.ObjSourceFieldName ) no-error.
  
  if valid-handle( hField ) then
    
    cFieldValue = hField:buffer-value( bttQueryWindow.ObjSourceFieldIndex ) no-error.
  
  else
    
    if qg_lIsPhysicalDatabase( hBuffer:dbname ) then
    do:
      
      find bttField
        where bttField.DatabaseName = cDatabaseName
          and bttField.TableName    = hBuffer:table
          and bttField.FieldName    = bttQueryWindow.ObjSourceFieldName
        no-error.
      
      if    available bttField
        and bttField.IsVirtual then
        
        cFieldValue = qg_clVirtualFieldValueAsLongchar( bttField.FieldType,
                                                        bttField.DataType,
                                                        bttField.FieldName,
                                                        qg_cObjectIdForBuffer( hBuffer ),
                                                        ? ).
      
    end. /* if qg_lIsPhysicalDatabase( cDatabaseName ) */
    
end. /* if hBuffer:available */

assign
  lObjectId =     length(cFieldValue)            <= 50
              and num-entries(cFieldValue, ':':U) = 3
  cTableRef = (if lObjectId then
                 entry(1, cFieldValue, ':':U)
               else if bttQueryWindow.ObjSourceFieldName matches '*_Obj':U then
                 substring(bttQueryWindow.ObjSourceFieldName,
                           1,
                           length(bttQueryWindow.ObjSourceFieldName) - 4)
               else
                 '':U)
  .

if    (     lObjectId
        and cTableRef <> bttQueryWindow.ObjTargetTableId )
   or (     not lObjectId
        and cTableRef <> bttQueryWindow.ObjTargetTableName )
   or not valid-handle(bttQueryWindow.QueryHandle) then
do:
  
  run qg_GetObjectIdTable(bttDatabase.DatabaseName,
                          (if lObjectId then
                             cFieldValue
                           else
                             bttQueryWindow.ObjSourceFieldName),
                          output cDatabaseName,
                          output cTableName).
  
  find bttTable
    where bttTable.DatabaseName = cDatabaseName
      and bttTable.TableName    = cTableName
    no-error.
  
  if not available bttTable then
    assign
      bttQuerywindow.ObjTargetTableId   = '':U
      bttQuerywindow.ObjTargetTableName = '':U
      bttQueryWindow.QueryText          = '':U
      cTables                           = '':U
      .
    
  else
    assign
      bttQuerywindow.ObjTargetTableId   = bttTable.InternalIdentifier
      bttQuerywindow.ObjTargetTableName = bttTable.TableName
      bttQueryWindow.QueryText          = substitute('for each &1~n  where &1.&1_Obj = &2':U,
                                                     bttTable.TableName,
                                                     substitute('$~{&1:&2~}':U,
                                                               string(bttQueryWindow.ObjSourceQuerySeq),
                                                               qg_cFormattedFieldName(?,
                                                                                      bttQueryWindow.ObjSourceBufferName,
                                                                                      bttQueryWindow.ObjSourceFieldName,
                                                                                      bttQueryWindow.ObjSourceFieldIndex)))
      cTables = substitute('&1.&2':U,
                           bttTable.DatabaseName,
                           bttTable.TableName)
      .
  
  validate bttQuerywindow.
  
  if valid-handle(bttQueryWindow.QueryFrameHandle) then
    bttQueryWindow.QueryTextEditorHandle:screen-value = bttQueryWindow.QueryText.
  
  run qg_QueryWindowUpdateQuery(bttQueryWindow.WindowHandle, cTables).
  
  run qg_ParseQueryLinks(bttQueryWindow.QueryText,
                         bttQueryWindow.QuerySeq,
                         temp-table ttQueryLink:handle).
  
  if not can-find(first ttQueryLink
                    where ttQueryLink.TargetSeq = bttQueryWindow.QuerySeq
                      and ttQueryLink.SourceSeq = b2ttQueryWindow.QuerySeq) then
  do:
    
    create bttQueryLink.
    
    assign
      bttQueryLink.TargetSeq = bttQueryWindow.QuerySeq
      bttQueryLink.SourceSeq = b2ttQueryWindow.QuerySeq
      .
    
    validate bttQueryLink.
    
  end. /* if not can-find(first ttQueryLink */
  
  run qg_QueryWindowListRefresh.
  
end. /* if cTableRef <> bttQueryWindow.ObjTargetTableId */

end procedure. /* qg_QueryWindowObjUpdateQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowObjUpdateFieldList hQueryWindow 
PROCEDURE qg_QueryWindowObjUpdateFieldList :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iQueryBufferCounter as integer   no-undo.
define variable iFieldCounter       as integer   no-undo.
define variable iFieldIndexCounter  as integer   no-undo.
define variable hBuffer             as handle    no-undo.
define variable hField              as handle    no-undo.

define variable cDatabaseName       as character no-undo.
define variable clFieldValue        as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow         for temp-table ttQueryWindow.

define buffer b2ttQueryWindow        for temp-table ttQueryWindow.
define buffer bttQueryWindowObjField for temp-table ttQueryWindowObjField.
define buffer bttField               for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttQueryWindowObjField
  where bttQueryWindowObjField.WindowHandle = bttQueryWindow.WindowHandle
  on error undo, throw:
  
  delete bttQueryWindowObjField.
  
end. /* for each bttQueryWindowObjField */

find b2ttQueryWindow
  where b2ttQueryWindow.QuerySeq = bttQueryWindow.ObjSourceQuerySeq
  no-error.

if   not available b2ttQueryWindow
  or not valid-handle(b2ttQueryWindow.QueryHandle) then
  leave.

do iQueryBufferCounter = 1 to b2ttQueryWindow.QueryHandle:num-buffers:
  
  assign
    hBuffer       = b2ttQueryWindow.QueryHandle:get-buffer-handle(iQueryBufferCounter)
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
    .
  
  do iFieldCounter = 1 to hBuffer:num-fields:
    
    hField = hBuffer:buffer-field( iFieldCounter ).
    
    if not hField:data-type = 'CHARACTER':U then
      
      next.
    
    do iFieldIndexCounter = integer(hField:extent > 0) to hField:extent:
      
      run qg_AddFieldToQueryWindowObjFieldTempTable( buffer bttQueryWindow,
                                                     cDatabaseName,
                                                     hBuffer:name,
                                                     hBuffer:table,
                                                     hField:name,
                                                     iFieldIndexCounter,
                                                     ( if hBuffer:available then
                                                         hField:string-value( iFieldIndexCounter )
                                                       else
                                                         ? ) ).
      
      validate bttQueryWindowObjField.
      
    end. /* do iFieldIndexCounter = integer(hField:extent > 0) to hField:extent */
    
  end. /* do iFieldCounter = 1 to hBuffer:num-fields */
  
  if qg_lIsPhysicalDatabase( hBuffer:dbname ) then
    
    for each bttField
      where bttField.DatabaseName = cDatabaseName
        and bttField.TableName    = hBuffer:table
        and bttField.IsVirtual    = yes
      on error undo, throw:
      
      clFieldValue = qg_clVirtualFieldValueAsLongchar( bttField.FieldType,
                                                       bttField.DataType,
                                                       bttField.FieldName,
                                                       qg_cObjectIdForBuffer( hBuffer ),
                                                       ? ).
      
      run qg_AddFieldToQueryWindowObjFieldTempTable( buffer bttQueryWindow,
                                                     bttField.DatabaseName,
                                                     hBuffer:name,
                                                     bttField.TableName,
                                                     bttField.FieldName,
                                                     0,
                                                     string( clFieldValue ) ).
      
    end. /* for each bttField */  
  
end. /* do iQueryBufferCounter = 1 to b2ttQueryWindow.QueryHandle:num-buffers */

end procedure. /* qg_QueryWindowObjUpdateFieldList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowOpenObjectFieldValues hQueryWindow 
PROCEDURE qg_QueryWindowOpenObjectFieldValues :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow   as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cParamList as character no-undo.
define variable iQuerySeq  as integer   no-undo init ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

cParamList = qg_cParamListWriteInteger(cParamList,
                                       'ObjSourceQuerySeq':U,
                                       bttQueryWindow.QuerySeq,
                                       {&K_PARAM_SPLITTER}).

run qg_ExecQuery({&K_QUERY_WINDOW_MODE_RECORD},
                 {&K_RECORD_SIZE_MODE_DEFAULT},
                 ?,
                 ?,
                 no,  /* Init mode */
                 cParamList,
                 input-output iQuerySeq).

end procedure. /* qg_QueryWindowOpenObjectFieldValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowOpenRelatedQuery hQueryWindow 
PROCEDURE qg_QueryWindowOpenRelatedQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer       as handle    no-undo.
define variable cDatabaseName as character no-undo.

define variable iFilterId     as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow       for temp-table ttQueryWindow.

define buffer bttTableRelationView for temp-table ttTableRelationView.
define buffer bttFilterMatch       for temp-table ttFilterMatch.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

define query brTableRelation
  for bttTableRelationView,bttFilterMatch
  scrolling.

define browse brTableRelation
  query brTableRelation no-lock
    display
      bttTableRelationView.RelatedTableName
      bttTableRelationView.RelationType width 8
      bttTableRelationView.ReferenceFields
      with no-assign fit-last-column size 96 by 16.

define variable cFilter as character no-undo
  format 'x(1024)':U
  view-as fill-in
  tooltip "Filter for related tables that match given name pattern (comma separated)"
  size 89 by 1.

define button btnClearFilter
  label '':T
  tooltip "Clear filter"
  size 7 by 1.

define variable cRelationFields as character no-undo
  format 'x(1024)':U
  view-as fill-in
  size 96 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Define frame. */

define frame fTableRelation
  cFilter at row 1.5 col 3 no-label
  btnClearFilter at row 1.5 col 92
  brTableRelation at row 2.5 col 3
  cRelationFields at row 19 col 3 no-label no-tab-stop
  btnOk at row 21 col 31
  btnCancel at row 21 col 51
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    title gcTitlePrefix + 'Select table relation':U
    side-labels no-underline three-d 
    size 101 by 22.94
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fTableRelation
  apply 'end-error' to self.

on off-home of brTableRelation in frame fTableRelation
do:
  apply 'entry':U to cFilter in frame fTableRelation.
  return no-apply.
end. /* on cursor-down of cProcedureFilter in frame fTableRelation */
  
on cursor-down of cFilter in frame fTableRelation
do:
  apply 'entry':U to brTableRelation in frame fTableRelation.
  browse brTableRelation:select-focused-row().
  return no-apply.
end. /* on cursor-down of cFilter in frame fTableRelation */

on cursor-down of btnClearFilter in frame fTableRelation
do:
  apply 'entry':U to brTableRelation in frame fTableRelation.
  browse brTableRelation:select-focused-row().
  return no-apply.
end. /* on cursor-down of btnClearFilter in frame fTableRelation */

on value-changed of cFilter in frame fTableRelation
do:
  
  define variable cFilterEntry as character no-undo.
  define variable cPrepFilter  as character no-undo.
  
  define variable i            as integer       no-undo.
  
  cFilter = input frame fTableRelation cFilter.
  
  do i = 1 to num-entries(cFilter):
    
    assign
      cFilterEntry = entry(i, cFilter).
      cPrepFilter  = substitute('&1,&2':U,
                                cPrepFilter,
                                qg_cFilterEntryMatchcode(cFilterEntry))
      .
    
  end. /* do i = 1 to num-entries(cFilter) */
  
  cPrepFilter = (if cPrepFilter = '':U then
                   '*':U
                 else
                   trim(cPrepFilter, ',':U)).
  
  for each bttTableRelationView
    where bttTableRelationView.DatabaseName       = cDatabaseName
      and bttTableRelationView.ReferenceTableName = hBuffer:table,
  first bttFilterMatch
    where bttFilterMatch.FilterId    = iFilterId
      and bttFilterMatch.RecordRowId = rowid(bttTableRelationView)
    on error undo, throw:
    
    bttFilterMatch.RecordMatches = can-do(cPrepFilter, bttTableRelationView.RelatedTableName).
    
  end. /* for each bttTableRelationView */
  
  open query brTableRelation
    for each bttTableRelationView
      where bttTableRelationView.DatabaseName       = cDatabaseName
        and bttTableRelationView.ReferenceTableName = hBuffer:table,
    first bttFilterMatch
      where bttFilterMatch.FilterId      = iFilterId
        and bttFilterMatch.RecordRowId   = rowid(bttTableRelationView)
        and bttFilterMatch.RecordMatches = yes
      by bttTableRelationView.RelatedTableName
      by bttTableRelationView.RelationId
      .
  
  apply 'value-changed':U to browse brTableRelation.
  
end. /* on value-changed of cFilter in frame fTableRelation */

on choose of btnClearFilter in frame fTableRelation
do:
  
  display unless-hidden
    '':U @ cFilter
    with frame fTableRelation.
  
  apply 'value-changed':U to cFilter in frame fTableRelation.
  
end. /* on choose of btnClearFilter in frame fTableRelation */

on default-action of browse brTableRelation
  apply 'go':U to frame fTableRelation.

on value-changed of browse brTableRelation
do:
  
  cRelationFields = (if available bttTableRelationView then
                       bttTableRelationView.FieldDetails
                     else
                       '':U).
  
  display unless-hidden
    cRelationFields
    with frame fTableRelation.
  
end. /* on value-changed of browse brRelation */

run qg_InitBrowse(browse brTableRelation:handle).

assign
  hBuffer       = bttQueryWindow.QueryHandle:get-buffer-handle(1)
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer )
  iFilterId     = qg_iFilterSeq()
  .

for each bttTableRelationView
  where bttTableRelationView.DatabaseName       = cDatabaseName
    and bttTableRelationView.ReferenceTableName = hBuffer:table
  on error undo, throw:
  
  create bttFilterMatch.
  
  assign
    bttFilterMatch.FilterId      = iFilterId
    bttFilterMatch.RecordRowId   = rowid(bttTableRelationView)
    bttFilterMatch.RecordMatches = yes
    .
  
  validate bttFilterMatch.
  
end. /* for each bttTableRelationView */

open query brTableRelation
  for each bttTableRelationView
    where bttTableRelationView.DatabaseName       = cDatabaseName
      and bttTableRelationView.ReferenceTableName = hBuffer:table,
  first bttFilterMatch
    where bttFilterMatch.FilterId      = iFilterId
      and bttFilterMatch.RecordRowId   = rowid(bttTableRelationView)
      and bttFilterMatch.RecordMatches = yes
    by bttTableRelationView.RelatedTableName
    by bttTableRelationView.RelationId
    .

cRelationFields:read-only in frame fTableRelation = yes.

update unless-hidden
  cFilter
  btnClearFilter
  brTableRelation
  cRelationFields
  btnOk
  btnCancel
  with frame fTableRelation
    in window bttQueryWindow.WindowHandle. 

if available bttTableRelationView then
  run qg_OpenRelatedQueryWindow(bttQueryWindow.WindowHandle,
                                bttTableRelationView.RelationId,
                                bttTableRelationView.ParentRelation).

finally:
  
  if iFilterId > 0 then
  do:
    
    for each bttFilterMatch
      where bttFilterMatch.FilterId = iFilterId
      on error undo, throw:
      
      delete bttFilterMatch.
      
    end. /* for each bttFilterMatch */
    
  end. /* if iFilterId > 0 */
  
end finally.

end procedure. /* qg_QueryWindowOpenRelatedQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowOpenRecordWindow hQueryWindow 
PROCEDURE qg_QueryWindowOpenRecordWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow   as handle    no-undo.
define input parameter piLinkMode as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                  as integer   no-undo.
define variable hBuffer            as handle    no-undo.
define variable hField             as handle    no-undo.
define variable cDatabaseName      as character no-undo.
define variable cTargetTableName   as character no-undo.
define variable cFieldList         as character no-undo.
define variable cValueList         as character no-undo.
define variable cExternalReference as character no-undo.
define variable cQueryText         as character no-undo.
define variable iQuerySeq          as integer   no-undo init ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.
define buffer bttIndex       for temp-table ttIndex.
define buffer bttIndexField  for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

case piLinkMode:
  
  when {&K_QUERY_WINDOW_LINK_MODE_FIX_ROWID} then
  do:
    
    do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
      
      hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(i).
      
      if not hBuffer:available then
        return.
      
      assign
        cDatabaseName    = qg_cDatabaseNameForTableOrBuffer( hBuffer )
        cTargetTableName = hBuffer:table
        cQueryText       = substitute('&1&2~nfor each &3~n  where rowid(&3) = to-rowid(&4)':U,
                                      cQueryText,
                                      (if i > 1 then
                                         ',':U
                                       else
                                         '':U),
                                      hBuffer:table,
                                      quoter(hBuffer:rowid))
        .
      
    end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers() */
    
  end. /* when {&K_QUERY_WINDOW_LINK_MODE_FIX_ROWID} */ 
  
  when {&K_QUERY_WINDOW_LINK_MODE_FIX_INDEX} then
  do:
    
    do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
      
      hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(i).
      
      if not hBuffer:available then
        return.
      
      assign
        cDatabaseName    = qg_cDatabaseNameForTableOrBuffer( hBuffer )
        cTargetTableName = hBuffer:table
        cQueryText       = substitute('&1&2~n&3each &4':U,
                                      cQueryText,
                                      (if i > 1 then
                                         ',':U
                                       else
                                         '':U),
                                      (if i = 1 then
                                         'for ':U
                                       else
                                         '':U),
                                      hBuffer:table)
        .
      
      find first bttIndex
        where bttIndex.DatabaseName = cDatabaseName
          and bttIndex.TableName    = hBuffer:table
          and bttIndex.IsPrimary    = true
          and bttIndex.IsUnique     = true
        no-error.
      
      if not available bttIndex then
        find first bttIndex
          where bttIndex.DatabaseName = cDatabaseName
            and bttIndex.TableName    = hBuffer:table
            and bttIndex.IsUnique     = true
          no-error.
      
      if available bttIndex then
      do:
        
        assign
          cFieldList = '':U
          cValueList = '':U
          .
        
        for each bttIndexField
          where bttIndexField.DatabaseName = bttIndex.DatabaseName
            and bttIndexField.TableName    = bttIndex.TableName
            and bttIndexField.IndexName    = bttIndex.IndexName
          by bttIndexField.IndexSequence
          on error undo, throw:
          
          assign
            cFieldList = substitute('&1,&2':U,
                                    cFieldList,
                                    bttIndexField.FieldName)
            hField     = hBuffer:buffer-field(bttIndexField.FieldName)
            cValueList = substitute('&1&2&3':U,
                                    cValueList,
                                    {&K_PARAM_SPLITTER},
                                    (if hField:data-type = 'CHARACTER':U then
                                       quoter(hField:buffer-value)
                                     else
                                       hField:buffer-value))
            .
          
        end. /* for each bttIndexField */
        
        assign
          cFieldList = trim(cFieldList, ',':U)
          cValueList = trim(cValueList, {&K_PARAM_SPLITTER})
          cQueryText = substitute( '&1~n&2~n':U,
                                   cQueryText,
                                   qg_cCreateWhereClause( /* pcDatabaseName   */ bttIndex.DatabaseName,
                                                          /* pcTableNames     */ bttIndex.TableName,
                                                          /* pcBufferNames    */ bttIndex.TableName,
                                                          /* pcFieldList      */ cFieldList,
                                                          /* pcFieldLabelList */ ?,
                                                          /* plStartWithWhere */ yes,
                                                          /* piValueMode      */ {&K_VALUE_MODE_PARAMETER},
                                                          /* pcValueList      */ cValueList,
                                                          /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                                          /* plAddTags        */ no,
                                                          /* piIndentBlanks   */ 2 ) )
          .
        
        
      end. /* if available bttIndex */
      
    end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers() */
    
  end. /* when {&K_QUERY_WINDOW_LINK_MODE_FIX_INDEX} */
  
  when {&K_QUERY_WINDOW_LINK_MODE_LINKED} then
  do:
    
    do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
      
      assign
        hBuffer          = bttQueryWindow.QueryHandle:get-buffer-handle(i)
        cDatabaseName    = qg_cDatabaseNameForTableOrBuffer( hBuffer )
        cTargetTableName = hBuffer:table
        cQueryText       = substitute('&1&2~nfor each &3~n  where rowid(&3) = &4':U,
                                      cQueryText,
                                      (if i > 1 then
                                         ',':U
                                       else
                                         '':U),
                                      hBuffer:table,
                                      substitute('$~{&1:rowid(&2)~}':U,
                                                 bttQueryWindow.QuerySeq,
                                                 hBuffer:name))
        .
      
    end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers() */
    
  end. /* when {&K_QUERY_WINDOW_LINK_MODE_LINKED} */
  
end case. /* piLinkMode */

run qg_ExecQuery({&K_QUERY_WINDOW_MODE_RECORD},
                 {&K_RECORD_SIZE_MODE_DEFAULT},
                 substitute('&1.&2':U, cDatabaseName, cTargetTableName),
                 trim(cQueryText),
                 no,  /* Init mode */
                 '':U,
                 input-output iQuerySeq).

end procedure. /* qg_QueryWindowOpenRecordWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowseCopy hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowseCopy :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iKeyState as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

run GetKeyState( {&K_WIN_CONST_VK_SHIFT}, output iKeyState ).

if    iKeyState < 0
   or not valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then

  run qg_QueryWindowCopyRecordValues( phWindow ).

else
  
  run qg_QueryWindowQueryBrowseCopySelectedColumnValue( phWindow, yes ).

end procedure. /* qg_QueryWindowQueryBrowseCopy */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowseCopySelectedColumnValue hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowseCopySelectedColumnValue :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter plRaw    as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then
  leave.

clipboard:value = ( if plRaw then
                      bttQueryWindow.QueryBrowseSelectedColumn:input-value
                    else
                      bttQueryWindow.QueryBrowseSelectedColumn:screen-value ).

end procedure. /* qg_QueryWindowQueryBrowseCopySelectedColumnValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowseDefaultAction hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowseDefaultAction :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Default action trigger of query browse.                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer   as handle    no-undo.
define variable iKeyState as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(1).

if not valid-handle(hBuffer) then
  leave.

run qg_QueryWindowEdit(bttQueryWindow.WindowHandle,
                       {&K_EDITACTION_EDIT}).

end procedure. /* qg_QueryWindowQueryBrowseDefaultAction */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowsePopupMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowsePopupMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Menu drop event trigger for context menu of the query text editor widget.  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBrowse               as handle    no-undo.
define variable hTemp                 as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow            for temp-table ttQueryWindow.

define buffer bttBufferComparisonField  for temp-table ttBufferComparisonField.
define buffer b2ttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hBrowse = bttQueryWindow.QueryBrowseHandle.

find first bttBufferComparisonField
  where bttBufferComparisonField.BufferNo = 1
  no-error.

find first b2ttBufferComparisonField
  where b2ttBufferComparisonField.BufferNo = 2
  no-error.

assign
  hTemp           = qg_hGetWidgetByName( hBrowse:popup-menu, 'mi_CopySelectedColumnValueRaw':U )
  hTemp:label     = ( if valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then
                        substitute( 'Copy raw value (&1)':T,
                                    ( if valid-handle( bttQueryWindow.QueryBrowseSelectedColumn:buffer-field ) then
                                        qg_cFormattedFieldName( '':U,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:buffer-field:buffer-handle:name,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:buffer-field:name,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:index )
                                      else
                                        bttQueryWindow.QueryBrowseSelectedColumn:name ) )
                      else
                        'Copy raw value':T )
  hTemp:sensitive = valid-handle( bttQueryWindow.QueryBrowseSelectedColumn )
  hTemp           = qg_hGetWidgetByName( hBrowse:popup-menu, 'mi_CopySelectedColumnValueFormatted':U )
  hTemp:label     = ( if valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then
                        substitute( 'Copy formatted value (&1)':T,
                                    ( if valid-handle( bttQueryWindow.QueryBrowseSelectedColumn:buffer-field ) then
                                        qg_cFormattedFieldName( '':U,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:buffer-field:buffer-handle:name,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:buffer-field:name,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:index )
                                      else
                                        bttQueryWindow.QueryBrowseSelectedColumn:name ) )
                      else
                        'Copy formatted value':T )
  hTemp:sensitive = valid-handle( bttQueryWindow.QueryBrowseSelectedColumn )
  hTemp           = qg_hGetWidgetByName(hBrowse:popup-menu, 'mi_SelectForComparison1':U)
  hTemp:label     = substitute('Select for comparison 1&1':T,
                               (if available bttBufferComparisonField then
                                  substitute(' (&1.&2)':U,
                                             bttBufferComparisonField.DatabaseName,
                                             bttBufferComparisonField.BufferName)
                                else
                                  '':U))
  hTemp           = qg_hGetWidgetByName(hBrowse:popup-menu, 'mi_SelectForComparison2':U)
  hTemp:label     = substitute('Select for comparison 2&1':T,
                               (if available b2ttBufferComparisonField then
                                  substitute(' (&1.&2)':U,
                                             b2ttBufferComparisonField.DatabaseName,
                                             b2ttBufferComparisonField.BufferName)
                                else
                                  '':U))
  hTemp           = qg_hGetWidgetByName(hBrowse:popup-menu, 'mi_CompareSelectedRecords':U)
  hTemp:sensitive =     available bttBufferComparisonField
                    and available b2ttBufferComparisonField
  hTemp           = qg_hGetWidgetByName( hBrowse:popup-menu, 'mi_CalculateSum':U )
  hTemp:label     = ( if valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then
                        substitute( 'Calculate Sum for &1':T,
                                    ( if valid-handle( bttQueryWindow.QueryBrowseSelectedColumn:buffer-field ) then
                                        qg_cFormattedFieldName( '':U,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:buffer-field:buffer-handle:name,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:buffer-field:name,
                                                                bttQueryWindow.QueryBrowseSelectedColumn:index )
                                      else
                                        bttQueryWindow.QueryBrowseSelectedColumn:name ) )
                      else
                        'Calculate Sum':T )
  hTemp:sensitive = ( if    valid-handle( bttQueryWindow.QueryBrowseSelectedColumn ) then
                        lookup( bttQueryWindow.QueryBrowseSelectedColumn:data-type, 'DECIMAL,INTEGER,INT64':U ) > 0
                      else
                        no )
  .

end procedure. /* qg_QueryWindowQueryBrowsePopupMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowseRowDisplay hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowseRowDisplay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName        as character no-undo.
define variable cTableId             as character no-undo.
define variable cOverlayDatabaseName as character no-undo.
define variable cOverlayTableName    as character no-undo.
define variable cObjectIdFieldName   as character no-undo.

define variable lIncludeTablename    as logical   no-undo.
define variable cKeyValues           as character no-undo.
define variable cOverlayValue        as character no-undo.
define variable iFieldColor          as integer   no-undo.

define variable cObjectIdValue       as character no-undo.
define variable cFieldValue          as character no-undo.
define variable lResolved            as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow                  for temp-table ttQueryWindow.

define buffer bttQueryWindowField             for temp-table ttQueryWindowField.
define buffer bttVirtualFieldColumn           for temp-table ttVirtualFieldColumn.
define buffer bttFieldOverlay                 for temp-table ttFieldOverlay.
define buffer bttQueryWindowQueryBrowseColumn for temp-table ttQueryWindowQueryBrowseColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/* Applay column formats. */

if    bttQueryWindow.DisplayRawValues
   or bttQueryWindow.ApplyColumnFormats then
  
  for each bttQueryWindowQueryBrowseColumn
    where bttQueryWindowQueryBrowseColumn.WindowHandle = bttQueryWindow.WindowHandle:
    
    if not valid-handle( bttQueryWindowQueryBrowseColumn.ColumnHandle ) then
      next.
    
    bttQueryWindowQueryBrowseColumn.ColumnHandle:format = ( if bttQueryWindow.DisplayRawValues then
                                                              bttQueryWindowQueryBrowseColumn.RawFormat
                                                            else
                                                              bttQueryWindowQueryBrowseColumn.OriginalFormat ).
    
  end. /* for each bttQueryWindowQueryBrowseColumn: */

/* Display virtual fields. */

for each bttVirtualFieldColumn
  where bttVirtualFieldColumn.OwnerHandle = bttQueryWindow.QueryHandle
  break by bttVirtualFieldColumn.BufferName
  on error undo, throw:
  
  if not valid-handle( bttVirtualFieldColumn.ColumnHandle ) then
    
    next.
  
  if first-of( bttVirtualFieldColumn.BufferName ) then
    
    cObjectIdValue = qg_cObjectIdForBuffer( bttVirtualFieldColumn.BufferHandle ).
  
  assign
    bttVirtualFieldColumn.ColumnHandle:screen-value = string( qg_clVirtualFieldValueAsLongchar( bttVirtualFieldColumn.FieldType,
                                                                                                bttVirtualFieldColumn.DataType,
                                                                                                bttVirtualFieldColumn.FieldName,
                                                                                                cObjectIdValue,
                                                                                                ( if bttQueryWindow.DisplayRawValues then
                                                                                                    ?
                                                                                                  else
                                                                                                    bttVirtualFieldColumn.FieldFormat ) ) )
    bttVirtualFieldColumn.ColumnHandle:fgcolor      = {&K_VIRTUAL_DB_FIELD_FGCOLOR}
    .
  
end. /* for each bttVirtualFieldColumn */

/* Display overlay fields. */

for each bttFieldOverlay
  where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
  on error undo, throw:
  
  if    not valid-handle( bttFieldOverlay.ColumnHandle )
     or not valid-handle( bttFieldOverlay.OverlayColumnHandle ) then
    
    next.
  
  run qg_GetOverlayColumnValue( buffer bttFieldOverlay,
                                bttQueryWindow.DeepResolveObjectIds,
                                bttQueryWindow.DisplayRawValues,
                                output cFieldValue,
                                output lResolved ).
  
  assign
    iFieldColor = ( if lResolved then
                      {&K_OBJECTID_OVERLAY_FGCOLOR}
                    else
                      {&K_COLOR_RED} )
    bttFieldOverlay.OverlayColumnHandle:screen-value = cFieldValue
    bttFieldOverlay.OverlayColumnHandle:fgcolor      = iFieldColor
    .
  
end. /* for each bttFieldOverlay */

end procedure. /* qg_QueryWindowQueryBrowseRowDisplay */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowseStartSearch hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowseStartSearch :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iKeyState as integer   no-undo.

define variable hColumn       as handle    no-undo.
define variable hBuffer       as handle    no-undo.
define variable hBufferField  as handle    no-undo.

define variable cDatabaseName as character no-undo.
define variable cBufferName   as character no-undo.
define variable cFieldName    as character no-undo.
define variable iFieldIndex   as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow        for temp-table ttQueryWindow.

define buffer bttQueryWindowField   for temp-table ttQueryWindowField.
define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.
define buffer bttFieldOverlay       for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

case last-event:function:
  
  when 'START-SEARCH':U then
  do:
    
    hColumn = bttQueryWindow.QueryBrowseHandle:current-column.
    
    find bttFieldOverlay
      where bttFieldOverlay.OwnerHandle         = bttQueryWindow.QueryHandle
        and bttFieldOverlay.OverlayColumnHandle = hColumn
      no-error.
    
    if available bttFieldOverlay then
      
      hColumn = bttFieldOverlay.ColumnHandle.
    
    if valid-handle( hColumn:buffer-field ) then
      
      assign
        hBufferField  = hColumn:buffer-field
        hBuffer       = hBufferField:buffer-handle
        cBufferName   = hBuffer:name
        cFieldName    = hBufferField:name
        iFieldIndex   = hColumn:index
        .
    
    else
    do:
      
      find bttVirtualFieldColumn
        where bttVirtualFieldColumn.OwnerHandle  = bttQueryWindow.QueryHandle
          and bttVirtualFieldColumn.ColumnHandle = hColumn
        no-error.
      
      if available bttVirtualFieldColumn then
        
        assign
          cBufferName = bttVirtualFieldColumn.BufferName
          cFieldName  = bttVirtualFieldColumn.FieldName
          iFieldIndex = bttVirtualFieldColumn.FieldIndex
          .
      
    end. /* else: if valid-handle( hColumn:buffer-field ) */
    
    apply 'end-search':U to bttQueryWindow.QueryBrowseHandle.
    
    find bttQueryWindowField
      where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
        and bttQueryWindowField.BufferName   = cBufferName
        and bttQueryWindowField.FieldName    = cFieldName
        and bttQueryWindowField.FieldIndex   = iFieldIndex
        and bttQueryWindowField.IsOverlay    = no
      no-lock no-error.
    
    if available bttQueryWindowField then
    do:
      
      run GetKeyState({&K_WIN_CONST_VK_SHIFT}, output iKeyState).
      
      if iKeyState >= 0 then
        
        bttQueryWindow.QueryFieldBrowseHandle:deselect-rows().
      
      bttQueryWindow.QueryFieldBrowseHandle:query:reposition-to-rowid(rowid(bttQueryWindowField)) no-error.
      
      if not error-status:error then
      do:
        
        bttQueryWindow.QueryFieldBrowseHandle:select-focused-row().
        apply 'entry':U to bttQueryWindow.QueryFieldBrowseHandle.
      end.
      
    end. /* if available bttField */

  end. /* when 'START-SEARCH':U */

  otherwise
  do:
    
    run GetKeyState({&K_WIN_CONST_VK_ALT}, output iKeyState).
    
    if iKeyState < 0 then
    do:
      
      run GetKeyState({&K_WIN_CONST_VK_SHIFT}, output iKeyState).
      
      run qg_QueryWindowAddSortOption(bttQueryWindow.WindowHandle,
                                      (iKeyState < 0)).
      
    end. /* else: if iKeyState >= 0 */
    
    else
    do:
      
      run GetKeyState({&K_WIN_CONST_VK_CTRL}, output iKeyState).
      
      if iKeyState < 0 then
        run qg_QueryWindowMoveColumn(bttQueryWindow.WindowHandle, yes).
      
      else
        run qg_QueryWindowQueryTextEditorAddCondition(bttQueryWindow.WindowHandle).
      
    end. /* else: if iKeyState < 0 */
    
  end. /* otherwise */
  
end case. /* last-event:function */

end procedure. /* qg_QueryWindowQueryBrowseStartSearch */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryBrowseSelectColumn hQueryWindow 
PROCEDURE qg_QueryWindowQueryBrowseSelectColumn :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hColumn         as handle    no-undo.
define variable hSelectedColumn as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hColumn = bttQueryWindow.QueryBrowseHandle:first-column.

do while valid-handle(hColumn):
  
  if    last-event:x > hColumn:x
    and last-event:x < ( hColumn:x + hColumn:width-pixels ) then
    
    hSelectedColumn = hColumn.
  
  hColumn = hColumn:next-column.
  
end. /* do while valid-handle(hColumn) */

if hSelectedColumn <> bttQueryWindow.QueryBrowseSelectedColumn then
do:
  
  bttQueryWindow.QueryBrowseSelectedColumn = hSelectedColumn.
  validate bttQueryWindow.
  
end. /* if hSelectedColumn <> bttQueryWindow.QueryBrowseSelectedColumn */

end procedure. /* qg_QueryWindowQueryBrowseSelectColumn */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryFieldBrowseRowDisplay hQueryWindow 
PROCEDURE qg_QueryWindowQueryFieldBrowseRowDisplay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFieldBrowseBufferHandle as handle    no-undo.
define variable iColor                   as integer   no-undo init ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

define buffer bttField       for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hFieldBrowseBufferHandle = bttQueryWindow.QueryFieldBrowseBufferHandle.

if    valid-handle( hFieldBrowseBufferHandle )
  and hFieldBrowseBufferHandle:available then
do:
  
  case integer( hFieldBrowseBufferHandle::FieldType ):
    
    when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
      
      iColor = {&K_VIRTUAL_DB_FIELD_FGCOLOR}.
    
  end case. /* hFieldBrowseBufferHandle::FieldType */
  
  if iColor <> ? then
    
    assign
      bttQueryWindow.QueryFieldBrowseColHandles[1]:fgcolor = iColor
      bttQueryWindow.QueryFieldBrowseColHandles[2]:fgcolor = iColor
      .
  
end. /* if    valid-handle( hFieldBrowseBufferHandle ) */ 

assign
  bttQueryWindow.QueryFieldBrowseColHandles[3]:fgcolor = {&K_COLOR_LIGHT_GREY}
  bttQueryWindow.QueryFieldBrowseColHandles[4]:fgcolor = {&K_COLOR_LIGHT_GREY}
  .

end procedure. /* qg_QueryWindowQueryFieldBrowseRowDisplay */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryOpenFieldQuery hQueryWindow 
PROCEDURE qg_QueryWindowQueryOpenFieldQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  cQueryText =            'for each ttQueryWindowField':U
               + '~n':U + '  where ttQueryWindowField.WindowHandle = &1':U
               + '~n':U + '    and ttQueryWindowField.IsOverlay    = no':U
               + '~n':U + '  use-index BufferName':U
  cQueryText = substitute(cQueryText, quoter(bttQueryWindow.WindowHandle))
  .

qg_lQueryOpen(bttQueryWindow.QueryFieldBrowseHandle:query,
              cQueryText,
              bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowQueryOpenFieldQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRefreshBrowseColumns hQueryWindow 
PROCEDURE qg_QueryWindowRefreshBrowseColumns :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                 as integer   no-undo.
define variable iBufferCounter    as integer   no-undo.
define variable j                 as integer   no-undo.
define variable hBuffer           as handle    no-undo.

define variable hColumn           as handle    no-undo.
define variable hField            as handle    no-undo.
define variable cDatabaseName     as character no-undo.
define variable cBufferName       as character no-undo.
define variable cFieldName        as character no-undo.
define variable iFieldIndex       as integer   no-undo.
define variable cColExceptList    as character no-undo.

define variable lInitialize       as logical   no-undo.
define variable cColumns          as character no-undo.
define variable cColumn           as character no-undo.
define variable cOverlayFieldName as character no-undo.
define variable hOverlayColumn    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow                  for temp-table ttQueryWindow.

define buffer bttField                        for temp-table ttField.
define buffer bttFieldOverlay                 for temp-table ttFieldOverlay.
define buffer bttQueryWindowQueryBrowseColumn for temp-table ttQueryWindowQueryBrowseColumn.
define buffer bttVirtualFieldColumn           for temp-table ttVirtualFieldColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/*----------------------------------------------------------------------------*/
/* Clear browse columns.                                                      */
/*----------------------------------------------------------------------------*/

lInitialize = (bttQueryWindow.QueryBrowseHandle:num-columns = 0).

run qg_RemoveInvalidVirtualFieldColumns( buffer bttQueryWindow ).

run qg_RemoveInvalidOverlayColumns( buffer bttQueryWindow ).

/* Remove all browse columns. */

for each bttQueryWindowQueryBrowseColumn
  where bttQueryWindowQueryBrowseColumn.WindowHandle = bttQueryWindow.WindowHandle:
  
  delete bttQueryWindowQueryBrowseColumn.
  
end. /* for each bttQueryWindowQueryBrowseColumn */

do i = bttQueryWindow.QueryBrowseHandle:num-columns to 1 by -1:
  
  hColumn = bttQueryWindow.QueryBrowseHandle:get-browse-column(i).
  delete object hColumn.
  
end. /* do i = bttQueryWindow.QueryBrowseHandle:num-columns to 1 by -1 */

/*----------------------------------------------------------------------------*/
/* Create browse columns.                                                     */
/*----------------------------------------------------------------------------*/

/* Create buffer field columns. */

do iBufferCounter = 1 to bttQueryWindow.QueryHandle:num-buffers:
  
  assign
    hBuffer       = bttQueryWindow.QueryHandle:get-buffer-handle( iBufferCounter )
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer )
    .
  
  /* If a field has format = ? then the entire progress session will crash on */
  /* "add-columns-from". To avoid this we add all fields with format = ? to   */
  /* the the blacklist.                                                       */
  
  for each bttField
    where bttField.DatabaseName = cDatabaseName
      and bttField.TableName    = hBuffer:table
      and bttField.FieldFormat  = ?
    on error undo, throw:
    
    cColExceptList = substitute( '&1,&2':U,
                                 cColExceptList,
                                 bttField.FieldName ).
    
  end. /* for each bttField */
  
  cColExceptList = trim( cColExceptList, ',':U ).
  
  bttQueryWindow.QueryBrowseHandle:add-columns-from( hBuffer, cColExceptList ).
  
  run qg_CreateVirtualFieldColumnsForBuffer( buffer bttQueryWindow,
                                             iBufferCounter ).
  
end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers */

if lInitialize then
  
  cColumns = qg_cBrowseColumnList( bttQueryWindow.QueryBrowseHandle,
                                   yes,
                                   no,
                                   yes ).

/* Create field overlay columns. */

do i = 1 to bttQueryWindow.QueryBrowseHandle:num-columns:
  
  assign
    hColumn = bttQueryWindow.QueryBrowseHandle:get-browse-column(i)
    hField  = hColumn:buffer-field
    .
  
  if valid-handle( hField ) then
    
    assign
      cBufferName  = hField:buffer-name
      cFieldName   = hField:name
      iFieldIndex  = hColumn:index
      .
  
  else
  do:
    
    find bttVirtualFieldColumn
      where bttVirtualFieldColumn.OwnerHandle  = bttQueryWindow.QueryHandle
        and bttVirtualFieldColumn.ColumnHandle = hColumn
      no-error.
    
    if not available bttVirtualFieldColumn then
      
      next.
    
    assign
      cBufferName = bttVirtualFieldColumn.BufferName
      cFieldName  = bttVirtualFieldColumn.FieldName
      iFieldIndex = bttVirtualFieldColumn.FieldIndex
      .
    
  end. /* if valid-handle( hField ) */
  
  find bttFieldOverlay
    where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
      and bttFieldOverlay.BufferName  = cBufferName
      and bttFieldOverlay.FieldName   = cFieldName
      and bttFieldOverlay.FieldIndex  = iFieldIndex
    no-error.
  
  if not available bttFieldOverlay then
    next.
  
  assign
    hOverlayColumn                      = bttQueryWindow.QueryBrowseHandle:add-calc-column
                                            ('CHARACTER':U,
                                             {&K_OBJECTID_OVERLAY_FORMAT},
                                             '':U,
                                             substitute({&K_OBJECTID_OVERLAY_LABEL_PATTERN},
                                                        hColumn:label))
    hOverlayColumn:name                 = substitute({&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                                     qg_cFormattedFieldName(?,
                                                                            bttFieldOverlay.BufferName,
                                                                            bttFieldOverlay.FieldName,
                                                                            bttFieldOverlay.FieldIndex))
    hOverlayColumn:width                = {&K_OBJECTID_OVERLAY_DEFAULT_WIDTH}
    hOverlayColumn:label-fgcolor        = {&K_OBJECTID_OVERLAY_FGCOLOR}
    bttFieldOverlay.ColumnHandle        = hColumn
    bttFieldOverlay.FieldHandle         = hField
    bttFieldOverlay.OverlayColumnHandle = hOverlayColumn
    .
  
  validate bttFieldOverlay.
  
  if lInitialize then
    assign
      cFieldName        = qg_cFormattedFieldName(?,
                                                 bttFieldOverlay.BufferName,
                                                 bttFieldOverlay.FieldName,
                                                 bttFieldOverlay.FieldIndex)
      cOverlayFieldName = substitute({&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                              cFieldName)
      cColumns          = qg_cReplaceColumn(cColumns,
                                            cFieldName,
                                            cOverlayFieldName).
  
end. /* do i = bttQueryWindow.QueryBrowseHandle:num-columns to 1 by -1: */

do i = 1 to bttQueryWindow.QueryBrowseHandle:num-columns:
  
  hColumn = bttQueryWindow.QueryBrowseHandle:get-browse-column(i).
  
  create bttQueryWindowQueryBrowseColumn.
  
  assign
    bttQueryWindowQueryBrowseColumn.WindowHandle   = bttQueryWindow.WindowHandle
    bttQueryWindowQueryBrowseColumn.ColumnHandle   = hColumn
    bttQueryWindowQueryBrowseColumn.OriginalFormat = hColumn:format
    bttQueryWindowQueryBrowseColumn.RawFormat      = ( if valid-handle( hColumn:buffer-field ) then
                                                         qg_cMaximumDataTypeFormat( hColumn:buffer-field:data-type,
                                                                                    hColumn:buffer-field:decimals )
                                                       else
                                                         qg_cMaximumDataTypeFormat( hColumn:data-type,
                                                                                    10 ) )
    .
  
  validate bttQueryWindowQueryBrowseColumn.
  
end. /* do i = 1 to bttQueryWindow.QueryBrowseHandle:num-columns */

if    lInitialize
  and cColumns > '':U
  and can-find( first ttFieldOverlay
                  where ttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle ) then
  
  run qg_SetBrowseColumns( bttQueryWindow.QueryBrowseHandle, cColumns ).

end procedure. /* qg_QueryWindowRefreshBrowseColumns */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryTextEditorAddCondition hQueryWindow 
PROCEDURE qg_QueryWindowQueryTextEditorAddCondition :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add selected field(s) as condition(s) to the current query text.           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hEditor               as handle    no-undo.
define variable cQueryText            as character no-undo.
define variable iOffset               as integer   no-undo.
define variable iLineEndOffset        as integer   no-undo.

define variable hBuffer               as handle    no-undo.
define variable hFieldSelectionBrowse as handle    no-undo.
define variable hFieldSelectionBuffer as handle    no-undo.
define variable hField                as handle    no-undo.
define variable i                     as integer   no-undo.
define variable iFieldCount           as integer   no-undo.
define variable cDatabaseName         as character no-undo.
define variable lPhysicalDatabase     as logical   no-undo.
define variable cFieldList            as character no-undo.
define variable lWhere                as logical   no-undo.
define variable cInsertText           as character no-undo.

define variable iLine                 as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow    for temp-table ttQueryWindow.
define buffer bttQueryAST       for temp-table ttQueryAST.
define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

/*----------------------------------------------------------------------------*/
/* Get selection info                                                         */
/*----------------------------------------------------------------------------*/

assign
  hEditor    = bttQueryWindow.QueryTextEditorHandle
  cQueryText = hEditor:input-value
  iOffset    = (if hEditor:selection-end = ? then
                  hEditor:cursor-offset
                else
                  hEditor:selection-end - 1)
  .

/*----------------------------------------------------------------------------*/
/* Analyze selection and query text                                           */
/*----------------------------------------------------------------------------*/

iLineEndOffset = index(cQueryText, '~n':U, iOffset).

if iLineEndOffset > 0 then
  iOffset = iLineEndOffset.

run qg_ParseQueryConditions(cQueryText).

/* Don't insert after certain progress keywords. */

find first bttQueryAST
  where bttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_KEYWORD}
    and bttQueryAST.TokenStart <= iOffset
    and lookup(bttQueryAST.TokenText, 'BREAK,BY,NO-LOCK,SHARE-LOCK,EXCLUSIVE-LOCK,USE-INDEX':U) > 0
  no-error.

if available bttQueryAST then
do:
  
  iLineEndOffset = r-index(cQueryText, '~n':U, bttQueryAST.TokenStart).
  
  if iLineEndOffset > 0 then
    iOffset = iLineEndOffset.
  
end. /* if available bttQueryAST */

/* Switch where to end if necessary. */

find last bttQueryCondition
  where bttQueryCondition.RightStartPos <= iOffset
    and bttQueryCondition.RightEndPos   >= iOffset
  no-error.

if available bttQueryCondition then
  iOffset = bttQueryCondition.RightEndPos.

lWhere = not can-find(first ttQueryAST
                        where ttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_KEYWORD}
                          and ttQueryAST.TokenText  = 'WHERE':U
                          and ttQueryAST.TokenStart < iOffset).

if lWhere then
do:
  
  find first bttQueryAST
    where bttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_KEYWORD}
      and bttQueryAST.TokenText   = 'WHERE':U
      and bttQueryAST.TokenStart >= iOffset
    no-error.
  
  if available bttQueryAST then
    overlay(cQueryText,
            bttQueryAST.TokenStart,
            bttQueryAST.TokenEnd - bttQueryAST.TokenStart) = 'and':U.
  
end. /* if lWhere */

/*----------------------------------------------------------------------------*/
/* Generate line text.                                                        */
/*----------------------------------------------------------------------------*/

assign
  hBuffer               = bttQueryWindow.QueryBrowseHandle:query:get-buffer-handle(1)
  hFieldSelectionBrowse = bttQueryWindow.QueryFieldBrowseHandle
  hFieldSelectionBuffer = bttQueryWindow.QueryFieldBrowseBufferHandle
  cDatabaseName         = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
  lPhysicalDatabase     = qg_lIsPhysicalDatabase( cDatabaseName )
  .

do i = 1 to hFieldSelectionBrowse:num-selected-rows:
  
  hFieldSelectionBrowse:fetch-selected-row (i).
  
  if    lPhysicalDatabase
    and hFieldSelectionBuffer::IsVirtual then
    
    message
      substitute( 'Virtual field &1 can not be used in the query!':T,
                  quoter( hFieldSelectionBuffer::FieldName ) ) skip
      view-as alert-box
      warning
      buttons ok
      in window bttQueryWindow.WindowHandle.
  
  else
    
    assign
      cFieldList  = substitute('&1,&2':U,
                               cFieldList,
                               qg_cFormattedFieldName(?,
                                                      ?,
                                                      hFieldSelectionBuffer::FieldName,
                                                      hFieldSelectionBuffer::FieldIndex))
      iFieldCount = iFieldCount + 1
      .
  
end. /* do i = 1 to bttQueryWindow.QueryFieldBrowseHandle:num-selected-rows */

if iFieldCount = 0 then
  
  return.

assign
  cFieldList  = trim(cFieldList, ',':U)
  cInsertText = qg_cCreateWhereClause( /* pcDatabaseName   */ cDatabaseName,
                                       /* pcTableNames     */ hBuffer:table,
                                       /* pcBufferNames    */ hBuffer:name,
                                       /* pcFieldList      */ cFieldList,
                                       /* pcFieldLabelList */ ?,
                                       /* plStartWithWhere */ lWhere,
                                       /* piValueMode      */ {&K_VALUE_MODE_DEFAULT_VALUE},
                                       /* pcValueList      */ ?,
                                       /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                       /* plAddTags        */ no,
                                       /* piIndentBlanks   */ 0 )
  .

/*----------------------------------------------------------------------------*/
/* Insert text lines.                                                         */
/*----------------------------------------------------------------------------*/

run qg_InsertTextLines(cInsertText,
                       iOffset,
                       input-output cQueryText,
                             output iLine).

/*----------------------------------------------------------------------------*/
/* Update editor                                                              */
/*----------------------------------------------------------------------------*/

cQueryText = qg_cBeautifyQueryText(cQueryText).

run qg_UpdateEditor(hEditor,
                    cQueryText,
                    iLine,
                    iLine + max(0, num-entries(cInsertText, '~n':U) - 1)).

apply 'entry':U to hEditor.

end procedure. /* qg_QueryWindowQueryTextEditorAddCondition */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryTextEditorDeleteLines hQueryWindow 
PROCEDURE qg_QueryWindowQueryTextEditorDeleteLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Delete selected lines.                                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hEditor                   as handle    no-undo.
define variable cQueryText                as character no-undo.

define variable iSelectionStart           as integer   no-undo.
define variable iSelectionEnd             as integer   no-undo.

define variable iLine                     as integer   no-undo.

define variable iSelectionStartLine       as integer   no-undo.
define variable iSelectionEndLine         as integer   no-undo.
define variable iSelectionStartLineOffset as integer   no-undo.
define variable iSelectionEndLineOffset   as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow    for temp-table ttQueryWindow.
define buffer bttQueryAST       for temp-table ttQueryAST.
define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

assign
  hEditor     = bttQueryWindow.QueryTextEditorHandle
  cQueryText  = hEditor:input-value
  .

/*----------------------------------------------------------------------------*/
/* Fix connective operator                                                    */
/*----------------------------------------------------------------------------*/

run qg_ParseQueryConditions(cQueryText).

run qg_GetEditorSelectionInfo(hEditor,
                              output iSelectionStart,
                              output iSelectionEnd,
                              output iSelectionStartLine,
                              output iSelectionEndLine).

if    iSelectionStartLine > 0
  and iSelectionEndLine   > 0 then
do:
  
  assign
    iSelectionStartLineOffset = hEditor:convert-to-offset(iSelectionStartLine,
                                                          1)
    iSelectionEndLineOffset   = hEditor:convert-to-offset(iSelectionEndLine,
                                                          length(entry(iSelectionEndLine,
                                                                       cQueryText,
                                                                       '~n':U)))
    .

  find first bttQueryAST
    where bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
      and bttQueryAST.TokenText = 'WHERE':U
    no-error.
  
  if    available bttQueryAST
    and bttQueryAST.TokenStart >= iSelectionStartLineOffset
    and bttQueryAST.TokenEnd   <= iSelectionEndLineOffset then
  do:
    
    find first bttQueryAST
      where bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_OPERATOR}
        and bttQueryAST.TokenStart > iSelectionEndLineOffset
        and lookup(bttQueryAST.TokenText, 'AND,OR':U) > 0
        and not can-find(first bttQueryCondition
                           where bttQueryCondition.RightStartPos <= bttQueryAST.TokenStart
                             and bttQueryCondition.RightEndPos   >= bttQueryAST.TokenEnd)

      no-error.
    
    if available bttQueryAST then
      cQueryText = substitute('&1where&2':U,
                              substring(cQueryText,
                                        1,
                                        bttQueryAST.TokenStart - 1),
                              substring(cQueryText,
                                        bttQueryAST.TokenEnd)).
      
  end. /* if    bttQueryAST.TokenStart >= iSelectionStartLineOffset */

  /*--------------------------------------------------------------------------*/
  /* Delete line                                                              */
  /*--------------------------------------------------------------------------*/
  
  run qg_DeleteTextLines(iSelectionStart,
                         iSelectionEnd,
                         input-output cQueryText,
                               output iLine).
  
  /*--------------------------------------------------------------------------*/
  /* Beautify query text                                                      */
  /*--------------------------------------------------------------------------*/
  
  cQueryText = qg_cBeautifyQueryText(cQueryText).
  
  assign
    hEditor:screen-value = cQueryText
    hEditor:cursor-line  = iLine
    .
  
end. /* if    iSelectionStartLine > 0 */

end procedure. /* qg_QueryWindowQueryTextEditorDeleteLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryTextEditorDuplicateLines hQueryWindow 
PROCEDURE qg_QueryWindowQueryTextEditorDuplicateLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add selected field(s) as condition(s) to the current query text.           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* phBuffer                       = Buffer that contains the field.           */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter plDown   as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hEditor                   as handle    no-undo.
define variable cQueryText                as character no-undo.

define variable iLine                     as integer   no-undo.
define variable iSelectionStart           as integer   no-undo.
define variable iSelectionEnd             as integer   no-undo.
define variable iSelectionStartLine       as integer   no-undo.
define variable iSelectionEndLine         as integer   no-undo.
define variable iSelectedLines            as integer   no-undo.

define variable iSelectionStartLineOffset as integer   no-undo.
define variable iSelectionEndLineOffset   as integer   no-undo.

define variable i                         as integer   no-undo.
define variable iOffset                   as integer   no-undo init 1.
define variable iLineEndOffset            as integer   no-undo.

define variable iRelativeOffset           as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow    for temp-table ttQueryWindow.
define buffer bttQueryAST       for temp-table ttQueryAST.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

/*----------------------------------------------------------------------------*/
/* Get selection info                                                         */
/*----------------------------------------------------------------------------*/

assign
  hEditor    = bttQueryWindow.QueryTextEditorHandle
  cQueryText = hEditor:input-value
  .

run qg_GetEditorSelectionInfo(hEditor,
                              output iSelectionStart,
                              output iSelectionEnd,
                              output iSelectionStartLine,
                              output iSelectionEndLine).

/*----------------------------------------------------------------------------*/
/* Analyze selection and query text                                           */
/*----------------------------------------------------------------------------*/

assign
  iSelectionStartLineOffset = hEditor:convert-to-offset(iSelectionStartLine,
                                                        1)
  iSelectionEndLineOffset   = hEditor:convert-to-offset(iSelectionEndLine,
                                                        length(entry(iSelectionStartLine,
                                                                     cQueryText,
                                                                     '~n':U))) + 1
  .

run qg_ParseQueryConditions(cQueryText).

find first bttQueryAST
  where bttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_KEYWORD}
    and bttQueryAST.TokenStart >= iSelectionStartLineOffset
    and bttQueryAST.TokenEnd   <= iSelectionEndLineOffset
    and bttQueryAST.TokenText   = 'WHERE':U
  use-index TokenType
  no-error.

if available bttQueryAST then
  iRelativeOffset = bttQueryAST.TokenStart - iSelectionStartLineOffset.

/*----------------------------------------------------------------------------*/
/* Move text lines                                                            */
/*----------------------------------------------------------------------------*/

run qg_DuplicateTextLines(iSelectionStart,
                          iSelectionEnd,
                          plDown,
                          input-output cQueryText,
                                output iLine).

/*----------------------------------------------------------------------------*/
/* Fix duplicted lines                                                        */
/*----------------------------------------------------------------------------*/

if available bttQueryAST then
do:
  
  /* Get line offset. */
  
  assign
    iSelectionStartLineOffset = 0
    iSelectionEndLineOffset   = 0
    .
  
  do i = 1 to num-entries(cQueryText, '~n':U):
    
    iLineEndOffset = iOffset + length(entry(i, cQueryText, '~n':U)).
    
    if i = iLine then
      iSelectionStartLineOffset = iOffset.
    
    if i = iLine + iSelectionEndLine - iSelectionStartLine then
    do:
      
      iSelectionEndLineOffset = iLineEndOffset.
      leave.
      
    end. /* if i = iLine + iSelectedLines - 1 */
    
    iOffset = iLineEndOffset + length('~n':U).
    
  end. /* do i = 1 to num-entries(cQueryText, '~n':U) */
  
  iOffset = (if plDown then
               iSelectionStartLineOffset
             else
               iSelectionEndLineOffset + length('~n':U)).
  
  /* Replace "where" by "and". */
  
  if iOffset > 0 then
    overlay(cQueryText,
            iOffset + iRelativeOffset,
            length(bttQueryAST.TokenText)) = 'and':U.
  
end. /* if available bttQueryAST */

/*----------------------------------------------------------------------------*/
/* Update editor                                                              */
/*----------------------------------------------------------------------------*/

cQueryText = qg_cBeautifyQueryText(cQueryText).

run qg_UpdateEditor(hEditor,
                    cQueryText,
                    iLine,
                    iLine + iSelectionEndLine - iSelectionStartLine).

apply 'entry':U to hEditor.

end procedure. /* qg_QueryWindowQueryTextEditorDuplicateLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryTextEditorMoveLines hQueryWindow 
PROCEDURE qg_QueryWindowQueryTextEditorMoveLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add selected field(s) as condition(s) to the current query text.           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plDown                         = If yes the lines will be moved down.      */
/*                                  Otherwise the lines will be moved up.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter plDown   as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hEditor                   as handle    no-undo.
define variable cQueryText                as character no-undo.

define variable iLine                     as integer   no-undo.
define variable iSelectionStart           as integer   no-undo.
define variable iSelectionEnd             as integer   no-undo.
define variable iSelectionStartLine       as integer   no-undo.
define variable iSelectionEndLine         as integer   no-undo.

define variable iSelectionStartLineOffset as integer   no-undo.
define variable iSelectionEndLineOffset   as integer   no-undo.
define variable iNextLineOffset           as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow    for temp-table ttQueryWindow.
define buffer b1ttQueryAST      for temp-table ttQueryAST.
define buffer b2ttQueryAST      for temp-table ttQueryAST.
define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

/*----------------------------------------------------------------------------*/
/* Get selection info                                                         */
/*----------------------------------------------------------------------------*/

assign
  hEditor    = bttQueryWindow.QueryTextEditorHandle
  cQueryText = hEditor:input-value
  .

run qg_GetEditorSelectionInfo(hEditor,
                              output iSelectionStart,
                              output iSelectionEnd,
                              output iSelectionStartLine,
                              output iSelectionEndLine).

/*----------------------------------------------------------------------------*/
/* Analyze selection and query text                                           */
/*----------------------------------------------------------------------------*/

assign
  iSelectionStartLineOffset = hEditor:convert-to-offset(iSelectionStartLine,
                                                        1)
  iSelectionEndLineOffset   = hEditor:convert-to-offset(iSelectionEndLine,
                                                        length(entry(iSelectionStartLine,
                                                                     cQueryText,
                                                                     '~n':U))) + 1
  .

run qg_ParseQueryConditions(cQueryText).

if plDown then
do:
  
  find first b1ttQueryAST
    where b1ttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_KEYWORD}
      and b1ttQueryAST.TokenStart >= iSelectionStartLineOffset
      and b1ttQueryAST.TokenEnd   <= iSelectionEndLineOffset
      and b1ttQueryAST.TokenText   = 'WHERE':U
    no-error.
  
  if available b1ttQueryAST then
  do:
    
    iNextLineOffset = index(cQueryText,
                            '~n':U,
                            iSelectionEndLineOffset + length('~n':U)).
    
    if iNextLineOffset = 0 then
      iNextLineOffset = length(cQueryText) + 1.
    
    find first b2ttQueryAST
      where b2ttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_OPERATOR}
        and b2ttQueryAST.TokenStart >= iSelectionEndLineOffset
        and b2ttQueryAST.TokenEnd   <= iNextLineOffset
        and lookup(b2ttQueryAST.TokenText, 'AND,OR':U) > 0
        and not can-find(first bttQueryCondition
                           where bttQueryCondition.RightStartPos <= b2ttQueryAST.TokenStart
                             and bttQueryCondition.RightEndPos   >= b2ttQueryAST.TokenEnd)
      no-error.
    
  end. /* if available b1ttQueryAST */
  
end. /* if plDown */

else
do:
  
  iNextLineOffset = r-index(cQueryText,
                            '~n':U,
                            maximum(1, iSelectionStartLineOffset - length('~n':U) - 1)).
  
  if iNextLineOffset = 0 then
    iNextLineOffset = 1.
    
  find first b1ttQueryAST
    where b1ttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_KEYWORD}
      and b1ttQueryAST.TokenStart >= iNextLineOffset
      and b1ttQueryAST.TokenEnd   <= iSelectionStartLineOffset
      and b1ttQueryAST.TokenText   = 'WHERE':U
    no-error.
  
  if available b1ttQueryAST then
    find first b2ttQueryAST
      where b2ttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_OPERATOR}
        and b2ttQueryAST.TokenStart >= iSelectionStartLineOffset
        and b2ttQueryAST.TokenEnd   <= iSelectionEndLineOffset
        and lookup(b2ttQueryAST.TokenText, 'AND,OR':U) > 0
        and not can-find(first bttQueryCondition
                           where bttQueryCondition.RightStartPos <= b2ttQueryAST.TokenStart
                             and bttQueryCondition.RightEndPos   >= b2ttQueryAST.TokenEnd)
      no-error.
    
end. /* else: if plDown */

if    available b1ttQueryAST
  and available b2ttQueryAST then
  assign
    cQueryText =   substring(cQueryText,
                             1,
                             b1ttQueryAST.TokenStart - 1)
                 + lc(b2ttQueryAST.TokenText)
                 + substring(cQueryText,
                             b1ttQueryAST.TokenEnd,
                             b2ttQueryAST.TokenStart - b1ttQueryAST.TokenEnd)
                 + lc(b1ttQueryAST.TokenText)
                 + substring(cQueryText, b2ttQueryAST.TokenEnd)
    iSelectionStart = iSelectionStart - 5 + length(b2ttQueryAST.TokenText)
        when iSelectionStart > b1ttQueryAST.TokenEnd
    iSelectionStart = iSelectionStart - 5 + length(b1ttQueryAST.TokenText)
        when iSelectionStart > b2ttQueryAST.TokenEnd
    iSelectionEnd = iSelectionEnd - 5 + length(b2ttQueryAST.TokenText)
        when iSelectionEnd > b1ttQueryAST.TokenEnd
    iSelectionEnd = iSelectionEnd - 5 + length(b1ttQueryAST.TokenText)
        when iSelectionEnd > b2ttQueryAST.TokenEnd
    .

/*----------------------------------------------------------------------------*/
/* Move text lines                                                            */
/*----------------------------------------------------------------------------*/

run qg_MoveTextLines(iSelectionStart,
                     iSelectionEnd,
                     plDown,
                     input-output cQueryText,
                           output iLine).

/*----------------------------------------------------------------------------*/
/* Update editor                                                              */
/*----------------------------------------------------------------------------*/

cQueryText = qg_cBeautifyQueryText(cQueryText).

run qg_UpdateEditor(hEditor,
                    cQueryText,
                    iLine,
                    iLine + iSelectionEndLine - iSelectionStartLine).

apply 'entry':U to hEditor.

end procedure. /* qg_QueryWindowQueryTextEditorMoveLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryTextEditorPopupMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowQueryTextEditorPopupMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Menu drop event trigger for context menu of the query text editor widget.  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hInsertExternalFieldReference as handle    no-undo.
define variable hInsertExternalTableReference as handle    no-undo.

define variable hTemp                         as handle    no-undo.

define variable iOffset                       as integer   no-undo.
define variable cQuerytext                    as character no-undo.
define variable cComparator                   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow    for temp-table ttQueryWindow.

define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

cQueryText = bttQueryWindow.QueryTextEditorHandle:input-value.

run qg_ParseQueryConditions(cQueryText).

iOffset = bttQueryWindow.QueryTextEditorHandle:cursor-offset.

find first bttQueryCondition
  where bttQueryCondition.StartPos <= iOffset
    and bttQueryCondition.EndPos   >= iOffset
  no-error.

if available bttQueryCondition then
  cComparator = substring(cQuerytext,
                          bttQueryCondition.ComparatorStartPos,
                          bttQueryCondition.ComparatorEndPos - bttQueryCondition.ComparatorStartPos).

if bttQueryWindow.ObjSourceQuerySeq = 0 then
  assign
    hInsertExternalFieldReference           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                                                  'mi_InsertExternalFieldReference':U)
    hInsertExternalFieldReference:sensitive /* code checked by mth */
        = can-find(first ttQueryWindow
                     where ttQueryWindow.QuerySeq <> bttQueryWindow.QuerySeq)
    hInsertExternalTableReference           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                                                  'mi_InsertExternalTableReference':U)
    hInsertExternalTableReference:sensitive /* code checked by mth */
        = hInsertExternalFieldReference:sensitive
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_Equal':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> '=':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_NotEqual':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> '<>':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_Greater':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> '>':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_GreaterEqual':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> '>=':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_Lower':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> '<':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_LowerEqual':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> '<=':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_Begins':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> 'begins':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_Matches':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> 'matches':U
    hTemp           = qg_hGetWidgetByName(bttQueryWindow.QueryTextEditorHandle:popup-menu,
                                         'mi_Contains':U)
    hTemp:sensitive =     cComparator  > '':U
                      and cComparator <> 'contains':U
    .

end procedure. /* qg_QueryWindowQueryTextEditorPopupMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryToolsMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowQueryToolsMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Menu drop event trigger for the query window tools menu.                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lBufferAvailable          as logical   no-undo.
define variable hOpenRecordWindowFixRowId as handle    no-undo.
define variable hOpenRecordWindowFixIndex as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  lBufferAvailable          =     valid-handle(bttQueryWindow.QueryHandle)
                              and bttQueryWindow.QueryHandle:get-buffer-handle(1):available
  hOpenRecordWindowFixRowId = qg_hGetWidgetByName(bttQueryWindow.WindowHandle:menu-bar,
                                                  'mi_OpenRecordWindowFixRowId':U)
  hOpenRecordWindowFixRowId:sensitive /* code checked by mth */
      = lBufferAvailable
  hOpenRecordWindowFixIndex = qg_hGetWidgetByName(bttQueryWindow.WindowHandle:menu-bar,
                                                  'mi_OpenRecordWindowFixIndex':U)
  hOpenRecordWindowFixIndex:sensitive /* code checked by mth */
      = lBufferAvailable
  .

end procedure. /* qg_QueryWindowQueryToolsMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQueryUpdateTitle hQueryWindow 
PROCEDURE qg_QueryWindowQueryUpdateTitle :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hQuery        as handle    no-undo.
define variable hBuffer       as handle    no-undo.

define variable cDatabaseName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hQuery = bttQueryWindow.QueryHandle.

if    valid-handle(hQuery)
  and hQuery:num-buffers > 0 then
  hBuffer = hQuery:get-buffer-handle(1).

if not valid-handle(hBuffer) then
    bttQueryWindow.WindowTitle = substitute('&1[&2] Query - unknown':U,
                                            gcTitlePrefix,
                                            bttQueryWindow.QuerySeq).

else
  assign
    cDatabaseName              = qg_cDatabaseNameForTableOrBuffer( hBuffer )
    bttQueryWindow.WindowTitle = substitute('&1[&2] Query - &3.&4':T,
                                            gcTitlePrefix,
                                            bttQueryWindow.QuerySeq,
                                            cDatabaseName,
                                            hBuffer:table)
    .

bttQueryWindow.WindowHandle:title = bttQueryWindow.WindowTitle.

end procedure. /* qg_QueryWindowQueryUpdateTitle */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecentQueries hQueryWindow 
PROCEDURE qg_QueryWindowRecentQueries :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show dialog with recently executed queries.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Window that contains the widgets.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iOrderLabel as integer   no-undo.

define query brRecentQueriesBrowse
  for ttRecentQuery
  scrolling.

define browse brRecentQueriesBrowse
  query brRecentQueriesBrowse no-lock
    display
      ttRecentQuery.OrderLabel format 'zzzzz9  ':U label 'Ord':U
      ttRecentQuery.QueryLabel format 'x(255)':U label 'Query':U
      with no-assign size 146 by 10.5.

define variable cQueryText as character no-undo
  view-as editor
  no-word-wrap
  scrollbar-horizontal
  scrollbar-vertical
  size 146 by 10
  font 0.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.


/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.
define buffer bttRecentQuery for temp-table ttRecentQuery.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  leave.

define frame fSelectRecentQuery
  brRecentQueriesBrowse at row 1.5 col 3
  cQueryText at row 12.5 col 3 no-label
  btnOk at row 23.5 col 56
  btnCancel at row 23.5 col 76
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    title gcTitlePrefix + 'Select recent query':U
    side-labels no-underline three-d 
    size 151 by 25.44
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSelectRecentQuery
  apply 'end-error' to self.

on value-changed of brRecentQueriesBrowse in frame fSelectRecentQuery
do:
  
  if available ttRecentQuery then
    cQueryText = ttRecentQuery.QueryText.
  
  else
    cQueryText = '':U.
  
  display unless-hidden
    cQueryText
    with frame fSelectRecentQuery.
  
end. /* on 'value-changed':U of browse brRecentQueriesBrowse in window fSelectRecentQuery */

on default-action of brRecentQueriesBrowse in frame fSelectRecentQuery
  apply 'go':U to frame fSelectRecentQuery.

/* Refresh display order numbers. */

for each bttRecentQuery
  where bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
  by Order
  on error undo, throw:
  
  assign
    iOrderLabel               = iOrderLabel + 1
    bttRecentQuery.OrderLabel = iOrderLabel
    .
  
end. /* for each bttRecentQuery */

open query brRecentQueriesBrowse
  for each ttRecentQuery
    where ttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
    by Order descending.

run qg_InitBrowse(browse brRecentQueriesBrowse:handle).

cQueryText:read-only in frame fSelectRecentQuery = yes.

if query brRecentQueriesBrowse:num-results > 0 then
do:
  
  display unless-hidden
    brRecentQueriesBrowse
    with frame fSelectRecentQuery
      in window bttQueryWindow.WindowHandle. 
  
  brRecentQueriesBrowse:select-row(1) in frame fSelectRecentQuery.
  apply 'value-changed':U to brRecentQueriesBrowse in frame fSelectRecentQuery.
  
end. /* if query brRecentQueriesBrowse:num-results > 0 */

update unless-hidden
  brRecentQueriesBrowse
  cQueryText
  btnOk
  btnCancel
  with frame fSelectRecentQuery
    in window bttQueryWindow.WindowHandle. 

if available ttRecentQuery then
do:
  
  run qg_ExecRecentQuery in target-procedure
        (bttQueryWindow.WindowHandle,
         ttRecentQuery.QueryText).
  
  apply 'entry':U to bttQueryWindow.QueryTextEditorHandle.
  
end. /* if available ttRecentQuery */

end procedure. /* qg_QueryWindowRecentQueries */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordBrowseRowDisplay hQueryWindow 
PROCEDURE qg_QueryWindowRecordBrowseRowDisplay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Copy selected record field value.                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer        as handle    no-undo.
define variable iColor         as integer   no-undo init ?.
define variable iColumnCounter as integer   no-undo.
define variable iLastColumn    as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hBuffer = bttQueryWindow.RecordQueryHandle:get-buffer-handle(1).

if hBuffer:available then
do:
  
  if hBuffer::IsOverlay then
    
    iColor = {&K_OBJECTID_OVERLAY_FGCOLOR}.
  
  else
    
    case integer( hBuffer::FieldType ):
      
      when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
        
        iColor = {&K_VIRTUAL_DB_FIELD_FGCOLOR}.
      
    end case. /* hFieldBrowseBufferHandle::FieldType */
  
  if iColor <> ? then
    
    do iColumnCounter = 1 to extent(bttQueryWindow.RecordBrowseColHandles):
      bttQueryWindow.RecordBrowseColHandles[iColumnCounter]:fgcolor = iColor.
    end. /* do i = 1 to extent(bttQueryWindow.RecordBrowseColHandles) */
  
  if hBuffer::IsOverlay then
  do:
      
    iLastColumn = extent(bttQueryWindow.RecordBrowseColHandles).
    
    bttQueryWindow.RecordBrowseColHandles[iLastColumn]:fgcolor = ( if hBuffer::IsOverlayResolved then
                                                                     {&K_OBJECTID_OVERLAY_FGCOLOR}
                                                                   else
                                                                     {&K_COLOR_RED} ).
    
  end. /* if hBuffer::IsOverlay */
  
end. /* for each bttFieldOverlay */

end procedure. /* qg_QueryWindowRecordBrowseRowDisplay */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordCopyValue hQueryWindow 
PROCEDURE qg_QueryWindowRecordCopyValue :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Copy selected record field value.                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer    as handle    no-undo.
define variable clValue    as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hBuffer = bttQueryWindow.RecordQueryHandle:get-buffer-handle(1).

if not hBuffer:available then
  message /* code checked by mth */
    'No field is selected':T skip
    view-as alert-box
    error
    buttons ok.
  
else
do:
  
  if bttQueryWindow.DisplayRawValues then
    copy-lob hBuffer::CurrentUnformattedValue to clValue.
  
  else
    copy-lob hBuffer::CurrentFormattedValue to clValue.
  
  clipboard:value = clValue.
    
end. /* else: if not hBuffer:available */

end procedure. /* qg_QueryWindowRecordCopyValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordFieldDetails hQueryWindow 
PROCEDURE qg_QueryWindowRecordFieldDetails :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show field details dialog for selected field.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hRecordBrowseBuffer as handle    no-undo.
define variable hRecordBuffer       as handle    no-undo.
define variable clValue             as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hRecordBrowseBuffer = bttQueryWindow.RecordQueryHandle:get-buffer-handle(1).

if not hRecordBrowseBuffer:available then
  message /* code checked by mth */
    'No field is selected':T skip
    view-as alert-box
    error
    buttons ok
    in window bttQueryWindow.WindowHandle.
  
else
do:
  
  hRecordBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(string(hRecordBrowseBuffer::BufferName)).
  
  if valid-handle(hRecordBuffer) then
  do:
  
    if not hRecordBuffer:available then
      message /* code checked by mth */
        '&1 record is not available':T skip
        view-as alert-box
        error
        buttons ok
        in window bttQueryWindow.WindowHandle.
    
    else
    do:
      
      if bttQueryWindow.DisplayRawValues then
        copy-lob from hRecordBrowseBuffer::CurrentUnformattedValue to clValue.
      
      else
        copy-lob from hRecordBrowseBuffer::CurrentFormattedValue to clValue.
      
      run qg_EditFieldValue(hRecordBrowseBuffer::FieldName,
                            hRecordBrowseBuffer::DataType,
                            hRecordBrowseBuffer::FieldFormat,
                            hRecordBrowseBuffer::FieldViewAs,
                            bttQueryWindow.DisplayRawValues,
                            no,
                            input-output clValue,
                            bttQueryWindow.WindowHandle).
      
    end. /* else: if not hRecordBuffer:available */
    
  end. /* if valid-handle(hRecordBuffer) */
  
end. /* else: if not hRecordBrowseBuffer:available */

apply 'entry':U to bttQueryWindow.RecordBrowseHandle.
  
end procedure. /* qg_QueryWindowRecordFieldDetails */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordNavigate hQueryWindow 
PROCEDURE qg_QueryWindowRecordNavigate :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow         as handle    no-undo.
define input parameter piNavigationType as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable rCurrentRecord as rowid     no-undo.
define variable hBuffer        as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

assign
  hBuffer        = bttQueryWindow.QueryHandle:get-buffer-handle(1)
  rCurrentRecord = hBuffer:rowid
  .

case piNavigationType:
  
  when {&K_NAVIGATE_FIRST} then
    bttQueryWindow.QueryHandle:get-first().
  
  when {&K_NAVIGATE_PREV} then
  do:
    
    bttQueryWindow.QueryHandle:get-prev().
    
    if    rCurrentRecord <> ?
      and not hBuffer:available then
    do:
      
      message
        'This already is the first record':T
        view-as alert-box
        information
        buttons ok
        in window bttQueryWindow.WindowHandle.
      
      bttQueryWindow.QueryHandle:get-next().
      
    end. /* if    rCurrentRecord <> ? */
    
  end. /* when {&K_NAVIGATE_PREV} */
  
  when {&K_NAVIGATE_NEXT} then
  do:
    
    bttQueryWindow.QueryHandle:get-next().
    
    if    rCurrentRecord <> ?
      and not hBuffer:available then
    do:
      
      message
        'This already is the last record':T
        view-as alert-box
        information
        buttons ok
        in window bttQueryWindow.WindowHandle.
      
      bttQueryWindow.QueryHandle:get-prev().
      
    end. /* if    rCurrentRecord <> ? */
    
  end. /* when {&K_NAVIGATE_NEXT} */
  
  when {&K_NAVIGATE_LAST} then
    bttQueryWindow.QueryHandle:get-last().
  
end case. /* piNavigationType */

run qg_QueryWindowRecordRefresh(bttQueryWindow.WindowHandle).

run qg_QueryWindowUpdateAll('':U).

end procedure. /* qg_QueryWindowRecordNavigate */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordOpenQuery hQueryWindow 
PROCEDURE qg_QueryWindowRecordOpenQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open query for record field browse.                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  cQueryText =   'for each ttQueryWindowField':U
               + '  where ttQueryWindowField.WindowHandle = ~'&1~'':U
               + '    and ttQueryWindowField.Order        > 0':U
               + '  use-index &2':U
  cQueryText = substitute(cQueryText,
                          string(bttQueryWindow.WindowHandle),
                          (if can-find(first ttQueryWindowField
                                         where ttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
                                           and ttQueryWindowField.Order        > 1) then
                             'Order':U
                           else
                             'Main':U))
  .

qg_lQueryOpen(bttQueryWindow.RecordQueryHandle,
              cQueryText,
              bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowRecordOpenQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordRefresh hQueryWindow 
PROCEDURE qg_QueryWindowRecordRefresh :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Refresh record field browse with current database values.                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.
define variable hField  as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
  on error undo, throw:
  
  run qg_UpdateRecordField( bttQueryWindowField.FieldHandle,
                            bttQueryWindowField.FieldIndex,
                            ( buffer bttQueryWindowField:handle ),
                            bttQueryWindow.DeepResolveObjectIds ).
  
end. /* for each bttQueryWindowField */

run qg_QueryWindowRecordUpdateValues(bttQueryWindow.WindowHandle).
run qg_QueryWindowRecordUpdateTitle(bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowRecordRefresh */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordSelectFields hQueryWindow 
PROCEDURE qg_QueryWindowRecordSelectFields :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select displayed fields.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cAvailableField_Keys   as character no-undo.
define variable cAvailableField_Labels as character no-undo.
define variable cSelectedField_Keys    as character no-undo.

define variable lOk                    as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  cAvailableField_Keys   = qg_cQueryWindowFieldList(bttQueryWindow.WindowHandle,
                                                    yes,
                                                    yes)
  cAvailableField_Labels = qg_cQueryWindowFieldList(bttQueryWindow.WindowHandle,
                                                    no,
                                                    yes)
  cSelectedField_Keys    = qg_cQueryWindowFieldList(bttQueryWindow.WindowHandle,
                                                    yes,
                                                    no)
  .

run qg_SelectionDialog(cAvailableField_Keys,
                       cAvailableField_Labels,
                       input-output cSelectedField_Keys,
                       'Select fields':U,
                       bttQueryWindow.WindowHandle,
                       yes,
                       output lOk).

if lOk then
  run qg_QueryWindowRecordSetFields(bttQueryWindow.WindowHandle,
                                    cSelectedField_Keys).

end procedure. /* qg_QueryWindowRecordSelectFields */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordSetFields hQueryWindow 
PROCEDURE qg_QueryWindowRecordSetFields :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set displayed fields.                                                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/* pcSelectedFields               = Selected fields that should be set.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow         as handle    no-undo.
define input parameter pcSelectedFields as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
  on error undo, throw:
  
  assign
    cFieldName                = qg_cFormattedFieldName( ?,
                                                        bttQueryWindowField.BufferName,
                                                        bttQueryWindowField.FieldName,
                                                        bttQueryWindowField.FieldIndex )
    bttQueryWindowField.Order = ( if pcSelectedFields > '':U then
                                    lookup( (if bttQueryWindowField.IsOverlay then
                                               substitute( {&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                                           cFieldName )
                                             else
                                               cFieldName ),
                                           pcSelectedFields )
                                  else
                                    1 )
    .
  
end. /* for each bttQueryWindowField */

run qg_QueryWindowRecordOpenQuery( bttQueryWindow.WindowHandle ).
run qg_QueryWindowRecordUpdateValues( bttQueryWindow.WindowHandle ).

end procedure. /* qg_QueryWindowRecordSetFields */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordUpdateTitle hQueryWindow 
PROCEDURE qg_QueryWindowRecordUpdateTitle :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update record window title.                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hQuery        as handle    no-undo.
define variable hBuffer       as handle    no-undo.

define variable cDatabaseName as character no-undo.

define variable cTitle        as character no-undo.
define variable cFieldValue   as character no-undo.
define variable clFieldValue  as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttField            for temp-table ttField.
define buffer bttQueryWindowField for temp-table ttQueryWindowField.
define buffer bttIndex            for temp-table ttIndex.
define buffer bttIndexField       for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hQuery = bttQueryWindow.QueryHandle.

if    valid-handle(hQuery)
  and hQuery:num-buffers > 0 then
  hBuffer = hQuery:get-buffer-handle(1).

if not valid-handle(hBuffer) then
  assign
    bttQueryWindow.WindowTitle = substitute('&1[&2] Record - unknown':U,
                                            gcTitlePrefix,
                                            bttQueryWindow.QuerySeq).

else
do:
  
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
  
  if not hBuffer:available then
    cTitle = 'not available':T.
  
  else
  do:
    
    find first bttIndex
      where bttIndex.DatabaseName = cDatabaseName
        and bttIndex.TableName    = hBuffer:table
        and bttIndex.IsPrimary    = yes
      no-error.
    
    if not available bttIndex then
      cTitle = substitute('Rowid: &1':T, hBuffer:rowid).
    
    else
    do:
      
      for each bttIndexField
        where bttIndexField.DatabaseName = bttIndex.DatabaseName
          and bttIndexField.TableName    = bttIndex.TableName
          and bttIndexField.IndexName    = bttIndex.IndexName,
      first bttField
        where bttField.DatabaseName = bttIndexField.DatabaseName
          and bttField.TableName    = bttIndexField.TableName
          and bttField.FieldName    = bttIndexField.FieldName,
      first bttQueryWindowField
        where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
          and bttQueryWindowField.BufferName   = hBuffer:name
          and bttQueryWindowField.FieldName    = bttIndexField.FieldName 
          and bttQueryWindowField.FieldIndex   = 0
        by bttIndexField.IndexSequence
        on error undo, throw:
        
        copy-lob bttQueryWindowField.CurrentUnformattedValue to clFieldValue.
        
        /* If the quoter function is used directly the result ist an odd      */
        /* character sequence. To avoid this we have to do it in two steps    */
        
        assign
          cFieldValue = substring(clFieldValue, 1, 30)
          cTitle      = substitute('&1, &2':U,
                                   cTitle,
                                   (if bttField.DataType = 'character':U then
                                      quoter(cFieldValue)
                                    else
                                      cFieldValue))
          .
        
      end. /* for each bttIndexField */
      
      cTitle = trim(cTitle, ',':U).
      
    end. /* else: if not available bttIndex */
    
  end. /* else: if not hBuffer:available */
  
  bttQueryWindow.WindowTitle = substitute('&1[&2] Record - &3.&4 (&5)':U,
                                          gcTitlePrefix,
                                          bttQueryWindow.QuerySeq,
                                          cDatabaseName,
                                          hBuffer:table,
                                          cTitle).
  
end. /* else: if not valid-handle(hBuffer) */

bttQueryWindow.WindowHandle:title = bttQueryWindow.WindowTitle.

end procedure. /* qg_QueryWindowRecordUpdateTitle */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordUpdateValues hQueryWindow 
PROCEDURE qg_QueryWindowRecordUpdateValues :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Refresh displayed values of record field browse.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = bttQueryWindow.WindowHandle
  on error undo, throw:
  
  run qg_UpdateRecordFieldDisplayValue((buffer bttQueryWindowField:handle),
                                        bttQueryWindow.DisplayRawValues,
                                        255). 
  
end. /* for each bttQueryWindowField */

if bttQueryWindow.RecordQueryHandle:num-results > 0 then
  bttQueryWindow.RecordBrowseHandle:refresh().

end procedure. /* qg_QueryWindowRecordUpdateValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowRecordViewMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowRecordViewMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hRawValues as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  hRawValues         = qg_hGetWidgetByName(bttQueryWindow.RecordMenuHandle,
                                           'mi_RawValues':U)
  hRawValues:checked = bttQueryWindow.DisplayRawValues
  .

end procedure. /* qg_QueryWindowRecordViewMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowResize hQueryWindow 
PROCEDURE qg_QueryWindowResize :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Resize widgets to match the current window size.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Window that contains the widgets.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

case bttQueryWindow.WindowMode:
  
  when {&K_QUERY_WINDOW_MODE_QUERY} then
    run qg_QueryWindowResizeQueryFrame(bttQueryWindow.WindowHandle).
  
  when {&K_QUERY_WINDOW_MODE_RECORD} then
    run qg_QueryWindowResizeRecordFrame(bttQueryWindow.WindowHandle).
  
end case. /* bttQueryWindow.WindowMod */

end procedure. /* qg_QueryWindowResize */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowResizeQueryFrame hQueryWindow 
PROCEDURE qg_QueryWindowResizeQueryFrame :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Resize widgets to match the current window size.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phFrame                        = Frame that contains the widgets.          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame       as handle    no-undo.
define variable hFieldGroup  as handle    no-undo.
define variable hWidget      as handle    no-undo.

define variable hSplitter1   as handle    no-undo.
define variable hFieldBrowse as handle    no-undo.

define variable dNewRow      as decimal   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hFrame = bttQueryWindow.QueryFrameHandle.

assign
  hSplitter1            = qg_hGetWidgetByName(phWindow, 'btnSplitter1':U)
  hFieldBrowse          = qg_hGetWidgetByName(phWindow, 'brFieldSelection':U)
  hSplitter1:row        = (if hFieldBrowse:hidden then
                             hSplitter1:row
                           else
                             max(3, hSplitter1:row))
  phWindow:height       = max(hSplitter1:row + hSplitter1:height + 3, phWindow:height)
  phWindow:width        = (if hFieldBrowse:hidden then
                             max(50, phWindow:width)
                           else
                             max(100, phWindow:width))
  hFrame:width          = max(1, phWindow:width)
  hFrame:virtual-width  = max(1, phWindow:width)
  hFrame:height         = max(1, phWindow:height)
  hFrame:virtual-height = max(1, phWindow:height)
  hSplitter1:width      = phWindow:width
  hSplitter1:row        = min(phWindow:height - 2,
                              max((if hFieldBrowse:hidden then
                                     3
                                   else
                                     3),
                                   hSplitter1:row))
  no-error.

hFieldGroup = hFrame:first-child.

do while valid-handle(hFieldGroup):
  
  hWidget = hFieldGroup:first-child.
  
  do while valid-handle(hWidget):
  
    case hWidget:name:
      
      when 'brQuery':U then
        assign
          hWidget:width  = max(1, phWindow:width)
          dNewRow        = hSplitter1:row + hSplitter1:height
          hWidget:height = max(1, phWindow:height - dNewRow + 1)
          hWidget:row    = dNewRow
          no-error.
        
      when 'cQueryText':U then
        assign
          hWidget:width  = (if hFieldBrowse:hidden then
                              max(1, phWindow:width - 23)
                            else
                              max(1, phWindow:width - 73))
          hWidget:height = hSplitter1:row - 1
          .
      
      when 'btnToggleFieldBrowse':U then
        assign
          hWidget:col    = (if hFieldBrowse:hidden then
                              max(1, phWindow:width - 22)
                            else
                              max(1, phWindow:width - 72))
          hWidget:height = hSplitter1:row - 1
          .
      
      when 'brFieldSelection':U then
        if not hWidget:hidden then
          assign
            hWidget:height = hSplitter1:row - 1
            hWidget:col    = max(1, phWindow:width - 69)
            no-error.
      
      when 'btnExecute':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
      when 'btnColumns':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
      when 'btnEdit':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
      when 'btnDelete':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
      when 'btnCreate':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
      when 'btnDuplicate':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
    end. /* case hWidget:name */

    hWidget = hWidget:next-sibling.
    
  end. /* do while valid-handle(hWidget) */
  
  hFieldGroup = hFieldGroup:next-sibling.
  
end. /* do while valid-handle(hFieldGroup) */

/* Since widgets might be moved after the frame has been resized there will */
/* somtimes be unnessesary scrollbars. As a workaround this can be avoided  */
/* by setting the width attribute a second time.                            */

hFrame:width = hFrame:width no-error.

end procedure. /* qg_QueryWindowResizeQueryFrame */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowResizeRecordFrame hQueryWindow 
PROCEDURE qg_QueryWindowResizeRecordFrame :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Adjust all widgets size and position according to current window size.     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame      as handle    no-undo.
define variable hFieldGroup as handle    no-undo.
define variable hWidget     as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hFrame = bttQueryWindow.RecordFrameHandle.

assign
  phWindow:height       = max(6, phWindow:height)
  phWindow:width        = max(75, phWindow:width)
  hFrame:width          = max(1, phWindow:width)
  hFrame:virtual-width  = max(1, phWindow:width)
  hFrame:height         = max(1, phWindow:height)
  hFrame:virtual-height = max(1, phWindow:height)
  no-error.

hFieldGroup = hFrame:first-child.

do while valid-handle(hFieldGroup):
  
  hWidget = hFieldGroup:first-child.
  
  do while valid-handle(hWidget):
  
    case hWidget:name:
      
      when 'brRecord':U then
        assign
          hWidget:width  = max(1, phWindow:width)
          hWidget:height = max(1, phWindow:height - hWidget:row + 1)
          no-error.
      
      when 'btnSelectObjField':U then
        assign
          hWidget:col = max(1, phWindow:width - 7)
          no-error.
      
      when 'btnFirstRecord':U then
        assign
          hWidget:col = max(1, phWindow:width - 25)
          no-error.
      
      when 'btnPrevRecord':U then
        assign
          hWidget:col = max(1, phWindow:width - 19)
          no-error.
      
      when 'btnNextRecord':U then
        assign
          hWidget:col = max(1, phWindow:width - 13)
          no-error.
      
      when 'btnLastRecord':U then
        assign
          hWidget:col = max(1, phWindow:width - 7)
          no-error.
      
    end. /* case hWidget:name */

    hWidget = hWidget:next-sibling.
    
  end. /* do while valid-handle(hWidget) */
  
  hFieldGroup = hFieldGroup:next-sibling.
  
end. /* do while valid-handle(hFieldGroup) */

end procedure. /* qg_QueryWindowResizeRecordFrame */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSelectNextCondition hQueryWindow 
PROCEDURE qg_QueryWindowSelectNextCondition :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select next condition in query text editor.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plNext                         = If yes the next condition will be         */
/*                                  selected otherwise the previous condition */
/*                                  will be selected.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter plNext   as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/


/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not qg_lSelectNextQueryCondition(bttQueryWindow.QueryTextEditorHandle, plNext) then
do:
  
  if plNext = yes then
    bttQueryWindow.QueryTextEditorHandle:cursor-offset = 1.
  
  else if plNext = no then
    bttQueryWindow.QueryTextEditorHandle:move-to-eof().
  
  qg_lSelectNextQueryCondition(bttQueryWindow.QueryTextEditorHandle, plNext).
  
end. /* if not qg_lSelectNextQueryCondition(bttQueryWindow.QueryTextEditorHandle, plNext) */

return no-apply.

end procedure. /* qg_QueryWindowSelectNextCondition */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowEditQueryBuffers hQueryWindow 
PROCEDURE qg_QueryWindowEditQueryBuffers :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select next condition in query text editor.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* plNext                         = If yes the next condition will be         */
/*                                  selected otherwise the previous condition */
/*                                  will be selected.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iFilterId         as integer   no-undo.
define variable lShowHiddenTables as logical   no-undo.

define variable i                 as integer   no-undo.
define variable hBuffer           as handle    no-undo.

define variable cQueryText        as character no-undo.
define variable cWhereClause      as character no-undo.
define variable cBufferList       as character no-undo.

define variable lMatch            as logical   no-undo.
define variable lContinuous       as logical   no-undo.
define variable iIndexScore       as integer   no-undo extent 2.
define variable iTempIndexScore   as integer   no-undo extent 2.
define variable cFieldList        as character no-undo.
define variable cTempFieldList    as character no-undo.
define variable cValueList        as character no-undo.
define variable cTempValueList    as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow       for temp-table ttQueryWindow.

define buffer bttDatabase          for temp-table ttDatabase.
define buffer bttTable             for temp-table ttTable.
define buffer bttField             for temp-table ttField.
define buffer bttIndex             for temp-table ttIndex.
define buffer bttIndexField        for temp-table ttIndexField.
define buffer bttFilterMatch       for temp-table ttFilterMatch.
define buffer bttQueryBuffer       for temp-table ttQueryBuffer.
define buffer b2ttQueryBuffer      for temp-table ttQueryBuffer.
define buffer bttTableRelation     for temp-table ttTableRelation.
define buffer bttTableRelationView for temp-table ttTableRelationView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

define query brBufferDatabase
  for bttDatabase
  scrolling.

define browse brBufferDatabase
  query brBufferDatabase no-lock
    display
      bttDatabase.DatabaseName width 12
      bttDatabase.PhysicalName
      with no-assign size 70 by 5.

define variable lRelatedTables as logical no-undo init yes
  format 'yes/no':U
  view-as radio-set
    radio-buttons
      'Related tables':T, yes,
      'All tables':T, no
    horizontal
  size 35 by 1.

define variable cTableFilter as character no-undo
  format 'x(32000)':U
  view-as combo-box inner-lines 8
     drop-down
  tooltip "Filter for tables that match given name pattern (comma separated)"
  size 63 by 1.

define button btnClearTableFilter
  label '':T2
  tooltip "Clear table filter"
  size 7 by 1.

define query brBufferTable
  for bttTable,bttFilterMatch
  scrolling.

define browse brBufferTable
  query brBufferTable no-lock
    display
      bttTable.TableName
      bttTable.ShortDescription
      with no-assign size 70 by 10.

define button btnAddTableBuffer
  label 'Add':T
  size 10 by 1.5.

define button btnRemoveTableBuffer
  label 'Remove':T
  size 10 by 1.5.

define button btnEditTableBuffer
  label 'Edit':T
  size 10 by 1.5.

define button btnClearTableBuffers
  label 'Clear':T
  size 10 by 1.5.

define button btnTop
  label 'Top':T
  size 10 by 1.5.

define button btnUp
  label 'Up':T
  size 10 by 1.5.

define button btnDown
  label 'Down':T
  size 10 by 1.5.

define button btnBottom
  label 'Bottom':T
  size 10 by 1.5.

define query brQueryBuffer
  for bttQueryBuffer
  scrolling.

define browse brQueryBuffer
  query brQueryBuffer no-lock
    display
      bttQueryBuffer.BufferName width 32
      bttQueryBuffer.TableDisplayName
      with no-assign size 70 by 18.

define button btnOk
  label 'Ok':T
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

define frame fBufferSelection
  brBufferDatabase at row 1.5 col 3
  lRelatedTables at row 7 col 3 no-label
  cTableFilter at row 8.5 col 3 no-label
  btnClearTableFilter at row 8.5 col 66
  brBufferTable at row 9.5 col 3
  brQueryBuffer at row 1.5 col 91
  btnAddTableBuffer at row 1.5 col 77
  btnRemoveTableBuffer at row 3 col 77
  btnEditTableBuffer at row 5 col 77
  btnClearTableBuffers at row 8.75 col 77
  btnTop at row 12.5 col 77
  btnUp at row 14.5 col 77
  btnDown at row 16 col 77
  btnBottom at row 18 col 77
  btnOk at row 20.5 col 62
  btnCancel at row 20.5 col 82
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 163 by 22.33
    title gcTitlePrefix + 'Select query buffers':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fBufferSelection
  apply 'end-error' to self.

on F3 of frame fBufferSelection anywhere
do:
  
  lRelatedTables = not input frame fBufferSelection lRelatedTables.
  
  display unless-hidden
    lRelatedTables
    with frame fBufferSelection.
  
  apply 'value-changed':U to lRelatedTables in frame fBufferSelection.
  
end. /* on F3 of frame fBufferSelection */

on ins of frame fBufferSelection anywhere
do:
  
  define variable hFocusWidget as handle    no-undo.
  
  hFocusWidget = focus.
  
  if valid-handle(hFocusWidget) then
  do:
    
    /* Fire leave trigger but keep focus in active widget. */
    apply 'leave':U to hFocusWidget.
    apply 'entry':U to hFocusWidget.
    
  end. /* if valid-handle(hFocusWidget) */

  apply 'choose':U to btnAddTableBuffer in frame fBufferSelection.
  
end. /* on ins of frame fBufferSelection */

on del of frame fBufferSelection anywhere
  apply 'choose':U to btnRemoveTableBuffer in frame fBufferSelection.

on value-changed of brBufferDatabase in frame fBufferSelection
do:
  
  define buffer bttTable       for temp-table ttTable.
  define buffer bttFilterMatch for temp-table ttFilterMatch.
  
  if    available(bttDatabase)
    and bttDatabase.PhysicalDB
    and not can-find(first ttTable
                       where ttTable.DatabaseName = bttDatabase.DatabaseName) then
  do:
    
    run qg_AddTables(bttDatabase.DatabaseName).
    
    for each bttTable
      where bttTable.DatabaseName = bttDatabase.DatabaseName
      on error undo, throw:
      
      create bttFilterMatch.
      
      assign
        bttFilterMatch.FilterId      = iFilterId
        bttFilterMatch.RecordRowId   = rowid(bttTable)
        bttFilterMatch.RecordMatches = yes
        .
      
      validate bttFilterMatch.
      
    end. /* for each bttTable */

  end. /* if    available(bttDatabase) */
  
  apply 'U1':U to brBufferTable in frame fBufferSelection.
  
end. /* on value-changed of brBufferDatabase */

on value-changed of lRelatedTables in frame fBufferSelection
  apply 'U1':U to brBufferTable in frame fBufferSelection.

on value-changed of cTableFilter in frame fBufferSelection
  apply 'U1':U to brBufferTable in frame fBufferSelection.

on choose of btnClearTableFilter in frame fBufferSelection
do:
  
  cTableFilter = '':U.
  
  display unless-hidden
    cTableFilter
    with frame fBufferSelection.
  
  apply 'value-changed':U to cTableFilter in frame fBufferSelection.
  
end. /* on choose of btnClearTableFilter */

on U1 of brBufferTable in frame fBufferSelection
do:
  
  define variable cDatabaseName       as character no-undo.
  define variable cFilterEntry        as character no-undo.
  define variable cPrepFilter         as character no-undo.
  
  define variable i                   as integer       no-undo.
  
  define variable cBufferDatabaseName as character no-undo.
  define variable cBufferTableName    as character no-undo.
  
  assign
    cDatabaseName  = (if available bttDatabase then
                        bttDatabase.DatabaseName
                      else
                        ?)
    cTableFilter   = input frame fBufferSelection cTableFilter
    lRelatedTables = input frame fBufferSelection lRelatedTables
    .
  
  if not available bttQueryBuffer then
    cBufferDatabaseName = cDatabaseName.
  
  else
    assign
      cBufferDatabaseName = bttQueryBuffer.DatabaseName
      cBufferTableName    = bttQueryBuffer.TableName
      .
  
  do i = 1 to num-entries(cTableFilter):
    
    assign
      cFilterEntry = entry(i, cTableFilter).
      cPrepFilter  = substitute('&1,&2':U,
                                cPrepFilter,
                                qg_cFilterEntryMatchcode(cFilterEntry))
      .
    
  end. /* do i = 1 to num-entries(cFilter) */
  
  cPrepFilter = (if cPrepFilter = '':U then
                   '*':U
                 else
                   trim(cPrepFilter, ',':U)).
  
  for each bttTable
    where bttTable.DatabaseName = cDatabaseName,
  first bttFilterMatch
    where bttFilterMatch.FilterId    = iFilterId
      and bttFilterMatch.RecordRowId = rowid(bttTable)
    on error undo, throw:
    
    bttFilterMatch.RecordMatches =     can-do(cPrepFilter, bttTable.TableName)
                                   and ( lShowHiddenTables
                                      or ( not can-do('sys*':U, bttTable.TableName)
                                       and not can-do('_*':U, bttTable.TableName) ) )
                                   and ( not lRelatedTables
                                      or cBufferTableName = '':U 
                                      or can-find(first ttTableRelationView
                                                    where ttTableRelationView.DatabaseName       = cBufferDatabaseName
                                                      and ttTableRelationView.ReferenceTableName = cBufferTableName
                                                      and ttTableRelationView.RelatedTableName   = bttTable.TableName ) ).
    
    validate bttFilterMatch.
    
  end. /* for each bttTableRelationView */
  
  open query brBufferTable
    for each bttTable
      where bttTable.DatabaseName = cDatabaseName,
    first bttFilterMatch
      where bttFilterMatch.FilterId      = iFilterId
        and bttFilterMatch.RecordRowId   = rowid(bttTable)
        and bttFilterMatch.RecordMatches = yes
      .
  
  apply 'value-changed':U to browse brBufferTable.
  
end. /* on value-changed of cTableFilte */

on leave of cTableFilter in frame fBufferSelection
do:
  
  if available bttDatabase then
    run qg_FixCase(cTableFilter:handle in frame fBufferSelection,
                   bttDatabase.DatabaseName,
                   ?,
                   {&K_CASEMODE_TABLE}).
  
  if brBufferTable:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(cTableFilter:handle in frame fBufferSelection).
  
end. /* on leave of cTableFilter */

on end-error of cTableFilter in frame fBufferSelection
do:
  
  apply 'choose':U to btnClearTableFilter in frame fBufferSelection.
  return no-apply.
  
end. /* on end-error of cTableFilter */

on default-action of brBufferTable in frame fBufferSelection
  apply 'choose':U to btnAddTableBuffer in frame fBufferSelection.

on row-display of brBufferTable in frame fBufferSelection
do:
  
  if    not bttTable.DescriptionLoaded
    
    /* For performance reasons we only do this when the database is connected */
    /* in shared memory mode.                                                 */
    
    and ( available bttDatabase
      and ( bttDatabase.SharedMemory
         or not bttDatabase.PhysicalDB ) ) then
    
    run qg_AddTableRepositoryInfo(bttTable.DatabaseName, bttTable.TableName).

  bttTable.ShortDescription:fgcolor in browse brBufferTable = {&K_COLOR_LIGHT_GREY}.
  
end. /* on row-display of brBufferDatabase in frame fBufferSelection */

on U1 of brQueryBuffer in frame fBufferSelection
do:
  
  open query brQueryBuffer
    for each bttQueryBuffer
    use-index Order.
  
  apply 'value-changed':U to brQueryBuffer in frame fBufferSelection.
  
end. /* on U1 of brQueryBuffer */

on value-changed of brQueryBuffer in frame fBufferSelection
do:
  
  if input frame fBufferSelection lRelatedTables then
    apply 'U1':U to brBufferTable in frame fBufferSelection.
  
end. /* on 'value-changed':U of frame fBufferSelection */

on choose of btnAddTableBuffer in frame fBufferSelection
do:
  
  define variable iOrder      as integer   no-undo.
  
  define variable iBuffer     as integer   no-undo.
  define variable cBufferName as character no-undo.
  
  define buffer bttQueryBuffer for temp-table ttQueryBuffer.
  
  find last bttQueryBuffer
    where bttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
    use-index Order
    no-error.
  
  iOrder = (if available bttQueryBuffer then
              bttQueryBuffer.Order + 1
            else
              1).
  
  if available bttTable then
  do:
    
    do while yes:
      
      case iBuffer:
        
        when 0 then
          cBufferName = bttTable.TableName.
        
        when 1 then
          cBufferName = substitute('b&1':U,
                                   bttTable.TableName).
        
        otherwise
          cBufferName = substitute('b&1&2':U,
                                   string(iBuffer),
                                   bttTable.TableName).
        
      end case. /* iBuffer */
      
      find bttQueryBuffer
        where bttQueryBuffer.QuerySeq   = bttQueryWindow.QuerySeq
          and bttQueryBuffer.BufferName = cBufferName
        no-error.
      
      if not available bttQueryBuffer then
        leave.
      
      iBuffer = iBuffer + 1.
      
    end. /* do while yes */
    
    create bttQueryBuffer.
    
    assign
      bttQueryBuffer.QuerySeq         = bttQueryWindow.QuerySeq
      bttQueryBuffer.BufferName       = cBufferName
      bttQueryBuffer.DatabaseName     = bttTable.DatabaseName
      bttQueryBuffer.TableName        = bttTable.TableName
      bttQueryBuffer.TableDisplayName = substitute('&1.&2':U,
                                                   bttQueryBuffer.DatabaseName,
                                                   bttQueryBuffer.TableName)
      bttQueryBuffer.Order            = iOrder
      .
    
    validate bttQueryBuffer.
    
    if not bttTable.DetailsLoaded then
      run qg_AddTableDetails(bttTable.DatabaseName,
                             bttTable.TableName).
    
    apply 'U1':U to brQueryBuffer in frame fBufferSelection.
    
    if    query brQueryBuffer:num-results > 0
      and can-find(first ttFilterMatch
                     where ttFilterMatch.FilterId    = iFilterId
                       and ttFilterMatch.RecordRowId = rowid(bttTable)) then
    do:
      reposition brQueryBuffer to rowid rowid(bttQueryBuffer) no-error.
      apply 'value-changed':U to brQueryBuffer in frame fBufferSelection.
    end. /* if    query brQueryBuffer:num-results > 0 */
    
  end. /* if available bttTable */
  
end. /* on choose of btnAddTableBuffer */

on choose of btnRemoveTableBuffer in frame fBufferSelection
do:
  
  define variable iOrder    as integer   no-undo.
  define variable iNewOrder as integer   no-undo.
  
  define buffer b2ttQueryBuffer for temp-table ttQueryBuffer.
  
  if available bttQueryBuffer then
  do:
    
    assign
      iOrder    = bttQueryBuffer.Order
      iNewOrder = iOrder
      .
    
    delete bttQueryBuffer.
    
    for each b2ttQueryBuffer
      where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
        and b2ttQueryBuffer.Order    > iOrder
      use-index Order
      on error undo, throw:
      
      b2ttQueryBuffer.Order = iNewOrder.
      
      validate bttQueryBuffer.
      
      iNewOrder = iNewOrder + 1.
      
    end. /* for each b2ttQueryBuffer */
    
    apply 'U1':U to brQueryBuffer in frame fBufferSelection.
    
    find first b2ttQueryBuffer
      where b2ttQueryBuffer.QuerySeq = bttQuerywindow.QuerySeq
        and b2ttQueryBuffer.Order   >= iOrder
      use-index Order
      no-error.
    
    if not available b2ttQueryBuffer then
      find last b2ttQueryBuffer
        where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
        use-index Order
        no-error.
    
    if    available b2ttQueryBuffer
      and query brQueryBuffer:num-results > 0 then
    do:
      reposition brQueryBuffer to rowid rowid(b2ttQueryBuffer) no-error.
      apply 'value-changed':U to brQueryBuffer in frame fBufferSelection.
    end. /* if    available b2ttQueryBuffer */
    
  end. /* if available bttQueryBuffer */
  
end. /* on choose of btnRemoveTableBuffer */

on choose of btnClearTableBuffers in frame fBufferSelection
do:
  
  define buffer bttQueryBuffer for temp-table ttQueryBuffer.
  
  for each bttQueryBuffer
    where bttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
    on error undo, throw:
    
    delete bttQueryBuffer.
    
  end. /* for each bttQueryBuffer */
  
  apply 'U1':U to brQueryBuffer in frame fBufferSelection.
  
end. /* on choose of btnClearTableBuffers in frame fBufferSelection */

on choose of btnTop in frame fBufferSelection
do:
  
  define variable iOrder as integer   no-undo.
  define variable rRowId as rowid     no-undo.
  
  define buffer b2ttQueryBuffer for temp-table ttQueryBuffer.
  
  if    available bttQueryBuffer
    and bttQueryBuffer.Order > 1 then
  do:
    
    for each b2ttQueryBuffer
      where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
        and b2ttQueryBuffer.Order    < bttQueryBuffer.Order
      use-index Order
      on error undo, throw:
      
      b2ttQueryBuffer.Order = b2ttQueryBuffer.Order + 1.
      
    end. /* for each b2ttQueryBuffer */
    
    bttQueryBuffer.Order = 1.
    
    rRowId = rowid(bttQueryBuffer).
    
    apply 'U1':U to brQueryBuffer in frame fBufferSelection.
    
    reposition brQueryBuffer to rowid rRowId no-error.
    
  end. /* if available bttQueryBuffer */
  
end. /* on choose of btnTop in frame fBufferSelection */

on choose of btnUp in frame fBufferSelection
do:
  
  define variable iOrder as integer   no-undo.
  define variable rRowId as rowid     no-undo.
  
  define buffer b2ttQueryBuffer for temp-table ttQueryBuffer.
  
  if    available bttQueryBuffer
    and bttQueryBuffer.Order > 1 then
  do:
    
    find last b2ttQueryBuffer
      where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
        and b2ttQueryBuffer.Order    < bttQueryBuffer.Order
      use-index Order
      no-error.
    
    if available b2ttQueryBuffer then
    do:
    
      assign
        iOrder                 = bttQueryBuffer.Order
        bttQueryBuffer.Order   = b2ttQueryBuffer.Order
        b2ttQueryBuffer.Order  = iOrder
        .
      
      validate bttQueryBuffer.
      validate b2ttQueryBuffer.
      
      rRowId = rowid(bttQueryBuffer).
      
      apply 'U1':U to brQueryBuffer in frame fBufferSelection.
      
      reposition brQueryBuffer to rowid rRowId no-error.
      
    end. /* if available b2ttQueryBuffer */
    
  end. /* if available bttQueryBuffer */
  
end. /* on choose of btnUp in frame fBufferSelection */

on choose of btnDown in frame fBufferSelection
do:
  
  define variable iOrder as integer   no-undo.
  define variable rRowId as rowid     no-undo.
  
  define buffer b2ttQueryBuffer for temp-table ttQueryBuffer.
  
  if available bttQueryBuffer then
  do:
    
    find first b2ttQueryBuffer
      where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
        and b2ttQueryBuffer.Order    > bttQueryBuffer.Order
      use-index Order
      no-error.
    
    if available b2ttQueryBuffer then
    do:
    
      assign
        iOrder                 = bttQueryBuffer.Order
        bttQueryBuffer.Order   = b2ttQueryBuffer.Order
        b2ttQueryBuffer.Order  = iOrder
        .
      
      validate bttQueryBuffer.
      validate b2ttQueryBuffer.
      
      rRowId = rowid(bttQueryBuffer).
      
      apply 'U1':U to brQueryBuffer in frame fBufferSelection.
      
      reposition brQueryBuffer to rowid rRowId.
      
    end. /* if available b2ttQueryBuffer */
    
  end. /* if available bttQueryBuffer */
  
end. /* on choose of btnDown in frame fBufferSelection */

on choose of btnBottom in frame fBufferSelection
do:
  
  define variable iOrder as integer   no-undo.
  define variable rRowId as rowid     no-undo.
  
  define buffer b2ttQueryBuffer for temp-table ttQueryBuffer.
  
  if available bttQueryBuffer then
  do:
    
    find last b2ttQueryBuffer
      where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
      use-index Order
      no-error.
    
    if    available b2ttQueryBuffer
      and b2ttQueryBuffer.Order > bttQueryBuffer.Order then
    do:
      
      iOrder = b2ttQueryBuffer.Order.
      
      for each b2ttQueryBuffer
        where b2ttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
          and b2ttQueryBuffer.Order    > bttQueryBuffer.Order
        use-index Order
        on error undo, throw:
        
        b2ttQueryBuffer.Order = b2ttQueryBuffer.Order - 1.
        
      end. /* for each b2ttQueryBuffer */
      
      bttQueryBuffer.Order = iOrder.
      
      rRowId = rowid(bttQueryBuffer).
      
      apply 'U1':U to brQueryBuffer in frame fBufferSelection.
      
      reposition brQueryBuffer to rowid rRowId.
      
    end. /* if    available b2ttQueryBuffer ... */
    
  end. /* if available bttQueryBuffer */
  
end. /* on choose of btnBottom in frame fBufferSelection */

iFilterId = qg_iFilterSeq().

for each bttTable
  on error undo, throw:
  
  create bttFilterMatch.
  
  assign
    bttFilterMatch.FilterId      = iFilterId
    bttFilterMatch.RecordRowId   = rowid(bttTable)
    bttFilterMatch.RecordMatches = yes
    .
  
  validate bttFilterMatch.
  
end. /* for each bttTable */

empty temp-table ttQueryBuffer.

do i = 1 to bttQueryWindow.QueryHandle:num-buffers:

  hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(i).

  create bttQueryBuffer.
  
  assign
    bttQueryBuffer.QuerySeq         = bttQueryWindow.QuerySeq
    bttQueryBuffer.BufferName       = hBuffer:name
    bttQueryBuffer.DatabaseName     = qg_cDatabaseNameForTableOrBuffer( hBuffer )
    bttQueryBuffer.TableName        = hBuffer:table
    bttQueryBuffer.TableDisplayName = substitute('&1.&2':U,
                                                 bttQueryBuffer.DatabaseName,
                                                 bttQueryBuffer.TableName)
    bttQueryBuffer.Order            = i
    .

end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers */

display unless-hidden
  brBufferDatabase
  lRelatedTables
  cTableFilter
  brBufferTable
  brQueryBuffer
  with frame fBufferSelection
    in window bttQueryWindow.WindowHandle.

assign
  cTableFilter:delimiter in frame fBufferSelection
      = chr(1)
  cTableFilter:list-items in frame fBufferSelection
      = gcTableFilter:list-items in frame {&FRAME-NAME}
  .

run qg_InitBrowse(browse brBufferDatabase:handle).
run qg_InitBrowse(browse brBufferTable:handle).
run qg_InitBrowse(browse brQueryBuffer:handle).

apply 'U1':U to brQueryBuffer in frame fBufferSelection.

open query brBufferDatabase
  for each bttDatabase
    no-lock.

apply 'value-changed':U to brBufferDatabase in frame fBufferSelection.

update unless-hidden
  cTableFilter
  btnClearTableFilter
  brBufferTable
  btnAddTableBuffer
  btnRemoveTableBuffer
  btnEditTableBuffer
  btnClearTableBuffers
  btnTop
  btnUp
  btnDown
  btnBottom
  brQueryBuffer
  btnOk
  btnCancel
  brBufferDatabase
  lRelatedTables
  with frame fBufferSelection
    in window bttQueryWindow.WindowHandle.

for each bttQueryBuffer
  where bttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
  by bttQueryBuffer.Order
  on error undo, throw:
  
  assign
    cQueryText   = (if cQueryText > '':U then
                      substitute('&1,~neach &2':U,
                                 cQueryText,
                                 bttQueryBuffer.BufferName)
                    else
                      substitute('for each &1':U,
                                 bttQueryBuffer.BufferName))
    cWhereClause = '':U
    cBufferList  = substitute('&1,&2.&3:&4',
                              cBufferList,
                              bttQueryBuffer.DatabaseName,
                              bttQueryBuffer.TableName,
                              bttQueryBuffer.BufferName)
    .
  
  find bttTable
    where bttTable.DatabaseName = bttQueryBuffer.DatabaseName
      and bttTable.TableName    = bttQueryBuffer.TableName
    no-error.
  
  if    available bttTable
    and not bttTable.DetailsLoaded then
    run qg_AddTableDetails(bttTable.DatabaseName,
                           bttTable.TableName).
  
  for each b2ttQueryBuffer
    where b2ttQueryBuffer.QuerySeq = bttQueryBuffer.QuerySeq
      and b2ttQueryBuffer.Order    < bttQueryBuffer.Order,
  first bttTableRelationView
    where bttTableRelationView.DatabaseName       = bttQueryBuffer.DatabaseName
      and bttTableRelationView.ReferenceTableName = bttQueryBuffer.TableName
      and bttTableRelationView.RelatedTableName   = b2ttQueryBuffer.TableName,
  first bttTableRelation
    where bttTableRelation.RelationId = bttTableRelationView.RelationId
    by b2ttQueryBuffer.Order descending
    on error undo, throw:
    
    cWhereClause = qg_cCreateRelatedWhereClause(buffer bttTableRelation,
                                                (bttTableRelation.ParentTableName = b2ttQueryBuffer.TableName),
                                                bttQueryBuffer.BufferName,
                                                b2ttQueryBuffer.BufferName,
                                                ?).
    
    if cWhereClause > '':U then
      leave.
    
  end. /* for each b2ttQueryBuffer */
  
  if   cWhereClause = ?
    or cWhereClause = '':U then
  do:
    
    assign
      iIndexScore     = 0
      cFieldList      = '':U
      cValueList      = '':U
      .
    
    for each bttIndex
      where ( bttIndex.DatabaseName = bttQueryBuffer.DatabaseName
          and bttIndex.TableName    = bttQueryBuffer.TableName
          and bttIndex.IsPrimary    = yes )
         or ( bttIndex.DatabaseName = bttQueryBuffer.DatabaseName
          and bttIndex.TableName    = bttQueryBuffer.TableName
          and bttIndex.IsPrimary    = no )
      on error undo, throw:
      
      assign
        lContinuous     = yes
        iTempIndexScore = 0
        cTempFieldList  = '':U
        cTempValueList  = '':U
        .
      
      for each bttIndexField
        where bttIndexField.DatabaseName = bttIndex.DatabaseName
          and bttIndexField.TableName    = bttIndex.Tablename
          and bttIndexField.IndexName    = bttIndex.IndexName
        by bttIndexField.IndexSequence
        on error undo, throw:
        
        lMatch = no.
        
        for each b2ttQueryBuffer
          where b2ttQueryBuffer.QuerySeq = bttQueryBuffer.QuerySeq
            and b2ttQueryBuffer.Order    < bttQueryBuffer.Order,
        each bttField
          where bttField.DatabaseName = b2ttQueryBuffer.DatabaseName
            and bttField.TableName    = b2ttQueryBuffer.TableName
            and bttField.FieldName    = bttIndexField.FieldName
          by b2ttQueryBuffer.Order descending
          on error undo, throw:
          
          assign
            cTempFieldList = substitute('&1,&2':U,
                                        cTempFieldList,
                                        bttIndexField.FieldName)
            cTempValueList = substitute('&1&2&3':U,
                                        cTempValueList,
                                        {&K_PARAM_SPLITTER},
                                        (if can-do({&K_COMPANY_FIELDS}, bttIndexField.FieldName) then
                                           substitute('~'&1~'',
                                                      qg_cGetCompany(bttField.TableName, ?))
                                         else
                                           qg_cFormattedFieldName(?,
                                                                  b2ttQueryBuffer.BufferName,
                                                                  bttField.FieldName,
                                                                  0)))
            lMatch         = yes
            .
        
        end. /* for each b2ttQueryBuffer */
        
        if not lMatch then
          lContinuous = no.
        
        else
          iTempIndexScore[2 - integer(lContinuous)] = iTempIndexScore[2 - integer(lContinuous)] + 1.
        
      end. /* for each bttIndexField */
      
      if    iTempIndexScore[1] > iIndexScore[1]
         or ( iTempIndexScore[1] = iIndexScore[1]
          and iTempIndexScore[2] > iIndexScore[2] ) then
        assign
          cFieldList = trim(cTempFieldList, ',':U)
          cValueList = trim(cTempValueList, {&K_PARAM_SPLITTER})
          .
      
    end. /* for each bttIndex */
    
    if cFieldList > '':U then
      cWhereClause = qg_cCreateWhereClause( /* pcDatabaseName   */ bttQueryBuffer.DatabaseName,
                                            /* pcTableNames     */ bttQueryBuffer.TableName,
                                            /* pcBufferNames    */ bttQueryBuffer.BufferName,
                                            /* pcFieldList      */ cFieldList,
                                            /* pcFieldLabelList */ ?,
                                            /* plStartWithWhere */ yes,
                                            /* piValueMode      */ {&K_VALUE_MODE_PARAMETER},
                                            /* pcValueList      */ cValueList,
                                            /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                            /* plAddTags        */ no,
                                            /* piIndentBlanks   */ 2 ).
    
  end. /* if   cWhereClause = ? */
  
  if cWhereClause > '':U then
    cQueryText = substitute('&1~n&2':U, cQuerytext, cWhereClause).
  
/*  assign                                           */
/*    cPrevDatabaseName = bttQueryBuffer.DatabaseName*/
/*    cPrevTableName    = bttQueryBuffer.TableName   */
/*    cPrevBufferName   = bttQueryBuffer.BufferName  */
/*    .                                              */
  
end. /* for each bttQueryBuffer */

assign
  cBufferList              = trim(cBufferList, ',':U).
  bttQueryWindow.QueryText = cQueryText
  .

validate bttQuerywindow.

if valid-handle(bttQueryWindow.QueryFrameHandle) then
  bttQueryWindow.QueryTextEditorHandle:screen-value = bttQueryWindow.QueryText.

run qg_QueryWindowUpdateQuery(bttQueryWindow.WindowHandle, cBufferList).

/*run qg_QueryWindowListRefresh.*/

/*message                 */
/*  cQueryText skip       */
/*  view-as alert-box     */
/*  title program-name(1).*/

finally:

/*  if cTableFilter:list-items in frame fBufferSelection > '':U then*/
/*    assign                                                        */
/*      cTableFilter = input frame {&FRAME-NAME} gcTableFilter      */
/*      gcTableFilter:list-items in frame {&FRAME-NAME}             */
/*          = cTableFilter:list-items in frame fBufferSelection     */
/*      gcTableFilter:screen-value in frame {&FRAME-NAME}           */
/*          = cTableFilter                                          */
/*      .                                                           */
  
  if iFilterId > 0 then
    
    for each bttFilterMatch
      where bttFilterMatch.FilterId = iFilterId
      on error undo, next:
      
      delete bttFilterMatch.
      
    end. /* for each bttFilterMatch */
    
  if available bttQueryWindow then
  
    for each bttQueryBuffer
      where bttQueryBuffer.QuerySeq = bttQueryWindow.QuerySeq
      on error undo, next:
      
      delete bttQueryBuffer.
      
    end. /* for each bttQueryBuffer */
    
end finally.

end procedure. /* qg_QueryWindowEditQueryBuffers */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetComparator hQueryWindow 
PROCEDURE qg_QueryWindowSetComparator :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow     as handle    no-undo.
define input parameter pcComparator as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText   as character no-undo.
define variable iOffset      as integer   no-undo.

define variable i            as integer   no-undo.
define variable iConditionNo as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow    for temp-table ttQueryWindow.
define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if    bttQueryWindow.ObjSourceQuerySeq > 0
   or not valid-handle(bttQueryWindow.QueryFrameHandle) then
  leave.

assign
  iOffset    = bttQueryWindow.QueryTextEditorHandle:cursor-offset
  cQueryText = bttQueryWindow.QueryTextEditorHandle:input-value
  .

run qg_ParseQueryConditions(cQueryText).

for each bttQueryCondition
  on error undo, throw:
  
  i = i + 1.
  
  if    bttQueryCondition.StartPos <= iOffset
    and bttQueryCondition.EndPos   >= iOffset then
  do:
    
    iConditionNo = i.
    leave.
    
  end. /* if    bttQueryCondition.StartPos <= iOffset */
  
end. /* for each bttQueryCondition */

if available bttQueryCondition then
  assign
    cQueryText = substitute('&1 &2 &3':U,
                            right-trim(substring(cQueryText,
                                                 1,
                                                 bttQueryCondition.ComparatorStartPos - 1)),
                            pcComparator,
                            left-trim(substring(cQueryText,
                                                bttQueryCondition.ComparatorEndPos)))
    cQueryText = qg_cBeautifyQueryText(cQuerytext)
    bttQueryWindow.QueryTextEditorHandle:screen-value  = cQueryText
    .

if iConditionNo > 0 then
do:
  
  run qg_ParseQueryConditions(cQueryText).
  
  i = 0.
  
  for each bttQueryCondition
    on error undo, throw:
    
    i = i + 1.
    
    if i = iConditionNo then
    do:
      
      bttQueryWindow.QueryTextEditorHandle:cursor-offset = bttQueryCondition.StartPos.
      run qg_QueryWindowSelectNextCondition(bttQueryWindow.WindowHandle, yes).
      
      leave.
      
    end. /* if i = iConditionNo */
    
  end. /* for each bttQueryCondition */
  
  apply 'entry':U to bttQueryWindow.QueryTextEditorHandle.
  
end. /* if iConditionNo > 0 */

end procedure. /* qg_QueryWindowSetComparator */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetFocus hQueryWindow 
PROCEDURE qg_QueryWindowSetFocus :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set focus to given widget.                                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcWidgetName                   = Name of the Widget to set focus to.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow     as handle    no-undo.
define input parameter pcWidgetName as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hWidget as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hWidget = qg_hGetWidgetByName(bttQueryWindow.WindowHandle, pcWidgetName).

if hWidget:name = 'cQueryText':U then
do:
  
  hWidget:cursor-offset = 1.
  qg_lSelectNextQueryCondition(hWidget, yes).
  
end. /* if phWidget:name = 'cQueryText':U */

apply 'entry':U to hWidget.

end procedure. /* qg_QueryWindowSetFocus */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetQueryText hQueryWindow 
PROCEDURE qg_QueryWindowSetQueryText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.
define input parameter pcQueryText as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/


/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

bttQueryWindow.QueryText = pcQueryText.

run qg_ParseQueryLinks(bttQueryWindow.QueryText,
                       bttQueryWindow.QuerySeq,
                       temp-table ttQueryLink:handle).

run qg_QueryWindowListRefresh.

end procedure. /* PROCEDURE qg_QueryWindowSetQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowQuerySetQueryText hQueryWindow 
PROCEDURE qg_QueryWindowQuerySetQueryText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set query text to given editor and place cursor to the first value.        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phEditor                       = Editor widget.                            */
/* pcQueryText                    = Query text.                               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow               as handle    no-undo.
define input parameter pcQueryText            as character no-undo.
define input parameter plSelectFirstCondition as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  bttQueryWindow.QueryTextEditorHandle:screen-value  = pcQueryText
  bttQueryWindow.QueryTextEditorHandle:cursor-offset = 1
  .

if plSelectFirstCondition then
  qg_lSelectNextQueryCondition(bttQueryWindow.QueryTextEditorHandle, yes).

end procedure. /* qg_QueryWindowQuerySetQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetSize hQueryWindow 
PROCEDURE qg_QueryWindowSetSize :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set Query window to a predefined size.                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* piSize                         = Size code to use.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.
define input parameter piSize   as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hSplitter1      as handle    no-undo.
define variable hFieldBrowse    as handle    no-undo.

define variable dSplitterMinRow as decimal   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
  assign
    hSplitter1      = qg_hGetWidgetByName(bttQueryWindow.QueryFrameHandle, 'btnSplitter1':U)
    hFieldBrowse    = qg_hGetWidgetByName(bttQueryWindow.QueryFrameHandle, 'brFieldSelection':U)
    dSplitterMinRow = (if hFieldBrowse:hidden then
                         3
                       else
                         4)
    .

case piSize:
  
  when {&K_QUERY_SIZE_MODE_DEFAULT} then
  do:
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
      hSplitter1:row = 7 no-error.
    
    assign
      bttQueryWindow.WindowHandle:width  = 150
      bttQueryWindow.WindowHandle:height = 18
      no-error.
    
  end. /* when {&K_QUERY_SIZE_MODE_DEFAULT} */
  
  when {&K_QUERY_SIZE_MODE_DEFAULT_SPLITTER} then
  do:
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
    do:
      
      if    bttQueryWindow.WindowHandle:width  = 150
        and bttQueryWindow.WindowHandle:height = 18 then
      do:

        if hSplitter1:row < 7 then
          hSplitter1:row = truncate(hSplitter1:row, 0) + 1.

        else
          hSplitter1:row = dSplitterMinRow.

      end. /* if    bttQueryWindow.WindowHandle:width  = 150 */
    
      hSplitter1:row = (if hSplitter1:row > 7 then
                          7
                        else
                          hSplitter1:row).
      
    end. /* if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} */
    
    assign
      bttQueryWindow.WindowHandle:width  = 150
      bttQueryWindow.WindowHandle:height = 18
      no-error.
    
  end. /* when {&K_QUERY_SIZE_MODE_DEFAULT_SPLITTER} */

  when {&K_QUERY_SIZE_MODE_SMALL} then
  do:
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
      hSplitter1:row = dSplitterMinRow no-error.
    
    assign
      bttQueryWindow.WindowHandle:width  = 150
      bttQueryWindow.WindowHandle:height = hSplitter1:row + hSplitter1:height + 3
      no-error.
      
  end. /* when {&K_QUERY_SIZE_MODE_SMALL} */
  
  when {&K_QUERY_SIZE_MODE_MINIMUM} then
  do:
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
      hSplitter1:row = dSplitterMinRow no-error.
    
    assign
      bttQueryWindow.WindowHandle:width  = (if hFieldBrowse:hidden then
                                              50
                                            else
                                              100)
      bttQueryWindow.WindowHandle:height = hSplitter1:row + hSplitter1:height + 3
      no-error.
    
  end. /* when {&K_QUERY_SIZE_MODE_MINIMUM} */
  
  when {&K_QUERY_SIZE_MODE_BIG} then
  do:
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY} then
      hSplitter1:row = 7 no-error.
    
    assign
      bttQueryWindow.WindowHandle:width  = 235
      bttQueryWindow.WindowHandle:height = 32
      no-error.
    
  end. /* when {&K_QUERY_SIZE_MODE_BIG} */
  
  when {&K_RECORD_SIZE_MODE_DEFAULT} then
    assign
      bttQueryWindow.WindowHandle:width  = 80
      bttQueryWindow.WindowHandle:height = 18
      no-error.
  
  otherwise
    leave.
  
end case. /* piSize */

run qg_QueryWindowResize(bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowSetSize */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetVisibleState hQueryWindow 
PROCEDURE qg_QueryWindowSetVisibleState :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set query window visible state.                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piSourceSeq                    = QuerySeq of the query window.             */
/* plVisible                      = Visible state that should be set.         */
/* plChildren                     = If yes the visible state is set for       */
/*                                  linked child windows as well.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piQuerySeq as integer   no-undo.
define input parameter plVisible  as logical   no-undo.
define input parameter plChildren as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.
define buffer bttQueryLink    for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttQueryWindow
  where bttQueryWindow.QuerySeq = piQuerySeq
  no-error.

if not available bttQueryWindow then
  leave.

bttQueryWindow.WindowHandle:visible = plVisible.

if plChildren then
do:

  for each bttQueryLink
    where bttQueryLink.SourceSeq = piQuerySeq,
  first bttQueryWindow
    where bttQueryWindow.QuerySeq = bttQueryLink.TargetSeq
    on error undo, throw:
    
    run qg_QueryWindowSetVisibleState(bttQueryWindow.QuerySeq, plVisible, yes).
    
  end. /* for each bttQueryLink */
  
end. /* if plChildren */

end procedure. /* qg_QueryWindowSetVisibleState */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetWindowMode hQueryWindow 
PROCEDURE qg_QueryWindowSetWindowMode :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow         as handle    no-undo.
define input parameter piWindowMode     as integer   no-undo.
define input parameter pcQueryText      as character no-undo.
define input parameter plFocusQueryText as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                       as integer   no-undo.

define variable hBuffer                 as handle    no-undo extent.
define variable rCurrentRecord          as rowid     no-undo extent.
define variable cDatabaseName           as character no-undo.
define variable cTableName              as character no-undo.

define variable cWindowTitle            as character no-undo.
define variable cIconFilename           as character no-undo.
define variable cSmallIconFilename      as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

bttQueryWindow.WindowMode = piWindowMode.

validate bttQueryWindow.

if    valid-handle(bttQueryWindow.QueryHandle)
  and bttQueryWindow.QueryHandle:num-buffers > 0 then
do:
  
  assign
    extent(hBuffer)        = bttQueryWindow.QueryHandle:num-buffers
    extent(rCurrentRecord) = bttQueryWindow.QueryHandle:num-buffers
      .
  
  do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
    
    assign
      hBuffer[i]        = bttQueryWindow.QueryHandle:get-buffer-handle(i)
      rCurrentRecord[i] = hBuffer[i]:rowid
      .
    
  end. /* do i = 1 to extent(hBuffer) */
  
  assign
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer[1] )
    cTableName    = hBuffer[1]:table
    .
  
end. /* if bttQueryWindow.QueryHandle:num-buffers > 0 */

case piWindowMode:
  
  when {&K_QUERY_WINDOW_MODE_QUERY} then
  do:
    
    assign
      cIconFilename      = (if gcIconDir > '':U then
                              substitute('&1/32/table_go.ico':U,
                                         gcIconDir)
                            else
                              search('adeicon/startdbs.ico':U))
      cSmallIconFilename = (if gcIconDir > '':U then
                              substitute('&1/16/table_go.ico':U,
                                         gcIconDir)
                            else
                              '':U)
      .
    
    if not valid-handle(bttQueryWindow.QueryFrameHandle) then
    do:
      
      run qg_QueryWindowCreateQueryFrame(bttQueryWindow.WindowHandle).
      
      run qg_QueryWindowQuerySetQueryText(bttQueryWindow.WindowHandle,
                                          (if pcQueryText > '':U then
                                             pcQueryText
                                           else
                                             bttQueryWindow.QueryText),
                                          plFocusQueryText).
      
      run qg_QueryWindowRefreshBrowseColumns(bttQueryWindow.WindowHandle).
      
      run qg_QueryWindowQueryOpenFieldQuery(bttQueryWindow.WindowHandle).
      
    end. /* if not valid-handle(bttQueryWindow.QueryFrameHandle) */

    bttQueryWindow.WindowHandle:menu-bar = bttQueryWindow.QueryMenuHandle.

    if valid-handle(bttQueryWindow.RecordFrameHandle) then
      bttQueryWindow.RecordFrameHandle:visible = no.
    
    bttQueryWindow.QueryFrameHandle:visible = yes.
    
    run qg_QueryWindowQueryUpdateTitle(bttQueryWindow.WindowHandle).
    
    /* Only reposition browse if necessary. */
    
    RepositionBrowse:
    do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
      
      if    i > extent(rCurrentRecord)
         or bttQueryWindow.QueryHandle:get-buffer-handle(i):rowid <> rCurrentRecord[i] then
      do:
        
        bttQueryWindow.QueryHandle:reposition-to-rowid(rCurrentRecord) no-error.
        leave RepositionBrowse.
        
      end. /* if    i > extent(rCurrentRecord) ... */
      
    end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers */
    
    if plFocusQueryText then
      apply 'entry':U to bttQueryWindow.QueryTextEditorHandle.
    
    else
      apply 'entry':U to bttQueryWindow.QueryBrowseHandle.
    
  end. /* when {&K_QUERY_WINDOW_MODE_QUERY} */
  
  when {&K_QUERY_WINDOW_MODE_RECORD} then
  do:
    
    assign
      cIconFilename      = (if gcIconDir > '':U then
                              substitute('&1/32/table_analysis.ico':U,
                                         gcIconDir)
                            else
                              search('adeicon/dict%.ico':U))
      cSmallIconFilename = (if gcIconDir > '':U then
                              substitute('&1/16/table_analysis.ico':U,
                                         gcIconDir)
                            else
                              '':U)
      .
    
    if not valid-handle(bttQueryWindow.RecordFrameHandle) then
    do:
      
      run qg_QueryWindowCreateRecordFrame(bttQueryWindow.WindowHandle).
      
      run qg_QueryWindowRecordOpenQuery(bttQueryWindow.WindowHandle).
      
    end. /* if not valid-handle(bttQueryWindow.RecordFrameHandle) */
    
    bttQueryWindow.WindowHandle:menu-bar = bttQueryWindow.RecordMenuHandle.

    if valid-handle(bttQueryWindow.QueryFrameHandle) then
      bttQueryWindow.QueryFrameHandle:visible = no.
    
    bttQueryWindow.RecordFrameHandle:visible = yes.
    
    run qg_QueryWindowRecordRefresh(bttQueryWindow.WindowHandle).

  end. /* when {&K_QUERY_WINDOW_MODE_RECORD} */
  
end case. /* piWindowMode */

run qg_QueryWindowUpdateRawValuesMode( bttQueryWindow.WindowHandle ).

if cIconFilename > '':U then
  bttQueryWindow.WindowHandle:load-icon(cIconFilename).

if cSmallIconFilename > '':U then
  bttQueryWindow.WindowHandle:load-small-icon(cSmallIconFilename) no-error.

run qg_QueryWindowResize(bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowSetWindowMode */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSetWindowState hQueryWindow 
PROCEDURE qg_QueryWindowSetWindowState :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set query window state.                                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piSourceSeq                    = QuerySeq of the query window.             */
/* piWindowState                  = Window state that should be set.          */
/* plChildren                     = If yes the window state is set for        */
/*                                  linked child windows as well.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piQuerySeq    as integer   no-undo.
define input parameter piWindowState as integer   no-undo.
define input parameter plChildren    as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.
define buffer bttQueryLink    for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttQueryWindow
  where bttQueryWindow.QuerySeq = piQuerySeq
  no-error.

if not available bttQueryWindow then
  leave.

bttQueryWindow.WindowHandle:window-state = piWindowState.

if plChildren then
do:

  for each bttQueryLink
    where bttQueryLink.SourceSeq = piQuerySeq,
  first bttQueryWindow
    where bttQueryWindow.QuerySeq = bttQueryLink.TargetSeq
    on error undo, throw:
    
    run qg_QueryWindowSetWindowState(bttQueryWindow.QuerySeq,
                                     piWindowState,
                                     yes).
    
  end. /* for each bttQueryLink */
  
end. /* if plChildren */

end procedure. /* qg_QueryWindowSetWindowState */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowShowAll hQueryWindow 
PROCEDURE qg_QueryWindowShowAll :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show all query records (remove where clause).                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i          as integer   no-undo.
define variable hBuffer    as handle    no-undo.
define variable cQueryText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if   bttQueryWindow.ObjSourceQuerySeq       > 0
  or not valid-handle(bttQueryWindow.QueryHandle)
  or bttQueryWindow.QueryHandle:num-buffers = 0 then
  leave.

do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
  
  assign
    hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(1)
    cQueryText = (if i = 1 then
                    substitute('for each &1':U, hBuffer:name)
                  else
                    substitute(',~nfirst &1':U, hBuffer:name))
    .
  
end. /* do i = 1 to bttQueryWindow.WindowHandle:num-buffers */

bttQueryWindow.QueryTextEditorHandle:screen-value = cQueryText.

run qg_QueryWindowExecute(bttQueryWindow.WindowHandle, ?, yes).

end procedure. /* qg_QueryWindowShowAll */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowShowChildWindows hQueryWindow 
PROCEDURE qg_QueryWindowShowChildWindows :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show all query windows that are linked to this query window.               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piSourceSeq                    = QuerySeq of the query window.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piSourceSeq as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.
define buffer bttQueryLink    for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryLink
  where bttQueryLink.SourceSeq = piSourceSeq,
first bttQueryWindow
  where bttQueryWindow.QuerySeq = bttQueryLink.TargetSeq
  on error undo, throw:
  
  run qg_QueryWindowShowChildWindows(bttQueryWindow.QuerySeq).
  
  run qg_ActivateWindow(bttQueryWindow.WindowHandle, ?).
  
end. /* for each bttQueryLink */

end procedure. /* qg_QueryWindowShowChildWindows */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowShowIndex hQueryWindow 
PROCEDURE qg_QueryWindowShowIndex :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Creates a dummy query for the given index and executes it.                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow       as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer       as handle    no-undo.
define variable cDatabaseName as character no-undo.
define variable cIndexName    as character no-undo.
define variable lOk           as logical   no-undo.
define variable cQueryText    as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndex       for temp-table ttIndex.
define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if    bttQueryWindow.ObjSourceQuerySeq        > 0
   or not valid-handle(bttQueryWindow.QueryHandle)
   or bttQueryWindow.QueryHandle:num-buffers <> 1 then
  leave.

assign
  hBuffer       = bttQueryWindow.QueryHandle:get-buffer-handle(1)
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer )
  .

run qg_SelectIndex(cDatabaseName,
                   hBuffer:table,
                   input-output cIndexName,
                         output lOk,
                   bttQueryWindow.WindowHandle).

if lOk then
do:
  
  find bttIndex
    where bttIndex.DatabaseName = cDatabaseName
      and bttIndex.TableName    = hBuffer:table
      and bttIndex.IndexName    = cIndexName
    no-error.
  
  if available bttIndex then
  do:
    
    assign
      cQueryText = substitute( 'for each &1':U,
                               bttIndex.TableName )
      cQueryText = substitute( '&1~n&2~n':U,
                               cQueryText,
                               qg_cCreateWhereClause( /* pcDatabaseName   */ bttIndex.DatabaseName,
                                                      /* pcTableNames     */ bttIndex.TableName,
                                                      /* pcBufferNames    */ bttIndex.TableName,
                                                      /* pcFieldList      */ bttIndex.IndexFieldList,
                                                      /* pcFieldLabelList */ ?,
                                                      /* plStartWithWhere */ yes,
                                                      /* piValueMode      */ {&K_VALUE_MODE_DEFAULT_VALUE},
                                                      /* pcValueList      */ ?,
                                                      /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                                      /* plAddTags        */ no,
                                                      /* piIndentBlanks   */ 2 ) )
      .
    
    run qg_QueryWindowQuerySetQueryText(bttQueryWindow.WindowHandle,
                                        cQueryText,
                                        yes).
    
    run qg_QueryWindowExecute(bttQueryWindow.WindowHandle, ?, no).
    
    apply 'entry':U to bttQueryWindow.QueryTextEditorHandle.
    
  end. /* if available bttIndex */
  
end. /* if lOk */

end procedure. /* qg_QueryWindowShowIndex */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowShowIndexInformation hQueryWindow 
PROCEDURE qg_QueryWindowShowIndexInformation :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Creates a dummy query for the given index and executes it.                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow       as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i              as integer   no-undo.
define variable j              as integer   no-undo.
define variable hQuery         as handle    no-undo.
define variable hBuffer        as handle    no-undo.

define variable cDatabaseName  as character no-undo.
define variable cIndexInfo     as character no-undo.
define variable cIndexName     as character no-undo.
define variable cIndexInfoText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.
define buffer bttIndex       for temp-table ttIndex.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

hQuery = bttQueryWindow.QueryHandle.

if not valid-handle(hQuery) then
  leave.

do i = 1 to hQuery:num-buffers:
  
  assign
    hBuffer       = hQuery:get-buffer-handle(i)
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer )
    cIndexInfo    = hQuery:index-information(i)
    .
  
  cIndexInfoText = substitute('&1~n~n&2 &3':U,
                              cIndexInfoText,
                              gcBulletChar2,
                              hBuffer:name).
  
  do j = 1 to num-entries(cIndexInfo):
    
    cIndexName = entry(j, cIndexInfo).
    
    if cIndexName = 'WHOLE-INDEX':U then
      cIndexInfoText = substitute('&1   !!! &2 !!!':U,
                                  cIndexInfoText,
                                  cIndexName).
    
    else
    do:
      
      find bttIndex
        where bttIndex.DatabaseName = cDatabaseName
          and bttIndex.TableName    = hBuffer:table
          and bttIndex.IndexName = cIndexName
        no-error.
      
      if available bttIndex then
        cIndexInfoText = substitute('&1~n&2&3 Index &4: &5':U,
                                    cIndexInfoText,
                                    gcLineUpAndRight,
                                    gcBulletChar1,
                                    bttIndex.IndexName,
                                    bttIndex.IndexFields).
      
      else
        cIndexInfoText = substitute('&1~n    -> Index &2':U,
                                    cIndexInfoText,
                                    bttIndex.IndexName).
      
    end. /* if cIndexName = 'WHOLE-INDEX':U */
    
  end. /* if cIndexName = 'WHOLE-INDEX':U */
  
end. /* do i = 1 to hQuery:num-buffers */

message
  trim(cIndexInfoText, '~n':U) skip
  view-as alert-box
  information
  buttons ok
  in window bttQueryWindow.WindowHandle.

end procedure. /* qg_QueryWindowShowIndexInformation */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowShowQueryText hQueryWindow 
PROCEDURE qg_QueryWindowShowQueryText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show actual query text with resolved external tokens.                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo
  view-as editor
  no-word-wrap
  scrollbar-horizontal
  scrollbar-vertical
  size 146 by 14.5
  font 0.

define button btnClose
  label 'Close':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

define frame fQueryText
  cQueryText at row 1.5 col 3 no-labels
  btnClose at row 16.5 col 66
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 151 by 18.44
    title gcTitlePrefix + 'Query text of query browse':T
    default-button btnClose
    cancel-button btnClose.

on window-close of frame fQueryText
  apply 'end-error' to self.

assign
  cQueryText                               = bttQueryWindow.QueryHandle:prepare-string
  cQueryText:read-only in frame fQueryText = yes
  .

update unless-hidden
  cQueryText
  btnClose
  with frame fQueryText
    in window bttQueryWindow.WindowHandle.

end procedure. /* qg_QueryWindowShowQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowSortByIndex hQueryWindow 
PROCEDURE qg_QueryWindowSortByIndex :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add Sort options for a given index.                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcDatabaseName                 = Database name.                            */
/* pcTableName                    = Table name.                               */
/* pcIndexName                    = Index name.                               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer        as handle    no-undo.
define variable cDatabaseName  as character no-undo.
define variable cIndexName     as character no-undo.
define variable lOk            as logical   no-undo.
define variable cSortFieldList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

define buffer bttIndexField  for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

if    bttQueryWindow.ObjSourceQuerySeq        > 0
   or not valid-handle(bttQueryWindow.QueryHandle)
   or bttQueryWindow.QueryHandle:num-buffers <> 1 then
  leave.

assign
  hBuffer       = bttQueryWindow.QueryHandle:get-buffer-handle(1)
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer )
  .

run qg_SelectIndex(cDatabaseName,
                   hBuffer:table,
                   input-output cIndexName,
                         output lOk,
                   phWindow).

if lOk then
do:
  
  for each bttIndexField
    where bttIndexField.DatabaseName = cDatabasename
      and bttIndexField.TableName    = hBuffer:table 
      and bttIndexField.IndexName    = cIndexName
    by DatabaseName by TableName by IndexName by IndexSequence
    on error undo, throw:
    
    cSortFieldList = substitute('&1,&2.&3&4':U,
                                cSortFieldList,
                                bttIndexField.TableName,
                                bttIndexField.FieldName,
                                (if bttIndexField.SortAscending then
                                   '':U
                                 else
                                   ' descending':U)).
    
  end. /* for each bttIndexField */

  cSortFieldList = trim(cSortFieldList, ',':U).
  
  if num-entries(cSortFieldList) > 0 then
    run qg_QueryWindowAddSortFields(phWindow,
                                    cSortFieldList).
  
end. /* if lOk */

end procedure. /* qg_QueryWindowSortByIndex */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowToggleDeepResolve hQueryWindow 
PROCEDURE qg_QueryWindowToggleDeepResolve :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow   as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame                     as handle    no-undo.
define variable hToggleDeepResolveMenuItem as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  hToggleDeepResolveMenuItem          = qg_hGetWidgetByName(phWindow:menu-bar,
                                                            'mi_DeepResolveObjectIds':U)
  bttQueryWindow.DeepResolveObjectIds = hToggleDeepResolveMenuItem:checked
  .

if    valid-handle(bttQueryWindow.QueryHandle)
  and bttQueryWindow.QueryHandle:num-results > 0
  and valid-handle(bttQueryWindow.QueryBrowseHandle) then
  bttQueryWindow.QueryBrowseHandle:refresh().

end procedure. /* qg_QueryWindowToggleDeepResolve */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowToggleRawValues hQueryWindow 
PROCEDURE qg_QueryWindowToggleRawValues :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the record window.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow         as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

bttQueryWindow.DisplayRawValues = not bttQueryWindow.DisplayRawValues.

if bttQueryWindow.DisplayRawValues then
  
  /* This flag will be set the first time "raw values" is set to true. Once   */
  /* we have been applying formats to columns we have to keep doing it,       */
  /* otherwise the display will not be correct.                               */
  
  bttQueryWindow.ApplyColumnFormats = yes.

run qg_QueryWindowUpdateRawValuesMode( bttQueryWindow.WindowHandle ).

end procedure. /* qg_QueryWindowToggleRawValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowToggleFieldList hQueryWindow 
PROCEDURE qg_QueryWindowToggleFieldList :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Toggle field list visibility.                                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow   as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame                   as handle    no-undo.
define variable hToggleFieldBrowseButton as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/* If the field selection browse should be displayed we first have to make    */
/* sure that it will fit into the frame to avoid errors.                      */

if bttQueryWindow.QueryFieldBrowseHandle:hidden then
  assign
    hFrame                            = qg_hGetWidgetByName(phWindow, 'fQuery':U)
    bttQueryWindow.WindowHandle:width = max(100, bttQueryWindow.WindowHandle:width)
    hFrame:width                      = bttQueryWindow.WindowHandle:width
    bttQueryWindow.QueryFieldBrowseHandle:height = 3
    bttQueryWindow.QueryFieldBrowseHandle:col    = max(1, bttQueryWindow.WindowHandle:width - 72)
    no-error.
  
/* Now we can toggle the hidden state. */

assign
  bttQueryWindow.QueryFieldBrowseHandle:hidden = not bttQueryWindow.QueryFieldBrowseHandle:hidden
  hToggleFieldBrowseButton         = qg_hGetWidgetByName(phWindow, 'btnToggleFieldBrowse':U)
  hToggleFieldBrowseButton:label   = (if bttQueryWindow.QueryFieldBrowseHandle:hidden then
                                        '<':T
                                      else
                                        '>':T)
  hToggleFieldBrowseButton:tooltip                 = (if bttQueryWindow.QueryFieldBrowseHandle:hidden then
                                        'Show field list':T
                                      else
                                        'Hide field List':T)
  .

run qg_QueryWindowResize(bttQueryWindow.WindowHandle).

end procedure. /* qg_QueryWindowToggleFieldList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowUpdate hQueryWindow 
PROCEDURE qg_QueryWindowUpdate :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Execute current query text of given query window.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Window handle of the query window that    */
/*                                  should be updated.                        */
/* pcForceUpdateWindowList        = List of window handles that should be up- */
/*                                  dated even if the query text is un-       */
/*                                  changed.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow                as handle    no-undo.
define input parameter pcForceUpdateWindowList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

/* Additional do block to ensure that bttQueryWindow will be available in     */
/* finally block.                                                             */

do on error undo, throw:
  
  phWindow:title = substitute('&1 (updating ...)':U, bttQueryWindow.WindowTitle).
  
  if bttQueryWindow.ObjSourceQuerySeq > 0 then
    run qg_QueryWindowObjUpdateQuery(bttQueryWindow.WindowHandle).
  
  if not valid-handle(bttQueryWindow.QueryHandle) then
    leave.
  
  cQueryText = qg_cSubstituteQueryLinkTokens(bttQueryWindow.WindowHandle).
  
  if   can-do(pcForceUpdateWindowList, string(bttQueryWindow.WindowHandle))
    or cQueryText <> bttQueryWindow.QueryHandle:prepare-string
    or not bttQueryWindow.QueryHandle:is-open then
  do:
    
    if    cQueryText > '':U
      and bttQueryWindow.QueryHandle:num-buffers > 0 then
    do:
      
      qg_lQueryOpen(bttQueryWindow.QueryHandle,
                    cQueryText,
                    bttQueryWindow.WindowHandle).
      
      run qg_AddRecentQuery(bttQueryWindow.WindowHandle).
      
    end. /* if    cQueryText > 0 */
    
    if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_RECORD} then
    do:
      
      if    bttQueryWindow.QueryHandle:is-open
        and bttQueryWindow.QueryHandle:num-results = 0 then
        bttQueryWindow.QueryHandle:get-first().
      
      run qg_QueryWindowRecordRefresh(bttQueryWindow.WindowHandle).
      
    end. /* if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_RECORD} */
    
  end. /* if   can-do(pcForceUpdateWindowList, string(bttQueryWindow.WindowHandle)) ... */
  
  finally:
    
    if    valid-handle(phWindow)
      and bttQueryWindow.WindowTitle > '':U then
      phWindow:title = bttQueryWindow.WindowTitle.
    
  end finally.
  
end.

end procedure. /* qg_QueryWindowUpdate */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowUpdateAll hQueryWindow 
PROCEDURE qg_QueryWindowUpdateAll :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Refresh all Query windows.                                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcForceUpdateWindowList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow            for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Check for circular references and reset update flags. */

for each bttQueryWindow
  on error undo, throw:
  
  if not qg_lCheckLinkReference(bttQueryWindow.QuerySeq, '':U) then
  do:
    
    message /* code checked by mth */
      substitute('Circular reference detected in Query window &1':T,
                 string(bttQueryWindow.QuerySeq)) skip
      view-as alert-box
      error
      buttons ok
      in window bttQueryWindow.WindowHandle.
    
    return error.
    
  end. /* not qg_lCheckLinkReference(bttQueryWindow.QuerySeq, '':U) */
  
  bttQueryWindow.Updated = no.
  
end. /* for each bttQueryWindow */

/* Refresh query windows. */

for each bttQueryWindow
  where not can-find(first ttQueryLink
                       where ttQueryLink.SourceSeq = bttQueryWindow.QuerySeq)
  on error undo, throw:
  
  if valid-handle(bttQueryWindow.WindowHandle) then
    run qg_QueryWindowUpdateRecursive(bttQueryWindow.WindowHandle,
                                      pcForceUpdateWindowList).
  
end. /* for each bttQueryWindow */

end procedure. /* qg_QueryWindowUpdateAll */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowUpdateRawValuesMode hQueryWindow 
PROCEDURE qg_QueryWindowUpdateRawValuesMode :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update all query windows that are linked to given query window.            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcForceUpdateWindowList        = List of window handles that should be up- */
/*                                  dated even if the query text is un-       */
/*                                  changed.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hRawValues as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave. 

validate bttQueryWindow.

case bttQueryWindow.WindowMode:
  
  when {&K_QUERY_WINDOW_MODE_QUERY} then
  do:
    
    hRawValues = qg_hGetWidgetByName( phWindow:menu-bar,
                                      'mi_RawValues':U ).
    
    if valid-handle( hRawValues ) then
      
      hRawValues:checked = bttQueryWindow.DisplayRawValues.
    
    if bttQueryWindow.QueryHandle:num-results > 0 then
  
      bttQueryWindow.QueryBrowseHandle:refresh().
    
  end. /* when {&K_QUERY_WINDOW_MODE_QUERY} */
  
  when {&K_QUERY_WINDOW_MODE_RECORD} then
  do:
    
    hRawValues = qg_hGetWidgetByName( bttQueryWindow.RecordFrameHandle,
                                      'lRawValues':U ).
    
    if valid-handle(hRawValues) then
      
      hRawValues:screen-value = string(bttQueryWindow.DisplayRawValues).
    
    run qg_QueryWindowRecordUpdateValues( bttQueryWindow.WindowHandle ).
    
  end. /* when {&K_QUERY_WINDOW_MODE_RECORD} */
  
end case. /* if not available bttQueryWindow */

end procedure. /* qg_QueryWindowUpdateRawValuesMode */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowUpdateRecursive hQueryWindow 
PROCEDURE qg_QueryWindowUpdateRecursive :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update all query windows that are linked to given query window.            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcForceUpdateWindowList        = List of window handles that should be up- */
/*                                  dated even if the query text is un-       */
/*                                  changed.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow                as handle    no-undo.
define input parameter pcForceUpdateWindowList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.
define buffer b2ttQueryWindow for temp-table ttQueryWindow.
define buffer bttQueryLink    for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave. 

if bttQueryWindow.Updated then
  leave.

for each bttQueryLink
  where bttQueryLink.TargetSeq = bttQueryWindow.QuerySeq,
first b2ttQueryWindow
  where b2ttQueryWindow.QuerySeq = bttQueryLink.SourceSeq
  break by bttQueryLink.SourceSeq
  on error undo, throw:
  
  if first-of(bttQueryLink.SourceSeq) then
    run qg_QueryWindowUpdateRecursive(b2ttQueryWindow.WindowHandle,
                                      pcForceUpdateWindowList).
  
end. /* for each bttQueryLink */

run qg_QueryWindowUpdate(bttQueryWindow.WindowHandle,
                         pcForceUpdateWindowList).

bttQueryWindow.Updated = yes.

end procedure. /* qg_QueryWindowUpdateRecursive */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowViewMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowViewMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow                as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFieldSelectionBrowse as handle    no-undo.

define variable hMenu                 as handle    no-undo.
define variable hFieldListMenuItem    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave. 

assign
  hMenu = bttQueryWindow.WindowHandle:menu-bar
  hFieldSelectionBrowse
      = qg_hGetWidgetByName(bttQueryWindow.WindowHandle,
                          'brFieldSelection':U)
  hFieldListMenuItem
      = qg_hGetWidgetByName(hMenu, 'mi_FieldList':U)
  hFieldListMenuItem:checked
      = hFieldSelectionBrowse:visible
  .

end procedure. /* qg_QueryWindowViewMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowWindowMenuDrop hQueryWindow 
PROCEDURE qg_QueryWindowWindowMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow                as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave. 

/* Nothing to do here right now. Maybe this can be deleted. */


end procedure. /* qg_QueryWindowWindowMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveInvalidOverlayColumns Method-Library
procedure qg_RemoveInvalidOverlayColumns :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow for temp-table ttQueryWindow.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttFieldOverlay for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttFieldOverlay
  where bttFieldOverlay.OwnerHandle = pbttQueryWindow.QueryHandle
  break by bttFieldOverlay.BufferName
  on error undo, throw:
  
  if first-of( bttFieldOverlay.BufferName ) then
    
    hBuffer = pbttQueryWindow.QueryHandle:get-buffer-handle( bttFieldOverlay.BufferName ) no-error.
  
  if    not valid-handle( hBuffer )
     or not can-find( first ttQueryWindowField
                        where ttQueryWindowField.WindowHandle = pbttQueryWindow.WindowHandle
                          and ttQueryWindowField.BufferName   = bttFieldOverlay.BufferName
                          and ttQueryWindowField.FieldName    = bttFieldOverlay.FieldName
                          and ttQueryWindowField.FieldIndex   = bttFieldOverlay.FieldIndex
                          and ttQueryWindowField.IsOverlay    = no ) then
    
    run qg_DeleteFieldOverlay( bttFieldOverlay.OwnerHandle,
                               bttFieldOverlay.BufferName,
                               bttFieldOverlay.FieldName,
                               bttFieldOverlay.FieldIndex ).
  
  if last-of( bttFieldOverlay.BufferName ) then
    
    hBuffer = ?.
  
end. /* for each bttFieldOverlay */

end procedure. /* qg_RemoveInvalidOverlayColumns */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

/* <<< Include: incl/query_window.i <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/virtual_fields.i >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
/*------------------------------------------------------------------------
    File        : virtual_fields.i
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Tue Apr 05 13:54:45 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/



/* **********************  Internal Procedures  *********************** */

procedure qg_AddTableVirtualDBFields :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttDatabase                                                               */
/* pbttTable                                                                  */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttDatabase for temp-table ttDatabase.
define parameter buffer pbttTable    for temp-table ttTable. 

/* Variables -----------------------------------------------------------------*/

define variable hRepVirtualFieldBuffer as handle    no-undo.
define variable hRepDomainBuffer       as handle    no-undo.
define variable hRepVirtualFieldQuery  as handle    no-undo.

define variable cQueryText             as character no-undo.

define variable cDataType              as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create buffer hRepVirtualFieldBuffer for table substitute( '&1.DRC_VirtualField':U, pbttDatabase.BasisDBName ).
create buffer hRepDomainBuffer for table substitute( '&1.DRC_Domain':U, pbttDatabase.BasisDBName ).

create query hRepVirtualFieldQuery.

hRepVirtualFieldQuery:set-buffers( hRepVirtualFieldBuffer, hRepDomainBuffer ).

cQueryText =            'for each DRC_VirtualField':U
             + '~n':U + '  where DRC_VirtualField.DRC_Table_Obj = &1':U
             + '~n':U + '    and DRC_VirtualField.&2            = yes':U
             + '~n':U + '  no-lock,':U
             + '~n':U + 'first DRC_Domain left outer-join':U
             + '~n':U + '  where DRC_Domain.DRC_Domain_Obj = DRC_VirtualField.DRC_Domain_Obj':U
             + '~n':U + '  no-lock':U.
             .

hRepVirtualFieldQuery:query-prepare( substitute( cQueryText,
                                                 quoter( pbttTable.RepObjectId ),
                                                 gcVirtualDBFieldReposFlagFieldName ) ).

hRepVirtualFieldQuery:query-open().

hRepVirtualFieldQuery:get-first().

do while not hRepVirtualFieldQuery:query-off-end:
  
  create bttField.
  
  assign
    bttField.DatabaseName      = pbttDatabase.DatabaseName
    bttField.TableName         = pbttTable.TableName
    bttField.FieldName         = hRepVirtualFieldBuffer::DRC_VirtualField_ID
    bttField.RepObjectId       = hRepVirtualFieldBuffer::DRC_VirtualField_Obj
    cDataType                  = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'DATA-TYPE':U )
    bttField.DataType          = substitute( '&1&2':U,
                                             caps( substring( cDataType, 1, 1 ) ),
                                             lc( substring( cDataType, 2 ) ) )
    bttField.FieldExtent       = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'EXTENT':U )
    bttField.FieldInitialValue = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'INITIAL':U )
    bttField.FieldLabel        = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'LABEL':U )
    bttField.FieldColumnLabel  = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'COLUMN-LABEL':U )
    bttField.FieldDecimals     = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'DECIMALS':U )
    bttField.FieldFormat       = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'FORMAT':U )
    bttField.IsMandatory       = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                                   hRepDomainBuffer::DRC_Domain_Obj,
                                                   'MANDATORY':U )
    bttField.Domain            = (if hRepDomainBuffer:available then
                                    hRepDomainBuffer::DRC_Domain_ID
                                  else
                                    '':U)
    bttField.IsObjectId        = (     bttField.FieldName matches '*_Obj':U
                                    or lookup(bttField.Domain, {&K_OBJECT_ID_DOMAIN}) > 0 )
    bttField.FieldType         = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD}
    bttField.IsVirtual         = yes
    .
  
  /* Attribute "VIEW-AS" is only available in development mode. To avoid      */
  /* errors when running in production mode we use "no-error" to assign this  */
  /* specific attribute.                                                      */
  
  bttField.FieldViewAs = dynamic-function( 'pa_cReposDomainInformationByObj':U,
                                           hRepDomainBuffer::DRC_Domain_Obj,
                                           'VIEW-AS':U ) no-error.
  
  /* An empty initial value for logical fields is interpreted as "no"   */
  /* by the database. Therefore we simulate this behaviour for virtual  */
  /* fields.                                                            */
  
  if    bttField.DataType          = 'logical':U
    and bttField.FieldInitialValue = '':U then
    
    bttField.FieldInitialValue = 'no':U.
  
  /* The "initial" attribute for date fields allways has to have the US       */
  /* format "mm/dd/yyyy" (or "today/now" or ?)                                */

  else if    cDataType                  begins  'date':U
         and bttField.FieldInitialValue matches '*/*/*':U then
    
    bttField.FieldInitialValue = qg_cDateStringFormUSFormat( bttField.FieldInitialValue ).
  
  if    bttField.FieldLabel = ?
     or bttField.FieldLabel = '':U then
    
    bttField.FieldLabel = bttField.FieldName.
  
  if    bttField.FieldColumnLabel = ?
     or bttField.FieldColumnLabel = '':U then
    
    bttField.FieldColumnLabel = bttField.FieldLabel.
  
  hRepVirtualFieldQuery:get-next().
  
end. /* do while not hRepVirtualFieldQuery:query-off-end */

catch oError as class progress.lang.error:
  return.
end catch. /* progress.lang.error */

finally:
  
  if valid-handle( hRepVirtualFieldQuery ) then
    
    delete object hRepVirtualFieldQuery no-error.
  
  if valid-handle( hRepDomainBuffer ) then
    
    delete object hRepDomainBuffer no-error.
  
  if valid-handle( hRepVirtualFieldBuffer ) then
    
    delete object hRepVirtualFieldBuffer no-error.
  
end finally.

end procedure. /* qg_AddTableVirtualDBFields */


procedure qg_AddVirtualFieldsToBufferComparisonBuffer :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                                                             */
/* phBuffer                                                                   */
/* piBufferNo                                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter phBuffer       as handle    no-undo.
define input parameter piBufferNo     as integer   no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cObjectIdValue     as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField                 for temp-table ttField.

define buffer bttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not phBuffer:available then
  
  return.

if not qg_lIsPhysicalDatabase( phBuffer:dbname ) then
  
  return.

cObjectIdValue = qg_cObjectIdForBuffer( phBuffer ).

for each bttField
  where bttField.DatabaseName = pcDatabaseName
    and bttField.TableName    = phBuffer:table
    and bttField.IsVirtual    = yes
  on error undo, throw:
  
  find bttBufferComparisonField
    where bttBufferComparisonField.BufferNo   = piBufferNo
      and bttBufferComparisonField.FieldName  = bttField.FieldName
      and bttBufferComparisonField.FieldIndex = 0
    no-error.
  
  if not available bttBufferComparisonField then
  do:
    
    create bttBufferComparisonField.
    
    assign
      bttBufferComparisonField.BufferNo   = piBufferNo
      bttBufferComparisonField.FieldName  = bttField.FieldName
      bttBufferComparisonField.FieldIndex = 0
      .
    
  end. /* if not available bttBufferComparisonField */
  
  assign
    bttBufferComparisonField.DatabaseName = pcDatabaseName
    bttBufferComparisonField.TableName    = phBuffer:table
    bttBufferComparisonField.BufferName   = phBuffer:name
    bttBufferComparisonField.DataType     = bttField.DataType
    bttBufferComparisonField.FieldFormat  = bttField.FieldFormat
    bttBufferComparisonField.IsVirtual    = bttField.IsVirtual
    bttBufferComparisonField.FieldType    = bttField.FieldType
    bttBufferComparisonField.FieldValue   = qg_clVirtualFieldValueAsLongchar( bttField.FieldType,
                                                                              bttField.DataType,
                                                                              bttField.FieldName,
                                                                              cObjectIdValue,
                                                                              ? ).
    .
  
  
  validate bttBufferComparisonField.
  
end. /* for each bttField */

end procedure. /* qg_AddVirtualFieldsToBufferComparisonBuffer */



procedure qg_AddVirtualFieldsToTempTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                                                             */
/* pcTableName                                                                */
/* phTempTable                                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.
define input parameter phTempTable    as handle    no-undo.

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttField
  where bttField.DatabaseName = pcDatabaseName
    and bttField.TableName    = pcTableName
    and bttField.IsVirtual    = yes
  on error undo, throw:
  
  case bttField.FieldType:
    
    when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
      
      phTempTable:add-new-field( bttField.FieldName,
                                 bttField.DataType,
                                 bttField.FieldExtent,
                                 bttField.FieldFormat,
                                 bttField.FieldInitialValue,
                                 bttField.FieldLabel,
                                 bttField.FieldColumnLabel ).
    
  end case. /* bttField.FieldType */
  
end. /* for each bttField */

end procedure. /* qg_AddVirtualFieldsToTempTable */


procedure qg_BufferCopyVirtualFieldsFromPhysicalBufferToTempTableBuffer :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                                                             */
/* phPhysicalBuffer                                                           */
/* phTempTableBuffer                                                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName    as character no-undo.
define input parameter phPhysicalBuffer  as handle    no-undo.
define input parameter phTempTableBuffer as handle    no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cObjectIdValue  as character no-undo.
define variable cMethodName     as character no-undo.
define variable hTempTableField as handle    no-undo.

define variable clFieldValue as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cObjectIdValue = qg_cObjectIdForBuffer( phPhysicalBuffer ).

if error-status:error then
  
  return.

for each bttField
  where bttField.DatabaseName = pcDatabaseName
    and bttField.TableName    = phPhysicalBuffer:table
    and bttField.IsVirtual    = yes
  on error undo, throw:
  
  hTempTableField = phTempTableBuffer:buffer-field( bttField.FieldName ) no-error.
  
  if not valid-handle( hTempTableField ) then
    
    next.
  
  case bttField.FieldType:
    
    when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
      
      assign
        cMethodName                  = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                                       'cMethodNameByDataType':U,
                                                       bttField.DataType )
        hTempTableField:buffer-value = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                                       cMethodName,
                                                       cObjectIdValue,
                                                       bttField.FieldName )
        .
    
  end case. /* bttField.FieldType */
  
end. /* for each bttField */

end procedure. /* qg_BufferCopyVirtualFieldsFromPhysicalBufferToTempTableBuffer */


procedure qg_BufferCopyVirtualFieldsFromTempTableBufferToPhysicalBuffer :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                                                             */
/* phTempTableBuffer                                                          */
/* phPhysicalBuffer                                                           */
/* plDisabelTriggers                                                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName    as character no-undo.
define input parameter phTempTableBuffer as handle    no-undo.
define input parameter phPhysicalBuffer  as handle    no-undo.
define input parameter plDisabelTriggers as logical   no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cObjectIdValue           as character no-undo.
define variable hTempTableField          as handle    no-undo.
define variable cVirtualFieldTableName as character no-undo.
define variable hVirtualFieldTableBuffer as handle    no-undo.

define variable clFieldValue             as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cObjectIdValue = qg_cObjectIdForBuffer( phPhysicalBuffer ).

if error-status:error then
  
  return.

for each bttField
  where bttField.DatabaseName = pcDatabaseName
    and bttField.TableName    = phPhysicalBuffer:table
    and bttField.IsVirtual    = yes
    and bttField.FieldType    = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD}
  break by bttField.DataType
  on error undo, throw:
  
  if    first-of( bttField.DataType )
    and plDisabelTriggers then
  do:
    
    cVirtualFieldTableName = dynamic-invoke( qg_oVirtualDBFieldDataFieldApiInstance(),
                                             'cTableNameByDataType':U,
                                             bttField.DataType ).
    
    create buffer hVirtualFieldTableBuffer for table cVirtualFieldTableName.
    
    hVirtualFieldTableBuffer:disable-load-triggers( no ).
    
  end. /* if first-of bttField.DataType */
  
  hTempTableField = phTempTableBuffer:buffer-field( bttField.FieldName ) no-error.
  
  if not valid-handle( hTempTableField ) then
    
    next.
  
  case bttField.DataType:
    
    when 'clob':U then
    do:
      
      copy-lob from hTempTableField:buffer-field( bttField.FieldName ):buffer-value
        to clFieldValue
        .
      
      dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                      'setValue':U,
                      cObjectIdValue,
                      bttField.FieldName,
                      clFieldValue ).
      
    end. /* when 'clob':U */
    
    otherwise
      
      dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                      'setValue':U,
                      cObjectIdValue,
                      bttField.FieldName,
                      hTempTableField:buffer-value ).
    
  end case. /* bttField.DataType */
  
  if    last-of( bttField.DataType )
    and plDisabelTriggers
    and valid-handle( hVirtualFieldTableBuffer ) then
    
    delete object hVirtualFieldTableBuffer.
  
end. /* for each bttField */

end procedure. /* qg_BufferCopyVirtualFieldsFromTempTableBufferToPhysicalBuffer */


procedure qg_CreateVirtualFieldColumn :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttQueryWindow                                                            */
/* pbttQueryWindowField                                                       */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow      for temp-table ttQueryWindow.
define parameter buffer pbttQueryWindowField for temp-table ttQueryWindowField.

/* Variables -----------------------------------------------------------------*/

define variable hVirtualFieldColumn as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField              for temp-table ttField.
define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle( pbttQueryWindowField.BufferHandle ) then
  
  return.

find first bttField
  where bttField.DatabaseName = pbttQueryWindowField.DatabaseName
    and bttField.TableName    = pbttQueryWindowField.BufferHandle:table
    and bttField.FieldName    = pbttQueryWindowField.FieldName
  no-error.

if not available bttField then
  
  return.

find bttVirtualFieldColumn
  where bttVirtualFieldColumn.OwnerHandle = pbttQueryWindow.QueryHandle
    and bttVirtualFieldColumn.BufferName  = pbttQueryWindowField.BufferName
    and bttVirtualFieldColumn.FieldName   = pbttQueryWindowField.FieldName
    and bttVirtualFieldColumn.FieldIndex  = pbttQueryWindowField.FieldIndex
  no-error.

if not available bttVirtualFieldColumn then
do:
  
  create bttVirtualFieldColumn.
  
  assign
    bttVirtualFieldColumn.OwnerHandle  = pbttQueryWindow.QueryHandle
    bttVirtualFieldColumn.BufferName   = pbttQueryWindowField.BufferName
    bttVirtualFieldColumn.FieldName    = pbttQueryWindowField.FieldName
    bttVirtualFieldColumn.FieldIndex   = pbttQueryWindowField.FieldIndex
    bttVirtualFieldColumn.DataType     = pbttQueryWindowField.DataType
    bttVirtualFieldColumn.FieldType    = pbttQueryWindowField.FieldType
    bttVirtualFieldColumn.FieldFormat  = pbttQueryWindowField.FieldFormat
    .
  
end. /* if not available bttVirtualFieldColumn */

assign
  bttVirtualFieldColumn.BufferHandle = pbttQueryWindowField.BufferHandle
  hVirtualFieldColumn                = pbttQueryWindow.QueryBrowseHandle:add-calc-column
                                         ( bttField.DataType,
                                           bttField.FieldFormat,
                                           bttField.FieldInitialValue,
                                           bttField.FieldColumnLabel )
  hVirtualFieldColumn:name           = qg_cFormattedFieldName( /* pcDatabaseName */ ?,
                                                               /* pcTableName    */ pbttQueryWindowField.BufferName,
                                                               /* pcFieldName    */ pbttQueryWindowField.FieldName,
                                                               /* piIndex        */ pbttQueryWindowField.FieldIndex )
  hVirtualFieldColumn:label-fgcolor  = {&K_VIRTUAL_DB_FIELD_FGCOLOR}
  bttVirtualFieldColumn.ColumnHandle = hVirtualFieldColumn
  .

validate bttVirtualFieldColumn.

end procedure. /* qg_CreateVirtualFieldColumn */


procedure qg_CreateVirtualFieldColumnsForBuffer:
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttQueryWindow                                                            */
/* piBufferId                                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow for temp-table ttQueryWindow.

define input parameter piBufferId as integer   no-undo.

/* Variables -----------------------------------------------------------------*/

define variable hVirtualFieldColumn as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = pbttQueryWindow.WindowHandle
    and bttQueryWindowField.BufferId     = piBufferId
    and bttQueryWindowField.IsOverlay    = no
    and bttQueryWindowField.IsVirtual    = yes
  on error undo, throw:
  
  run qg_CreateVirtualFieldColumn( buffer pbttQueryWindow,
                                   buffer bttQueryWindowField ).
  
end. /* for each bttQueryWindowField */

end procedure. /* qg_CreateVirtualFieldColumnsForBuffer */


procedure qg_DeleteVirtualFieldRecordsForRecord :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                                                             */
/* phPhysicalBuffer                                                           */
/* plDisableTriggers                                                          */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName    as character no-undo.
define input parameter phPhysicalBuffer  as handle    no-undo.
define input parameter plDisableTriggers as logical   no-undo.

/* Variables -----------------------------------------------------------------*/

define variable cVirtualFieldTableName   as character no-undo.
define variable hVirtualFieldTableBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not can-find( first ttField
                   where ttField.DatabaseName = pcDatabaseName
                     and ttField.TableName    = phPhysicalBuffer:table
                     and ttField.IsVirtual    = yes ) then
  
  return.

if plDisableTriggers then
  
  for each bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = phPhysicalBuffer:table
      and bttField.IsVirtual    = yes
    break by bttField.DataType:
    
    if first-of( bttField.DataType ) then
    do on error undo, throw:
      
      cVirtualFieldTableName = dynamic-invoke( qg_oVirtualDBFieldDataFieldApiInstance(),
                                               'cTableNameByDataType':U,
                                               bttField.DataType ).
      
      create buffer hVirtualFieldTableBuffer for table cVirtualFieldTableName.
      
      hVirtualFieldTableBuffer:disable-load-triggers( no ).
      
      finally:
        
        if valid-handle( hVirtualFieldTableBuffer ) then
          
          delete object hVirtualFieldTableBuffer.
        
      end finally.
      
    end. /* if first-of( bttField.DataType ) */
    
  end. /* for each bttField */

dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                'deleteAllForOID':U,
                qg_cObjectIdForBuffer( phPhysicalBuffer ) ).

end procedure. /* qg_DeleteVirtualFieldRecordsForRecord */


procedure qg_InitializeVirtualDBFieldFramework :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable oVirtualDBFieldDataApiInstance as class progress.lang.object no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

oVirtualDBFieldDataApiInstance = qg_oVirtualDBFieldDataApiInstance().

if valid-object( oVirtualDBFieldDataApiInstance ) then
  
  case oVirtualDBFieldDataApiInstance:GetClass():TypeName:
    
    when 'basis.base.cls.BMCAddDataSvc':U then
      
      gcVirtualDBFieldReposFlagFieldName = 'AdditionalDBField':U.
    
    when 'x.adm.cls.XDCAddDataSvc':U then
      
      gcVirtualDBFieldReposFlagFieldName = 'xDB-Field':U.
    
  end case. /* oVirtualDBFieldDataApiInstance:GetClass():TypeName */
  
end procedure. /* qg_InitializeVirtualDBFieldFramework */


procedure qg_RemoveInvalidVirtualFieldColumns :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttQueryWindow                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow for temp-table ttQueryWindow.

/* Variables -----------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttVirtualFieldColumn
  where bttVirtualFieldColumn.OwnerHandle = pbttQueryWindow.QueryHandle
  break by bttVirtualFieldColumn.BufferName
  on error undo, throw:
  
  if first-of( bttVirtualFieldColumn.BufferName ) then
    
    hBuffer = pbttQueryWindow.QueryHandle:get-buffer-handle( bttVirtualFieldColumn.BufferName ) no-error.
  
  if    not valid-handle( hBuffer )
     or not can-find( first ttQueryWindowField
                        where ttQueryWindowField.WindowHandle = pbttQueryWindow.WindowHandle
                          and ttQueryWindowField.BufferName   = bttVirtualFieldColumn.BufferName
                          and ttQueryWindowField.FieldName    = bttVirtualFieldColumn.FieldName
                          and ttQueryWindowField.FieldIndex   = bttVirtualFieldColumn.FieldIndex
                          and ttQueryWindowField.IsOverlay    = no ) then
    
    run qg_RemoveVirtualFieldColumn( bttVirtualFieldColumn.OwnerHandle,
                                     bttVirtualFieldColumn.BufferName,
                                     bttVirtualFieldColumn.FieldName,
                                     bttVirtualFieldColumn.FieldIndex ).
  
  if last-of( bttVirtualFieldColumn.BufferName ) then
    
    hBuffer = ?.
  
end. /* for each bttFieldOverlay */

end procedure. /* qg_RemoveInvalidVirtualFieldColumns */


procedure qg_RemoveVirtualFieldColum :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttVirtualFieldColumn                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttVirtualFieldColumn for temp-table ttVirtualFieldColumn.

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle( pbttVirtualFieldColumn.ColumnHandle ) then
  
  delete object pbttVirtualFieldColumn.ColumnHandle no-error.

delete pbttVirtualFieldColumn.

end procedure. /* qg_RemoveVirtualFieldColum */


procedure qg_RemoveAllVirtualFieldColums :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttQueryWindow                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow for temp-table ttQueryWindow.

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttVirtualFieldColumn
where bttVirtualFieldColumn.OwnerHandle = pbttQueryWindow.QueryHandle
  on error undo, throw:
  
  run qg_RemoveVirtualFieldColum( buffer bttVirtualFieldColumn ).
  
end. /* for each bttVirtualFieldColumn */

end procedure. /* qg_RemoveVirtualFieldColums */


/* ************************  Function Implementations ***************** */

function qg_cBufferCompareVirtualFields returns character 
  ( phBuffer1 as handle,
    phBuffer2 as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer1                                                                  */
/* phBuffer2                                                                  */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable cDatabaseName1       as character no-undo.
define variable lDatabase1IsPhysical as logical   no-undo.
define variable cObjectIdValue1      as character no-undo.

define variable cDatabaseName2       as character no-undo.
define variable lDatabase2IsPhysical as logical   no-undo.
define variable cObjectIdValue2      as character no-undo.

define variable cFieldList           as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cDatabaseName1       = qg_cDatabaseNameForTableOrBuffer( phBuffer1 )
  lDatabase1IsPhysical = qg_lIsPhysicalDatabase( phBuffer1:dbname )
  cDatabaseName2       = qg_cDatabaseNameForTableOrBuffer( phBuffer2 )
  lDatabase2IsPhysical = qg_lIsPhysicalDatabase( phBuffer2:dbname )
  .

/* Non-physical tables can't have virtual fields. */

if    not lDatabase1IsPhysical
  and not lDatabase2IsPhysical then
  
  return '':U.

if lDatabase1IsPhysical then
  
  cObjectIdValue1 = qg_cObjectIdForBuffer( phBuffer1 ).

if lDatabase2IsPhysical then
  
  cObjectIdValue2 = qg_cObjectIdForBuffer( phBuffer1 ).

if lDatabase1IsPhysical then
  
  for each bttField
    where bttField.DatabaseName = cDatabaseName1
      and bttField.TableName    = phBuffer1:table
      and bttField.IsVirtual    = yes
      and bttField.FieldType    = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD}
    on error undo, throw:
    
    if not qg_lBufferCompareSingleVirtualField( phBuffer1,
                                                lDatabase1IsPhysical,
                                                cObjectIdValue1,
                                                phBuffer2,
                                                lDatabase2IsPhysical,
                                                cObjectIdValue2,
                                                bttField.FieldName,
                                                bttField.DataType ) then
      
      cFieldList = cFieldList + ',':U + bttField.FieldName.
    
  end. /* for each bttField */

if    lDatabase2IsPhysical
  and phBuffer2:table <> phBuffer1:table then
  
  for each bttField
    where bttField.DatabaseName = cDatabaseName1
      and bttField.TableName    = phBuffer2:table
      and bttField.IsVirtual    = yes
      and bttField.FieldType    = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD}
    on error undo, throw:
    
    if not qg_lBufferCompareSingleVirtualField( phBuffer1,
                                                lDatabase1IsPhysical,
                                                cObjectIdValue1,
                                                phBuffer2,
                                                lDatabase2IsPhysical,
                                                cObjectIdValue2,
                                                bttField.FieldName,
                                                bttField.DataType ) then
      
      cFieldList = cFieldList + ',':U + bttField.FieldName.
    
  end. /* for each bttField */

return trim( cFieldList, ',':U ).

end function. /* qg_cBufferCompareVirtualFields */


function qg_cGetFieldAssignmentsStatementForVirtualFields returns character 
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcBufferName   as character,
    pcFieldList    as character,
    piValueMode    as integer,
    pcValueList    as character,
    plAddTags      as logical,
    piIndentBlanks as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                                                             */
/* pcTableName                                                                */
/* pcBufferName                                                               */
/* pcFieldList                                                                */
/* piValueMode                                                                */
/* pcValueList                                                                */
/* plAddTags                                                                  */
/* piIndentBlanks                                                             */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable lRelevantFieldsExist           as logical   no-undo.
define variable iFieldCounter                  as integer   no-undo.
define variable cAssingStatement               as character no-undo.

define variable cCompanyInclude                as character no-undo.
define variable cCompany                       as character no-undo.

define variable iFieldNameLength               as integer   no-undo.
define variable iLongestFieldname              as integer   no-undo.

define variable cValue                         as character no-undo.

define variable oVirtualDBFieldDataApiInstance as Progress.Lang.Object no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/    

do iFieldCounter = 1 to num-entries(pcFieldList):
  
  find first bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = pcTableName
      and bttField.FieldName    = entry(iFieldCounter, pcFieldList)
      and bttField.FieldType    = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD}
    no-error.

  if available(bttField) then
  do:
    
    assign
      lRelevantFieldsExist = yes
      iFieldNameLength     = length(bttField.FieldName).
  
    if iFieldNameLength > iLongestFieldname then
      iLongestFieldname = iFieldNameLength.
    
  end. /* if    available(bttField) ... */
  
end. /* do iFieldCounter = 1 to num-entries(pcFieldList) */

if not lRelevantFieldsExist then
  
  return '':U.

oVirtualDBFieldDataApiInstance = qg_oVirtualDBFieldDataApiInstance() no-error.

if not valid-object( oVirtualDBFieldDataApiInstance ) then
  
  return '':U.

do iFieldCounter = 1 to num-entries(pcFieldList):
  
  find first bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = pcTableName
      and bttField.FieldName    = entry(iFieldCounter, pcFieldList)
      and bttField.FieldType    = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD}
    no-error.
  
  if available(bttField) then
  do:
    
    if piValueMode = {&K_VALUE_MODE_PARAMETER} then
      cValue = entry(iFieldCounter, pcValueList, {&K_PARAM_SPLITTER}).

    assign
      iFieldNameLength = length(bttField.FieldName)
      cAssingStatement = substitute('&1~n&2&3:prpoInstance:setValue( &5.&4_Obj, ~'&6~':U, &7&8 ).':U,
                                    cAssingStatement,
                                    fill(' ':U, piIndentBlanks),
                                    oVirtualDBFieldDataApiInstance:getClass():TypeName,
                                    pcTableName,
                                    pcBufferName,
                                    bttField.FieldName,
                                    fill(' ':U, max(0, iLongestFieldname - iFieldNameLength)),
                                    (if piValueMode = {&K_VALUE_MODE_PARAMETER} then
                                       (if cValue = '%DATATYPE%':U then
                                          qg_cTaggedValue(substitute('<&1>':U, caps(bttField.DataType)),
                                                          plAddTags)
                                        else if cValue = '%COMPANY%':U then
                                          (if cCompanyInclude > '':U then
                                             substitute('~{firma/&1 &2~}':U,
                                                        cCompanyInclude,
                                                        qg_cTaggedValue(cCompany,
                                                                        plAddTags))
                                           else
                                             qg_cTaggedValue(cCompany,
                                                             plAddTags))
                                        else
                                          qg_cTaggedValue(cValue,
                                                          plAddTags))
                                     else
                                       (if can-do({&K_COMPANY_FIELDS}, bttField.FieldName) then
                                          (if cCompanyInclude > '':U then
                                             substitute('~{firma/&1 &2~}':U,
                                                        cCompanyInclude,
                                                        qg_cTaggedValue(cCompany,
                                                                        plAddTags))
                                           else
                                             qg_cTaggedValue(cCompany,
                                                             plAddTags))
                                        else
                                          qg_cTaggedValue(substitute('<&1>':U,
                                                                  caps(bttField.DataType)),
                                                          plAddTags)))
                                     ).
  
  end. /* if available(bttField) */
  
end. /* do iFieldCounter = 1 to num-entries(pcFieldList) */

return cAssingStatement.

end function. /* qg_cGetFieldAssignmentsStatementForVirtualFields */


function qg_clVirtualDBFieldValueAsLongchar returns longchar 
  ( pcDataType      as character,
    pcFieldName     as character,
    pcObjectIdValue as character,
    pcFormat        as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDataType                                                                 */
/* pcFieldName                                                                */
/* pcObjectIdValue                                                            */
/* pcFormat                                                                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable cMethodName  as character no-undo.
define variable cFieldValue  as character   no-undo.
define variable iFieldValue  as integer     no-undo.
define variable dFieldValue  as decimal     no-undo.
define variable lFieldValue  as logical     no-undo.
define variable tFieldValue  as date        no-undo.
define variable tzFieldValue as datetime-tz no-undo.
define variable clFieldValue as longchar    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cMethodName = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                              'cMethodNameByDataType':U,
                              pcDataType ).

if cMethodName > '':U then
  
  case pcDataType:
    
    when 'character':U then
    do:
      
      cFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                    cMethodName,
                                    pcObjectIdValue,
                                    pcFieldName ).
      
      return ( if pcFormat <> ? then
                 string( cFieldValue, pcFormat )
               else
                 cFieldValue ).
      
    end. /* when 'character':U */
    
    when 'integer':U then
    do:
      
      iFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                    cMethodName,
                                    pcObjectIdValue,
                                    pcFieldName ).
      
      return ( if pcFormat <> ? then
                 trim( string( iFieldValue, pcFormat ) )
               else
                 trim( string( iFieldValue ) ) ).
      
    end. /* when 'integer':U */
    
    when 'decimal':U then
    do:
      
      dFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                    cMethodName,
                                    pcObjectIdValue,
                                    pcFieldName ).
      
      return ( if pcFormat <> ? then
                 trim( string( dFieldValue, pcFormat ) )
               else
                 trim( string( dFieldValue ) ) ).
      
    end. /* when '':U */
    
    when 'logical':U then
    do:
      
      lFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                    cMethodName,
                                    pcObjectIdValue,
                                    pcFieldName ).
      
      return ( if pcFormat <> ? then
                 trim( string( lFieldValue, pcFormat ) )
               else
                 trim( string( lFieldValue ) ) ).
      
    end. /* when '':U */
    
    when 'date':U then
    do:
      
      tFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                    cMethodName,
                                    pcObjectIdValue,
                                    pcFieldName ).
      
      return ( if pcFormat <> ? then
                 trim( string( tFieldValue, pcFormat ) )
               else
                 trim( string( tFieldValue ) ) ).
      
    end. /* when 'date':U */
    
    when 'datetime-tz':U then
    do:
      
      tzFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                     cMethodName,
                                     pcObjectIdValue,
                                     pcFieldName ).
      
      return ( if pcFormat <> ? then
                 trim( string( tzFieldValue, pcFormat ) )
               else
                 trim( string( tzFieldValue ) ) ).
      
    end. /* when '':U */
    
    when 'clob':U then
    do:
      
      clFieldValue = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                     cMethodName,
                                     pcObjectIdValue,
                                     pcFieldName ).
      
      /* Never apply format to clob fields. */
      
      return clFieldValue.
      
    end. /* when '':U */
    
    otherwise
      return ?.
    
  end case. /* pcDataType */
  
catch oError as class progress.lang.error:
  return ?.
end catch.

end function. /* qg_clVirtualDBFieldValueAsLongchar */


function qg_clVirtualFieldValueAsLongchar returns longchar 
  ( piFieldType     as integer,
    pcDataType      as character,
    pcFieldName     as character,
    pcObjectIdValue as character,
    pcFormat        as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piFieldType                                                                */
/* pcDataType                                                                 */
/* pcFieldName                                                                */
/* pcObjectIdValue                                                            */
/* pcFormat                                                                   */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

case piFieldType:
  
  when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
    
    return qg_clVirtualDBFieldValueAsLongchar( pcDataType,
                                               pcFieldName,
                                               pcObjectIdValue,
                                               pcFormat ).
  
  otherwise
    return ?.
  
end case. /* case phQueryWindowFieldBuffer::FieldType */

end function. /* qg_clVirtualFieldValueAsLongchar */


function qg_lBufferCompareSingleVirtualField returns logical 
  ( phBuffer1             as handle,
    plDatabase1IsPhysical as logical,
    pcObjectIdValue1      as character,
    phBuffer2             as handle,
    plDatabase2IsPhysical as logical,
    pcObjectIdValue2      as character,
    pcFieldName           as character,
    pcDataType            as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer1                                                                  */
/* plDatabase1IsPhysical                                                      */
/* pcObjectIdValue1                                                           */
/* phBuffer2                                                                  */
/* plDatabase2IsPhysical                                                      */
/* pcObjectIdValue2                                                           */
/* pcFieldName                                                                */
/* pcDataType                                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable hField1       as handle    no-undo.
define variable hField2       as handle    no-undo.

define variable cMethodName   as character no-undo.
define variable clFieldValue1 as longchar  no-undo.
define variable clFieldValue2 as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

hField1 = phBuffer1:buffer-field( pcFieldName ) no-error.
hField2 = phBuffer2:buffer-field( pcFieldName ) no-error.

/* Case 1: Field does exist physically in both tables. */

if    valid-handle( hField1 )
  and valid-handle( hField2 ) then
do:
  
  if    hField1:data-type <> hField2:data-type
     or hField1:extent     > 0
     or hField2:extent     > 0 then
    
    return yes.
  
  if lookup( hField1:data-type, 'CLOB,BLOB':U ) = 0 then
    
    return ( if lookup( hField1:data-type, 'character,longchar':U ) = 0 then
               ( hField1:buffer-value = hField2:buffer-value )
             else
               compare( hField1:buffer-value,
                        'EQ':U,
                        hField1:buffer-value,
                        'RAW':U ) ).
  
  else
  do:
    
    copy-lob
      from hField1:buffer-value
      to clFieldValue1
      .
    
    copy-lob
      from hField1:buffer-value
      to clFieldValue2
      .
    
    return compare( clFieldValue1,
                    'EQ':U,
                    clFieldValue2,
                    'RAW':U ).
    
  end. /* else: if lookup( pcDataType, 'CLOB,BLOB':U ) = 0 */
  
end. /* if    valid-handle( hField1 ) */

/* Case 2: Field does not exist physically in both tables. */

else
  
  if    not valid-handle( hField1 )
    and not valid-handle( hField2 ) then
  do:
    
    if    not plDatabase1IsPhysical
       or not plDatabase2IsPhysical then
      
      return yes.
    
    cMethodName = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                  'cMethodNameByDataType':U,
                                  pcDataType ).
    
    return ( if lookup( pcDataType, 'character,longchar':U ) = 0 then
                 dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                      cMethodName,
                                      pcObjectIdValue1,
                                      pcFieldName )
               = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                    cMethodName,
                                    pcObjectIdValue2,
                                    pcFieldName )
             else
               compare( dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                        cMethodName,
                                        pcObjectIdValue1,
                                        pcFieldName ),
                        'EQ':U,
                        dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                        cMethodName,
                                        pcObjectIdValue2,
                                        pcFieldName ),
                        'RAW':U ) ).
    
  end. /* if    not valid-handle( hField1 ) */

/* Case 3: Field does exist physically in table 1 but not in table 2. */

else
  
  if    valid-handle( hField1 )
    and not valid-handle( hField2 ) then
  do:
    
    if not plDatabase2IsPhysical then
      
      return yes.
    
    if    hField1:data-type <> pcDataType
       or hField1:extent     > 0 then
      
      return yes.
    
    cMethodName = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                  'cMethodNameByDataType':U,
                                  pcDataType ).
    
    if lookup( pcDataType, 'CLOB,BLOB':U ) = 0 then
      
      return ( if lookup( pcDataType, 'character,longchar':U ) = 0 then
                   hField1:buffer-value
                 = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                   cMethodName,
                                   pcObjectIdValue2,
                                   pcFieldName )
               else
                 compare( hField1:buffer-value,
                          'EQ':U,
                          dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                          cMethodName,
                                          pcObjectIdValue2,
                                          pcFieldName ),
                          'RAW':U ) ).
      
    else
    do:
      
      copy-lob
        from hField1:buffer-value
        to clFieldValue1
        .
      
      return compare( clFieldValue1,
                      'EQ':U,
                      dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                      cMethodName,
                                      pcObjectIdValue2,
                                      pcFieldName ),
                      'RAW':U ).
      
    end. /* else: if lookup( pcDataType, 'CLOB,BLOB':U ) = 0 */
    
  end. /* else: if    not error-status:error */

/* Case 4: Field does exist physically in table 2 but not in table 1. */

else
  
  if    not valid-handle( hField1 )
    and valid-handle( hField2 ) then
  do:
    
    if not plDatabase1IsPhysical then
      
      return yes.
    
    if    hField2:data-type <> pcDataType
       or hField2:extent     > 0 then
      
      return yes.
    
    cMethodName = dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                  'cMethodNameByDataType':U,
                                  pcDataType ).
    
    if lookup( pcDataType, 'CLOB,BLOB':U ) = 0 then
      
      return ( if lookup( pcDataType, 'character,longchar':U ) = 0 then
                   dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                   cMethodName,
                                   pcObjectIdValue1,
                                   pcFieldName )
                 = hField2:buffer-value
               else
                 compare( dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                          cMethodName,
                                          pcObjectIdValue1,
                                          pcFieldName ),
                          'EQ':U,
                          hField2:buffer-value,
                          'RAW':U ) ).
      
    else
    do:
      
      copy-lob
        from hField2:buffer-value
        to clFieldValue2
        .
      
      return compare( dynamic-invoke( qg_oVirtualDBFieldDataApiInstance(),
                                      cMethodName,
                                      pcObjectIdValue2,
                                      pcFieldName ),
                      'EQ':U,
                      clFieldValue2,
                      'RAW':U ).
      
    end. /* else: if lookup( pcDataType, 'CLOB,BLOB':U ) = 0 */
    
  end. /* else: if    not error-status:error */

  return ?.

end function. /* qg_lBufferCompareSingleVirtualField */


function qg_lVirtualDBFieldsPossible returns logical 
  ( buffer pbttDatabase for ttDatabase ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttDatabase                                                               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if pbttDatabase.BasisDBName <> {&K_BASE_DB_NAME} then
  
  return no.


/* We are not really interested in the fields object id. We make this call to */
/* deterimine if (1) the field exists and (2) we are in an environment that   */
/* has the repository manager up and runnung.                                 */

if    qg_lFieldExistsInDatabaseSchema( pbttDatabase.BasisDBName,
                                       'DRC_VirtualField':U,
                                       gcVirtualDBFieldReposFlagFieldName )
  and dynamic-function( 'pa_cReposFieldInformationByName':U,
                        /* pcDRC_Table_ID */ 'DRC_VirtualField':U,
                        /* pcDRC_Field_ID */ gcVirtualDBFieldReposFlagFieldName,
                        /* pcRequest      */ 'DRC_Field_Obj':U ) > '':U then
    
    return yes.
  
  return no.
  
  catch oError as class progress.lang.error:
    
    return no.
    
  end catch. /* progress.lang.error */
  
end function. /* qg_lVirtualDBFieldsPossible */


function qg_oVirtualDBFieldDataApiInstance returns class progress.lang.object 
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable oAddDataClass as Progress.Lang.Class no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

&IF keyword-all('dynamic-property':U) <> ? &THEN
  
  if not valid-object( goVirtualDBFieldDataApiInstance ) then
  do:
    
    oAddDataClass = Progress.Lang.Class:GetClass( 'basis.base.cls.BMCAddDataSvc':U ) no-error.
    
    if not valid-object( oAddDataClass ) then
      oAddDataClass = Progress.Lang.Class:GetClass( 'x.adm.cls.XDCAddDataSvc':U ) no-error.
    
    if valid-object( oAddDataClass ) then
      goVirtualDBFieldDataApiInstance = oAddDataClass:GetPropertyValue( 'prpoInstance':U ).
    
  end.
  
&ENDIF

return goVirtualDBFieldDataApiInstance.

catch oError as class progress.lang.error:
  return ?.
end catch.

end function. /* qg_oVirtualDBFieldDataApiInstance */


function qg_oVirtualDBFieldDataFieldApiInstance returns class progress.lang.object 
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable oAddDataClass as Progress.Lang.Class no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

&IF keyword-all( 'dynamic-property':U ) <> ? &THEN
  
  if not valid-object( goVirtualDBFieldDataFieldApiInstance ) then
  do:
    
    oAddDataClass = Progress.Lang.Class:GetClass( 'adm.repos.cls.DRCAddDataFieldSvc':U ) no-error.
    
    if not valid-object( oAddDataClass ) then
      oAddDataClass = Progress.Lang.Class:GetClass( 'x.adm.cls.XDCAddDataSvc':U ) no-error.
    
    if valid-object( oAddDataClass ) then
      goVirtualDBFieldDataFieldApiInstance = oAddDataClass:GetPropertyValue( 'prpoInstance':U ).
    
  end.
  
&ENDIF

return goVirtualDBFieldDataFieldApiInstance.

catch oError as class progress.lang.error:
  return ?.
end catch.

end function. /* qg_oVirtualDBFieldDataFieldApiInstance */

/* <<< Include: incl/virtual_fields.i <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* >>> Include: incl/virtual_indices.i >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*------------------------------------------------------------------------
    File        : virtual_indices.i
    Purpose     : 

    Syntax      :

    Description : 

    Author(s)   : Thiemann_M
    Created     : Wed Jun 01 14:37:00 CEST 2022
    Notes       :
  ----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */


/* ********************  Preprocessor Definitions  ******************** */


/* ***************************  Main Block  *************************** */



/* **********************  Internal Procedures  *********************** */

procedure qg_AddTableVirtualIndices :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttDatabase                                                               */
/* pbttTable                                                                  */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttDatabase for temp-table ttDatabase.
define parameter buffer pbttTable    for temp-table ttTable.

/* Variables -----------------------------------------------------------------*/

define variable hRepVirtualIndexBuffer      as handle    no-undo.
define variable hRepVirtualIndexFieldBuffer as handle    no-undo.

define variable hRepVirtualIndexQuery       as handle    no-undo.
define variable hRepVirtualIndexFieldQuery  as handle    no-undo.
define variable cIndexQueryText             as character no-undo.
define variable cIndexFieldQueryText        as character no-undo.

define variable iVirtIdxFieldNo             as integer   no-undo.
define variable cVirtIdxFieldDataType       as character no-undo.
define variable cLastVirtIdxFieldDataType   as character no-undo init 'Dec':U.

define variable cMappedFields               as character no-undo.
define variable iMappedFieldIndex           as integer   no-undo.
define variable cSkippedFields              as character no-undo.
define variable iSkippedFieldIndex          as integer   no-undo.

define variable cFieldName                  as character no-undo.
define variable cFieldDataType              as character no-undo.
define variable cFieldValue                 as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndex              for temp-table ttIndex.
define buffer bttIndexField         for temp-table ttIndexField.
define buffer bttTable              for temp-table ttTable.
define buffer bttField              for temp-table ttField.
define buffer bttTable-Virtual      for temp-table ttTable.
define buffer bttIndex-Virtual      for temp-table ttIndex.
define buffer bttIndexField-Virtual for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttTable-Virtual
  where bttTable-Virtual.DatabaseName = pbttDatabase.BasisDBName
    and bttTable-Virtual.TableName    = gcVirtualIndexDataTableName
  no-error.

if    available bttTable-Virtual
  and not bttTable-Virtual.DetailsLoaded
  and bttTable-Virtual.TableName <> pbttTable.TableName then

  run qg_AddTableDetails( bttTable-Virtual.DatabaseName,
                          bttTable-Virtual.TableName ).

create buffer hRepVirtualIndexBuffer for table substitute( '&1.DRC_Index':U,
                                                           pbttDatabase.BasisDBName ).
create buffer hRepVirtualIndexFieldBuffer for table substitute( '&1.DRC_IndexField':U,
                                                                 pbttDatabase.BasisDBName ).

create query hRepVirtualIndexQuery.
create query hRepVirtualIndexFieldQuery.

hRepVirtualIndexQuery:set-buffers( hRepVirtualIndexBuffer ).
hRepVirtualIndexFieldQuery:set-buffers( hRepVirtualIndexFieldBuffer ).

assign
  cIndexQueryText      =            'for each DRC_Index':U
                         + '~n':U + '  where DRC_Index.DRC_Table_Obj = &1':U
                         + '~n':U + '    and DRC_Index.&2            = yes':U
                         + '~n':U + '  no-lock':U
  cIndexFieldQueryText =            'for each DRC_IndexField':U
                         + '~n':U + '  where DRC_IndexField.DRC_Index_Obj = &1':U
                         + '~n':U + '  no-lock':U
                         .

hRepVirtualIndexQuery:query-prepare( substitute( cIndexQueryText,
                                                 quoter( pbttTable.RepObjectId ),
                                                 gcVirtualIndexReposFlagFieldName ) ).

hRepVirtualIndexQuery:query-open().

do while hRepVirtualIndexQuery:get-next():
  
  create bttIndex.
  
  assign
    bttIndex.DatabaseName = pbttDatabase.DatabaseName
    bttIndex.TableName    = pbttTable.TableName
    bttIndex.IndexName    = hRepVirtualIndexBuffer::DRC_Index_ID
    bttIndex.IsPrimary    = hRepVirtualIndexBuffer::IndexIsPrimary
    bttIndex.IsUnique     = hRepVirtualIndexBuffer::IndexIsUnique
    bttIndex.IsVirtual    = yes
    .
  
  validate bttIndex.
  
  assign
    iVirtIdxFieldNo           = 0
    cMappedFields             = '':U
    cSkippedFields            = '':U
    cLastVirtIdxFieldDataType = '':U
    .
  
  hRepVirtualIndexFieldQuery:query-prepare( substitute( cIndexFieldQueryText, quoter( hRepVirtualIndexBuffer::DRC_Index_Obj ) ) ).
  
  hRepVirtualIndexFieldQuery:query-open().
  
  do while hRepVirtualIndexFieldQuery:get-next()
    on error undo, throw:
    
    find bttField
      where bttField.RepObjectId = hRepVirtualIndexFieldBuffer::DRC_Field_Obj
      no-error.
    
    if not available bttField then
      next.
    
    create bttIndexField.
  
    assign
      bttIndexField.DatabaseName     = bttIndex.DatabaseName
      bttIndexField.TableName        = bttIndex.TableName
      bttIndexField.IndexName        = bttIndex.IndexName
      bttIndexField.FieldName        = bttField.FieldName
      bttIndexField.IndexSequence    = hRepVirtualIndexFieldBuffer::DRC_IndexField_ID
      bttIndexField.DataType         = bttField.DataType
      bttIndexField.SortAscending    = hRepVirtualIndexFieldBuffer::IndexFieldAscending
      bttIndex.IndexFieldList        =   bttIndex.IndexFieldList
                                       + ',':U
                                       + bttIndexField.FieldName
      bttIndex.IndexFields           =   bttIndex.IndexFields
                                       + ' '
                                       + string( bttIndexField.SortAscending, '+/-':U )
                                       + bttIndexField.FieldName
      bttIndex.VirtualFieldList      =   bttIndex.VirtualFieldList
                                       + ',':U
                                       + bttIndexField.FieldName
      bttIndex.VirtualFieldDataTypes =   bttIndex.VirtualFieldDataTypes
                                       + ',':U
                                       + bttIndexField.DataType
      cVirtIdxFieldDataType          = ( if bttIndexField.DataType = 'character':U then
                                           'Char':U
                                         else
                                           'Dec':U )
      .
    
    validate bttIndexField.
    
    if cVirtIdxFieldDataType = cLastVirtIdxFieldDataType then
      
      assign
        iVirtIdxFieldNo = iVirtIdxFieldNo + 1
        cSkippedFields  =   cSkippedFields
                          + ',Field':U
                          + string( iVirtIdxFieldNo, '99':U )
                          + ( if cLastVirtIdxFieldDataType = 'Char':U then
                                'Dec':U
                              else
                                'Char':U )
        .
    
    assign
      iVirtIdxFieldNo = iVirtIdxFieldNo + 1
      cMappedFields   =   cMappedFields
                        + ',Field':U
                        + string( iVirtIdxFieldNo, '99':U )
                        + cVirtIdxFieldDataType
      cLastVirtIdxFieldDataType = cVirtIdxFieldDataType
      .
    
  end. /* do while hRepVirtualIndexFieldQuery:get-next() */
  
  assign
    bttIndex.IndexFieldList                 = trim( bttIndex.IndexFieldList, ',':U )
    bttIndex.IndexFields                    = trim( bttIndex.IndexFields )
    bttIndex.VirtualFieldList               = trim( bttIndex.VirtualFieldList, ',':U )
    bttIndex.VirtualFieldDataTypes          = trim( bttIndex.VirtualFieldDataTypes, ',':U )
    cSkippedFields                          = trim( cSkippedFields, ',':U )
    cMappedFields                           = trim( cMappedFields, ',':U )
    bttIndex.VirtualIndexDataFieldList      = 'DRC_Table_ID,DRC_Index_ID':U
    bttIndex.VirtualIndexDataFieldLabels    = ',':U
    bttIndex.VirtualIndexDataUntaggedValues = '~'':U + bttIndex.TableName + '~':U':U + {&K_PARAM_SPLITTER} + '~'':U + bttIndex.IndexName + '~':U':U
    bttIndex.VirtualIndexDataTaggedValues   = '~'':U + bttIndex.TableName + '~':U':U + {&K_PARAM_SPLITTER} + '~'':U + bttIndex.IndexName + '~':U':U
    .
  
  find first bttIndex-Virtual
    where bttIndex-Virtual.DatabaseName = bttTable-Virtual.DatabaseName
      and bttIndex-Virtual.TableName    = bttTable-Virtual.TableName
    no-error.
  
  if available bttIndex-Virtual then
  
    for each bttIndexField-Virtual
      where bttIndexField-Virtual.DatabaseName = bttIndex-Virtual.DatabaseName
        and bttIndexField-Virtual.TableName    = bttIndex-Virtual.TableName
      on error undo, throw:
      
      if lookup( bttIndexField-Virtual.FieldName, 'DRC_Table_ID,DRC_Index_ID':U ) > 0 then
        next.
      
      assign
        iMappedFieldIndex  = lookup( bttIndexField-Virtual.FieldName, cMappedFields )
        iSkippedFieldIndex = ( if iMappedFieldIndex > 0 then
                                 0
                               else
                                 lookup( bttIndexField-Virtual.FieldName, cSkippedFields ) )
        .
      
      if    iMappedFieldIndex  = 0
        and iSkippedFieldIndex = 0 then
        
        leave.
      
      assign
        bttIndex.VirtualIndexDataFieldList      =   bttIndex.VirtualIndexDataFieldList
                                                  + ',':U
                                                  + bttIndexField-Virtual.FieldName
        bttIndex.VirtualIndexDataFieldLabels    =   bttIndex.VirtualIndexDataFieldLabels
                                                  + ',':U
                                                  + ( if iMappedFieldIndex > 0 then
                                                        entry( iMappedFieldIndex, bttIndex.IndexFieldList )
                                                      else
                                                        '':U )
        cFieldName                              = ( if iMappedFieldIndex > 0 then
                                                      entry( iMappedFieldIndex, bttIndex.VirtualFieldList )
                                                    else
                                                      '':U )
        cFieldDataType                          = ( if iMappedFieldIndex > 0 then
                                                      entry( iMappedFieldIndex, bttIndex.VirtualFieldDataTypes )
                                                    else
                                                      bttIndexField-Virtual.DataType )
        cFieldValue                             = ( if iMappedFieldIndex > 0 then
                                                      ( if can-do( {&K_COMPANY_FIELDS}, cFieldName ) then
                                                          substitute( '~{firma/&1 %COMPANY%}':U,
                                                                      qg_cGetCompanyInclude( bttIndex.TableName ) )
                                                        else if not cFieldDataType begins 'datetime':U then
                                                          substitute( '<&1>':U, caps( cFieldDataType ) )
                                                        else
                                                          qg_cVirtualIndexFieldVariableName( cFieldName, 'decimal':U ) )
                                                    else
                                                      ( if bttIndexField-Virtual.DataType = 'character':U then
                                                          '~'~':U':U
                                                        else
                                                          '0':U ) )
        bttIndex.VirtualIndexDataUntaggedValues =   bttIndex.VirtualIndexDataUntaggedValues
                                                  + {&K_PARAM_SPLITTER}
                                                  + cFieldValue
        bttIndex.VirtualIndexDataTaggedValues   = bttIndex.VirtualIndexDataTaggedValues
                                                  + {&K_PARAM_SPLITTER}
                                                  + ( if can-do( {&K_COMPANY_FIELDS}, cFieldName ) then
                                                        cFieldValue
                                                      else if lookup( cFieldDataType, 'character,decimal':U ) > 0 then
                                                        qg_cTaggedValue( cFieldValue,
                                                                         (     iMappedFieldIndex > 0
                                                                           and cFieldValue > '':U ) )
                                                      else if not cFieldDataType begins 'datetime':U then
                                                        substitute( 'decimal( &1 )':U,
                                                                    qg_cTaggedValue( cFieldValue,
                                                                                     (     iMappedFieldIndex > 0
                                                                                       and cFieldValue > '':U ) ) )
                                                      else
                                                        cFieldValue )
        .
      
    end. /* for each bttIndexField-Virtual */
  
  validate bttIndex.
  
end. /* do while not hRepVirtualIndexQuery:query-off-end */

end procedure. /* qg_AddTableVirtualIndices */

procedure qg_InitializeVirtualIndexFramework :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable oVirtualQueryApiClass as Progress.Lang.Class no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

oVirtualQueryApiClass = Progress.Lang.Class:GetClass( 'basis.base.cls.BMCVirtIndexQuerySvo':U ) no-error.

if valid-object( oVirtualQueryApiClass ) then
  
  assign
    gcVirtualQueryApiPackageName     = 'basis.base.cls':U
    gcVirtualQueryApiClassName       = 'BMCVirtIndexQuerySvo':U
    gcVirtualIndexDataTableName      = 'DBT_VirtualIndex':U
    gcVirtualIndexReposFlagFieldName = 'IndexIsVirtual':U
    .

else
do:
  
  oVirtualQueryApiClass = Progress.Lang.Class:GetClass( 'x.adm.cls.XDCVirtQuerySvo':U ) no-error.
  
  if valid-object( oVirtualQueryApiClass ) then
    
    assign
      gcVirtualQueryApiPackageName      = 'x.adm.cls':U
      gcVirtualQueryApiClassName        = 'XDCVirtQuerySvo':U
      gcVirtualIndexDataTableName       = 'XDM_VirtualIndex':U
      gcVirtualIndexReposFlagFieldName  = 'xVirtualIndex':U
      .
  
end.

end procedure. /* qg_InitializeVirtualIndexFramework */


/* ************************  Function Implementations ***************** */

function qg_cVirtualIndexFieldVariableName returns character 
  ( pcFieldName as character,
    pcDataType  as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFieldName                                                                */
/* pcDataType                                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable cFieldName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cFieldName = ( if pcFieldName = 'Firma':U then
                 'Company':U
               else
                 pcFieldName ).

return    qg_cDataTypePrefix( pcDataType )
        + ( if    cFieldName begins 'x':U
               or cFieldName begins 'y':U then
              substring( cFieldName, 1, 1 )
            else
              caps( substring( cFieldName, 1, 1 ) ) )
        + substring( cFieldName, 2 )
        .

end function. /* qg_cVirtualIndexFieldVariableName */


function qg_lVirtualIndexPossible returns logical 
  ( buffer pbttDatabase for ttDatabase ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pbttDatabase                                                               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/    

if pbttDatabase.BasisDBName <> {&K_BASE_DB_NAME} then
  
  return no.

/* We are not really interested in the fields object id. We make this call to */
/* deterimine if (1) the field exists and (2) we are in an environment that   */
/* has the repository manager up and runnung.                                 */

if    qg_lFieldExistsInDatabaseSchema( pbttDatabase.BasisDBName,
                                       'DRC_VirtualField':U,
                                       gcVirtualDBFieldReposFlagFieldName )
  and dynamic-function( 'pa_cReposFieldInformationByName':U,
                        /* pcDRC_Table_ID */ 'DRC_Index':U,
                        /* pcDRC_Field_ID */ gcVirtualIndexReposFlagFieldName,
                        /* pcRequest      */ 'DRC_Field_Obj':U ) > '':U then
  
  return yes.

return no.

catch oError as class progress.lang.error:
  return no.
end catch. /* progress.lang.error */

end function. /* qg_lVirtualIndexPossible */


function qg_oVirtualIndexApiInstance returns class progress.lang.object 
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable oVirtualIndexClass as Progress.Lang.Class no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

&IF keyword-all('dynamic-property':U) <> ? &THEN
  
  if not valid-object( goVirtualIndexApiInstance ) then
  do:
    
    oVirtualIndexClass = Progress.Lang.Class:GetClass( 'adm.repos.cls.DRCVirtualIndexSvc':U ) no-error.
    
    if not valid-object( oVirtualIndexClass ) then
      oVirtualIndexClass = Progress.Lang.Class:GetClass( 'x.adm.cls.XDCVirtualIndexSvc':U ) no-error.
    
    if valid-object( oVirtualIndexClass ) then
      goVirtualIndexApiInstance = oVirtualIndexClass:GetPropertyValue( 'prpoInstance':U ).
    
  end.
  
&ENDIF

return goVirtualIndexApiInstance.

catch oError as class progress.lang.error:
  return ?.
end catch.

end function. /* qg_oVirtualIndexApiInstance */


function qg_oVirtualIndexDataApiInstance returns class progress.lang.object 
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable oVirtualIndexClass as Progress.Lang.Class no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

&IF keyword-all('dynamic-property':U) <> ? &THEN
  
  if not valid-object( goVirtualIndexDataApiInstance ) then
  do:
    
    oVirtualIndexClass = Progress.Lang.Class:GetClass( 'basis.base.cls.BMCVirtualIndexSvc':U ) no-error.
    
    if not valid-object( oVirtualIndexClass ) then
      oVirtualIndexClass = Progress.Lang.Class:GetClass( 'x.adm.cls.XDCVirtualIndexSvc':U ) no-error.
    
    if valid-object( oVirtualIndexClass ) then
      goVirtualIndexDataApiInstance = oVirtualIndexClass:GetPropertyValue( 'prpoInstance':U ).
    
  end.
  
&ENDIF

return goVirtualIndexDataApiInstance.

catch oError as class progress.lang.error:
  return ?.
end catch.

end function. /* qg_oVirtualIndexDataApiInstance */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

/* <<< Include: incl/virtual_indices.i <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */



/* ************************  Control Triggers  ************************ */

&Scoped-define SELF-NAME hQueryWindow
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL hQueryWindow hQueryWindow
ON end-error OF hQueryWindow
or endkey of {&WINDOW-NAME} anywhere do:
  /* This case occurs when the user presses the "Esc" key.
     In a persistently run window, just ignore this.  If we did not, the
     application would exit. */
  if this-procedure:persistent then return no-apply.
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL hQueryWindow hQueryWindow
ON window-close OF hQueryWindow
do:

  define buffer bttQueryWindow  for temp-table ttQueryWindow.
  define buffer bttTable        for temp-table ttTable.

  for each bttQueryWindow
    on error undo, next:
    
    if valid-handle(bttQueryWindow.WindowHandle) then
      run qg_QueryWindowClose(bttQueryWindow.WindowHandle, no).
    
    else
      delete bttQueryWindow.
    
  end. /* for each bttQueryWindow */
  
  if    OEIDEIsRunning
    and glIDECanSaveSetting then
  do:
    
    /* gcTableFilter history */
    if gcTableFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcTableFilter':U,
                            gcTableFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcTableFieldFilter history */
    if gcTableFieldFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcTableFieldFilter':U,
                            gcTableFieldFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcIndexFilter history */
    if gcIndexFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcIndexFilter':U,
                            gcIndexFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcIndexFieldFilter history */
    if gcIndexFieldFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcIndexFieldFilter':U,
                            gcIndexFieldFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcRelationFilter history */
    if gcRelationFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcRelationFilter':U,
                            gcRelationFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcRelationFieldFilter history */
    if gcRelationFieldFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcRelationFieldFilter':U,
                            gcRelationFieldFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcFieldFilter history */
    if gcFieldFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcFieldFilter':U,
                            gcFieldFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* gcFieldLabelFilter history */
    if gcFieldLabelFilter:list-items in frame {&FRAME-NAME} <> ? then
      run qg_SaveIDESetting('FieldHistory_gcFieldLabelFilter':U,
                            gcFieldLabelFilter:list-items in frame {&FRAME-NAME}) no-error.
    
    /* Initial gcBufferName */
    run qg_SaveIDESetting('FieldInitial_gcBufferName':U,
                          gcBufferPattern) no-error.
    
    /* Initial glDefineBuffer */
    run qg_SaveIDESetting('FieldInitial_glDefineBuffer':U,
                          string(input frame {&FRAME-NAME} glDefineBuffer, 'true/false':U)) no-error.
    
    /* Initial glCompanyViaClass */
    run qg_SaveIDESetting('FieldInitial_glCompanyViaClass':U,
                          string(input frame {&FRAME-NAME} glCompanyViaClass, 'true/false':U)) no-error.
    
    /* Initial glExclusiveLock */
    run qg_SaveIDESetting('FieldInitial_glExclusiveLock':U,
                          string(input frame {&FRAME-NAME} glExclusiveLock, 'true/false':U)) no-error.
    
    /* Initial glNoError */
    run qg_SaveIDESetting('FieldInitial_glNoError':U,
                          string(input frame {&FRAME-NAME} glNoError, 'true/false':U)) no-error.
    
    /* Initial glIfStatement */
    run qg_SaveIDESetting('FieldInitial_glIfStatement':U,
                          string(input frame {&FRAME-NAME} glIfStatement, 'true/false':U)) no-error.
    
    /* Initial glNot */
    run qg_SaveIDESetting('FieldInitial_glNot':U,
                          string(input frame {&FRAME-NAME} glNot, 'true/false':U)) no-error.
    
    /* Initial glDoBlock */
    run qg_SaveIDESetting('FieldInitial_glDoBlock':U,
                          string(input frame {&FRAME-NAME} glDoBlock, 'true/false':U)) no-error.
    
    /* Initial glDefineVariables */
    run qg_SaveIDESetting('FieldInitial_glDefineVariables':U,
                          string(input frame {&FRAME-NAME} glDefineVariables, 'true/false':U)) no-error.
    
    /* Initial glUseVirtualIndexIncludes */
    run qg_SaveIDESetting('FieldInitial_glUseVirtualIndexIncludes':U,
                          string(input frame {&FRAME-NAME} glUseVirtualIndexIncludes, 'true/false':U)) no-error.
    
    /* Initial glOnError */
    run qg_SaveIDESetting('FieldInitial_glOnError':U,
                          string(input frame {&FRAME-NAME} glOnError)) no-error.
    
    /* Initial giOnErrorPhrase */
    run qg_SaveIDESetting('FieldInitial_giOnErrorPhrase':U,
                          string(input frame {&FRAME-NAME} giOnErrorPhrase)) no-error.
    
    /* Initial gcBlockName */
    run qg_SaveIDESetting('FieldInitial_gcBlockName':U,
                          gcBlockPattern) no-error.
    
    /* Initial glDefineBlock */
    run qg_SaveIDESetting('FieldInitial_glDefineBlock':U,
                          string(input frame {&FRAME-NAME} glDefineBlock, 'true/false':U)) no-error.
    
    /* Initial glRetryBlock */
    run qg_SaveIDESetting('FieldInitial_glRetryBlock':U,
                          string(input frame {&FRAME-NAME} glRetryBlock, 'true/false':U)) no-error.
    
    /* Initial glFinallyBlock */
    run qg_SaveIDESetting('FieldInitial_glFinallyBlock':U,
                          string(input frame {&FRAME-NAME} glFinallyBlock, 'true/false':U)) no-error.
    
    /* Initial giQueryType */
    run qg_SaveIDESetting('FieldInitial_giQueryType':U,
                          string(input frame {&FRAME-NAME} giQueryType)) no-error.
    
    /*------------------------------------------------------------------------*/
    /* Options                                                                */
    /*------------------------------------------------------------------------*/
    
    /* Show query type modifier */
    
    run qg_SaveIDESetting('Options_ShowQueryTypeModifier':U,
                          string(menu-item mi_ShowQueryTypeModifier:checked in menu m_Options, 'true/false':U)) no-error.
    
    /* Always use 'find first' */
    
    run qg_SaveIDESetting('Options_AlwaysUseFindFirst':U,
                          string(menu-item mi_AlwaysUseFindFirst:checked in menu m_Options, 'true/false':U)) no-error.
    
    /* Always use 'can-find first' */
    
    run qg_SaveIDESetting('Options_AlwaysUseCanFindFirst':U,
                          string(menu-item mi_AlwaysUseCanFindFirst:checked in menu m_Options, 'true/false':U)) no-error.
    
    /* Use virtual index api */
    
    run qg_SaveIDESetting('Options_glUseVirtualIndexApi':U,
                          string(menu-item mi_UseVirtualIndexApi:checked in menu m_Options, 'true/false':U)) no-error.
    
    /* Open query window for persistent temp-tables */
    
    run qg_SaveIDESetting('Options_OpenQueryWindowForPersistentTT':U,
                          string(menu-item mi_OpenQueryWindowPersistentTT:checked in menu m_Options, 'true/false':U)) no-error.
    
    /* Open query window for snapshot temp-tables */
    
    run qg_SaveIDESetting('Options_OpenQueryWindowForSnapshotTT':U,
                          string(menu-item mi_OpenQueryWindowSnapshotTT:checked in menu m_Options, 'true/false':U)) no-error.
    
    /*--------------------------------------------------------------------------*/
    /* Session-Trigger settings                                                 */
    /*--------------------------------------------------------------------------*/
  
    run qg_SaveIDESetting('Options_SessionTriggerShowMessage':U,
                          string(glSessionTriggerShowMessage, 'true/false':U)) no-error.

    run qg_SaveIDESetting('Options_SessionTriggerWriteLog':U,
                          string(glSessionTriggerWriteLog, 'true/false':U)) no-error.

    run qg_SaveIDESetting('Options_SessionTriggerLogFileName':U,
                          gcSessionTriggerLogFileName) no-error.

    run qg_SaveIDESetting('Options_SessionTriggerIndexValues':U,
                          string(glSessionTriggerIndexValues, 'true/false':U)) no-error.

    run qg_SaveIDESetting('Options_SessionTriggerStackTrace':U,
                          string(glSessionTriggerStackTrace, 'true/false':U)) no-error.
    
    /*--------------------------------------------------------------------------*/
    /* Session-Trigger settings                                                 */
    /*--------------------------------------------------------------------------*/
    
    run qg_SaveIDESetting('Options_ShowVirtualFields':U,
                          string(glShowVirtualFields, 'true/false':U)) no-error.
    
    run qg_SaveIDESetting('Options_ShowVirtualIndices':U,
                          string(glShowVirtualIndices, 'true/false':U)) no-error.
    
  end. /* if    OEIDEIsRunning ... */
  
  for each bttTable
    where bttTable.PhysicalTable = no
    on error undo, next:
    
    if    bttTable.Snapshot
      and valid-handle(bttTable.TableHandle) then
      delete object bttTable.TableHandle.
    
  end. /* for each bttTable */
  
  if gcTTWidgetPool > '':U then
    delete widget-pool gcTTWidgetPool no-error.
  
  if valid-handle(ghQueryWindowListWindow) then
    apply 'window-close':U to ghQueryWindowListWindow.
  
  if valid-handle(ghSessionTriggersWindow) then
    apply 'window-close':U to ghSessionTriggersWindow.
  
  run qg_RemoveAllSessionTriggers.
  
  if valid-handle(gchMerge) then
  do:

    release object gchMerge.
    gchMerge = ?.

  end. /* if valid-handle(gchMerge) */

  /* This event will close the window and terminate the procedure.  */
  apply "CLOSE":U to this-procedure.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL hQueryWindow hQueryWindow
ON window-resized OF hQueryWindow
do:

  assign
    hQueryWindow:width-chars  = max(gdMinWidth, hQueryWindow:width-chars)
    hQueryWindow:height-chars = max(gdMinHeight, hQueryWindow:height-chars)
    .

  run qg_AdjustWidgetsSizeAndPos(frame {&FRAME-NAME}:handle,
                                 hQueryWindow:width-chars - gdOriginalWidth,
                                 hQueryWindow:height-chars - gdOriginalHeight).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME fQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on CTRL-INS of frame fQuery anywhere
do:

  apply 'choose' to btnCopyToClipboard in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME fQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on off-home of brTable in frame fQuery anywhere
do:

  apply 'entry' to gcTableFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME fQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcTableFilter in frame fQuery anywhere
do:

  apply 'entry' to brTable in frame {&FRAME-NAME}.
  browse brTable:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearTableFilter in frame fQuery anywhere
do:

  apply 'entry' to brTable in frame {&FRAME-NAME}.
  browse brTable:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcTableFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brTable in frame {&FRAME-NAME}.
  browse brTable:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearTableFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brTable in frame {&FRAME-NAME}.
  browse brTable:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME fQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on off-home of brField in frame fQuery anywhere
do:

  apply 'entry' to gcFieldFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brField in frame {&FRAME-NAME}.
  browse brField:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brField in frame {&FRAME-NAME}.
  browse brField:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcFieldLabelFilter in frame fQuery anywhere
do:

  apply 'entry' to brField in frame {&FRAME-NAME}.
  browse brField:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearFieldLabelFilter in frame fQuery anywhere
do:

  apply 'entry' to brField in frame {&FRAME-NAME}.
  browse brField:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME fQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on off-home of brIndex in frame fQuery anywhere
do:

  apply 'entry' to gcIndexFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcIndexFilter in frame fQuery anywhere
do:

  apply 'entry' to brIndex in frame {&FRAME-NAME}.
  browse brIndex:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearIndexFilter in frame fQuery anywhere
do:

  apply 'entry' to brIndex in frame {&FRAME-NAME}.
  browse brIndex:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcIndexFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brIndex in frame {&FRAME-NAME}.
  browse brIndex:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearIndexFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brIndex in frame {&FRAME-NAME}.
  browse brIndex:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME fQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on off-home of brRelation in frame fQuery anywhere
do:

  apply 'entry' to gcRelationFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcRelationFilter in frame fQuery anywhere
do:

  apply 'entry' to brRelation in frame {&FRAME-NAME}.
  browse brRelation:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearRelationFilter in frame fQuery anywhere
do:

  apply 'entry' to brRelation in frame {&FRAME-NAME}.
  browse brRelation:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of gcRelationFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brRelation in frame {&FRAME-NAME}.
  browse brRelation:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on cursor-down of btnClearRelationFieldFilter in frame fQuery anywhere
do:

  apply 'entry' to brRelation in frame {&FRAME-NAME}.
  browse brRelation:select-focused-row().
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
ON drop-file-notify OF FRAME fQuery
do:

  define variable i         as integer   no-undo.
  define variable cFileName as character no-undo.
  
  do i = 1 to frame fQuery:num-dropped-files:
  
    cFileName = frame fQuery:get-dropped-file(i).
  
    if cFileName matches '*.qsc':U then
      run qg_LoadQueryScenario(cFileName, (i = 1)).
    
  end. /* do i = 1 to frame fQuery:num-dropped-files */
  
  finally:
    
    frame fQuery:end-file-drop().
    
  end finally.
    
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK
on SHIFT-ALT-Q anywhere
do:

  run qg_OpenExternalRecord in target-procedure.
  
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F10 of frame fQuery anywhere
do:

  run qg_SetQueryType({&K_QUERYTYPE_CANFIND}).
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F11 of frame fQuery anywhere
do:

  run qg_SetSlimMode(yes).
  
  assign
    hQueryWindow:width-chars  = {&K_WINDOW_MIN_WIDTH_SLIM}
    hQueryWindow:height-chars = {&K_WINDOW_MIN_HEIGHT_SLIM}
    .

  apply 'window-resized':U to hQueryWindow.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F12 of frame fQuery anywhere
do:

  apply 'choose':U to menu-item mi_RestoreDefaultWindowSize in menu m_Window.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F3 of frame fQuery anywhere
do:

  apply 'entry':U to brDatabase in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F4 of frame fQuery anywhere
do:

  if    valid-handle(focus)
    and focus:name = 'gcTableFilter':U then
    apply 'entry':U to brTable in frame {&FRAME-NAME}.
  
  else  
    apply 'entry':U to gcTableFilter in frame {&FRAME-NAME}.
  
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F5 of frame fQuery anywhere
do:

  if    valid-handle(focus)
    and focus:name = 'gcFieldFilter':U then
    apply 'entry':U to brField in frame {&FRAME-NAME}.
    
  else
  do:
    run qg_SetDisplayMode({&K_DISPLAYMODE_FIELD}).
    apply 'entry':U to gcFieldFilter in frame {&FRAME-NAME}.
  end. /* else: if    valid-handle(focus) ... */
  
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F6 of frame fQuery anywhere
do:

  if    valid-handle(focus)
    and focus:name = 'gcIndexFilter':U then
    apply 'entry':U to brIndex in frame {&FRAME-NAME}.
    
  else
  do:
    run qg_SetDisplayMode({&K_DISPLAYMODE_INDEX}).
    apply 'entry':U to gcIndexFilter in frame {&FRAME-NAME}.
  end. /* else: if    valid-handle(focus) ... */
  
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F7 of frame fQuery anywhere
do:

  apply 'entry':U to gcBufferName in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F8 of frame fQuery anywhere
do:

  run qg_SetQueryType({&K_QUERYTYPE_FINDFIRST}).
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL fQuery hQueryWindow
on SHIFT-F9 of frame fQuery anywhere
do:

  run qg_SetQueryType({&K_QUERYTYPE_FOREACH}).
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define BROWSE-NAME brDatabase
&Scoped-define SELF-NAME brDatabase
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brDatabase hQueryWindow
ON CTRL-C OF brDatabase IN FRAME fQuery
do:

  apply 'choose':U to menu-item mi_CopyDatabaseName in menu POPUP-MENU-brDatabase.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brDatabase hQueryWindow
ON value-changed OF brDatabase IN FRAME fQuery
do:

  run qg_RefreshTableBrowse.
  
  run qg_WidgetState('*':U).

  run qg_SetWorkingDatabase.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define BROWSE-NAME brField
&Scoped-define SELF-NAME brField
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brField hQueryWindow
ON CTRL-A OF brField IN FRAME fQuery
do:

  apply 'choose':U to menu-item mi_SelectAllFields in menu POPUP-MENU-brField.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brField hQueryWindow
ON CTRL-C OF brField IN FRAME fQuery
do:

  apply 'choose':U to menu-item mi_CopyFieldName in menu POPUP-MENU-brField.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brField hQueryWindow
ON default-action OF brField IN FRAME fQuery
do:
  
  define variable iKeyState  as integer   no-undo.
  define variable cFieldName as character no-undo.
  
  run GetKeyState({&K_WIN_CONST_VK_CTRL}, output iKeyState).
  
  if iKeyState >= 0 then
    apply 'choose':U to menu-item mi_FindFieldIndex in sub-menu m_SelectedFields.
  
  else
    if available ttField then
    do:
      
      run GetKeyState({&K_WIN_CONST_VK_SHIFT}, output iKeyState).
      
      assign
        gcBufferName    = (if glSlimMode then
                             substitute({&K_DEFAULT_BUFFER_PATTERN},
                                        qg_cGetBufferBaseName(no))
                           else
                             input frame {&FRAME-NAME} gcBufferName)
        cFieldName      = (if iKeyState < 0 then
                             substitute('&1.&2':U,
                                        gcBufferName,
                                        ttField.FieldName)
                           else
                             ttField.FieldName)
        .
      
      if glInsertMode then
        run qg_IDE_InsertText(qg_cTaggedValue(cFieldName, glInsertMode)).
      
      else
        clipboard:value = cFieldName.
      
    end. /* ese if available ttField */
    
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brField hQueryWindow
ON value-changed OF brField IN FRAME fQuery
do:
  
  run qg_FillQueryRange.
  run qg_UpdateQueryText.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define BROWSE-NAME brIndex
&Scoped-define SELF-NAME brIndex
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brIndex hQueryWindow
ON CTRL-C OF brIndex IN FRAME fQuery
do:

  apply 'choose':U to menu-item mi_CopyIndexName in menu POPUP-MENU-brIndex.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brIndex hQueryWindow
ON default-action OF brIndex IN FRAME fQuery
do:

  apply 'choose':U to menu-item mi_ModifyIndexQueryFields in menu POPUP-MENU-brIndex.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brIndex hQueryWindow
ON value-changed OF brIndex IN FRAME fQuery
do:

  if giDisplayMode = {&K_DISPLAYMODE_INDEX} then
  do:
    
    if    available ttIndex
      and ttIndex.IsVirtual
      and not glUseVirtualIndexApi then
      
      assign
        giRelationId         = 0
        glParentRelation     = no
        gcRelationBufferName = gcVirtualIndexDataTableName
        .
    
    else
      
      assign
        giRelationId         = 0
        glParentRelation     = no
        gcRelationBufferName = '':U
        .
    
    run qg_FillQueryRange.
    run qg_WidgetState('*':U).
    run qg_UpdateQueryText.
    
  end. /* if giDisplayMode = {&K_DISPLAYMODE_INDEX} */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define BROWSE-NAME brRelation
&Scoped-define SELF-NAME brRelation
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brRelation hQueryWindow
ON CTRL-C OF brRelation IN FRAME fQuery /* ? */
do:

  apply 'choose':U to menu-item mi_CopyRelationTable in menu POPUP-MENU-brRelation.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brRelation hQueryWindow
ON default-action OF brRelation IN FRAME fQuery /* ? */
do:

  apply 'choose':U to menu-item mi_SwitchToRelatedTable in menu POPUP-MENU-brRelation.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brRelation hQueryWindow
ON value-changed OF brRelation IN FRAME fQuery /* ? */
do:

  if giDisplayMode = {&K_DISPLAYMODE_RELATION} then
  do:
    
    if available ttTableRelationView then
      assign
        giRelationId         = ttTableRelationView.RelationId
        glParentRelation     = ttTableRelationView.ParentRelation
        gcRelationBufferName = ttTableRelationView.RelatedTableName
        .
    
    else
      assign
        giRelationId         = 0
        glParentRelation     = no
        gcRelationBufferName = '':U
        .
    
    run qg_FillQueryRange.
    run qg_UpdateQueryText.
    
  end. /* if giDisplayMode = {&K_DISPLAYMODE_RELATION} */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define BROWSE-NAME brTable
&Scoped-define SELF-NAME brTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brTable hQueryWindow
ON CTRL-C OF brTable IN FRAME fQuery
do:

  apply 'choose':U to menu-item mi_CopyTableName in menu POPUP-MENU-brTable.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brTable hQueryWindow
ON default-action OF brTable IN FRAME fQuery
do:

  if available ttTable then
  do:
    
    gcTableFilter = ttTable.TableName.
    gcTableFilter:delete(gcTableFilter) in frame {&FRAME-NAME}.
    
    display unless-hidden
      gcTableFilter
      with frame {&FRAME-NAME}.
    
    apply 'value-changed':U to gcTableFilter in frame {&FRAME-NAME}.
    run qg_AddFieldHistoryEntry(gcTableFilter:handle in frame {&FRAME-NAME}).
    
  end. /* if available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brTable hQueryWindow
ON value-changed OF brTable IN FRAME fQuery
do:

  if    available ttTable
    and not ttTable.DetailsLoaded then
  do:
    
    run qg_AddTableDetails(ttDatabase.DatabaseName,
                           ttTable.TableName).
    
    display unless-hidden
      ttTable.ShortDescription
      with browse brTable.
    
  end. /* if    available ttTable */
    
  assign
    gcFieldDatatypeFilter   = '*':U
    giRelationId            = 0
    glParentRelation        = no
    gcRelationBuffername    = '':U
    glRefreshFieldBrowse    = yes
    glRefreshIndexBrowse    = yes
    glRefreshRelationBrowse = yes
    .
  
  run qg_RefreshFieldBrowse.
  run qg_RefreshIndexBrowse.
  run qg_RefreshRelationBrowse.
  
  run qg_UpdateBufferName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBlock1
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBlock1 hQueryWindow
ON choose OF btnBlock1 IN FRAME fQuery /* 1 */
do:

  run qg_SetBlockPattern({&K_BLOCK_PATTERN_1}).
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBlock2
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBlock2 hQueryWindow
ON choose OF btnBlock2 IN FRAME fQuery /* 2 */
do:

  run qg_SetBlockPattern({&K_BLOCK_PATTERN_2}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBlock3
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBlock3 hQueryWindow
ON choose OF btnBlock3 IN FRAME fQuery /* 3 */
do:

  run qg_SetBlockPattern({&K_BLOCK_PATTERN_3}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBlock4
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBlock4 hQueryWindow
ON choose OF btnBlock4 IN FRAME fQuery /* 4 */
do:

  run qg_SetBlockPattern({&K_BLOCK_PATTERN_4}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBuffer1
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBuffer1 hQueryWindow
ON choose OF btnBuffer1 IN FRAME fQuery /* 1 */
do:

  run qg_SetBufferPattern({&K_BUFFER_PATTERN_1}, 0).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBuffer2
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBuffer2 hQueryWindow
ON choose OF btnBuffer2 IN FRAME fQuery /* 2 */
do:

  run qg_SetBufferPattern({&K_BUFFER_PATTERN_2}, 0).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBuffer3
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBuffer3 hQueryWindow
ON choose OF btnBuffer3 IN FRAME fQuery /* 3 */
do:

  run qg_SetBufferPattern({&K_BUFFER_PATTERN_3}, 0).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnBuffer4
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnBuffer4 hQueryWindow
ON choose OF btnBuffer4 IN FRAME fQuery /* 4 */
do:

  run qg_SetBufferPattern({&K_BUFFER_PATTERN_4}, 0).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearBlockName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearBlockName hQueryWindow
ON choose OF btnClearBlockName IN FRAME fQuery
do:
  
  run qg_SetBlockPattern('':U).
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearBufferPattern
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearBufferPattern hQueryWindow
ON choose OF btnClearBufferPattern IN FRAME fQuery
do:

  run qg_SetBufferPattern('':U, 0).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearFieldFilter hQueryWindow
ON choose OF btnClearFieldFilter IN FRAME fQuery
do:

  gcFieldFilter = '':U.
  
  display unless-hidden
    gcFieldFilter
    with frame {&FRAME-NAME}.

  apply 'value-changed':U to gcFieldFilter in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearFieldLabelFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearFieldLabelFilter hQueryWindow
ON choose OF btnClearFieldLabelFilter IN FRAME fQuery
do:

  gcFieldLabelFilter = '':U.
  
  display unless-hidden
    gcFieldLabelFilter
    with frame {&FRAME-NAME}.

  apply 'value-changed':U to gcFieldLabelFilter in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearIndexFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearIndexFieldFilter hQueryWindow
ON choose OF btnClearIndexFieldFilter IN FRAME fQuery
do:
  
  gcIndexFieldFilter = '':U.
  
  display unless-hidden
    gcIndexFieldFilter
    with frame {&FRAME-NAME}.
  
  apply 'value-changed':U to gcIndexFieldFilter in frame {&FRAME-NAME}.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearIndexFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearIndexFilter hQueryWindow
ON choose OF btnClearIndexFilter IN FRAME fQuery
do:

  gcIndexFilter = '':U.
  
  display unless-hidden
    gcIndexFilter
    with frame {&FRAME-NAME}.
  
  apply 'value-changed':U to gcIndexFilter in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearRelationFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearRelationFieldFilter hQueryWindow
ON choose OF btnClearRelationFieldFilter IN FRAME fQuery
do:
  
  gcRelationFieldFilter = '':U.
  
  display unless-hidden
    gcRelationFieldFilter
    with frame {&FRAME-NAME}.
  
  apply 'value-changed':U to gcRelationFieldFilter in frame {&FRAME-NAME}.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearRelationFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearRelationFilter hQueryWindow
ON choose OF btnClearRelationFilter IN FRAME fQuery
do:

  gcRelationFilter = '':U.
  
  display unless-hidden
    gcRelationFilter
    with frame {&FRAME-NAME}.
  
  apply 'value-changed':U to gcRelationFilter in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearTableFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearTableFieldFilter hQueryWindow
ON choose OF btnClearTableFieldFilter IN FRAME fQuery
do:

  gcTableFieldFilter = '':U.
  
  display unless-hidden
    gcTableFieldFilter
    with frame {&FRAME-NAME}.
  
  apply 'value-changed':U to gcTableFieldFilter in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnClearTableFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnClearTableFilter hQueryWindow
ON choose OF btnClearTableFilter IN FRAME fQuery
do:

  gcTableFilter = '':U.
  
  display unless-hidden
    gcTableFilter
    with frame {&FRAME-NAME}.
  
  apply 'value-changed':U to gcTableFilter in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnConnectDB
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnConnectDB hQueryWindow
ON choose OF btnConnectDB IN FRAME fQuery /* Connect */
do:

define variable lPar01    as logical   no-undo.
define variable cPar02    as character no-undo. /* physical name */
define variable cPar03    as character no-undo. /* logical name */
define variable cPar04    as character no-undo. /* db type */
define variable lPar05    as logical   no-undo.
define variable cPar06    as character no-undo. 
define variable cPar07    as character no-undo. 
define variable cPar08    as character no-undo. 
define variable cPar09    as character no-undo. 
define variable cPar10    as character no-undo. 
define variable cPar11    as character no-undo. 
define variable cPar12    as character no-undo. 
define variable cPar13    as character no-undo. 
define variable cPar14    as character no-undo. 

define buffer bttDatabase for temp-table ttDatabase.

assign
  lPar01 = yes
  cPar04 = 'PROGRESS':U
  lPar05 = no.
  .

run adecomm/_dbconnx.p(lPar01,
                       input-output cPar02,
                       input-output cPar03,
                       input-output cPar04,
                       input-output lPar05,
                       input-output cPar06,
                       input-output cPar07,
                       input-output cPar08,
                       input-output cPar09,
                       input-output cPar10,
                       input-output cPar11,
                       input-output cPar12,
                       input-output cPar13,
                             output cPar14).

if    cPar02 <> ?
  and cPar03 <> ? then
do:
  
  run qg_AddDatabase(cPar03).
  {&OPEN-QUERY-brDatabase}
  
  find bttDatabase
    where bttDatabase.DatabaseName = cPar03
    no-error.
  
  reposition brDatabase to rowid rowid(bttDatabase).
  
  apply 'value-changed':U to brDatabase in frame {&FRAME-NAME}.
  
end. /* if    cPar02 <> ? ... */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnCopyToClipboard
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnCopyToClipboard hQueryWindow
ON choose OF btnCopyToClipboard IN FRAME fQuery /* Copy */
do:

  if glInsertMode then
    run qg_InsertQueryText.
    
  else
    clipboard:value = gcQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnDecreaseIndentation
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnDecreaseIndentation hQueryWindow
ON choose OF btnDecreaseIndentation IN FRAME fQuery /* << */
do:

  giIndentation = max(0, giIndentation - 2).
  
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnDisconnectDB
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnDisconnectDB hQueryWindow
ON choose OF btnDisconnectDB IN FRAME fQuery /* Disconnect */
do:
  
  define variable cDatabase as character no-undo.
  
  define variable lOk       as logical   no-undo.
  
  cDatabase = (if available ttDatabase then
                 ttDatabase.DatabaseName
               else
                 '':U).
  
  if connected(cDatabase) then
  do:
    
    message /* code checked by mth */
      substitute('Are you sure you want to disconnect database &1':T,
                 cDatabase) skip
      view-as alert-box
      question
      buttons ok-cancel
      update lOk.
    
    if not lOk then
      leave.
      
    disconnect value(cDatabase).
  
  end. /* if connected(cDatabase) */
  
  run qg_RemoveDatabase(cDatabase).
  {&OPEN-QUERY-brDatabase}
  
  process events.
  
  run qg_CloseInvalidQueryWindows.

  apply 'value-changed':U to brDatabase in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnExecuteQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnExecuteQuery hQueryWindow
ON choose OF btnExecuteQuery IN FRAME fQuery /* Execute */
do:

  define variable cDatabaseName  as character no-undo.
  define variable cTableName     as character no-undo.
  define variable cBufferName    as character no-undo.
  define variable cQueryText     as character no-undo.
  define variable cParamList     as character no-undo.
  
  define variable iQuerySeq      as integer   no-undo initial ?.
  
  if    available ttDatabase
    and available ttTable then
  do:
    
    assign
      cDatabaseName = ttDatabase.DatabaseName
      cTableName    = ttTable.TableName
      cBufferName   = (if glSlimMode then
                         substitute({&K_DEFAULT_BUFFER_PATTERN},
                                    qg_cGetBufferBaseName(no))
                       else
                         input frame {&FRAME-NAME} gcBufferName)
      cQueryText    = substitute('for each &1~n&2~n':U,
                                 cTableName,
                                 qg_cCreateWhereClause( /* pcDatabaseName   */ cDatabaseName,
                                                        /* pcTableNames     */ cTableName,
                                                        /* pcBufferNames    */ cTableName,
                                                        /* pcFieldList      */ qg_cCurrentFieldList(),
                                                        /* pcFieldLabelList */ ?,
                                                        /* plStartWithWhere */ yes,
                                                        /* piValueMode      */ {&K_VALUE_MODE_DEFAULT_VALUE},
                                                        /* pcValueList      */ ?,
                                                        /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                                        /* plAddTags        */ no,
                                                        /* piIndentBlanks   */ 2 ) )
      cParamList    = qg_cParamListWriteLogical(cParamList,
                                                'FocusQueryText':U,
                                                yes,
                                                {&K_PARAM_SPLITTER})
      .

    run qg_ExecQuery({&K_QUERY_WINDOW_MODE_QUERY},
                     {&K_QUERY_SIZE_MODE_DEFAULT},
                     substitute('&1.&2:&3':U,
                                cDatabaseName,
                                cTableName,
                                cTableName),
                     cQueryText,
                     no,  /* Init mode */
                     cParamList,
                     input-output iQuerySeq).
    
  end. /* if    available ttDatabase */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnIncreaseIndentation
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnIncreaseIndentation hQueryWindow
ON choose OF btnIncreaseIndentation IN FRAME fQuery /* >> */
do:

  giIndentation = giIndentation + 2.
  
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnOf
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnOf hQueryWindow
ON CHOOSE OF btnOf IN FRAME fQuery /* ... */
DO:

run qg_SelectRelation.

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnRefresh
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnRefresh hQueryWindow
ON choose OF btnRefresh IN FRAME fQuery /* Refresh */
do:

  run qg_LoadCache(?).
  run qg_CloseInvalidQueryWindows.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnResetAll
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnResetAll hQueryWindow
ON choose OF btnResetAll IN FRAME fQuery /* Reset */
do:

  run qg_SetDefaultValues.
  
  apply 'value-changed':U to brDatabase in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME btnResetIndentation
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL btnResetIndentation hQueryWindow
ON choose OF btnResetIndentation IN FRAME fQuery /* | */
do:

  giIndentation = {&K_DEFAULT_INDENTATION}.
  
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcBlockName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcBlockName hQueryWindow
ON end-error OF gcBlockName IN FRAME fQuery /* Block */
do:

  apply 'choose':U to btnClearBlockName in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcBlockName hQueryWindow
ON value-changed OF gcBlockName IN FRAME fQuery /* Block */
do:

  run qg_ProcessBlockNameChange.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcBufferName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcBufferName hQueryWindow
ON end-error OF gcBufferName IN FRAME fQuery /* Buffer */
do:

  apply 'choose':U to btnClearBufferPattern in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcBufferName hQueryWindow
ON value-changed OF gcBufferName IN FRAME fQuery /* Buffer */
do:

  run qg_ProcessBufferNameChange.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldFilter hQueryWindow
ON end-error OF gcFieldFilter IN FRAME fQuery /* Field filter */
do:

  apply 'choose':U to btnClearFieldFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldFilter hQueryWindow
ON leave OF gcFieldFilter IN FRAME fQuery /* Field filter */
do:

  if available ttTable then
    run qg_FixCase(gcFieldFilter:handle in frame {&FRAME-NAME},
                   ttTable.DatabaseName,
                   ttTable.TableName,
                   {&K_CASEMODE_TABLE_FIELD}).
  
  if brField:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcFieldFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldFilter hQueryWindow
ON return OF gcFieldFilter IN FRAME fQuery /* Field filter */
do:

  if available ttField then
  do:
    
    gcFieldFilter = ttField.FieldName.
    
    display unless-hidden
      gcFieldFilter
      with frame {&FRAME-NAME}.
    
    apply 'value-changed':U to gcFieldFilter in frame {&FRAME-NAME}.
    run qg_AddFieldHistoryEntry(gcFieldFilter:handle in frame {&FRAME-NAME}).
    
  end. /* if available ttField */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldFilter hQueryWindow
ON value-changed OF gcFieldFilter IN FRAME fQuery /* Field filter */
do:

  glRefreshFieldBrowse = yes.
  run qg_RefreshFieldBrowse.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcFieldLabelFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldLabelFilter hQueryWindow
ON end-error OF gcFieldLabelFilter IN FRAME fQuery
do:

  apply 'choose':U to btnClearFieldLabelFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldLabelFilter hQueryWindow
ON leave OF gcFieldLabelFilter IN FRAME fQuery
do:

  if available ttTable then
    run qg_FixCase(gcFieldLabelFilter:handle in frame {&FRAME-NAME},
                   ttTable.DatabaseName,
                   ttTable.TableName,
                   {&K_CASEMODE_TABLE_FIELD_LABEL}).
  
  if brField:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcFieldLabelFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcFieldLabelFilter hQueryWindow
ON value-changed OF gcFieldLabelFilter IN FRAME fQuery
do:

  glRefreshFieldBrowse = yes.
  run qg_RefreshFieldBrowse.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcIndexFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFieldFilter hQueryWindow
ON end-error OF gcIndexFieldFilter IN FRAME fQuery
do:

  apply 'choose':U to btnClearIndexFieldFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFieldFilter hQueryWindow
ON leave OF gcIndexFieldFilter IN FRAME fQuery
do:

  if available ttTable then
    run qg_FixCase(gcIndexFieldFilter:handle in frame {&FRAME-NAME},
                   ttTable.DatabaseName,
                   ttTable.TableName,
                   {&K_CASEMODE_TABLE_FIELD}).
  
  if brIndex:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcIndexFieldFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFieldFilter hQueryWindow
ON value-changed OF gcIndexFieldFilter IN FRAME fQuery
do:

  glRefreshIndexBrowse = yes.
  run qg_RefreshIndexBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcIndexFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFilter hQueryWindow
ON end-error OF gcIndexFilter IN FRAME fQuery /* Index filter */
do:

  apply 'choose':U to btnClearIndexFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFilter hQueryWindow
ON leave OF gcIndexFilter IN FRAME fQuery /* Index filter */
do:

  if available ttTable then
    run qg_FixCase(gcIndexFilter:handle in frame {&FRAME-NAME},
                   ttTable.DatabaseName,
                   ttTable.TableName,
                   {&K_CASEMODE_TABLE_INDEX}).
  
  if brIndex:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcIndexFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFilter hQueryWindow
ON return OF gcIndexFilter IN FRAME fQuery /* Index filter */
do:

  if available ttIndex then
  do:
    
    gcIndexFilter = ttIndex.IndexName.
    
    display unless-hidden
      gcIndexFilter
      with frame {&FRAME-NAME}.
    
    apply 'value-changed':U to gcIndexFilter in frame {&FRAME-NAME}.
    run qg_AddFieldHistoryEntry(gcIndexFilter:handle in frame {&FRAME-NAME}).
    
  end. /* if available ttIndex */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcIndexFilter hQueryWindow
ON value-changed OF gcIndexFilter IN FRAME fQuery /* Index filter */
do:

  glRefreshIndexBrowse = yes.
  run qg_RefreshIndexBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcRelationFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFieldFilter hQueryWindow
ON end-error OF gcRelationFieldFilter IN FRAME fQuery
do:

  apply 'choose':U to btnClearRelationFieldFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFieldFilter hQueryWindow
ON leave OF gcRelationFieldFilter IN FRAME fQuery
do:

  if available ttTableRelationView then
    run qg_FixCase(gcRelationFieldFilter:handle in frame {&FRAME-NAME},
                   ttTableRelationView.DatabaseName,
                   ttTableRelationView.RelatedTableName,
                   {&K_CASEMODE_TABLE_FIELD}).
  
  if brRelation:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcRelationFieldFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFieldFilter hQueryWindow
ON value-changed OF gcRelationFieldFilter IN FRAME fQuery
do:

  glRefreshRelationBrowse = yes.
  run qg_RefreshRelationBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcRelationFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFilter hQueryWindow
ON end-error OF gcRelationFilter IN FRAME fQuery /* Relation filter */
do:

  apply 'choose':U to btnClearRelationFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFilter hQueryWindow
ON leave OF gcRelationFilter IN FRAME fQuery /* Relation filter */
do:

  if available ttTable then
    run qg_FixCase(gcRelationFilter:handle in frame {&FRAME-NAME},
                   ttTable.DatabaseName,
                   ttTable.TableName,
                   {&K_CASEMODE_TABLE_RELATION}).
  
  if brRelation:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcRelationFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFilter hQueryWindow
ON return OF gcRelationFilter IN FRAME fQuery /* Relation filter */
do:

  if available ttTableRelationView then
  do:
    
    gcRelationFilter = ttTableRelationView.RelatedTableName.
    
    display unless-hidden
      gcRelationFilter
      with frame {&FRAME-NAME}.
    
    apply 'value-changed':U to gcRelationFilter in frame {&FRAME-NAME}.
    run qg_AddFieldHistoryEntry(gcRelationFilter:handle in frame {&FRAME-NAME}).
    
  end. /* if available ttTableRelationView */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcRelationFilter hQueryWindow
ON value-changed OF gcRelationFilter IN FRAME fQuery /* Relation filter */
do:

  glRefreshRelationBrowse = yes.
  run qg_RefreshRelationBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcTableFieldFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFieldFilter hQueryWindow
ON end-error OF gcTableFieldFilter IN FRAME fQuery
do:

  apply 'choose':U to btnClearTableFieldFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFieldFilter hQueryWindow
ON leave OF gcTableFieldFilter IN FRAME fQuery
do:

  if available ttDatabase then
    run qg_FixCase(gcTableFieldFilter:handle in frame {&FRAME-NAME},
                   ttDatabase.DatabaseName,
                   ?,
                   {&K_CASEMODE_FIELD}).
  
  if brTable:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcTableFieldFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFieldFilter hQueryWindow
ON value-changed OF gcTableFieldFilter IN FRAME fQuery
do:

  run qg_RefreshTableBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME gcTableFilter
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFilter hQueryWindow
ON end-error OF gcTableFilter IN FRAME fQuery /* Table filter */
do:

  apply 'choose':U to btnClearTableFilter in frame {&FRAME-NAME}.
  return no-apply.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFilter hQueryWindow
ON leave OF gcTableFilter IN FRAME fQuery /* Table filter */
do:

  if available ttDatabase then
    run qg_FixCase(gcTableFilter:handle in frame {&FRAME-NAME},
                   ttDatabase.DatabaseName,
                   ?,
                   {&K_CASEMODE_TABLE}).
  
  if brTable:query:num-results > 0 then
    run qg_AddFieldHistoryEntry(gcTableFilter:handle in frame {&FRAME-NAME}).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFilter hQueryWindow
ON return OF gcTableFilter IN FRAME fQuery /* Table filter */
do:

  if available ttTable then
  do:
    
    gcTableFilter = ttTable.TableName.
    
    display unless-hidden
      gcTableFilter
      with frame {&FRAME-NAME}.
    
    apply 'value-changed':U to gcTableFilter in frame {&FRAME-NAME}.
    run qg_AddFieldHistoryEntry(gcTableFilter:handle in frame {&FRAME-NAME}).
    
  end. /* if available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brTable hQueryWindow
ON ROW-DISPLAY OF brTable IN FRAME fQuery /* Table filter */
do:

  if not ttTable.DescriptionLoaded
    
    /* For performance reasons we only do this when the database is connected */
    /* in shared memory mode.                                                 */
    
    and ( available ttDatabase
      and ( ttDatabase.SharedMemory
         or not ttDatabase.PhysicalDB ) ) then
    
    run qg_AddTableRepositoryInfo(ttTable.DatabaseName, ttTable.TableName).

  ttTable.ShortDescription:fgcolor in browse brTable = {&K_COLOR_LIGHT_GREY}.

end. /* ON ROW-DISPLAY OF brTable IN FRAME fQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brField hQueryWindow
ON ROW-DISPLAY OF brField IN FRAME fQuery /* Table filter */
do:
  
  define variable iColor as integer   no-undo initial ?.
  
  if available ttField then
  do:
    
    case ttField.FieldType:
      
      when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
        
        iColor = {&K_VIRTUAL_DB_FIELD_FGCOLOR}.
      
    end case.
    
    if iColor <> ? then
    
      assign
        ttField.FieldName:fgcolor in browse brField          = iColor
        ttField.IsVirtual:fgcolor in browse brField          = iColor
        ttField.DataType:fgcolor in browse brField           = iColor
        ttField.FieldExtent:fgcolor in browse brField        = iColor
        ttField.FieldDecimals:fgcolor in browse brField      = iColor
        ttField.FieldInitialValue :fgcolor in browse brField = iColor
        ttField.FieldFormat:fgcolor in browse brField        = iColor
        ttField.FieldLabel:fgcolor in browse brField         = iColor
        ttField.FieldColumnLabel:fgcolor in browse brField   = iColor
        ttField.IsMandatory:fgcolor in browse brField        = iColor
        ttField.Domain:fgcolor in browse brField             = iColor
        .
    
  end. /* if available ttField */
  
end. /* ON ROW-DISPLAY OF brField IN FRAME fQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL brIndex hQueryWindow
ON ROW-DISPLAY OF brIndex IN FRAME fQuery /* Index */
do:
  
  define variable iColor as integer   no-undo initial ?.
  
  if    available ttIndex
    and ttIndex.IsVirtual then
    
    iColor = {&K_VIRTUAL_INDEX_FGCOLOR}.
    
  if iColor <> ? then
  
    assign
      ttIndex.IsPrimary:fgcolor in browse brIndex   = iColor
      ttIndex.IndexName:fgcolor in browse brIndex   = iColor
      ttIndex.IsUnique:fgcolor in browse brIndex    = iColor
      ttIndex.IsVirtual:fgcolor in browse brIndex   = iColor
      ttIndex.IndexFields:fgcolor in browse brIndex = iColor
      .
  
end. /* ON ROW-DISPLAY OF brIndex IN FRAME fQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL gcTableFilter hQueryWindow
ON value-changed OF gcTableFilter IN FRAME fQuery /* Table filter */
do:

  run qg_RefreshTableBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME giDisplayMode
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL giDisplayMode hQueryWindow
ON value-changed OF giDisplayMode IN FRAME fQuery
do:
  
  giDisplayMode = input frame {&FRAME-NAME} giDisplayMode.
  
  run qg_SetDisplayMode(giDisplayMode).
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME glInvertQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glInvertQuery hQueryWindow
ON value-changed OF glInvertQuery IN FRAME fQuery
do:
  
  glInvertQuery = input frame {&FRAME-NAME} glInvertQuery.
  
  run qg_FillQueryRange.
  run qg_UpdateQueryText.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glOnError
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glOnError hQueryWindow
ON value-changed OF glOnError IN FRAME fQuery
do:
  
  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME giOnErrorPhrase
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL giOnErrorPhrase hQueryWindow
ON value-changed OF giOnErrorPhrase IN FRAME fQuery
do:
  
  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME giQueryTypeModifier
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL giQueryTypeModifier hQueryWindow
ON value-changed OF giQueryTypeModifier IN FRAME fQuery
do:
  
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME giQueryType
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL giQueryType hQueryWindow
ON value-changed OF giQueryType IN FRAME fQuery
do:

  run qg_FillQueryRange.
  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glCompanyViaClass
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glCompanyViaClass hQueryWindow
ON value-changed OF glCompanyViaClass IN FRAME fQuery
do:

  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glDefineBlock
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glDefineBlock hQueryWindow
ON value-changed OF glDefineBlock IN FRAME fQuery /* define block */
do:
  
  run qg_UpdateQueryText.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glDefineBuffer
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glDefineBuffer hQueryWindow
ON value-changed OF glDefineBuffer IN FRAME fQuery /* define buffer */
do:
  
  assign
    glDefineBuffer   = (if glSlimMode then
                          {&K_DEFAULT_DEFINE_BUFFER}
                        else
                          input frame {&FRAME-NAME} glDefineBuffer).
    gcBufferBaseName = qg_cGetBufferBaseName(   glDefineBuffer
                                             or (  gcBufferPattern > '':U
                                               and gcBufferPattern <> '&1':U)).
  
  run qg_UpdateBufferName.
  
  run qg_UpdateQueryText.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glDoBlock
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glDoBlock hQueryWindow
ON value-changed OF glDoBlock IN FRAME fQuery /* do */
do:

  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glExclusiveLock
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glExclusiveLock hQueryWindow
ON value-changed OF glExclusiveLock IN FRAME fQuery
do:

  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glFinallyBlock
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glFinallyBlock hQueryWindow
ON value-changed OF glFinallyBlock IN FRAME fQuery /* finally block */
do:

  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glIfStatement
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glIfStatement hQueryWindow
ON value-changed OF glIfStatement IN FRAME fQuery /* if statement */
do:

  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glNoError
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glNoError hQueryWindow
ON value-changed OF glNoError IN FRAME fQuery /* no error */
do:

  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glNot
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glNot hQueryWindow
ON value-changed OF glNot IN FRAME fQuery /* not */
do:

  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME glDefineVariables
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glDefineVariables hQueryWindow
ON value-changed OF glDefineVariables IN FRAME fQuery /* define variables */
do:

  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glUseVirtualIndexIncludes
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glUseVirtualIndexIncludes hQueryWindow
ON value-changed OF glUseVirtualIndexIncludes IN FRAME fQuery /* via includes */
do:

  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME glRetryBlock
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL glRetryBlock hQueryWindow
ON value-changed OF glRetryBlock IN FRAME fQuery /* retry block */
do:

  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_About
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_About hQueryWindow
ON choose OF MENU-ITEM mi_About /* About Query Generator */
do:

  run qg_About(hQueryWindow).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_AddPersistentTempTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_AddPersistentTempTable hQueryWindow
ON choose OF MENU-ITEM mi_AddPersistentTempTable /* Add persistent temp table */
do:

  run qg_AddPersistentTempTable.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_AddSnapshot
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_AddSnapshot hQueryWindow
ON choose OF MENU-ITEM mi_AddSnapshot /* Add snpapshot */
do:

  define variable hBuffer as handle no-undo.
  
  if available ttTable then
  do on error undo, throw:
    
    if ttTable.PhysicalTable then
      create buffer hBuffer for table substitute('&1.&2':U,
                                                 ttTable.DatabaseName,
                                                 ttTable.TableName).
    
    else if valid-handle(ttTable.TableHandle) then
      create buffer hBuffer for table ttTable.TableHandle.
    
    if valid-handle(hBuffer) then
      run qg_AddTableSnapshot(hBuffer, '':U, {&WINDOW-NAME}).
    
    finally:
      
      if valid-handle(hBuffer) then
        delete object hBuffer.
      
    end finally.
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_AddSnapshotBtn
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_AddSnapshotBtn hQueryWindow
ON choose OF MENU-ITEM mi_AddSnapshotBtn /* Add snapshot */
do:

  apply 'choose':U to menu-item mi_AddSnapshot in menu m_Tools.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CloseAllQueryWindows
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CloseAllQueryWindows hQueryWindow
ON choose OF MENU-ITEM mi_CloseAllQueryWindows /* Close all query windows */
do:

  define buffer bttQueryWindow for temp-table ttQueryWindow.
  
  for each bttQueryWindow
    on error undo, throw:
    
    if valid-handle(bttQueryWindow.WindowHandle) then
      run qg_QueryWindowClose(bttQueryWindow.WindowHandle, no).
    
    else
      delete bttQueryWindow.
    
  end. /* for each bttQueryWindow */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyDatabaseName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyDatabaseName hQueryWindow
ON choose OF MENU-ITEM mi_CopyDatabaseName /* Copy name */
do:

  if available ttDatabase then
    clipboard:value = ttDatabase.DatabaseName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldAssignments
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldAssignments hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldAssignments /* Copy field assignments */
do:
  
  if glInsertMode then
    run qg_InsertFieldAssigments.
      
  else
    clipboard:value = qg_cFieldAssignments(no).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldAssignStatement
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldAssignStatement hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldAssignStatement /* Copy assign statement */
do:

  if glInsertMode then
    run qg_InsertFieldAssignStatement.
      
  else
    clipboard:value = qg_cFieldAssignStatement(no).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldColumnLabel
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldColumnLabel hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldColumnLabel /* Copy column label */
do:

  if available ttField then
    clipboard:value = ttField.FieldColumnLabel.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldDomain
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldDomain hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldDomain /* Copy Domain */
do:

  if available(ttField) then
    clipboard:value = ttField.Domain.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldFormat
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldFormat hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldFormat /* Copy format */
do:

  if available(ttField) then
    clipboard:value = ttField.FieldFormat.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldInitialValue
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldInitialValue hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldInitialValue /* Copy initial value */
do:
  if available ttField then
    clipboard:value = ttField.FieldInitialValue.
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldLabel
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldLabel hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldLabel /* Copy label */
do:

  if available ttField then
    clipboard:value = ttField.FieldLabel.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldName hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldName /* Copy name */
do:

  if available(ttField) then
    clipboard:value = ttField.FieldName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldNamesCommaSeparated
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldNamesCommaSeparated hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldNamesCommaSeparated /* Copy names (comma separated) */
do:
  
  define variable lOk as logical   no-undo.
  
  gcBufferName = (if glSlimMode then
                    substitute({&K_DEFAULT_BUFFER_PATTERN},
                               qg_cGetBufferBaseName(no))
                  else
                    input frame {&FRAME-NAME} gcBufferName).
  
  message /* code checked by mth */
    'Do you want to include the buffer name?':T skip
    view-as alert-box
      question
      buttons yes-no
      update lOk.
  
  clipboard:value = qg_cGetSelectedFields((if lOk then
                                             gcBufferName
                                           else
                                             ?),
                                          ',':U,
                                          no).
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldNamesLineSeparated
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldNamesLineSeparated hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldNamesLineSeparated /* Copy names (line separated) */
do:

  define variable lOk as logical   no-undo.
  
  gcBufferName = (if glSlimMode then
                    substitute({&K_DEFAULT_BUFFER_PATTERN},
                               qg_cGetBufferBaseName(no))
                  else
                    input frame {&FRAME-NAME} gcBufferName).
  
  message /* code checked by mth */
    'Do you want to include the buffer name?':T skip
    view-as alert-box
      question
      buttons yes-no
      update lOk.
  
  clipboard:value = qg_cGetSelectedFields((if lOk then
                                             gcBufferName
                                           else
                                             ?),
                                          '~n':U,
                                          no).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFieldNamesSpaceSeparated
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFieldNamesSpaceSeparated hQueryWindow
ON choose OF MENU-ITEM mi_CopyFieldNamesSpaceSeparated /* Copy names (space separated) */
do:

  define variable lOk as logical   no-undo.
  
  gcBufferName = (if glSlimMode then
                    substitute({&K_DEFAULT_BUFFER_PATTERN},
                               qg_cGetBufferBaseName(no))
                  else
                    input frame {&FRAME-NAME} gcBufferName).
  
  message /* code checked by mth */
    'Do you want to include the buffer name?':T skip
    view-as alert-box
      question
      buttons yes-no
      update lOk.
  
  clipboard:value = qg_cGetSelectedFields((if lOk then
                                             gcBufferName
                                           else
                                             ?),
                                          ' ':U,
                                          no).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyFullFieldName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyFullFieldName hQueryWindow
ON choose OF MENU-ITEM mi_CopyFullFieldName /* Copy name */
do:

  if available(ttField) then
    assign
      gcBufferName    = (if glSlimMode then
                           substitute({&K_DEFAULT_BUFFER_PATTERN},
                                      qg_cGetBufferBaseName(no))
                         else
                           input frame {&FRAME-NAME} gcBufferName)
      clipboard:value = substitute('&1.&2':U,
                                   gcBufferName,
                                   ttField.FieldName)
      .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyIndexFields
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyIndexFields hQueryWindow
ON choose OF MENU-ITEM mi_CopyIndexFields /* Copy fields */
do:

  if available ttIndex then
    clipboard:value = ttIndex.IndexFields.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyRelationFields
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyRelationFields hQueryWindow
ON choose OF MENU-ITEM mi_CopyRelationFields /* Copy fields */
do:

  if available ttTableRelationView then
    clipboard:value = ttTableRelationView.RelatedFields.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyIndexName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyIndexName hQueryWindow
ON choose OF MENU-ITEM mi_CopyIndexName /* Copy name */
do:

  if available ttIndex then
    clipboard:value = ttIndex.IndexName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyRelationTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyRelationTable hQueryWindow
ON choose OF MENU-ITEM mi_CopyRelationTable /* Copy table */
do:

  if available ttTableRelationView then
    clipboard:value = ttTableRelationView.RelatedTableName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyPhysicalName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyPhysicalName hQueryWindow
ON choose OF MENU-ITEM mi_CopyPhysicalName /* Copy physical name */
do:

  if available ttDatabase then
    clipboard:value = ttDatabase.PhysicalName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyPutStatement
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyPutStatement hQueryWindow
ON choose OF MENU-ITEM mi_CopyPutStatement /* Copy put statement */
do:

  if glInsertMode then
    run qg_InsertPutStatement.
      
  else
    clipboard:value = qg_cPutStatement(no).
  

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyQueryGeneratorSource
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyQueryGeneratorSource hQueryWindow
ON choose OF MENU-ITEM mi_CopyQueryGeneratorSource /* Copy Query Generator Source */
do:

  run qg_CopyQueryGeneratorSource.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_CopyQueryGeneratorSourcefilePath
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyQueryGeneratorSource hQueryWindow
ON choose OF MENU-ITEM mi_CopyQueryGeneratorSourcefilePath /* Copy Query Generator Sourcefile Path */
do:

  run qg_CopyQueryGeneratorSourcefilePath.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_CopyQueryScenario
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyQueryScenario hQueryWindow
ON choose OF MENU-ITEM mi_CopyQueryScenario /* Copy query scenario */
do:

  run qg_SaveQueryScenario(?).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyQueryText
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyQueryText hQueryWindow
ON choose OF MENU-ITEM mi_CopyQueryText /* Copy query text */
do:

  clipboard:value = gcQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableCompanyInclude
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableCompanyInclude hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableCompanyInclude /* Copy include name */
do:

  clipboard:value = (if    available ttTable
                       and ttTable.CompanyInclude > '':U then
                       ttTable.CompanyInclude
                     else
                       '':U).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableCompanyIncludeReference
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableCompanyIncludeReference hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableCompanyIncludeReference /* Copy include reference */
do:

  define variable cIncludeReferenceText as character no-undo.
  
  if    available ttTable
    and ttTable.CompanyInclude > '':U then
    cIncludeReferenceText = substitute('~{firma/&1 &2~}&3':U,
                                       ttTable.CompanyInclude,
                                       qg_cTaggedValue((if glCompanyViaClass then
                                                          '{&K_CLASS_COMPANY_STATEMENT}':U
                                                        else
                                                          'pa-Firma':U),
                                                        glInsertMode),
                                           (if glInsertMode then
                                             '$~{cursor~}':U
                                            else
                                              '':U)).
    
  if glInsertMode then
    run qg_IDE_InsertText(cIncludeReferenceText).
    
  else
    clipboard:value = cIncludeReferenceText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableCreateTrigger
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableCreateTrigger hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableCreateTrigger /* Copy trigger name */
do:

  if    available ttTable
    and ttTable.CreateTriggerProcName > '':U then
    clipboard:value = ttTable.CreateTriggerProcName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableDefineBuffer
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableDefineBuffer hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableDefineBuffer /* Copy "define buffer" */
do:

  if available ttTable then
  do:
    
    if glInsertMode then
      run qg_InsertBufferDefinition.
    
    else
      assign
        gcBufferName    = (if glSlimMode then
                             substitute({&K_DEFAULT_BUFFER_PATTERN},
                                        qg_cGetBufferBaseName(no))
                           else
                             input frame {&FRAME-NAME} gcBufferName)
        clipboard:value = substitute('define buffer &1 for &2.':U,
                                     gcBufferName,
                                     ttTable.TableName)
        .
    
  end. /* if available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableDeleteTrigger
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableDeleteTrigger hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableDeleteTrigger /* Copy trigger name */
do:

  if    available ttTable
    and ttTable.DeleteTriggerProcName > '':U then
    clipboard:value = ttTable.DeleteTriggerProcName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableFillInclude
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableFillInclude hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableFillInclude /* Copy include name */
do:

  clipboard:value = (if    available ttTable
                       and ttTable.FillInclude > '':U then
                       ttTable.FillInclude
                     else
                       '':U).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableFillIncludeReference
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableFillIncludeReference hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableFillIncludeReference /* Copy include reference */
do:

  define variable cFillInclude          as character no-undo.
  define variable cIncludeReferenceText as character no-undo.
  
  if    available ttTable
    and ttTable.FillInclude > '':U then
  do:
    
    cFillInclude = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                    ttTable.FillInclude) no-error.
    
    if cFillInclude > '':U then
      assign
        gcBufferName          = (if glSlimMode then
                                   substitute({&K_DEFAULT_BUFFER_PATTERN},
                                              qg_cGetBufferBaseName(no))
                                 else
                                   input frame {&FRAME-NAME} gcBufferName)
        cIncludeReferenceText = substitute('~{&1~n  &&Buffer = "&2"~n~}&3':U,
                                           cFillInclude,
                                           qg_cTaggedValue(gcBufferName, glInsertMode),
                                           (if glInsertMode then
                                             '$~{cursor~}':U
                                            else
                                              '':U))
        .
    
  end. /* if    available ttTable */
  
  if glInsertMode then
    run qg_IDE_InsertText(cIncludeReferenceText).
    
  else
    clipboard:value = cIncludeReferenceText.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableKeyInclude
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableKeyInclude hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableKeyInclude /* Copy include name */
do:

  clipboard:value = (if    available ttTable
                       and ttTable.KeyInclude > '':U then
                       ttTable.KeyInclude
                     else
                       '':U).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableKeyIncludeReference
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableKeyIncludeReference hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableKeyIncludeReference /* Copy include reference */
do:
  
  define variable cKeyInclude           as character no-undo.
  define variable cIncludeReferenceText as character no-undo.

  
  if    available ttTable
    and ttTable.KeyInclude > '':U then
  do:
    
    cKeyInclude = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                   ttTable.KeyInclude) no-error.
    
    if cKeyInclude > '':U then
      assign
        gcBufferName          = (if glSlimMode then
                                   substitute({&K_DEFAULT_BUFFER_PATTERN},
                                              qg_cGetBufferBaseName(no))
                                 else
                                   input frame {&FRAME-NAME} gcBufferName)
        cIncludeReferenceText = substitute('~{&1 &&Tabelle = "&2"~}&3':U,
                                           cKeyInclude,
                                           qg_cTaggedValue(gcBufferName, glInsertMode),
                                           (if glInsertMode then
                                             '$~{cursor~}':U
                                            else
                                              '':U))
        .
      
  end. /* if    available ttTable */

  if glInsertMode then
    run qg_IDE_InsertText(cIncludeReferenceText).
    
  else
    clipboard:value = cIncludeReferenceText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableName
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableName hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableName /* Copy name */
do:

  if available ttTable then
      clipboard:value = (if glSlimMode then
                           substitute({&K_DEFAULT_BUFFER_PATTERN},
                                      qg_cGetBufferBaseName(no))
                         else
                           input frame {&FRAME-NAME} gcBufferName).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_CopyTableWriteTrigger
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_CopyTableWriteTrigger hQueryWindow
ON choose OF MENU-ITEM mi_CopyTableWriteTrigger /* Copy trigger name */
do:

  if    available ttTable
    and ttTable.WriteTriggerProcName > '':U then
    clipboard:value = ttTable.WriteTriggerProcName.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_DataAdministration
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_DataAdministration hQueryWindow
ON choose OF MENU-ITEM mi_DataAdministration /* Data Administration */
do:

  run qg_SetWorkingDatabase.
  run _admin.p.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_DataDictionary
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_DataDictionary hQueryWindow
ON choose OF MENU-ITEM mi_DataDictionary /* Data Dictionary */
do:

  run qg_SetWorkingDatabase.
  run adedict/_dictg.p.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ExecuteQuery
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ExecuteQuery hQueryWindow
ON choose OF MENU-ITEM mi_ExecuteQuery /* Execute query */
do:

  define variable hFocusWidget as handle    no-undo.
  
  hFocusWidget = focus.
  
  if valid-handle(hFocusWidget) then
  do:
    
    /* Fire leave trigger but keep focus in active widget. */
    apply 'leave':U to hFocusWidget.
    apply 'entry':U to hFocusWidget.
    
  end. /* if valid-handle(hFocusWidget) */
  
  apply 'choose':U to btnExecuteQuery in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_Exit
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_Exit hQueryWindow
ON choose OF MENU-ITEM mi_Exit /* Exit */
do:
  
  apply 'window-close':U to hQueryWindow.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_ExportJSON
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ExportJSON hQueryWindow
ON choose OF MENU-ITEM mi_ExportJSON /* Exit */
do:
  
  /* TODO: mi_ExportJSON */
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_ExportXML
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ExportXML hQueryWindow
ON choose OF MENU-ITEM mi_ExportXML /* Exit */
do:
  
  /* TODO: mi_ExportXML */
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_FilterDataypes
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_FilterDataypes hQueryWindow
ON choose OF MENU-ITEM mi_FilterDataypes /* Dataype filter */
do:

  run qg_UpdateFieldDataypeFilter.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_FindFieldIndex
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_FindFieldIndex hQueryWindow
ON choose OF MENU-ITEM mi_FindFieldIndex /* Find index for selected fields */
do:

  if available ttField then
  do:
    
    gcIndexfieldFilter = qg_cGetSelectedFields(?, ',':U, yes).
    
    display unless-hidden
      gcIndexFieldFilter
      with frame {&FRAME-NAME}.
    
    run qg_SetDisplayMode({&K_DISPLAYMODE_INDEX}).
    
    apply 'value-changed':U to gcIndexFieldFilter in frame {&FRAME-NAME}.
    
  end. /* if available ttIndex */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_FindFieldTables
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_FindFieldTables hQueryWindow
ON choose OF MENU-ITEM mi_FindFieldTables /* Find tables containing selected fields */
do:

  if available ttField then
  do:
    
    gcTableFieldFilter = qg_cGetSelectedFields(?, ',':U, yes).
    
    display unless-hidden
      gcTableFieldFilter
      with frame {&FRAME-NAME}.
    
    apply 'value-changed':U to gcTableFieldFilter in frame {&FRAME-NAME}.
    
  end. /* if available ttIndex */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_FindObjectIdRecord
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_FindObjectIdRecord hQueryWindow
ON choose OF MENU-ITEM mi_FindObjectIdRecord /* Find object id record */
do:

  run qg_FindObjectIdRecord(hQueryWindow).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_AlwaysUseFindFirst
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_AlwaysUseFindFirst hQueryWindow
ON value-changed OF MENU-ITEM mi_AlwaysUseFindFirst /* Always use 'find first' */
do:

  glAlwaysUseFindFirst = menu-item mi_AlwaysUseFindFirst:checked in menu M_Options.
  
  run qg_FillQueryRange.
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_AlwaysUseCanFindFirst
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_AlwaysUseCanFindFirst hQueryWindow
ON value-changed OF MENU-ITEM mi_AlwaysUseCanFindFirst /* Always use 'can-find first' */
do:

  glAlwaysUseCanFindFirst = menu-item mi_AlwaysUseCanFindFirst:checked in menu M_Options.
  
  run qg_FillQueryRange.
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_AlwaysUseCanFindFirst
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_AlwaysUseCanFindFirst hQueryWindow
ON value-changed OF MENU-ITEM mi_UseVirtualIndexApi /* Use virtual index API' */
do:

  glUseVirtualIndexApi = menu-item mi_UseVirtualIndexApi:checked in menu M_Options.
  
  if    available ttIndex
    and ttIndex.IsVirtual
    and not glUseVirtualIndexApi then
    
    assign
      giRelationId         = 0
      glParentRelation     = no
      gcRelationBufferName = gcVirtualIndexDataTableName
      .
  
  run qg_WidgetState('*':U).
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_InsertMode
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_InsertMode hQueryWindow
ON value-changed OF MENU-ITEM mi_InsertMode /* Insert mode */
do:

  glInsertMode = menu-item mi_InsertMode:checked in menu m_Options.
  run qg_WidgetState('*':U).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_InsertModeBtn
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_InsertModeBtn hQueryWindow
ON value-changed OF MENU-ITEM mi_InsertModeBtn /* Insert mode */
do:

  glInsertMode = menu-item mi_InsertModeBtn:checked in menu POPUP-MENU-btnCopyToClipboard.
  run qg_WidgetState('*':U).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ShowQueryTypeModifier
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ShowQueryTypeModifier hQueryWindow
ON value-changed OF MENU-ITEM mi_ShowQueryTypeModifier /* Show query type modifier */
do:

  run qg_SetShowQueryTypeModifier(menu-item mi_ShowQueryTypeModifier:checked in menu M_Options).
  
  run qg_FillQueryRange.
  run qg_UpdateQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ShowChildRelations
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ShowChildRelations hQueryWindow
ON value-changed OF MENU-ITEM mi_ShowChildRelations /* Show query type modifier */
do:

  assign
    glShowChildRelations    = menu-item mi_ShowChildRelations:checked in menu POPUP-MENU-brRelation
    glRefreshRelationBrowse = yes
    .
  run qg_RefreshRelationBrowse.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ShowParentRelations
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ShowParentRelations hQueryWindow
ON value-changed OF MENU-ITEM mi_ShowParentRelations /* Show query type modifier */
do:

  assign
    glShowParentRelations   = menu-item mi_ShowParentRelations:checked in menu POPUP-MENU-brRelation.
    glRefreshRelationBrowse = yes
    .
  run qg_RefreshRelationBrowse.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ImportDatasetFile
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ImportDatasetFile hQueryWindow
ON choose OF MENU-ITEM mi_ImportDatasetFile /* Import Dataset File */
do:

  run qg_ImportFile( {&K_IMPORT_TYPE_DATASET} ).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_ImportPDS
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ImportPDS hQueryWindow
ON choose OF MENU-ITEM mi_ImportPDS /* Import PDS as Snapshot*/
do:

  run qg_ImportDefinitionFile( {&K_IMPORT_TYPE_DATASET} ).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_ImportTDF
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ImportTDF hQueryWindow
ON choose OF MENU-ITEM mi_ImportTDF /* Import TDF as Snapshot*/
do:

  run qg_ImportDefinitionFile( {&K_IMPORT_TYPE_TEMP_TABLE} ).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_ImportTempTableFile
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ImportTempTableFile hQueryWindow
ON choose OF MENU-ITEM mi_ImportTempTableFile /* Import Temp-Table File */
do:

  run qg_ImportFile( {&K_IMPORT_TYPE_TEMP_TABLE} ).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_InsertQueryText
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_InsertQueryText hQueryWindow
ON choose OF MENU-ITEM mi_InsertQueryText /* Insert query text */
do:

  run qg_InsertQueryText.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ReconcileDatabaseSchema
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ReconcileDatabaseSchema hQueryWindow
ON choose OF MENU-ITEM mi_ReconcileDatabaseSchema /* Incremental Dump & Reconcile of Database Schema */
do:
  
  run adm/entw/proc/detdum00.w ( '':U ).
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_LoadDataDefinitions
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_LoadDataDefinitions hQueryWindow
ON choose OF MENU-ITEM mi_LoadAllTableDetails /* Load all table details */
do:
  
  if not available ttDatabase then
    
    return.
  
  run qg_LoadAllTableDetailsOfSingleDatabase( ttDatabase.DatabaseName ).
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_LoadDataDefinitions
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_LoadDataDefinitions hQueryWindow
ON choose OF MENU-ITEM mi_LoadDataDefinitions /* Load data definitions (.df) */
do:

  run qg_LoadDataDefinitions(hQueryWindow).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_LoadQueryScenario
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_LoadQueryScenario hQueryWindow
ON choose OF MENU-ITEM mi_LoadQueryScenario /* Load query scenario */
do:

  define variable lOk as logical   no-undo.

  system-dialog get-file gcQRScenarioFileName
    title             gcTitlePrefix + 'Load query scenario ...':T
    filters           'Query scenario (*.qsc)':T '*.qsc':U
    default-extension '.qsc':U
    ask-overwrite
    use-filename
    update lOk
    in window hQueryWindow
    .
  
  if not lOk then
    return.
  
  run qg_LoadQueryScenario(gcQRScenarioFileName, ?).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ModifyIndexQueryFields
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ModifyIndexQueryFields hQueryWindow
ON choose OF MENU-ITEM mi_ModifyIndexQueryFields /* Modify query fields */
do:

  if available ttIndex then
  do:
    
    run qg_SetDisplayMode({&K_DISPLAYMODE_FIELD}).
    run qg_SelectFieldList(ttIndex.IndexFieldList).
    
    apply 'value-changed':U to brField in frame {&FRAME-NAME}.
    
  end. /* if available ttIndex */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ModifyRelationQueryFields
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ModifyRelationQueryFields hQueryWindow
ON choose OF MENU-ITEM mi_ModifyRelationQueryFields /* Modify query fields */
do:

  if available ttTableRelationView then
  do:
    
    run qg_SetDisplayMode({&K_DISPLAYMODE_FIELD}).
    run qg_SelectFieldList(ttTableRelationView.ReferenceFieldList).
    
    apply 'value-changed':U to brField in frame {&FRAME-NAME}.
    
  end. /* if available ttTableRelationView */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_OpenTableCompanyInclude
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenTableCompanyInclude hQueryWindow
ON choose OF MENU-ITEM mi_OpenTableCompanyInclude /* Open include file */
do:

  define variable cFilename    as character no-undo.
  
  if    available ttTable
    and ttTable.CompanyInclude > '':U then
  do:
    
    cFilename = search(substitute('firma/&1':U,
                                  ttTable.CompanyInclude)).
    
    if cFilename > '':U then
      run qg_OpenEditor(cFilename).
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_OpenPluginWiki
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenPluginWiki hQueryWindow
ON choose OF MENU-ITEM mi_OpenPluginWiki /* Open pA-Wiki for Query Generator Plugin */
do:

  define variable iResult as integer   no-undo.

  display unless-hidden
    'Connection to host pawiki ...':T
      @ gcStatusText60
    with frame fStatus
      no-labels
      overlay
      color messages
      centered
      view-as dialog-box
      width 65
      in window {&WINDOW-NAME}
      .
  process events.

  if qg_lIsHostReachable('pawiki':U, 'http':U) then
  do:
    
    hide frame fStatus.
    
    run ShellExecuteA(0,
                      'Open':U,
                      {&K_PLUGIN_WIKI_URL},
                      '':U,
                      '':U,
                      0,
                      output iResult).
    
  end. /* if qg_lIsHostReachable('pawiki':U, 'http':U) */
  
  else
  do:
    
    hide frame fStatus.
    
    run ShellExecuteA(0,
                      'Open':U,
                      {&K_PLUGIN_CUSTOMER_WIKI_URL},
                      '':U,
                      '':U,
                      0,
                      output iResult).
    
  end. /* else: if qg_lIsHostReachable('pawiki':U, 'http':U) */
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_OpenQGWiki
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenQGWiki hQueryWindow
ON choose OF MENU-ITEM mi_OpenQGWiki /* Open pA-Wiki for Query Generator */
do:

  define variable iResult as integer   no-undo.

  display unless-hidden
    'Connection to host pawiki ...':T
      @ gcStatusText60
    with frame fStatus
      no-labels
      overlay
      color messages
      centered
      view-as dialog-box
      width 65
      in window {&WINDOW-NAME}
      .
  process events.

  if qg_lIsHostReachable('pawiki':U, 'http':U) then
  do:
    
    hide frame fStatus.
    
    run ShellExecuteA(0,
                      'Open':U,
                      {&K_QG_WIKI_URL},
                      '':U,
                      '':U,
                      0,
                      output iResult).
    
  end. /* if qg_lIsHostReachable('pawiki':U, 'http':U) */
  
  else
  do:
    
    hide frame fStatus.
    
    run ShellExecuteA(0,
                      'Open':U,
                      {&K_QG_CUSTOMER_WIKI_URL},
                      '':U,
                      '':U,
                      0,
                      output iResult).
    
  end. /* else: if qg_lIsHostReachable('pawiki':U, 'http':U) */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_OpenQueryWindowListWindow
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenQueryWindowListWindow hQueryWindow
ON choose OF MENU-ITEM mi_OpenQueryWindowListWindow /* Query window */
do:

  run qg_OpenQueryWindowListWindow.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_OpenTableCreateTrigger
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenTableCreateTrigger hQueryWindow
ON choose OF MENU-ITEM mi_OpenTableCreateTrigger /* Open trigger procedure */
do:

  define variable cFilename as character no-undo.
  
  if    available ttTable
    and ttTable.CreateTrigger > '':U then
  do:
    
    cFilename = search(ttTable.CreateTrigger).
    
    if cFilename > '':U then
      run qg_OpenEditor(cFilename).
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_OpenTableDeleteTrigger
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenTableDeleteTrigger hQueryWindow
ON choose OF MENU-ITEM mi_OpenTableDeleteTrigger /* Open trigger procedure */
do:

  define variable cFilename as character no-undo.
  
  if    available ttTable
    and ttTable.DeleteTrigger > '':U then
  do:
    
    cFilename = search(ttTable.DeleteTrigger).
    
    if cFilename > '':U then
      run qg_OpenEditor(cFilename).
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_OpenTableFillInclude
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenTableFillInclude hQueryWindow
ON choose OF MENU-ITEM mi_OpenTableFillInclude /* Open include file */
do:

  define variable cIncludeName as character no-undo.
  define variable cFilename    as character no-undo.
  
  if    available ttTable
    and ttTable.CompanyInclude > '':U then
  do:
    
    cIncludeName = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                    ttTable.FillInclude) no-error.
    
    cFilename = search(cIncludeName).
    
    if cFilename > '':U then
      run qg_OpenEditor(cFilename).
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_OpenTableKeyInclude
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenTableKeyInclude hQueryWindow
ON choose OF MENU-ITEM mi_OpenTableKeyInclude /* Open include file */
do:

  define variable cIncludeName as character no-undo.
  define variable cFilename    as character no-undo.
  
  if    available ttTable
    and ttTable.KeyInclude > '':U then
  do:
    
    cIncludeName = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                    ttTable.KeyInclude) no-error.
    
    cFilename = search(cIncludeName).
    
    if cFilename > '':U then
      run qg_OpenEditor(cFilename).
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_OpenTableWriteTrigger
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_OpenTableWriteTrigger hQueryWindow
ON choose OF MENU-ITEM mi_OpenTableWriteTrigger /* Open trigger procedure */
do:

  define variable cFilename as character no-undo.
  
  if    available ttTable
    and ttTable.WriteTrigger > '':U then
  do:
    
    cFilename = search(ttTable.WriteTrigger).
    
    if cFilename > '':U then
      run qg_OpenEditor(cFilename).
    
  end. /* if    available ttTable */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_PasteQueryScenario
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_PasteQueryScenario hQueryWindow
ON choose OF MENU-ITEM mi_PasteQueryScenario /* Paste query scenario */
do:

  run qg_LoadQueryScenario(?, ?).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_RemoveTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_RemoveTable hQueryWindow
ON choose OF MENU-ITEM mi_RemoveTable /* Remove table */
do:

  if    available ttDatabase
    and available ttTable
    and not ttTable.PhysicalTable then
  do:
    
    run qg_RemoveTable(ttTable.DatabaseName, ttTable.TableName).
    
    if can-find(first ttTable
                  where ttTable.DatabaseName = ttDatabase.DatabaseName) then
    do:
      
      {&OPEN-QUERY-brTable}
      
      process events.
      
      apply 'value-changed':U to brTable in frame {&FRAME-NAME}.
      
    end. /* if can-find(first ttTable */
    
    else
    do:
      
      run qg_RemoveDatabase(ttDatabase.DatabaseName).
      {&OPEN-QUERY-brDatabase}
      
      process events.
      
      apply 'value-changed':U to brDatabase in frame {&FRAME-NAME}.
      
    end. /* else: if can-find(first ttTable */
    
  end. /* if    available ttDatabase */
  
  run qg_CloseInvalidQueryWindows.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_RepositoryLanguage
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_RepositoryLanguage hQueryWindow
ON choose OF MENU-ITEM mi_RepositoryLanguage /* Repository Langauge */
do:

  run qg_SelectRepositoryLanguage.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ResetAll
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ResetAll hQueryWindow
ON choose OF MENU-ITEM mi_ResetAll /* Reset */
do:

  apply 'choose':U to btnResetAll in frame {&FRAME-NAME}.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_RestoreDefaultWindowSize
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_RestoreDefaultWindowSize hQueryWindow
ON choose OF MENU-ITEM mi_RestoreDefaultWindowSize /* Restore default window size */
do:

  assign
    hQueryWindow:window-state = {&K_WINDOW_NORMAL}
    hQueryWindow:width-chars  = gdOriginalWidth
    hQueryWindow:height-chars = gdOriginalHeight
    .
  
  apply 'window-resized':U to hQueryWindow.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SaveQueryScenario
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SaveQueryScenario hQueryWindow
ON choose OF MENU-ITEM mi_SaveQueryScenario /* Save query scenario */
do:

  define variable lOk as logical   no-undo.

  system-dialog get-file gcQRScenarioFileName
    title             gcTitlePrefix + 'Save query scenario as ...':U
    filters           'Query scenario (*.qsc)':U '*.qsc':U
    default-extension '.qsc':U
    ask-overwrite
    save-as
    use-filename
    update lOk
    in window hQueryWindow
    .
  
  if not lOk then
    return.
  
  run qg_SaveQueryScenario(gcQRScenarioFileName).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SelectAllFields
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SelectAllFields hQueryWindow
ON choose OF MENU-ITEM mi_SelectAllFields /* Selected all */
do:

  if query brField:num-results > 0 then
  do:
    
    browse brField:select-all().
    browse brField:scroll-to-selected-row(1).
    
    apply 'value-changed':U to browse brField.
    
  end. /* if brField:num-results > 0 */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggerAddFieldsAssign
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerAddFieldsAssign hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerAddFieldsAssign /* Add session triggers (assign) */
DO:

  define variable i               as integer   no-undo.
  define variable cSelectedFields as character no-undo.
  
  define buffer bttField for temp-table ttField.
  
  if available ttField then
  do:
    
    cSelectedFields = qg_cGetSelectedFields(?,
                                            ',':U,
                                            no).
    
    do i = 1 to num-entries(cSelectedFields):
      
      find bttField
        where bttField.DatabaseName = ttField.DatabaseName
          and bttField.TableName    = ttField.TableName
          and bttField.FieldName    = entry(i, cSelectedFields)
        no-error.
      
      if    available bttField
        and bttField.FieldExtent = 0 then
        run qg_AddSessionTrigger('assign':U,
                                 bttField.DatabaseName,
                                 bttField.TableName,
                                 bttField.FieldName,
                                 yes).
      
    end. /* do i = 1 to num-entries(cSelectedFields) */
    
  end. /* if available ttField */

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggerCreate
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerCreate hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerCreate /* Add session trigger (create) */
DO:

  if available ttTable then
  do:
    
    if can-find(first ttSessionTrigger
                  where ttSessionTrigger.TriggerEvent = 'create':U
                    and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                    and ttSessionTrigger.TableName    = ttTable.TableName
                    and ttSessionTrigger.FieldName    = '':U) then
      run qg_RemoveSessionTrigger('create':U,
                                  ttTable.DatabaseName,
                                  ttTable.TableName,
                                  '':U).
    
    else
      run qg_AddSessionTrigger('create':U,
                               ttTable.DatabaseName,
                               ttTable.TableName,
                               '':U,
                               yes).
    
  end. /* if available ttTable */

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggerDelete
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerDelete hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerDelete /* Add session trigger (delete) */
DO:

  if available ttTable then
  do:
    
    if can-find(first ttSessionTrigger
                  where ttSessionTrigger.TriggerEvent = 'delete':U
                    and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                    and ttSessionTrigger.TableName    = ttTable.TableName
                    and ttSessionTrigger.FieldName    = '':U) then
      run qg_RemoveSessionTrigger('delete':U,
                                  ttTable.DatabaseName,
                                  ttTable.TableName,
                                  '':U).
    
    else
      run qg_AddSessionTrigger('delete':U,
                               ttTable.DatabaseName,
                               ttTable.TableName,
                               '':U,
                               yes).
    
  end. /* if available ttTable */

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggerFieldAssign
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerFieldAssign hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerFieldAssign /* Add session trigger (assign) */
DO:

  if    available ttField
    and ttField.FieldExtent = 0 then
  do:
    
    if can-find(first ttSessionTrigger
                  where ttSessionTrigger.TriggerEvent = 'assign':U
                    and ttSessionTrigger.DatabaseName = ttField.DatabaseName
                    and ttSessionTrigger.TableName    = ttField.TableName
                    and ttSessionTrigger.FieldName    = ttField.FieldName) then
      run qg_RemoveSessionTrigger('assign':U,
                                  ttField.DatabaseName,
                                  ttField.TableName,
                                  ttField.FieldName).
    
    else
      run qg_AddSessionTrigger('assign':U,
                               ttField.DatabaseName,
                               ttField.TableName,
                               ttField.FieldName,
                               yes).
    
  end. /* if available ttField */
  
END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_SessionTriggerFind
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerFind hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerFind /* Add session trigger (find) */
DO:

  if available ttTable then
  do:
    
    if can-find(first ttSessionTrigger
                  where ttSessionTrigger.TriggerEvent = 'find':U
                    and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                    and ttSessionTrigger.TableName    = ttTable.TableName
                    and ttSessionTrigger.FieldName    = '':U) then
      
      run qg_RemoveSessionTrigger( 'find':U,
                                   ttTable.DatabaseName,
                                   ttTable.TableName,
                                   '':U ).
    
    else
      
      run qg_AddSessionTrigger( 'find':U,
                                ttTable.DatabaseName,
                                ttTable.TableName,
                                '':U,
                                yes ).
    
  end. /* if available ttTable */

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggerRemoveFieldsAssign
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerRemoveFieldsAssign hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerRemoveFieldsAssign /* Remove session triggers (assign) */
DO:

  define variable i               as integer   no-undo.
  define variable cSelectedFields as character no-undo.
  
  if available ttField then
  do:
    
    cSelectedFields = qg_cGetSelectedFields(?,
                                            ',':U,
                                            no).
    
    do i = 1 to num-entries(cSelectedFields):
      
      run qg_RemoveSessionTrigger('assign':U,
                                  ttField.DatabaseName,
                                  ttField.TableName,
                                  entry(i, cSelectedFields)).
      
    end. /* do i = 1 to num-entries(cSelectedFields) */
    
  end. /* if available ttField */

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggers
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggers hQueryWindow
ON choose OF MENU-ITEM mi_SessionTriggers /* Session triggers */
do:

  run qg_OpenSessionTriggerWindow.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SessionTriggerWrite
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SessionTriggerWrite hQueryWindow
ON CHOOSE OF MENU-ITEM mi_SessionTriggerWrite /* Add session trigger (write) */
DO:

  if available ttTable then
  do:
    
    if can-find(first ttSessionTrigger
                  where ttSessionTrigger.TriggerEvent = 'write':U
                    and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                    and ttSessionTrigger.TableName    = ttTable.TableName
                    and ttSessionTrigger.FieldName    = '':U) then
      run qg_RemoveSessionTrigger('write':U,
                                  ttTable.DatabaseName,
                                  ttTable.TableName,
                                  '':U).
    
    else
      run qg_AddSessionTrigger('write':U,
                               ttTable.DatabaseName,
                               ttTable.TableName,
                               '':U,
                               yes).
    
  end. /* if available ttTable */

END.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_ShowHiddenTables
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_ShowHiddenTables hQueryWindow
ON value-changed OF MENU-ITEM mi_ShowHiddenTables /* Show hidden tables */
do:

  glShowHiddenTables = menu-item mi_ShowHiddenTables:checked in menu POPUP-MENU-brTable.
  
  run qg_RefreshTableBrowse.
  run qg_WidgetState('*':U).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_SwitchToRelatedTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SwitchToRelatedTable hQueryWindow
ON choose OF MENU-ITEM mi_SwitchToRelatedTable /* Swtich to related table */
do:

  define variable iRelationId   as integer   no-undo.
  define variable cDatabaseName as character no-undo.
  define variable cTableName    as character no-undo.

  define buffer bttTableRelationView for temp-table ttTableRelationView.

  if available ttTableRelationView then
  do:
    
    assign
      iRelationId           = ttTableRelationView.RelationId
      cDatabaseName         = ttTableRelationView.DatabaseName
      cTableName            = ttTableRelationView.ReferenceTableName
      gcRelationFilter      = '':U
      gcRelationFieldFilter = '':U
      .
    
    display unless-hidden
      gcRelationFilter
      gcRelationFieldFilter
      with frame {&FRAME-NAME}.
    
    run qg_SelectTable(ttTableRelationView.RelatedTableName, no).
    
    find first bttTableRelationView
      where bttTableRelationView.RelationId         = iRelationId
        and bttTableRelationView.DatabaseName       = cDatabaseName
        and bttTableRelationView.RelatedTableName   = cTableName
        and bttTableRelationView.TableFilterMatches = yes
        and bttTableRelationView.FieldFilterMatches = yes
      no-error.
    
    if available bttTableRelationView then
    do:
      
      reposition brRelation to rowid rowid(bttTableRelationView) no-error.
      
      apply 'value-changed':U to brRelation in frame {&FRAME-NAME}.
      
    end. /* if available bttTableRelationView */
    
    apply 'entry':U to brRelation in frame {&FRAME-NAME}.
    
  end. /* if available ttTableRelationView */

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME mi_SlimMode
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_SlimMode hQueryWindow
ON value-changed OF MENU-ITEM mi_SlimMode /* Slim mode */
do:
  
  run qg_SetSlimMode(not glSlimMode).

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_VirtualFields
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_VirtualFields hQueryWindow
ON value-changed OF MENU-ITEM mi_VirtualFields /* Show Virtual Fields */
do:
  
  assign
    glShowVirtualFields  = menu-item mi_VirtualFields:checked in menu POPUP-MENU-brField
    glRefreshFieldBrowse = yes
    .
  
  run qg_RefreshFieldBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&Scoped-define SELF-NAME mi_VirtualIndices
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL mi_VirtualIndices hQueryWindow
ON value-changed OF MENU-ITEM mi_VirtualIndices /* Show Virtual Indices */
do:
  
  assign
    glShowVirtualIndices  = menu-item mi_VirtualIndices:checked in menu POPUP-MENU-brIndex
    glRefreshIndexBrowse = yes
    .
  
  run qg_RefreshIndexBrowse.
  
end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME m_Edit
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL m_Edit hQueryWindow
ON menu-drop OF MENU m_Edit /* Edit */
do:

  define variable lQueryWindows as logical   no-undo.
  
  assign
    lQueryWindows = can-find(first ttQueryWindow)
    menu-item mi_InsertQueryText:sensitive in menu m_Edit /* code checked by mth */
        =     OEIDEIsRunning
          and glIDECanInsert
    menu-item mi_CopyQueryScenario:sensitive in menu m_Edit /* code checked by mth */
        = lQueryWindows
    menu-item mi_PasteQueryScenario:sensitive in menu m_Edit /* code checked by mth */
        = lookup('PRO_TEXT':U, clipboard:available-formats) > 0
    .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME m_File
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL m_File hQueryWindow
ON menu-drop OF MENU m_File /* File */
do:
  
  define variable lQueryWindows as logical   no-undo.
  
  assign
    lQueryWindows = can-find(first ttQueryWindow)
    menu-item mi_SaveQueryScenario:sensitive in menu m_File /* code checked by mth */
        = lQueryWindows
    .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME m_Options
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL m_Options hQueryWindow
ON menu-drop OF MENU m_Options /* Options */
do:

  assign
    menu-item mi_InsertMode:checked in menu m_Options
        = glInsertMode
    menu-item mi_InsertMode:sensitive in menu m_Options /* code checked by mth */
        =     OEIDEIsRunning
          and glIDECanInsert
    .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME m_Tools
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL m_Tools hQueryWindow
ON menu-drop OF MENU m_Tools /* Tools */
do:

  assign
    menu-item mi_AddSnapshot:sensitive in menu m_Tools /* code checked by mth 20.01.2015 */
      =     available(ttTable)
        and not ttTable.Snapshot
    menu-item mi_AddPersistentTempTable:sensitive in menu m_Tools /* code checked by mth 20.01.2015 */
      = (proversion >= '11.2':U)
    .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME m_Window
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL m_Window hQueryWindow
ON menu-drop OF MENU m_Window /* Window */
do:

  define variable lQueryWindow  as logical   no-undo.
  
  assign
    lQueryWindow  = can-find(first ttQueryWindow)
    menu-item mi_CloseAllQueryWindows:sensitive in menu m_Window /* code checked by mth */
        = lQueryWindow
    menu-item mi_SlimMode:checked in menu m_Window
        = glSlimMode
    .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME POPUP-MENU-brDatabase
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL POPUP-MENU-brDatabase hQueryWindow
ON menu-drop OF MENU POPUP-MENU-brDatabase
do:
  
  run qg_UpdateDatabasePopupMenu.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME POPUP-MENU-brField
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL POPUP-MENU-brField hQueryWindow
ON menu-drop OF MENU POPUP-MENU-brField
do:

  run qg_UpdateFieldPopupMenu.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME POPUP-MENU-brIndex
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL POPUP-MENU-brIndex hQueryWindow
ON menu-drop OF MENU POPUP-MENU-brIndex
do:

  run qg_UpdateIndexPopupMenu.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME POPUP-MENU-brRelation
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL POPUP-MENU-brRelation hQueryWindow
ON menu-drop OF MENU POPUP-MENU-brRelation
do:
  
  run qg_UpdateRelationPopupMenu.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME POPUP-MENU-brTable
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL POPUP-MENU-brTable hQueryWindow
ON menu-drop OF MENU POPUP-MENU-brTable
do:

  run qg_UpdateTablePopupMenu.

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define SELF-NAME POPUP-MENU-btnCopyToClipboard
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CONTROL POPUP-MENU-btnCopyToClipboard hQueryWindow
ON menu-drop OF MENU POPUP-MENU-btnCopyToClipboard
do:

  assign
    menu-item mi_InsertModeBtn:checked in menu POPUP-MENU-btnCopyToClipboard
        = glInsertMode
    menu-item mi_InsertModeBtn:sensitive in menu POPUP-MENU-btnCopyToClipboard /* code checked by mth */
        =     OEIDEIsRunning
          and glIDECanInsert
    .

end.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&Scoped-define BROWSE-NAME brDatabase
&UNDEFINE SELF-NAME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _MAIN-BLOCK hQueryWindow 


/* ***************************  Main Block  *************************** */

/* Set CURRENT-WINDOW: this will parent dialog-boxes and frames.        */
assign CURRENT-WINDOW                = {&WINDOW-NAME} 
       THIS-PROCEDURE:CURRENT-WINDOW = {&WINDOW-NAME}.

/* The CLOSE event can be used from inside or outside the procedure to  */
/* terminate it.                                                        */

on close of this-procedure
do:
  
  apply 'window-close':U to hQueryWindow.
  
  run disable_UI.

end. /*  */

/* Best default for GUI applications is...                              */
pause 0 before-hide.

/* Now enable the interface and wait for the exit condition.            */
/* (NOTE: handle ERROR and END-KEY so cleanup code will always fire.    */
MAIN-BLOCK:
do on error   undo MAIN-BLOCK, leave MAIN-BLOCK
   on endkey undo MAIN-BLOCK, retry MAIN-BLOCK
   on stop   undo MAIN-BLOCK, leave MAIN-BLOCK
   on quit   undo MAIN-BLOCK, leave MAIN-BLOCK:
  
  if not retry then
  do:
    
    run enable_UI.
    
    run qg_Initialize.
  
  end. /* if not retry */
  
  if not this-procedure:persistent then
    wait-for close of this-procedure.
    
end.

/* If this procedure was used as the startup procedure for this session then  */
/* source-procedure is not set. In this case we can quit the session to avoid */
/* to be dropped to the procedure editor window.                              */

if not valid-handle(source-procedure) then
  quit.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


/* **********************  Internal Procedures  *********************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE disable_UI hQueryWindow  _DEFAULT-DISABLE
PROCEDURE disable_UI :
/*------------------------------------------------------------------------------
  Purpose:     DISABLE the User Interface
  Parameters:  <none>
  Notes:       Here we clean-up the user-interface by deleting
               dynamic widgets we have created and/or hide 
               frames.  This procedure is usually called when
               we are ready to "clean-up" after running.
------------------------------------------------------------------------------*/
  /* Delete the WINDOW we created */
  IF SESSION:DISPLAY-TYPE = "GUI":U AND VALID-HANDLE(hQueryWindow)
  THEN DELETE WIDGET hQueryWindow.
  IF THIS-PROCEDURE:PERSISTENT THEN DELETE PROCEDURE THIS-PROCEDURE.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE enable_UI hQueryWindow  _DEFAULT-ENABLE
PROCEDURE enable_UI :
/*------------------------------------------------------------------------------
  Purpose:     ENABLE the User Interface
  Parameters:  <none>
  Notes:       Here we display/view/enable the widgets in the
               user-interface.  In addition, OPEN all queries
               associated with each FRAME and BROWSE.
               These statements here are based on the "Other 
               Settings" section of the widget Property Sheets.
------------------------------------------------------------------------------*/
  DISPLAY gdIndexUsage gcFieldLabelFilter gcFieldDummy gcTableFilter 
          gcTableFieldFilter giDisplayMode glInvertQuery gcFieldFilter gcIndexFilter 
          gcIndexFieldFilter gcBufferName glDefineBuffer glCompanyViaClass 
          glExclusiveLock glNoError glIfStatement glNot glDoBlock 
          glOnError giOnErrorPhrase giQueryTypeModifier gcBlockName glDefineBlock glRetryBlock 
          glFinallyBlock giQueryType gcQueryText gcRelationFilter 
          gcRelationFieldFilter glDefineVariables glUseVirtualIndexIncludes
      WITH FRAME fQuery IN WINDOW hQueryWindow.
  ENABLE gdIndexUsage btnClearFieldLabelFilter gcFieldLabelFilter gcFieldDummy 
         brDatabase btnConnectDB btnDisconnectDB btnRefresh gcTableFilter 
         btnClearTableFilter gcTableFieldFilter btnClearTableFieldFilter 
         brTable giDisplayMode glInvertQuery gcFieldFilter btnClearFieldFilter brField 
         gcIndexFilter btnClearIndexFilter gcIndexFieldFilter 
         btnClearIndexFieldFilter brIndex gcBufferName btnClearBufferPattern 
         btnBuffer1 btnBuffer2 btnBuffer3 btnBuffer4 glDefineBuffer 
         glCompanyViaClass glExclusiveLock glNoError glIfStatement glNot 
         glDoBlock glOnError giOnErrorPhrase giQueryTypeModifier gcBlockName btnClearBlockName 
         btnBlock1 btnBlock2 btnBlock3 btnBlock4 glDefineBlock glRetryBlock 
         glFinallyBlock giQueryType btnCopyToClipboard btnExecuteQuery 
         btnResetAll btnIncreaseIndentation btnDecreaseIndentation 
         btnResetIndentation btnOf gcQueryText brRelation gcRelationFilter 
         gcRelationFieldFilter btnClearRelationFilter 
         btnClearRelationFieldFilter glDefineVariables
         glUseVirtualIndexIncludes
      WITH FRAME fQuery IN WINDOW hQueryWindow.
  {&OPEN-BROWSERS-IN-QUERY-fQuery}
  VIEW hQueryWindow.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_About hQueryWindow 
PROCEDURE qg_About :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show about dialog.                                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phMenuBar as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/



define variable iHwnd        as int64     no-undo.
define variable iDummy       as integer   no-undo.

define variable iX1          as integer   no-undo.
define variable iY1          as integer   no-undo.
define variable iX2          as integer   no-undo.
define variable iY2          as integer   no-undo.

define variable cVersionText as character no-undo.
define variable cInfoText    as character no-undo.

define variable hWindow      as handle    no-undo.
define variable hFrame       as handle    no-undo.
define variable hImage       as handle    no-undo.
define variable hVersionText as handle    no-undo.
define variable hInfoText    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create window hWindow
  assign
    hidden          = yes
    width           = 80
    max-width       = 1024
    height          = 12
    max-height      = 1024
    scroll-bars     = no
    status-area     = no
    three-d         = yes
    message-area    = no
    control-box     = no
    small-title     = yes
    show-in-taskbar = no
    top-only        = yes
    sensitive       = yes
    resize          = no
    parent          = phMenuBar:window
    title           = substitute('&1&2':U, gcTitlePrefix, 'About Query Generator':T)
  triggers:

    on leave
      persistent run qg_CloseWindow in target-procedure
                       (hWindow).
    
    on end-error anywhere
      persistent run qg_CloseWindow in target-procedure
                       (hWindow).
    
    on window-close
      persistent run qg_DeleteWidgetTree  in target-procedure
                       (hWindow, yes).
    
  end triggers.


create frame hFrame
  assign
    name           = 'fAbout':U
    box            = no
    three-d        = yes
    width          = hWindow:width
    virtual-width  = hWindow:width
    height         = hWindow:height
    virtual-height = hWindow:height
    sensitive      = yes
    parent         = hWindow
  triggers:
    
    on mouse-select-click
      persistent run qg_CloseWindow in target-procedure
                       (hWindow).
    
  end triggers.

create image hImage
  assign
    name      = 'imgQueryGenerator':U
    frame     = hFrame
    width     = 1
    height    = 1
    row       = 2
    col       = 6
    sensitive = yes
  triggers:
    
    on mouse-select-click
      persistent run qg_CloseWindow in target-procedure
                       (hWindow).
    
  end triggers.
    .

create text hVersionText
  assign
    name      = 'cVersionText':U
    frame     = hFrame
    data-type = 'character':U
    format    = 'x(255)':U
    width     = 30
    height    = 1
    row       = 2
    col       = 6
    sensitive = yes
  triggers:
    
    on mouse-select-click
      persistent run qg_CloseWindow in target-procedure
                       (hWindow).

  end triggers.
    .

create editor hInfoText
  assign
    name                 = 'cInfoText':U
    frame                = hFrame
    data-type            = 'character':U
    width                = 69
    height               = 7
    read-only            = yes
    box                  = no
    word-wrap            = yes
    scrollbar-horizontal = no
    scrollbar-vertical   = no
    row                  = 2.5
    col                  = 6
    sensitive            = yes
    .

assign
  hImage:height-pixels = 32
  hImage:width-pixels  = 32
  .

if gcIconDir = '':U then
  hImage:load-image('adeicon/sqlexp.ico':U) no-error.

else
  hImage:load-image(substitute('&1/32/query_wizard.ico':U,
                               gcIconDir)) no-error.

assign
  cVersionText  = substitute('Query Generator Version &1':U,
                         {&K_Version})
  cInfoText =            'The Query Generator is a tool for lazy developeres. It ...':T
              + '~n':U
              + '~n':U + '... provides fast and easy access to database schema information':T
              + '~n':U + '... helps to integrate database queries into your code with little typing effort':T
              + '~n':U + '... displays table contents in a convenient and supporting manner':T
              + '~n':U
              + '~n':U + 'This Program is provided with absolutely no warranty. Use it at your own risk.':T
              + '~n':U
              + '~n':U + 'If you want to report a bug or provide feedback please contact manuel.thiemann@proalpha.de.':T
  .

if gcIconDir > '':U then
  assign
  cInfoText =   cInfoText
              + '~n':U
              + '~n':U + 'The icons are part of the "Free FatCow-Farm Fresh Icons" (http://www.fatcow.com/free-icons). These icon sets are licensed under a Creative Commons Attribution 3.0 License (http://creativecommons.org/licenses/by/3.0/us).':T
    hWindow:height = hWindow:height + 3.5
    hFrame:height  = hFrame:height + 3.5
    
              .

assign
  hVersionText:x             = hImage:x + hImage:width-pixels + 20
  hVersionText:height-pixels = hImage:height-pixels
  hVersionText:screen-value  = cVersionText
  hInfoText:y                = hImage:y + hImage:height-pixels + 30
  hInfoText:height-pixels    = hFrame:height-pixels - hInfoText:y
  hInfoText:screen-value     = cInfoText
  .

run GetParent(hWindow:hwnd,
              output iHwnd).

run SetWindowLongA(iHwnd,
                   {&K_WIN_CONST_GWL_STYLE},
                   {&K_WIN_CONST_WS_BORDER},
                   output iDummy).

run qg_GetWindowRect(phMenuBar:window,
                     output iX1,
                     output iY1,
                     output iX2,
                     output iY2).

run SetWindowPos(iHwnd,
                 0,
                 max(0, integer(iX1 + ((iX2 - iX1) / 2) - (hFrame:width-pixels / 2))),
                 max(0, integer(iY1 + ((iY2 - iY1) / 2) - (hFrame:height-pixels / 2))),
                 hWindow:width-pixels,
                 hWindow:height-pixels,
                 {&K_WIN_CONST_SWP_FRAMECHANGED},
                 output iDummy).

assign
  hWindow:hidden  = no
  hWindow:bgcolor = 15
  hFrame:hidden   = no
  hFrame:bgcolor  = 15
  .

apply 'entry':U to hWindow.

end procedure. /* qg_About */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddFieldHistoryEntry hQueryWindow 
PROCEDURE qg_AddFieldHistoryEntry :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Adds current value of given combo-box to it's value list.                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWidget                       = Combo-box widget.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWidget as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cValue as character no-undo.
define variable i      as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cValue = phWidget:input-value no-error.
phWidget:delete(cValue) no-error.

if length(cValue) > 3 then
do:
  phWidget:add-first(cValue).
  phWidget:screen-value = cValue.
end. /* if length(cValue) > 3 */

do i = phWidget:num-items to {&K_MAX_FIELD_HISTORY_ENTRIES} + 1 by -1:
  phWidget:delete(i).
end. /* do i = {&K_MAX_FIELD_HISTORY_ENTRIES} */

/* This causes flickering
if    OEIDEIsRunning
  and glIDECanSaveSetting
  and phWidget:list-items <> ? then
  run qg_SaveIDESetting(substitute('FieldHistory_&1':U, phWidget:name),
                        phWidget:list-items) no-error.
*/

end procedure. /* qg_AddFieldHistoryEntry */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddHelpMenu Method-Library
procedure qg_AddHelpMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phMenuBar as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hSubMenu as handle    no-undo.
define variable hTemp    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create sub-menu hSubMenu
  assign
    name      = 'm_Help':U
    label     = 'Help':T
    sensitive = yes
    parent    = phMenuBar
    .

create menu-item hTemp
  assign
    name        = 'mi_About':U
    label       = 'About Query Generator':T
    sensitive   = yes
    parent      = hSubMenu
  triggers:
    on choose
      persistent run qg_About in target-procedure
                       (phMenuBar).  
  end triggers.

end procedure. /* qg_AddHelpMenu */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddPersistentTempTable hQueryWindow 
PROCEDURE qg_AddPersistentTempTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add persistent temp-table entry.                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i              as integer   no-undo.

define variable hTempTable     as handle    no-undo.
define variable cProcedureName as character no-undo.

define variable cParamList     as character no-undo.

define variable iQuerySeq      as integer   no-undo initial ?.
define variable iFilterId      as integer   no-undo.

define variable cProcedureFilter    as character no-undo
  format 'x(1024)':U
  view-as fill-in
  tooltip "Filter for procedures and classes that match given name pattern (comma separated)"
  size 63 by 1.

define button btnClearProcedureFilter
  label '':T2
  size 7 by 1.

define variable cTableFilter as character no-undo
  format 'x(1024)':U
  view-as fill-in
  tooltip "Filter for procedures and classes containing tables that match given name pattern (comma separated)"
  size 63 by 1.

define button btnClearTableFilter
  label '':T2
  size 7 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttPersistentProcedure for temp-table ttPersistentProcedure.
define buffer bttPersistentTempTable for temp-table ttPersistentTempTable.
define buffer bttFilterMatch         for temp-table ttFilterMatch.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

&IF proversion >= '11.2':U &THEN

  define query brPersistentProcedureBrowse
    for bttPersistentProcedure,bttFilterMatch
    scrolling.
  
  define browse brPersistentProcedureBrowse
    query brPersistentProcedureBrowse no-lock
      display
        bttPersistentProcedure.ProcedureName
        with no-assign size 70 by 18.5.
  
  define query brPersistentTempTableBrowse
    for bttPersistentTempTable
    scrolling.
  
  define browse brPersistentTempTableBrowse
    query brPersistentTempTableBrowse no-lock
      display
        bttPersistentTempTable.TableName
        with no-assign size 70 by 18.5 fit-last-column.
  
  define frame fSelectPersistentTempTable
    cProcedureFilter at row 1.5 col 3 no-label
    btnClearProcedureFilter at row 1.5 col 66
    cTableFilter at row 1.5 col 75 no-label
    btnClearTableFilter at row 1.5 col 138
    brPersistentProcedureBrowse at row 2.5 col 3
    brPersistentTempTableBrowse at row 2.5 col 75
    btnOk at row 22 col 54
    btnCancel at row 22 col 74
    with 1 down keep-tab-order overlay
      view-as dialog-box 
      side-labels no-underline three-d 
      size 147 by 23.83
      title gcTitlePrefix + 'Select persistent temp-table':T
      default-button btnOk
      cancel-button btnCancel.
  
  on window-close of frame fSelectPersistentTempTable
    apply 'end-error' to self.
  
  on off-home of brPersistentProcedureBrowse in frame fSelectPersistentTempTable
  do:
    apply 'entry':U to cProcedureFilter in frame fSelectPersistentTempTable.
    return no-apply.
  end. /* on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable
  do:
    apply 'entry':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.
    browse brPersistentProcedureBrowse:select-focused-row().
    return no-apply.
  end. /* on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on cursor-down of btnClearProcedureFilter in frame fSelectPersistentTempTable
  do:
    apply 'entry':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.
    browse brPersistentProcedureBrowse:select-focused-row().
    return no-apply.
  end. /* on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on off-home of brPersistentTempTableBrowse in frame fSelectPersistentTempTable
  do:
    apply 'entry':U to cTableFilter in frame fSelectPersistentTempTable.
    return no-apply.
  end. /* on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on cursor-down of cTableFilter in frame fSelectPersistentTempTable
  do:
    apply 'entry':U to brPersistentTempTableBrowse in frame fSelectPersistentTempTable.
    browse brPersistentTempTableBrowse:select-focused-row().
    return no-apply.
  end. /* on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on cursor-down of btnClearTableFilter in frame fSelectPersistentTempTable
  do:
    apply 'entry':U to brPersistentTempTableBrowse in frame fSelectPersistentTempTable.
    browse brPersistentTempTableBrowse:select-focused-row().
    return no-apply.
  end. /* on cursor-down of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on u1 of brPersistentProcedureBrowse in frame fSelectPersistentTempTable
  do:
    
    define variable i                    as integer   no-undo.
    define variable cFilterEntry         as character no-undo.
    define variable cPrepProcedureFilter as character no-undo.
    define variable cPrepTableFilter     as character no-undo.
    
    assign
      cProcedureFilter = input frame fSelectPersistentTempTable cProcedureFilter
      cTableFilter     = input frame fSelectPersistentTempTable cTableFilter
      .
    
    do i = 1 to num-entries(cProcedureFilter):
      
      assign
        cFilterEntry          = entry(i, cProcedureFilter).
        cPrepProcedureFilter  = substitute('&1,&2':U,
                                           cPrepProcedureFilter,
                                           qg_cFilterEntryMatchcode(cFilterEntry))
        .
      
    end. /* do i = 1 to num-entries(cProcedureFilter) */
    
    cPrepProcedureFilter = (if cPrepProcedureFilter = '':U then
                              '*':U
                            else
                              trim(cPrepProcedureFilter, ',':U)).

    do i = 1 to num-entries(cTableFilter):
      
      assign
        cFilterEntry      = entry(i, cTableFilter).
        cPrepTableFilter  = substitute('&1,&2':U,
                                       cPrepTableFilter,
                                       qg_cFilterEntryMatchcode(cFilterEntry))
        .
      
    end. /* do i = 1 to num-entries(cTableFilter) */
    
    cPrepTableFilter = (if cPrepTableFilter = '':U then
                          '*':U
                        else
                          trim(cPrepTableFilter, ',':U)).
    
    for each bttPersistentProcedure,
    first bttFilterMatch
      where bttFilterMatch.FilterId    = iFilterId
        and bttFilterMatch.RecordRowId = rowid(bttPersistentProcedure)
      on error undo, throw:
      
      bttFilterMatch.RecordMatches = can-do(cPrepProcedureFilter, bttPersistentProcedure.ProcedureName).
      
      if bttFilterMatch.RecordMatches then
      do:
        
        do i = 1 to num-entries(cPrepTableFilter):
          
          assign
            cFilterEntry                 = entry(i, cPrepTableFilter)
            bttFilterMatch.RecordMatches = can-find(first ttPersistentTempTable
                                                      where ttPersistentTempTable.ProcedureName   = bttPersistentProcedure.ProcedureName
                                                        and ttPersistentTempTable.TableName matches cFilterEntry)
            .
          
          if bttFilterMatch.RecordMatches then
            leave.
          
        end. /* do i = 1 to num-entries(cPrepTableFilter) */
        
      end. /* if bttFilterMatch.RecordMatches */
      
    end. /* for each bttPersistentProcedure */
    
    open query brPersistentProcedureBrowse
      for each bttPersistentProcedure,
      first bttFilterMatch
        where bttFilterMatch.FilterId      = iFilterId
          and bttFilterMatch.RecordRowId   = rowid(bttPersistentProcedure)
          and bttFilterMatch.RecordMatches = yes
          no-lock.
    
    apply 'value-changed':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.
    
  end. /* on value-changed of cProcedureFilter in frame fSelectPersistentTempTable */
  
  on value-changed of cProcedureFilter in frame fSelectPersistentTempTable
    apply 'u1':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.
  
  on choose of btnClearProcedureFilter in frame fSelectPersistentTempTable
  do:
    
    display unless-hidden
      '':U @ cProcedureFilter
      with frame fSelectPersistentTempTable.
    
    apply 'value-changed':U to cProcedureFilter in frame fSelectPersistentTempTable.
    
  end. /* on value-changed of btnClearProcedureFilter in frame fSelectPersistentTempTable */
  
  on value-changed of cTableFilter in frame fSelectPersistentTempTable
    apply 'u1':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.

  on choose of btnClearTableFilter in frame fSelectPersistentTempTable
  do:
    
    display unless-hidden
      '':U @ cTableFilter
      with frame fSelectPersistentTempTable.
    
    apply 'value-changed':U to cTableFilter in frame fSelectPersistentTempTable.
    
  end. /* on value-changed of btnClearTableFilter in frame fSelectPersistentTempTable */
  
  on value-changed of brPersistentProcedureBrowse in frame fSelectPersistentTempTable
  do:
    
    define variable i                as integer   no-undo.
    define variable cFilterEntry     as character no-undo.
    define variable cPrepTableFilter as character no-undo.

    define buffer b2ttPersistentTempTable for temp-table ttPersistentTempTable.

    open query brPersistentTempTableBrowse
      for each bttPersistentTempTable
        where bttPersistentTempTable.ProcedureName = bttPersistentProcedure.ProcedureName
        no-lock
        use-index TableName.
    
    if available bttPersistentProcedure then
    do:
      
      cTableFilter = input frame fSelectPersistentTempTable cTableFilter.
      
      do i = 1 to num-entries(cTableFilter):
        
        assign
          cFilterEntry      = entry(i, cTableFilter).
          cPrepTableFilter  = substitute('&1,&2':U,
                                         cPrepTableFilter,
                                         qg_cFilterEntryMatchcode(cFilterEntry))
          .
        
      end. /* do i = 1 to num-entries(cTableFilter) */
      
      cPrepTableFilter = (if cPrepTableFilter = '':U then
                            '*':U
                          else
                            trim(cPrepTableFilter, ',':U)).
      
      for each b2ttPersistentTempTable
        where b2ttPersistentTempTable.ProcedureName = bttPersistentProcedure.ProcedureName
        use-index TableName
        on error undo, throw:
        
        if can-do(cPrepTableFilter, b2ttPersistentTempTable.TableName) then
        do:
          
          reposition brPersistentTempTableBrowse to rowid rowid(b2ttPersistentTempTable) no-error.
          leave.
          
        end. /* if can-do(cPrepTableFilter, ttPersistentTempTable.TableName) */
        
      end. /* for each b2ttPersistentTempTable */
      
    end. /* if available bttPersistentProcedure */
    
  end. /* on value-changed of brPersistentProcedureBrowse in frame fSelectPersistentTempTable */
  
  on default-action of brPersistentTempTableBrowse in frame fSelectPersistentTempTable
    apply 'go':U to frame fSelectPersistentTempTable.
  
  /* Create list of all available temp-tables. */
  
  empty temp-table ttPersistentProcedure.
  empty temp-table ttPersistentTempTable.
  
  iFilterId = qg_iFilterSeq().
  
  &IF proversion >= '11.2':U &THEN
    
    do i = 1 to Progress.Database.TempTableInfo:TempTableCount:
      
      /* Sometimes this invocation fails with an progress runtime error         */
      /* "Invalid value specified for Progress.Database.TempTableInfo:          */
      /* GetTableInfoByPosition (15246)" even though we queried TempTableCount  */
      /* just one line above. To avoid that we call GetTableInfoByPosition with */
      /* no-error and continue with the next entry in case of an error.         */
      
      Progress.Database.TempTableInfo:GetTableInfoByPosition
        (i, output hTempTable, output cProcedureName) no-error.
      
      if error-status:error then
        next.
      
      /* Ignore before tables. */
      
      if valid-handle(hTempTable:after-table) then
        next.
      
      /* Add procedure entry if needed. */
      
      if not can-find(first ttPersistentProcedure
                        where ttPersistentProcedure.ProcedureName = cProcedureName) then
      do:
        
        create bttPersistentProcedure.
        
        bttPersistentProcedure.ProcedureName = cProcedureName.
        
        validate bttPersistentProcedure.
        
        create bttFilterMatch.
        
        assign
          bttFilterMatch.FilterId      = iFilterId
          bttFilterMatch.RecordRowId   = rowid(bttPersistentProcedure)
          bttFilterMatch.RecordMatches = yes
          .
        
        validate bttFilterMatch.
        
      end. /* if not can-find(first ttPersistentProcedure */
      
      /* Add table entry. */
      
      if not can-find(first bttPersistentTempTable
                        where bttPersistentTempTable.ProcedureName = cProcedureName
                          and bttPersistentTempTable.TableHandle   = hTempTable) then
      do:
        
        create bttPersistentTempTable.
        
        assign
          bttPersistentTempTable.ProcedureName = cProcedureName
          bttPersistentTempTable.TableHandle   = hTempTable
          bttPersistentTempTable.TableName     = hTempTable:name
          .
        
      end. /* if not can-find(first bttPersistentTempTable */
      
    end. /* do i = 1 to Progress.Database.TempTableInfo:TempTableCount */
    
  &ENDIF
  
  run qg_InitBrowse(browse brPersistentProcedureBrowse:handle).
  run qg_InitBrowse(browse brPersistentTempTableBrowse:handle).
  
  display unless-hidden
    brPersistentProcedureBrowse
    with frame fSelectPersistentTempTable
      in window {&WINDOW-NAME}. 
  
  apply 'u1':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.
  
  if gcPersitentTTProcedure > '':U then
  do:
    
    find bttPersistentProcedure
      where bttPersistentProcedure.ProcedureName = gcPersitentTTProcedure
      no-error.
    
    if available bttPersistentProcedure then
      reposition brPersistentProcedureBrowse to rowid rowid(bttPersistentProcedure) no-error.
    
  end. /* if gcPersitentTTProcedure > '':U */
  
  apply 'value-changed':U to brPersistentProcedureBrowse in frame fSelectPersistentTempTable.
  
  update unless-hidden
    cProcedureFilter
    btnClearProcedureFilter
    cTableFilter
    btnClearTableFilter
    brPersistentProcedureBrowse
    brPersistentTempTableBrowse
    btnOk
    btnCancel
    with frame fSelectPersistentTempTable
      in window {&WINDOW-NAME}. 
  
  if available bttPersistentTempTable then
  do:
    
    gcPersitentTTProcedure = bttPersistentTempTable.ProcedureName.
    
    run qg_AddTableHandle(bttPersistentTempTable.TableHandle,
                          bttPersistentTempTable.TableHandle,
                          no,
                          {&K_PERSISTENT_TT_DBNAME},
                          {&K_PERSISTENT_TT_PHYSICALNAME}).
    
    if menu-item mi_OpenQueryWindowPersistentTT:checked in menu m_Options then
    do:
      
      cParamList = qg_cParamListWriteLogical(cParamList,
                                             'FocusQueryText':U,
                                             yes,
                                             {&K_PARAM_SPLITTER}).
      
      run qg_ExecQuery({&K_QUERY_WINDOW_MODE_QUERY},
                       {&K_QUERY_SIZE_MODE_DEFAULT},
                       substitute('&1.&2':U,
                                  {&K_PERSISTENT_TT_DBNAME},
                                  bttPersistentTempTable.TableHandle:name),
                       substitute('for each &1':U,
                                  bttPersistentTempTable.TableHandle:name),
                       no,  /* Init mode */
                       cParamList,
                       input-output iQuerySeq).
      
    end. /* if menu-item mi_OpenQueryWindowPersistentTT:checked in menu m_Options */
    
  end. /* if available ttPersistentTempTable */
  
  finally:
    
    if iFilterId > 0 then
    do:
    
      for each bttFilterMatch
        where bttFilterMatch.FilterId = iFilterId
        on error undo, throw:
        
        delete bttFilterMatch.
        
      end. /* for each bttFilterMatch */
      
    end. /* if iFilterId > 0 */
    
  end finally.
  
&ENDIF

end procedure. /* qg_AddPersistentTempTable */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddQueryWindowViewLine hQueryWindow 
PROCEDURE qg_AddQueryWindowViewLine :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define parameter buffer pbttQueryWindow for temp-table ttQueryWindow.

define input parameter piRoot         as integer   no-undo.
define input parameter phParentWindow as handle    no-undo.
define input parameter piDepth        as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer       as handle    no-undo.
define variable cDatabaseName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow     for temp-table ttQueryWindow.
define buffer bttQueryLink       for temp-table ttQueryLink.
define buffer bttQueryWindowView for temp-table ttQueryWindowView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(pbttQueryWindow.QueryHandle) then
do:
  
  hBuffer = pbttQueryWindow.QueryHandle:get-buffer-handle(1) no-error.
  
  if valid-handle(hBuffer) then
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
  
end. /* if valid-handle(pbttQueryWindow.QueryHandle) */

find first bttQueryWindowView
  where bttQueryWindowView.ParentWindowHandle = phParentWindow
    and bttQueryWindowView.WindowHandle       = pbttQueryWindow.WindowHandle
  no-error.

if not available bttQueryWindowView then
do:
  
  create bttQueryWindowView.
  
  assign
    bttQueryWindowView.WindowHandle       = pbttQueryWindow.WindowHandle
    bttQueryWindowView.ParentWindowHandle = phParentWindow
    .
  
end. /* if not can-find(first bttQueryWindowView */

assign
  ghQueryWindowListWindowSeq    = ghQueryWindowListWindowSeq + 1
  bttQueryWindowView.Id         = ghQueryWindowListWindowSeq
  bttQueryWindowView.Root       = (if piRoot = ? then
                                     bttQueryWindowView.Id
                                   else
                                     piRoot)
  bttQueryWindowView.WindowMode = pbttQueryWindow.WindowMode
  bttQueryWindowView.Depth      = piDepth
  bttQueryWindowView.LineText   = substitute('[&1] &2':U,
                                             string(pbttQueryWindow.QuerySeq),
                                             (if valid-handle(hBuffer) then
                                                substitute('&1.&2':U,
                                                           cDatabaseName,
                                                           hBuffer:name)
                                              else
                                                'unknown':U))
  .

validate bttQueryWindowView.

for each bttQueryLink
  where bttQueryLink.SourceSeq = pbttQueryWindow.QuerySeq,
first bttQueryWindow
  where bttQueryWindow.QuerySeq = bttQueryLink.TargetSeq
  break by bttQueryLink.TargetSeq
  on error undo, throw:
  
  if first-of(bttQueryLink.TargetSeq) then
    run qg_AddQueryWindowViewLine(buffer bttQueryWindow,
                                  bttQueryWindowView.Root,
                                  pbttQueryWindow.WindowHandle,
                                  piDepth + 1).
  
end. /* for each bttQueryLink */

end procedure. /* qg_AddQueryWindowViewLine */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddRecentQuery hQueryWindow 
PROCEDURE qg_AddRecentQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Creeate a new menu item for the current query to the recent queries sub-   */
/* menu.                                                                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.
define buffer bttRecentQuery for temp-table ttRecentQuery.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

assign
  cQueryText         = bttQueryWindow.QueryText
  giRecentQueriesSeq = giRecentQueriesSeq + 1
  .

find first bttRecentQuery
  where bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
    and bttRecentQuery.QueryText    = cQueryText
  no-error.

if available bttRecentQuery then
  bttRecentQuery.Order = giRecentQueriesSeq.

else
do:
  
  create bttRecentQuery.
  
  assign
    bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
    bttRecentQuery.QueryText    = cQueryText
    bttRecentQuery.Order        = giRecentQueriesSeq
    bttRecentQuery.QueryLabel   = qg_cQueryLabel(cQueryText)
    .
  
end. /* if not can-find(first ttRecentQuery */

end procedure. /* qg_AddRecentQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddSessionTrigger hQueryWindow 
PROCEDURE qg_AddSessionTrigger :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add session trigger for given event and table/field.                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTriggerEvent                 = Trigger event that should be added.       */
/* pcDatabaseName                 = Database of table for trigger event.      */
/* pcTableName                    = Table for trigger event.                  */
/* pcFieldName                    = Field for trigger event.                  */
/* plActivate                     = Activate session trigger.                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcTriggerEvent as character no-undo.
define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.
define input parameter pcFieldName    as character no-undo.
define input parameter plActivate     as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTriggerFileName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if pcFieldName = ? then
  pcFieldName = '':U.

/* Every session trigger may be defined only once. */

if can-find(first ttSessionTrigger
              where ttSessionTrigger.TriggerEvent = pcTriggerEvent
                and ttSessionTrigger.DatabaseName = pcDatabaseName
                and ttSessionTrigger.TableName    = pcTableName
                and ttSessionTrigger.FieldName    = pcFieldName) then
  leave.

/* Get next free filename. */

do while yes:

  assign
    giSessionTriggerSeq = giSessionTriggerSeq + 1.
    cTriggerFileName    = substitute(qg_cFileName('%Temp%/qg_SessionTrigger_&1.p':U),
                                     string(giSessionTriggerSeq)).
    file-info:file-name = cTriggerFileName
    .
  
  if file-info:full-pathname = ? then
    leave.
  
end. /* do while yes */

create bttSessionTrigger.

assign
  bttSessionTrigger.Id              = giSessionTriggerSeq
  bttSessionTrigger.TriggerEvent    = pcTriggerEvent
  bttSessionTrigger.DatabaseName    = pcDatabaseName
  bttSessionTrigger.TableName       = pcTableName
  bttSessionTrigger.FieldName       = pcFieldName
  bttSessionTrigger.TriggerFileName = cTriggerFileName
  bttSessionTrigger.LogfileName     = '<default>':U
  .

validate bttSessionTrigger.

if not plActivate then
  
  run qg_WriteSessionTriggerProc(bttSessionTrigger.Id).

else
do:
  
assign
  bttSessionTrigger.ProcedureHandle = qg_hStartSessionTrigger(bttSessionTrigger.Id)
  bttSessionTrigger.TriggerActive   = valid-handle(bttSessionTrigger.ProcedureHandle)
  .

validate bttSessionTrigger.

end. /* else: if not plActivate */

if valid-handle(ghSessionTriggersWindow) then
do:

  run qg_SessionTriggersOpenQuery.
  
  ghSessionTriggersBrowse:query:reposition-to-rowid(rowid(bttSessionTrigger)).
  
end. /* if valid-handle(ghSessionTriggerWindow) */

end procedure. /* qg_AddSessionTrigger */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddSnapshot hQueryWindow 
PROCEDURE qg_AddSnapshot :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add snapshot for given database object (table, temp-table or dataset).     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phDBObject                     = Database object for that the snapshot     */
/*                                  should be added.                          */
/* pcSnapshotName                 = Name for the snapshot. For tables or      */
/*                                  temp-tables this will be the name of the  */
/*                                  temp-table clone. For datasets this will  */
/*                                  the database name.                        */
/* pcWhere                        = Where condition for the records that      */
/*                                  should be copied (not used for datasets). */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phDBObject     as handle    no-undo.
define input parameter pcSnapshotName as character no-undo.
define input parameter pcWhere        as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTimestamp            as character no-undo.
define variable cSnapshotName         as character no-undo.
define variable iNumReplacements      as integer   no-undo.
define variable cStatusText           as character no-undo.

define variable i                     as integer   no-undo.
define variable hDBObject             as handle    no-undo.
define variable hTable                as handle    no-undo.

define variable cParamList            as character no-undo.

define variable iQuerySeq             as integer   no-undo initial ?.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phDBObject) then
  leave.

cTimestamp = replace(string(time, 'HH:MM:SS':U),
                     ':':U,
                     '':U).

run qg_SubstituteChar(pcSnapshotName,
                      '#':U,
                      cTimestamp,
                      output cSnapshotName,
                      output iNumReplacements).

if phDBObject:type = 'DATASET':U then
do:
  
  if iNumReplacements > 0 then
  do:
    
    i = 0.
    
    do while can-find(first ttDatabase
                        where ttDatabase.DatabaseName = cSnapshotName):
      
      i = i + 1.
      
      run qg_SubstituteChar(pcSnapshotName,
                            '#':U,
                            substitute('&1-&2':U, cTimestamp, string(i)),
                            output cSnapshotName,
                            output iNumReplacements).
      
    end. /* do while can-find(first ttDatabase */
    
  end. /* if iNumReplacements > 0 */
  
  do i = 1 to phDBObject:num-buffers:
    
    hDBObject = phDBObject:get-buffer-handle(i).
    
    cStatusText = substitute('Adding snapshot &2 / &3':T,
                             cSnapshotName,
                             hDBObject:name).
    
    /* Create temp-table like parameter table. */
    
    run qg_CreateTableClone(hDBObject,
                            hDBObject:name,
                            ?,
                            cStatusText,
                            output hTable).
    
    /* Add snapshot. */
    
    run qg_AddTableHandle(hTable,
                          hDBObject,
                          yes,
                          cSnapshotName,
                          {&K_SNAPSHOT_PHYSICALNAME}).

    
  end. /* do i = 1 to phDBObject:num-buffers */
  
  run qg_AddDatasetRelations( cSnapshotName, phDBObject ).
  
end. /* if phDBObject:type = 'DATASET':U */

else
do:
  
  if iNumReplacements > 0 then
  do:
    
    i = 0.
    
    do while can-find(first ttTable
                        where ttTable.DatabaseName = {&K_SNAPSHOT_DBNAME}
                          and ttTable.TableName    = cSnapshotName):
        
        i = i + 1.
        
        run qg_SubstituteChar(pcSnapshotName,
                              '#':U,
                              substitute('&1-&2':U, cTimestamp, string(i)),
                              output cSnapshotName,
                              output iNumReplacements).
      
    end. /* do while can-find(first ttTable */
    
  end. /* if iNumReplacements > 0 */
  
  cStatusText = substitute('Adding snapshot &1':T, cSnapshotName).
  
  /* Create temp-table like parameter table. */
  
  run qg_CreateTableClone(phDBObject,
                          cSnapshotName,
                          pcWhere,
                          cStatusText,
                          output hTable).
  
  /* Add snapshot. */
  
  run qg_AddTableHandle(hTable,
                        phDBObject,
                        yes,
                        {&K_SNAPSHOT_DBNAME},
                        {&K_SNAPSHOT_PHYSICALNAME}).
  
  if menu-item mi_OpenQueryWindowSnapshotTT:checked in menu m_Options then
  do:
    
    cParamList = qg_cParamListWriteLogical(cParamList,
                                           'FocusQueryText':U,
                                           yes,
                                           {&K_PARAM_SPLITTER}).
    
    run qg_ExecQuery({&K_QUERY_WINDOW_MODE_QUERY},
                     {&K_QUERY_SIZE_MODE_DEFAULT},
                     substitute('&1.&2':U, {&K_SNAPSHOT_DBNAME}, cSnapshotName),
                     substitute('for each &1':U, cSnapshotName),
                     no,  /* Init mode */
                     cParamList,
                     input-output iQuerySeq).
    
  end. /* if menu-item mi_OpenQueryWindowSnapshotTT:checked in menu m_Options */
  
end. /* else: if phDBObject:type = 'DATASET':U */

finally:
  
  hide frame fStatus.
  
end finally.

end procedure. /* qg_AddSnapshot */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddSnapshotLine hQueryWindow 
PROCEDURE qg_AddSnapshotLine :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add snapshot line for given buffer to given snapshot.                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer                       = Buffer handle of the record that should   */
/*                                  be added.                                 */
/* pcSnapshotName                 = Name of the snapshot to which the record  */
/*                                  should be added.                          */
/* plUpdate                       = If yes then an existing snapshot record   */
/*                                  will be updated. Otherwise if a record    */
/*                                  is already present it will not be added   */
/*                                  or updated.                               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBuffer       as handle    no-undo.
define input parameter pcSnapshotName as character no-undo.
define input parameter plUpdate       as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                as integer   no-undo.
define variable cTimestamp       as character no-undo.
define variable cSnapshotName    as character no-undo.
define variable iNumReplacements as integer   no-undo.

define variable hTable        as handle    no-undo.
define variable hTargetBuffer as handle    no-undo.

define variable cQueryText    as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable      for temp-table ttTable.
define buffer bttIndex      for temp-table ttIndex.
define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   not valid-handle(phBuffer)
  or not can-query(phBuffer, 'type':U)
  or phBuffer:type <> 'BUFFER':U then
do:
  
  message
    'Invalid handle in qgEvt_SnapshotLine event':T
    view-as alert-box
    error
    buttons ok
    in window hQueryWindow.
  
  leave.
  
end. /* if   not valid-handle(phBuffer) */

if not phBuffer:available then
  leave.

cTimestamp = replace(string(time, 'HH:MM:SS':U),
                     ':':U,
                     '':U).

run qg_SubstituteChar(pcSnapshotName,
                      '#':U,
                      cTimestamp,
                      output cSnapshotName,
                      output iNumReplacements).

if iNumReplacements > 0 then
do:
  
  i = 0.
  
  do while can-find(first ttTable
                      where ttTable.DatabaseName = {&K_SNAPSHOT_DBNAME}
                        and ttTable.TableName    = cSnapshotName):
      
      i = i + 1.
      
      run qg_SubstituteChar(pcSnapshotName,
                            '#':U,
                            substitute('&1-&2':U, cTimestamp, string(i)),
                            output cSnapshotName,
                            output iNumReplacements).
    
  end. /* do while can-find(first ttTable */
  
end. /* if iNumReplacements > 0 */

find bttTable
  where bttTable.DatabaseName = {&K_SNAPSHOT_DBNAME}
    and bttTable.TableName    = cSnapshotName
  no-error.

if available bttTable then
do:
  
  if not bttTable.Snapshot then
  do:
    
    message
      substitute('Table ~'&1~' is not a Snapshot':T) skip
      view-as alert-box
      error
      buttons ok
      in window hQueryWindow.
    
    leave.
    
  end. /* if not bttTable.Snapshot */
  
  if valid-handle(bttTable.TableHandle) then
    hTable = bttTable.TableHandle.
  
  else
    run qg_RemoveTable(bttTable.DatabaseName,
                       bttTable.TableName).
  
end. /* if available bttTable */

if not valid-handle(hTable) then
do:
  
  /* Create temp-table like parameter table. */
  
  create temp-table hTable in widget-pool qg_cTTWidgetPool().
  hTable:create-like(phBuffer).
  hTable:temp-table-prepare(cSnapshotName).
  
  run qg_AddTableHandle(hTable,
                        phBuffer,
                        yes,
                        {&K_SNAPSHOT_DBNAME},
                        {&K_SNAPSHOT_PHYSICALNAME}).
  
end. /* if not valid-handle(hTable) */

create buffer hTargetBuffer for table hTable.

/* Check if the record already exists */

if plUpdate then
  for each bttIndex
    where bttIndex.DatabaseName = {&K_SNAPSHOT_DBNAME}
      and bttIndex.TableName    = hTable:name
      and bttIndex.IsUnique     = yes
    no-lock
    on error undo, throw:
    
    cQueryText = '':U.
    
    for each bttIndexField
      where bttIndexField.DatabaseName = bttIndex.DatabaseName
        and bttIndexField.TableName    = bttIndex.TableName
        and bttIndexField.IndexName    = bttIndex.IndexName
      no-lock
      on error undo, throw:
      
      cQueryText = substitute('&1~n&2 &3.&4 = &5':U,
                              cQueryText,
                              (if cQueryText = '':U then
                                 'where':U
                               else
                                 'and':U),
                              hTargetBuffer:name,
                              bttIndexField.FieldName,
                              quoter(phBuffer:buffer-field(bttIndexField.FieldName):buffer-value)).
      
    end. /* for each bttIndexField */
    
    hTargetBuffer:find-first(cQueryText, no-lock) no-error.
    
    if hTargetBuffer:available then
      leave.
    
  end. /* for each bttIndex */

if not hTargetBuffer:available then
  hTargetBuffer:buffer-create().
  
do on error undo, throw:

  hTargetBuffer:buffer-copy(phBuffer).
  hTargetBuffer:buffer-validate().
  
  catch oError as class progress.lang.error:
    
    /* If the buffer-copy failed (most likely because the record already      */
    /* exists) then the newly created record has to bedeleted.                */
    
    if    valid-handle(hTargetBuffer)
      and hTargetBuffer:available
      and hTargetBuffer:new then
      hTargetBuffer:buffer-delete().
    
  end catch.

end.

finally:
  
  if valid-handle(hTargetBuffer) then
    delete object hTargetBuffer.
  
end finally.

end procedure. /* qg_AddSnapshotLine */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddTableHandle hQueryWindow 
PROCEDURE qg_AddTableHandle :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create a temp-table like given table/buffer handle, copy all its contents  */
/* and add its schema information to the cache.                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phTable                        = Table for wich a snapshot should be cre-  */
/*                                  ated.                                     */
/* pcDatabaseName                 = Database name for the table.              */
/* pcPhysicalName                 = Physical name for the table.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phTable         as handle    no-undo.
define input parameter phOriginalTable as handle    no-undo.
define input parameter plSnapshot      as logical   no-undo.
define input parameter pcDatabaseName  as character no-undo.
define input parameter pcPhysicalName  as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer    as handle    no-undo.
define variable hField     as handle    no-undo.

define variable i          as integer   no-undo.
define variable j          as integer   no-undo.

define variable cIndexInfo as character no-undo.

define variable lNewDB     as logical   no-undo.
define variable rCurrentDB as rowid     no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase   for temp-table ttDatabase.
define buffer bttTable      for temp-table ttTable.
define buffer bttField      for temp-table ttField.
define buffer bttIndex      for temp-table ttIndex.
define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phTable) then
  leave.

/* Add database. */

find bttDatabase
  where bttDatabase.DatabaseName = pcDatabaseName
  no-error.

if not available bttDatabase then
do:
  
  lNewDB = yes.
  
  create bttDatabase.
  
  assign
    bttDatabase.DatabaseName    = pcDatabaseName
    bttDatabase.PhysicalName    = pcPhysicalName
    bttDatabase.DirectoryName   = '':U
    bttDatabase.TempDB          = yes
    bttDatabase.BasisDB         = no
    bttDatabase.BasisDBName     = '':U
    bttDatabase.PhysicalDB      = no
    .
  
  case bttDatabase.DatabaseName:
    
    when {&K_PERSISTENT_TT_DBNAME} then
      bttDatabase.DisplayPriority = 2000.
    
    when {&K_SNAPSHOT_DBNAME} then
      bttDatabase.DisplayPriority = 3000.
    
    otherwise 
      bttDatabase.DisplayPriority = 4000.
    
  end case. /* bttDatabase.DatabaseName */
  
  validate bttDatabase.
  
end. /* if not available bttDatabase */

phTable:private-data = qg_cParamListWriteCharacter(phTable:private-data,
                                                   'DatabaseName':U,
                                                   pcDatabaseName,
                                                   ',':U).

/* Add table. */

find bttTable
  where bttTable.DatabaseName = bttDatabase.DatabaseName
    and bttTable.TableName    = phTable:name
  no-error.

if available bttTable then
  run qg_RemoveTable(bttTable.DatabaseName,
                     bttTable.TableName).

create bttTable.

assign
  bttTable.DatabaseName        = bttDatabase.DatabaseName
  bttTable.TableName           = phTable:name
  bttTable.DetailsLoaded       = yes
  bttTable.PhysicalTable       = no
  bttTable.TableHandle         = phTable
  bttTable.OriginalTableHandle = phOriginalTable
  bttTable.Snapshot            = plSnapshot
  .

validate bttTable.

hBuffer = phTable:default-buffer-handle.

/* Add fields. */
do i = 1 to hBuffer:num-fields:
  
  hField = hBuffer:buffer-field(i).
  
  create bttField.
  
  assign
    bttField.DatabaseName      = bttTable.DatabaseName
    bttField.TableName         = bttTable.TableName
    bttField.FieldName         = hField:name
    bttField.DataType          = substitute('&1&2':U,
                                            caps(substring(hField:data-type, 1, 1)),
                                            lc(substring(hField:data-type, 2)))
    bttField.FieldFormat       = hField:format
    bttField.FieldExtent       = hField:extent
    bttField.FieldDecimals     = (if bttField.DataType = 'DECIMAL':U then
                                    hField:decimals
                                  else
                                    ?)
    bttField.FieldInitialValue = trim(hField:initial)
    bttField.FieldLabel        = hField:label
    bttField.FieldColumnLabel  = hField:column-label
    bttField.IsMandatory       = hField:mandatory
    bttField.FieldViewAs       = hField:view-as
    bttField.IsObjectId        = (bttField.FieldName matches '*_Obj':U)
    .
  
  validate bttField.
  
end. /* do i = 1 to hBuffer:num-fields */

/* Add Indices. */
i = 1.

do while hBuffer:index-information(i) <> ?:

  cIndexInfo = hBuffer:index-information(i).
  
  create bttIndex.
  
  assign
    bttIndex.DatabaseName = bttTable.DatabaseName
    bttIndex.TableName    = bttTable.TableName
    bttIndex.IndexName    = entry(1, cIndexInfo)
    bttIndex.IsUnique     = logical(entry(2, cIndexInfo), '1/0':U)
    bttIndex.IsPrimary    = logical(entry(3, cIndexInfo), '1/0':U)
    .
  
  validate bttIndex.
  
  /* Add index fields. */
  
  do j = 5 to num-entries(cIndexInfo) by 2:
    
    if entry(j, cIndexInfo) = '':U then
      next.
    
    create bttIndexField.
    
    assign
      bttIndexField.DatabaseName  = bttIndex.DatabaseName
      bttIndexField.TableName     = bttIndex.TableName
      bttIndexField.IndexName     = bttIndex.IndexName
      bttIndexField.IndexSequence = j - 5
      bttIndexField.FieldName     = entry(j, cIndexInfo)
      bttIndexField.SortAscending = logical(entry(j + 1, cIndexInfo), '0/1':U)
      .  
    
    validate bttIndexField.
    
    assign
      bttIndex.IndexFieldList = substitute( '&1,&2':U,
                                            bttIndex.IndexFieldList,
                                            bttIndexField.FieldName )
      bttIndex.IndexFields    = substitute( '&1 &2&3':U,
                                            bttIndex.IndexFields,
                                            string( bttIndexField.SortAscending, '+/-':U ),
                                            bttIndexField.FieldName )
      .
    
    validate bttIndex.
    
  end. /* do iFieldCounter = 5 to num-entries(cIndexInfo) by 2 */
  
  assign
    bttIndex.IndexFieldList = trim(bttIndex.IndexFieldList, ',':U)
    bttIndex.IndexFields    = trim(bttIndex.IndexFields)
    .
  
  validate bttIndex.
  
  i = i + 1.

end. /* do while phBuffer:index-information(i) <> ? */

/* Refresh and reposition database and table browse. */

if lNewDB then
do:

  rCurrentDB = rowid(ttDatabase).

  {&OPEN-QUERY-brDatabase}

  if rCurrentDB <> ? then
    reposition brDatabase to rowid rCurrentDB no-error.
  
end. /* if lNewDB */

if    available ttDatabase
  and ttDatabase.DatabaseName = pcDatabaseName then
  apply 'value-changed':U to browse brDatabase.

process events.

end procedure. /* qg_AddTableHandle */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddTableSnapshot hQueryWindow 
PROCEDURE qg_AddTableSnapshot :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Shows a snapshot name dialog and creates the snapshot.                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer                       = Buffer handle of the table for which a    */
/*                                  Snapshot should be created.               */
/* pcWhere                        = Where condition for the records that      */
/*                                  should be copied.                         */
/* phParentWindow                 = Parent window for the dialog.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBuffer       as handle    no-undo.
define input parameter pcWhere        as character no-undo.
define input parameter phParentWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cSnapshotName as character no-undo
  format 'x(32)':U
  view-as fill-in
  size 65 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fSnapshot
    'Please enter snapshot name:':T view-as text size 45 by 1 at col 3 row 1.5
    cSnapshotName at row 2.5 col 3 no-label
    btnOk at row 4.5 col 16
    btnCancel at row 4.5 col 36
  with 1 down keep-tab-order overlay
    view-as dialog-box
    side-labels no-underline three-d 
    size 71 by 6.44
    title gcTitlePrefix + 'Add snapshot':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSnapshot
  apply 'end-error' to self.
  
cSnapshotName = substitute('&1_&2':U,
                           phBuffer:table,
                           replace(string(time, 'HH:MM:SS':U),
                                   ':':U,
                                   '':U)).

update unless-hidden
  cSnapshotName
  btnOk
  btnCancel
  with frame fSnapshot
    in window phParentWindow.

run qg_AddSnapshot(phBuffer,
                   cSnapshotName,
                   pcWhere).

end procedure. /* qg_AddTableSnapshot */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AddTableSnapshot hQueryWindow 
PROCEDURE qg_AdoptLinkValues :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phTargetBuffer as handle    no-undo.
define input parameter piTargetSeq    as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName as character no-undo.
define variable hSourceBuffer as handle    no-undo.

define variable iField        as integer   no-undo.
define variable hSourceField  as handle    no-undo.
define variable hTargetField  as handle    no-undo.
define variable iIndex        as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryLink          for temp-table ttQueryLink.
define buffer bttQueryWindow        for temp-table ttQueryWindow.
define buffer bttTableRelationField for temp-table ttTableRelationField.
define buffer bttTableRelationView  for temp-table ttTableRelationView.


/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cDatabaseName = qg_cDatabaseNameForTableOrBuffer( phTargetBuffer ).

for each bttQueryLink
  where bttQueryLink.TargetSeq = piTargetSeq
  break by bttQueryLink.SourceSeq descending
  on error undo, throw:
  
  if first-of( bttQueryLink.SourceSeq ) then
  do:
    
    find bttQueryWindow
      where bttQueryWindow.QuerySeq = bttQueryLink.SourceSeq
      no-error.
    
    if available bttQueryWindow then
    do:
      
      hSourceBuffer = bttQueryWindow.QueryHandle:get-buffer-handle( string( bttQueryLink.BufferName ) ).
      
      if    not valid-handle( hSourceBuffer )
         or not hSourceBuffer:available then
        next.
      
      /* Step one: copy fields that match by name. */
      
      do iField = 1 to phTargetBuffer:num-fields:
        
        assign
          hTargetField = phTargetBuffer:buffer-field( iField )
          hSourceField = hSourceBuffer:buffer-field( hTargetField:name )
          no-error.
        
        if    error-status:error
           or not valid-handle( hSourceField )
           or hSourceField:data-type <> hTargetField:data-type
           or hSourceField:extent    <> hTargetField:extent then
          next.
        
        if hTargetField:name = substitute( '&1_Obj':U, phTargetBuffer:table ) then
          next.
        
        if    can-do( {&K_COMPANY_FIELDS}, hTargetField:name )
          and hTargetField:extent    = 0
          and hTargetField:data-type = 'character':U then
          hTargetField:buffer-value = qg_cGetCompany( phTargetBuffer:table,
                                                      hSourceField:buffer-value ).
        
        else
        do iIndex = hSourceField:extent to integer( hSourceField:extent > 0 ):
          
          hTargetField:buffer-value( iIndex ) = hSourceField:buffer-value( iIndex ).
          
        end. /* do iIndex = hSourceField:extent to integer( hSourceField:extent > 0 ) */ 
        
      end. /* do iField = 1 to phTargetBuffer:num-fields */
      
      /* Step two: copy fields that match by relation. */
      
      for each bttTableRelationView
        where bttTableRelationView.DatabaseName       = cDatabaseName
          and bttTableRelationView.ReferenceTableName = phTargetBuffer:table
          and bttTableRelationView.RelatedTableName   = hSourceBuffer:table,
      each bttTableRelationField
        where bttTableRelationField.RelationId      = bttTableRelationView.RelationId
          and bttTableRelationField.ParentFieldName > '':U
          and bttTableRelationField.ChildFieldName  > '':U
        on error undo, throw:
        
        if bttTableRelationView.ReferenceTableName = hSourceBuffer:table then
          assign
            hSourceField = hSourceBuffer:buffer-field( bttTableRelationField.ChildFieldName )
            hTargetField = phTargetBuffer:buffer-field( bttTableRelationField.ParentFieldName )
            no-error.
        
        else
          assign
            hSourceField = hSourceBuffer:buffer-field( bttTableRelationField.ParentFieldName )
            hTargetField = phTargetBuffer:buffer-field( bttTableRelationField.ChildFieldName )
            no-error.
        
        if    valid-handle( hSourceField )
          and valid-handle( hTargetField ) then
        do iIndex = hSourceField:extent to integer( hSourceField:extent > 0 ):
          
          hTargetField:buffer-value( iIndex ) = hSourceField:buffer-value( iIndex ).
          
        end. /* do iIndex = hSourceField:extent to integer( hSourceField:extent > 0 ) */ 
        
      end. /* for each bttTableRelationView */
      
    end. /* if available bttQueryWindow */
    
  end. /* if first-of( bttQueryLink.SourceSeq ) */
  
end. /* for each bttQueryLink */

end procedure. /* qg_AdoptLinkValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_AdjustWidgetsSizeAndPos hQueryWindow 
PROCEDURE qg_AdjustWidgetsSizeAndPos :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Adjust widget size and position.                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWidget                       = Widget handle.                            */
/* pdWidthDelta                   = Width delta.                              */
/* pdHeightDelta                  = Height delta.                             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWidget      as handle    no-undo.
define input parameter pdWidthDelta  as decimal   no-undo.
define input parameter pdHeightDelta as decimal   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hChild            as handle    no-undo.

define variable dOriginalCol      as decimal   no-undo.
define variable dOriginalRow      as decimal   no-undo.
define variable dOriginalWidth    as decimal   no-undo.
define variable dOriginalHeight   as decimal   no-undo.

define variable dColFactor        as decimal   no-undo.
define variable dRowFactor        as decimal   no-undo.
define variable dWidthFactor      as decimal   no-undo.
define variable dHeightFactor     as decimal   no-undo.
define variable dMaxHeight        as decimal   no-undo.
define variable dMaxRow           as decimal   no-undo.

define variable lSlimModeWidget   as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if can-query(phWidget, 'private-data':U) then
do:
  
  assign
    dOriginalCol    = qg_dParamListReadValue(phWidget:private-data, 'OriginalCol':U, ',':U)
    dOriginalRow    = qg_dParamListReadValue(phWidget:private-data, 'OriginalRow':U, ',':U)
    dOriginalWidth  = qg_dParamListReadValue(phWidget:private-data, 'OriginalWidth':U, ',':U)
    dOriginalHeight = qg_dParamListReadValue(phWidget:private-data, 'OriginalHeight':U, ',':U)
    dColFactor      = qg_dParamListReadValue(phWidget:private-data, 'ColFactor':U, ',':U)
    dRowFactor      = qg_dParamListReadValue(phWidget:private-data, 'RowFactor':U, ',':U)
    dWidthFactor    = qg_dParamListReadValue(phWidget:private-data, 'WidthFactor':U, ',':U)
    dHeightFactor   = qg_dParamListReadValue(phWidget:private-data, 'HeightFactor':U, ',':U)
    dMaxHeight      = qg_dParamListReadValue(phWidget:private-data, 'MaxHeight':U, ',':U)
    dMaxRow         = qg_dParamListReadValue(phWidget:private-data, 'MaxRow':U, ',':U)
    .
  
  if glSlimMode then
  do:
    
    lSlimModeWidget = qg_lParamListReadValue(phWidget:private-data, 'SlimModeWidget':U, ',':U).
    
    if lSlimModeWidget then
      assign
        dColFactor   = dColFactor * 2
        dWidthFactor = dWidthFactor * 2
        .
    
    else
      if not phWidget:name = ? then
        assign
          dOriginalCol = 1
          dOriginalRow = 1
          dColFactor   = 0
          dRowFactor   = 0
          .
    
  end. /* if glSlimMode */
  
  /* Adjust widget size and position. */
  
  assign
    phWidget:col          = dOriginalCol + (pdWidthDelta * dColFactor)
        when can-set(phWidget, 'col':U)
    phWidget:row          = dOriginalRow + (pdHeightDelta * dRowFactor)
        when can-set(phWidget, 'row':U)
    phWidget:width-chars  = dOriginalWidth + (pdWidthDelta * dWidthFactor)
        when can-set(phWidget, 'width-chars':U)
    phWidget:height-chars = dOriginalHeight + (pdHeightDelta * dHeightFactor)
        when can-set(phWidget, 'height-chars':U)
    .
  
  if dMaxRow > 0 then
    phWidget:row = minimum(dMaxRow, phWidget:row).
  
  if dMaxHeight > 0 then
    phWidget:height-chars = minimum(dMaxHeight, phWidget:height-chars).
  
  /* Adjust side label position. */
  
  if    can-query(phWidget, 'side-label-handle':U)
    and valid-handle(phWidget:side-label-handle)
    and can-query(phWidget:side-label-handle, 'private-data':U) then
  do:
    
    assign
      dRowFactor                     = (if pdHeightDelta <> 0 then
                                          (phWidget:row - dOriginalRow) / pdHeightDelta
                                        else
                                          dRowFactor)
      dOriginalCol                   = qg_dParamListReadValue(phWidget:side-label-handle:private-data, 'OriginalCol':U, ',':U)
      dOriginalRow                   = qg_dParamListReadValue(phWidget:side-label-handle:private-data, 'OriginalRow':U, ',':U)
      phWidget:side-label-handle:col = dOriginalCol + (pdWidthDelta * dColFactor)
          when can-set(phWidget:side-label-handle, 'col':U)
      phWidget:side-label-handle:row = dOriginalRow + (pdHeightDelta * dRowFactor)
          when can-set(phWidget:side-label-handle, 'row':U)
      .
      
    end. /*  */
    
end. /* if can-query(phWidget, 'private-data':U) */
  
/* Adjust children size and position recursively. */

if    can-query(phWidget, 'first-child':U)
  and can-query(phWidget, 'next-sibling':U) then
do:
  
  hChild = phWidget:first-child.
  
  do while valid-handle(hChild):
    
    run qg_AdjustWidgetsSizeAndPos(hChild,
                                   pdWidthDelta,
                                   pdHeightDelta).
    
    hChild = hChild:next-sibling.
    
  end. /* do while valid-handle */
  
end. /* if    can-query(phWidget, 'first-child':U) */

assign
  phWidget:virtual-width-chars  = phWidget:width-chars
    when can-set(phWidget, 'virtual-width-chars':U)
  phWidget:virtual-height-chars = phWidget:height-chars
      when can-set(phWidget, 'virtual-height-chars':U)
  .

end procedure. /* qg_AdjustWidgetsSizeAndPos */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CloseInvalidQueryWindows hQueryWindow 
PROCEDURE qg_CloseInvalidQueryWindows :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Close all query windows without buffers (because its db has been dis-      */
/* connected or the temp-table has been deletetd).                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i       as integer   no-undo.
define variable hQuery  as handle    no-undo.
define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase    for temp-table ttDatabase.
define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryWindow
  on error undo, throw:
  
  hQuery = bttQueryWindow.QueryHandle.
  
  if   not valid-handle(hQuery)
    or hQuery:num-buffers = 0 then
    next.
  
  do i = 1 to hQuery:num-buffers:
    
    hBuffer = hQuery:get-buffer-handle(i).
    
    find bttDatabase
      where bttDatabase.DatabaseName = hBuffer:dbname
      no-error.
    
    if    available(bttDatabase)
      and bttDatabase.PhysicalDB
      and not can-find(first ttTable
                         where ttTable.DatabaseName = bttDatabase.DatabaseName) then
      run qg_AddTables(bttDatabase.DatabaseName).

    if    not can-find(first ttTable
                         where ttTable.DatabaseName = hBuffer:dbname
                           and ttTable.TableName    = hBuffer:table)
      and not can-find(first ttTable
                         where ttTable.TableHandle = hBuffer:table-handle) then
    do:
      
      run qg_QueryWindowClose(bttQueryWindow.WindowHandle, no).
      leave.
      
    end. /* if    not can-find(first ttTable ... */
    
  end. /* do i = 1 to hQuery:num-buffers */
  
end. /* for each bttQueryWindow */

end procedure. /* qg_CloseInvalidQueryWindows */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CloseWindow hQueryWindow 
PROCEDURE qg_CloseWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Close given window.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* This procedure is inteded to be used as a persistent trigger procedure     */
/* for dynamically created windows.                                           */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Window that should be closed.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(phWindow) then
  apply 'window-close':U to phWindow.

end procedure. /* qg_CloseWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CompareText hQueryWindow 
PROCEDURE qg_CompareText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcTitle1        as character no-undo.
define input parameter pclText1        as longchar  no-undo.

define input parameter pcTitle2        as character no-undo.
define input parameter pclText2        as longchar  no-undo.

define input parameter plCaseSensitive as logical   no-undo.
define input parameter plReadOnly      as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                as integer   no-undo.

define variable cCompFile1       as character no-undo.
define variable cCompFile2       as character no-undo.

define variable chTextComparison as com-handle no-undo.
define variable iMergeIgnoreCase as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(gchMerge) then
  leave.

do while yes:

  assign
    i          = i + 1
    cCompFile1 = qg_cFileName(substitute('%Temp%\qg_comp&1.1.txt':U, string(i)))
    cCompFile2 = qg_cFileName(substitute('%Temp%\qg_comp&1.2.txt':U, string(i)))
    .
  
  file-info:file-name = cCompFile1.
  
  if file-info:full-pathname <> ? then
    next.
  
  file-info:file-name = cCompFile2.
  
  if file-info:full-pathname <> ? then
    next.
  
  leave.
  
end. /* do while yes */

copy-lob pclText1 to file cCompFile1.
copy-lob pclText2 to file cCompFile2.

assign
  iMergeIgnoreCase = gchMerge:Preferences:longs:item('clIgnoreCase':U)
  gchMerge:Preferences:longs:item('clIgnoreCase':U) = integer(not plCaseSensitive)
  .

chTextComparison = gchMerge:TextComparison.

chTextComparison:compare(cCompFile1, cCompFile2).

assign
  chTextComparison:ReadOnly(0) = plReadOnly
  chTextComparison:ReadOnly(1) = plReadOnly
  .

if    pcTitle1 <> ?
  and pcTitle2 <> ? then
  chTextComparison:SetPanelTitles(pcTitle1, pcTitle2).

gchMerge:Preferences:longs:item('clIgnoreCase':U) = iMergeIgnoreCase.

chTextComparison:GiveUserControl().

gchMerge:visible = yes.
gchMerge:active = yes.

gchMerge:GiveUserControl().

finally:
  
  if valid-handle(chTextComparison) then
  do:
    
    release object chTextComparison.
    chTextComparison = ?.
    
  end. /* if valid-handle(chTextComparison) */
  
  if cCompFile1 > '':U then
    os-delete value(cCompFile1).
  
  if cCompFile2 > '':U then
    os-delete value(cCompFile2).
  
end finally.

end procedure. /* qg_CompareText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ConfirmRecordChanges hQueryWindow 
PROCEDURE qg_ConfirmRecordChanges :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show a confirmation dialog to confirm any changes to a record.             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTitle                        = Title string for the dialog.              */
/* pcText                         = Text to display on the dialog.            */
/* phOldBuffer                    = Buffer handle of the buffer before any    */
/*                                  changes.                                  */
/* phNewBuffer                    = Buffer handle of the buffer that contains */
/*                                  the changes.                              */
/* phParentWindow                 = Parent window to show the dialog.         */
/* oplOk                          = Output flag. True if the user clicked the */
/*                                  ok button - otherwise false.              */
/* oplDisableTriggers             = Output flag. True if the user chose to    */
/*                                  disable the triggers - otherwise false.   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter pcTitle             as character no-undo.
define input        parameter pcText              as character no-undo.
define input        parameter phOldBuffer         as handle    no-undo.
define input        parameter phNewBuffer         as handle    no-undo.
define input        parameter plCanEnableTriggers as logical   no-undo.
define input        parameter plRawValues         as logical   no-undo.
define input        parameter phParentWindow      as handle    no-undo.

define       output parameter oplOk               as logical   no-undo.
define input-output parameter ioplDisableTriggers as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                 as integer   no-undo.

define variable hOldField         as handle    no-undo.
define variable clOldFieldValue   as longchar  no-undo.
define variable hNewField         as handle    no-undo.
define variable clNewFieldValue   as longchar  no-undo.
define variable cFieldList        as character no-undo.
define variable cFieldName        as character no-undo.
define variable iIndex            as integer   no-undo.

define variable cText as character no-undo
  format 'x(150)':U
  view-as text
  size 156 by 1.

define query brRecordBrowse
  for ttQueryWindowFieldChanges
  scrolling.

define browse brRecordBrowse
  query brRecordBrowse no-lock
    display
      ttQueryWindowFieldChanges.DisplayName
      ttQueryWindowFieldChanges.OldDisplayValue
      ttQueryWindowFieldChanges.CurrentDisplayValue
      with no-assign size 156 by 18.

define variable lDisableTriggers as logical no-undo
  format 'yes/no':U
  label 'disable triggers':T
  view-as toggle-box
  size 50 by 1.

define rectangle reDisableTriggers
  no-fill
  edge-pixels 2
  graphic-edge
  size 156 by 2
  .

define button btnOk
  label 'Save':T4
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T6
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindowFieldChanges for temp-table ttQueryWindowFieldChanges.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fConfirmRecordChanges
  cText at row 1.5 col 3 no-label
  brRecordBrowse at row 3 col 3
  reDisableTriggers at row 21.5 col 3
  lDisableTriggers at row 22 col 5
  btnOk at row 24.5 col 61
  btnCancel at row 24.5 col 81
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 161 by 26.44
    title '':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fConfirmRecordChanges
  apply 'end-error' to self.

on t of frame fConfirmRecordChanges anywhere
do:
  
  if lDisableTriggers:sensitive then
    lDisableTriggers:checked = not lDisableTriggers:checked.
  
end. /* on t of frame fConfirmRecordChanges anywhere */

cFieldList = qg_cBufferCompare(phOldBuffer, phNewBuffer).

if num-entries(cFieldList) = 0 then
  leave.

empty temp-table ttQueryWindowFieldChanges.

do i = 1 to num-entries(cFieldList):
  
  assign
    cFieldName = qg_cExtractFieldName(entry(i, cFieldList))
    iIndex     = qg_iExtractIndex(entry(i, cFieldList))
    hOldField  = phOldBuffer:buffer-field(cFieldName)
    hNewField  = phNewBuffer:buffer-field(cFieldName)
    .
  
  create bttQueryWindowFieldChanges.
  
  assign
    bttQueryWindowFieldChanges.FieldName   = cFieldName
    bttQueryWindowFieldChanges.FieldIndex  = iIndex
    bttQueryWindowFieldChanges.DisplayName = qg_cFormattedFieldName(?,
                                                                    ?,
                                                                    cFieldName,
                                                                    iIndex)
    .
  
  if lookup(hNewField:data-type, 'CLOB,BLOB':U) = 0 then
  do:
    
    if plRawValues  then
      assign
        bttQueryWindowFieldChanges.OldDisplayValue     = hOldField:buffer-value(iIndex)
        bttQueryWindowFieldChanges.CurrentDisplayValue = hNewField:buffer-value(iIndex)
        .
    
    else
      assign
        bttQueryWindowFieldChanges.OldDisplayValue     = hOldField:string-value(iIndex)
        bttQueryWindowFieldChanges.CurrentDisplayValue = hNewField:string-value(iIndex)
        .
    
  end. /* if lookup(hNewField:data-type, 'CLOB,BLOB':U) = 0 */
  
  else
  do:
    
    copy-lob hOldField:buffer-value(iIndex) to clOldFieldValue.
    copy-lob hNewField:buffer-value(iIndex) to clNewFieldValue.
    
    assign
      bttQueryWindowFieldChanges.OldDisplayValue     = substring(clOldFieldValue, 1, 255)
      bttQueryWindowFieldChanges.CurrentDisplayValue = substring(clnewFieldValue, 1, 255)
      .
    
  end. /* else: if lookup(hNewField:data-type, 'CLOB,BLOB':U) = 0 */
  
  validate bttQueryWindowFieldChanges.
  
end. /* do i = 1 to num-entries(cFieldList) */

run qg_InitBrowse(browse brRecordBrowse:handle).

assign
  cText                             = pcText
  frame fConfirmRecordChanges:title = gcTitlePrefix + pcTitle
  lDisableTriggers                  = ioplDisableTriggers
  brRecordBrowse:num-locked-columns in frame fConfirmRecordChanges             = 1
  ttQueryWindowFieldChanges.DisplayName:width in browse brRecordBrowse         = 39
  ttQueryWindowFieldChanges.OldDisplayValue:width in browse brRecordBrowse     = 56
  ttQueryWindowFieldChanges.CurrentDisplayValue:width in browse brRecordBrowse = 56
  .

if    lDisableTriggers
  and not plCanEnableTriggers then
  assign
    lDisableTriggers:bgcolor  in frame fConfirmRecordChanges = 12
    reDisableTriggers:filled  in frame fConfirmRecordChanges = yes
    reDisableTriggers:bgcolor in frame fConfirmRecordChanges = 12
    .

open query brRecordBrowse
  for each ttQueryWindowFieldChanges
    no-lock.

display unless-hidden
  lDisableTriggers
  with frame fConfirmRecordChanges
    in window phParentWindow. 

update unless-hidden
  cText
  brRecordBrowse
  lDisableTriggers when plCanEnableTriggers
  btnOk
  btnCancel
  with frame fConfirmRecordChanges
    in window phParentWindow. 

assign
  oplOk               = yes
  ioplDisableTriggers = input frame fConfirmRecordChanges lDisableTriggers
  .

end procedure. /* qg_ConfirmRecordChanges */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ConfirmTriggerChanges hQueryWindow 
PROCEDURE qg_ConfirmTriggerChanges :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show a confirmation dialog to confirm deletion to a record.                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTitle                        = Title string for the dialog.              */
/* pcText                         = Text to display on the dialog.            */
/* plCanEnableTriggers            = If false the "disable triggers" toggle    */
/*                                  box is disabled.                          */
/* phParentWindow                 = Parent window to show the dialog.         */
/* oplOk                          = Output flag. True if the user clicked the */
/*                                  ok button - otherwise false.              */
/* ioplDisableTriggers            = Output flag. True if the user chose to    */
/*                                  disable the triggers - otherwise false.   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter pcTitle             as character no-undo.
define input        parameter pcText              as character no-undo.
define input        parameter pcButtonLabel       as character no-undo.
define input        parameter plCanEnableTriggers as logical   no-undo.
define input        parameter phParentWindow      as handle    no-undo.

define       output parameter oplOk               as logical   no-undo.
define input-output parameter ioplDisableTriggers as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cText as character no-undo
  format 'x(100)':U
  view-as text
  size 100 by 1.

define variable lDisableTriggers as logical no-undo
  format 'yes/no':U
  label 'disable triggers':T
  view-as toggle-box
  size 20 by 1.

define rectangle reDisableTriggers
  no-fill
  edge-pixels 2
  graphic-edge
  size 105 by 2
  .

define button btnOk
  label 'Ok':T6
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T6
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fConfirmTriggerChanges
  cText at row 1.5 col 3 no-label
  reDisableTriggers at row 3 col 3
  lDisableTriggers at row 3.5 col 5
  btnOk at row 6 col 36
  btnCancel at row 6 col 56
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 110 by 7.94
    title '':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fConfirmTriggerChanges
  apply 'end-error' to self.

on t of frame fConfirmTriggerChanges anywhere
do:
  
  if lDisableTriggers:sensitive then
    lDisableTriggers:checked = not lDisableTriggers:checked.
  
end. /* on t of frame fConfirmTriggerChanges anywhere */

assign
  frame fConfirmTriggerChanges:title          = gcTitlePrefix + pcTitle
  lDisableTriggers                            = ioplDisableTriggers
  btnOk:label in frame fConfirmTriggerChanges = pcButtonLabel
  cText                                       = pcText
  .

if    lDisableTriggers
  and not plCanEnableTriggers then
  assign
    lDisableTriggers:bgcolor  in frame fConfirmTriggerChanges = 12
    reDisableTriggers:filled  in frame fConfirmTriggerChanges = yes
    reDisableTriggers:bgcolor in frame fConfirmTriggerChanges = 12
    .

display unless-hidden
  lDisableTriggers
  with frame fConfirmTriggerChanges
    in window phParentWindow. 

update unless-hidden
  cText
  lDisableTriggers when plCanEnableTriggers
  btnOk
  btnCancel
  with frame fConfirmTriggerChanges
    in window phParentWindow. 

assign
  oplOk               = yes
  ioplDisableTriggers = input frame fConfirmTriggerChanges lDisableTriggers
  .

end procedure. /* qg_ConfirmTriggerChanges */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CopyQueryGeneratorSource Method-Library
procedure qg_CopyQueryGeneratorSource :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable clSourceContent as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

fix-codepage ( clSourceContent ) = 'UTF-8':U.

copy-lob
  from file this-procedure:file-name
  to clSourceContent
  .

run qg_WriteLongcharToClipboard( clSourceContent ).

end procedure. /* qg_CopyQueryGeneratorSource */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CopyQueryGeneratorSourcefilePath Method-Library
procedure qg_CopyQueryGeneratorSourcefilePath :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

clipboard:value = search( this-procedure:file-name ).

end procedure. /* qg_CopyQueryGeneratorSourcefilePath */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CreateBuffer hQueryWindow 
PROCEDURE qg_CreateBuffer :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create a record for given buffer.                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer                       = Buffer for the new record.                */
/* plDisableTriggers              = Flag to indicate if create triggers       */
/*                                  should be disabled.                       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBuffer          as handle    no-undo.
define input parameter plDisableTriggers as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if plDisableTriggers then
  phBuffer:disable-load-triggers(no).

phBuffer:buffer-create().

end procedure. /* qg_CreateBuffer */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CreateBufferButtonMenu hQueryWindow 
PROCEDURE qg_CreateBufferButtonMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create popup menu for buffer name buttons.                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phButton                       = Button handle.                            */
/* pcBufferPattern                = Buffer pattern for this button.           */
/* pcLabelPattern                 = Buffer label pattern for this button.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phButton        as handle    no-undo.

define input parameter pcBufferPattern as character no-undo.
define input parameter pcLabelPattern  as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i     as integer   no-undo.
define variable hTemp as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create menu hTemp
  assign
    name       = substitute('m_&1PopupMenu':U, phButton:name)
    popup-only = yes
    sensitive  = yes
    .

phButton:popup-menu = hTemp.

do i = 1 to {&K_NUM_BUFFER_PATTERN_INDICES}:
  
  create menu-item hTemp
    assign
      name         = substitute('mi_&1_&2':U, phButton:name, string(i))
      parent       = phButton:popup-menu
      label        = qg_cSubstituteChar(pcLabelPattern, '#':U, string(i))
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SetBufferPattern in target-procedure
                         (pcBufferPattern, i).
    end triggers
    .
  
end. /* do i = 1 to {&K_NUM_BUFFER_PATTERN_INDICES} */

end procedure. /* qg_CreateBufferButtonMenu */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_CreateTableClone hQueryWindow 
PROCEDURE qg_CreateTableClone :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create a temp table like given table and copy over all records.            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* Can not be a function due to use of "process events" which might not be    */
/* allowed in a user defined function (Progrerss error 5622).                 */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phTable                        = Table handle or buffer handle of table    */
/*                                  that should be cloned.                    */
/* pcTableName                    = New table name that should be used for    */
/*                                  the clone.                                */
/* pcWhere                        = Where condition of records that should be */
/*                                  copied (or blank for all records).        */
/* pcStatusText                   = Status text that should be used for the   */
/*                                  progress status dialog.                   */
/* ophTable                       = Handle of the new temp-table clone.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter phTable      as handle    no-undo.
define input  parameter pcTableName  as character no-undo.
define input  parameter pcWhere      as character no-undo.
define input  parameter pcStatusText as character no-undo.
define output parameter ophTable     as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName     as character no-undo.
define variable lPhysicalDatabase as logical   no-undo.
define variable hQuery            as handle    no-undo.
define variable hSourceBuffer     as handle    no-undo.
define variable hTargetBuffer     as handle    no-undo.

define variable cQueryText        as character no-undo.

define variable i                 as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    pcStatusText > '':U then
do:
  
  display unless-hidden
    substitute('&1 ...':T, pcStatusText)
      @ gcStatusText120
    with frame fStatus
      no-labels
      overlay
      color messages
      centered
      view-as dialog-box
      width 125
      .
  process events.
  
end. /* if    pcStatusText > '':U */

/* Create temp-table like parameter table. */

assign
  cDatabaseName     = qg_cDatabaseNameForTableOrBuffer( phTable )
  lPhysicalDatabase = qg_lIsPhysicalDatabase( cDatabaseName ).
  .

create temp-table ophTable in widget-pool qg_cTTWidgetPool().

ophTable:create-like(phTable).

if lPhysicalDatabase then
  
  run qg_AddVirtualFieldsToTempTable( cDatabaseName,
                                      phTable:name,
                                      ophTable ).

ophTable:temp-table-prepare(pcTableName).

/* Copy parameter table to new temp-table. */

create query hQuery.

create buffer hSourceBuffer for table phTable buffer-name phTable:name.
create buffer hTargetBuffer for table ophTable.

hQuery:add-buffer(hSourceBuffer).

assign
  pcWhere    = trim(pcWhere)
  cQueryText = (if pcWhere begins 'for':U then
                  pcWhere
                else if pcWhere begins 'where':U then
                  substitute('for each &1 &2':U,
                             hSourceBuffer:name,
                             pcWhere)
                else if pcWhere > '':U then
                  substitute('for each &1 where &2':U,
                             hSourceBuffer:name,
                             pcWhere)
                else
                  substitute('for each &1':U,
                             hSourceBuffer:name))
  .

hQuery:query-prepare(cQueryText).
hQuery:query-open().

hQuery:get-first().

do while not hQuery:query-off-end:
  
  i = i + 1.
  
  if    pcStatusText > '':U
    and i mod 5000   = 0 then
  do:
    
    display unless-hidden
      substitute('&1 (&2 records) ...':T,
                 pcStatusText,
                 trim(string(i, {&K_MAX_INT64_FORMAT})))
        @ gcStatusText120
      with frame fStatus
        no-labels
        overlay
        color messages
        centered
        view-as dialog-box
        width 125
        .
    process events.
    
  end. /* if    pcStatusText > '':U */
  
  hTargetBuffer:buffer-create().
  
  hTargetBuffer:buffer-copy(hSourceBuffer).
  
  if lPhysicalDatabase then
    
    run qg_BufferCopyVirtualFieldsFromPhysicalBufferToTempTableBuffer
          ( cDatabaseName,
            hSourceBuffer,
            hTargetBuffer ).
  
  hTargetBuffer:buffer-validate().
  
  hQuery:get-next().
  
end. /* do while not hQuery:query-off-end */

finally:
  
  if valid-handle(hQuery) then
    delete object hQuery.
  
  if valid-handle(hSourceBuffer) then
    delete object hSourceBuffer.
  
  if valid-handle(hTargetBuffer) then
    delete object hTargetBuffer.
  
end finally.

end procedure. /* qg_CreateTableClone */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_DeleteFile Method-Library
procedure qg_DeleteFile :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcFilename as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFilename as character no-undo.
define variable lOk       as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  pcFilename          = qg_cFileName(pcFilename)
  file-info:file-name = pcFilename
  .

if file-info:full-pathname = ? then
  message
    substitute('File ~'&1~' does not exist.':T, pcFilename)
    view-as alert-box
    warning
    buttons ok.

else
do:
  
  message
    substitute('Do you really want to irrevocably delete File ~'&1~'?':T,
               pcFilename)
    view-as alert-box
    question
    buttons yes-no
    update lOk.
  
  if not lOk then
    leave.
  
  os-delete value(pcFilename).
  
  if    os-error <> 0
    and os-error <> 2 then
    message
      substitute('File ~'&1~' could not be deleted!':T, pcFilename)
      view-as alert-box
      error
      buttons ok.
  
  else
    message
      substitute('File ~'&1~' has been deleted!':T, pcFilename)
      view-as alert-box
      information
      buttons ok.
  
end. /* else: if file-info:full-pathname = ? */

end procedure. /* qg_DeleteFile */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_DeleteFieldOverlay Method-Library
procedure qg_DeleteFieldOverlay :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phOwner      as handle    no-undo.
define input parameter pcBufferName as character no-undo.
define input parameter pcFieldName  as character no-undo.
define input parameter piFieldIndex as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttFieldOverlay                 for temp-table ttFieldOverlay.

define buffer bttQueryWindowQueryBrowseColumn for temp-table ttQueryWindowQueryBrowseColumn.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttFieldOverlay
  where bttFieldOverlay.OwnerHandle = phOwner
    and bttFieldOverlay.BufferName  = pcBufferName
    and bttFieldOverlay.FieldName   = pcFieldName
    and bttFieldOverlay.FieldIndex  = piFieldIndex
  no-error.

if not available bttFieldOverlay then
  leave.

if valid-handle(bttFieldOverlay.OverlayBufferHandle) then
  delete object bttFieldOverlay.OverlayBufferHandle no-error.

if valid-handle(bttFieldOverlay.OverlayColumnHandle) then
  delete object bttFieldOverlay.OverlayColumnHandle no-error.

for each bttQueryWindowQueryBrowseColumn
  where bttQueryWindowQueryBrowseColumn.ColumnHandle = bttFieldOverlay.OverlayColumnHandle:
  
  delete bttQueryWindowQueryBrowseColumn.
  
end. /* for each bttQueryWindowQueryBrowseColumn */

delete bttFieldOverlay.

end procedure. /* qg_DeleteFieldOverlay */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_DeleteTextLines hQueryWindow 
PROCEDURE qg_DeleteTextLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Inserts given Text after line of given offset index.                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcLine                         = Text that should be inserted.             */
/* piOffset                       = offset of the line after that the text    */
/*                                  should be inserted.                       */
/* pcText                         = Text in which the line should be inser-   */
/*                                  ted.                                      */
/* opiLine                        = Line number of the inserted line.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter piOffsetStart as integer   no-undo.
define input        parameter piOffsetEnd   as integer   no-undo.
define input-output parameter pcText        as character no-undo.
define       output parameter opiLine       as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i               as integer   no-undo.
define variable iOffset         as integer   no-undo initial 1.
define variable iLineEndOffset  as integer   no-undo.

define variable iStartOffset    as integer   no-undo.
define variable iEndOffset      as integer   no-undo.

define variable iLineCount      as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if length(pcText) = 0 then
  opiLine = 1.

else
do:
  
  do i = 1 to num-entries(pcText, '~n':U):
    
    iLineEndOffset = iOffset + length(entry(i, pcText, '~n':U)).
    
    if    iOffset        <= piOffsetStart
      and iLineEndOffset >= piOffsetStart then
      assign
        iStartOffset = iOffset
        opiLine      = i
        .
    
    if    iOffset        <= piOffsetEnd
      and iLineEndOffset >= piOffsetEnd then
    do:
      
      iEndOffset = iLineEndOffset + length('~n':U).
      leave.
      
    end. /* if iOffset <= piOffsetEnd */
    
    iOffset = iLineEndOffset + length('~n':U). 
    
  end. /* do i = 1 to num-entries(pcText, '~n':U) */
  
  if    iStartOffset > 0
    and iEndOffset  >= iStartOffset then
  do:
    
    assign
      pcText     = substitute('&1&2':U,
                              substring(pcText, 1, iStartOffset - 1),
                              substring(pcText, iEndOffset))
      iLineCount = max(1, num-entries(pcText, '~n':U))
      .
    
    if opiLine > iLineCount then
      opiLine = iLineCount.
    
    if    opiLine = iLineCount
      and opiLine > 1
      and length(entry(opiLine, pcText, '~n':U)) = 0 then
      opiLine = opiLine - 1.
    
  end. /* if    iStartOffset > 0 */
  
end. /* if length(pcText) = 0 */

end procedure. /* qg_DeleteTextLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_DeleteWidgetTree hQueryWindow 
PROCEDURE qg_DeleteWidgetTree :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Delete a tree of widgets with a parent child relation recursively.         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phParent                       = Handle of the Widget that should be       */
/*                                  deleted.                                  */
/* plDeleteParent                 = Delete given parent as well.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phParent       as handle    no-undo.
define input parameter plDeleteParent as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i          as integer   no-undo.
define variable hChild     as handle    no-undo.
define variable hNextChild as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(phParent) then
do:
  
  if can-query(phParent, 'first-child':U) then
  do:
    
    hChild = phParent:first-child.
    
    do while valid-handle(hChild):
      
      hNextChild = hChild:next-sibling.
      
      run qg_DeleteWidgetTree(hChild, yes).
      
      hChild = hNextChild.
      
    end. /* do while valid-handle(hChild) */
    
  end. /* if can-query(phParent, 'first-child':U) */
  
  if phParent:type = 'QUERY' then
  do i = 1 to phParent:num-buffers:
    run qg_DeleteWidgetTree(phParent:get-buffer-handle(i), yes).
  end. /* do i = 1 to phParent:num-buffers */
  
  if phParent:type = 'BROWSE' then
    run qg_DeleteWidgetTree(phParent:query, yes).
  
  if can-query(phParent, 'menu-bar':U) then
    run qg_DeleteWidgetTree(phParent:menu-bar, yes).
  
  if can-query(phParent, 'popup-menu':U) then
    run qg_DeleteWidgetTree(phParent:popup-menu, yes).
  
  if    plDeleteParent
    and ( not can-query(phParent, 'dynamic':U)
       or phParent:dynamic ) then
    delete object phParent no-error.
  
end. /* if valid-handle(phParent) */

end procedure. /* qg_DeleteWidgetTree */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_DropDownWindow hQueryWindow 
PROCEDURE qg_DropDownWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow             as handle    no-undo.
define input parameter phButton             as handle    no-undo.
define input parameter piPreferredDirection as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iHwnd     as int64   no-undo.
define variable iDummy    as integer   no-undo.

define variable iButtonX1 as integer   no-undo.
define variable iButtonY1 as integer   no-undo.
define variable iButtonX2 as integer   no-undo.
define variable iButtonY2 as integer   no-undo.

define variable iWindowX1 as integer   no-undo.
define variable iWindowY1 as integer   no-undo.
define variable iWindowX2 as integer   no-undo.
define variable iWindowY2 as integer   no-undo.

define variable iRelWinX  as integer   no-undo.
define variable iRelWiny  as integer   no-undo.


/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Sometimes the hwnd attribute is only set after the window was schown. So   */
/* as a workaround we have no other choice but to show it for a short moment  */
/* because we need the hwnd before the window is actually displayed.          */

if phWindow:hwnd = ? then
  assign
    phWindow:hidden = no
    phWindow:hidden = yes
    .

/* Get correct window handle. */

if phWindow:type = 'WINDOW':U then
  run GetParent(phWindow:hwnd, output iHwnd).

/* Set window style. */

run SetWindowLongA(iHwnd,
                   {&K_WIN_CONST_GWL_STYLE},
                   {&K_WIN_CONST_WS_POPUP} + {&K_WIN_CONST_WS_BORDER},
                   output iDummy).

/* Position window exactly next to the button. */

run qg_GetWindowRect(phButton,
                     output iButtonX1,
                     output iButtonY1,
                     output iButtonX2,
                     output iButtonY2).

assign
  iRelWinX = (if    piPreferredDirection = {&K_DIRECTION_RIGHT}
                and iButtonX1 + phWindow:width-pixels <= session:width-pixels then
                iButtonX1
              else if    piPreferredDirection = {&K_DIRECTION_LEFT}
                     and iButtonX2 - phWindow:width-pixels > 0 then
                iButtonX2 - phWindow:width-pixels
              else if iButtonX1 + phWindow:width-pixels <= session:width-pixels then
                iButtonX1
              else
                iButtonX2 - phWindow:width-pixels)
  iRelWiny = (if iButtonY2 + phWindow:height-pixels <= session:height-pixels then
                iButtonY2
              else
                iButtonY1 - phWindow:height-pixels)
  .

run SetWindowPos(iHwnd,
                 0,
                 iRelWinX,
                 iRelWiny,
                 phWindow:width-pixels,
                 phWindow:height-pixels,
                 {&K_WIN_CONST_SWP_FRAMECHANGED},
                 output iDummy).

end procedure. /* qg_DropDownWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_DuplicateTextLines hQueryWindow 
PROCEDURE qg_DuplicateTextLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Duplicate text lines.                                                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piOffsetStart                  = Selection Start.                          */
/* piOffsetEnd                    = Selection end.                            */
/* plDown                         = If yes then duplicate downwards.          */
/*                                  Otherwise duplicate upwards.              */
/* pcText                         = Text in which the line should be          */
/*                                  duplicated.                               */
/* opiLine                        = Line number of the duplicated lines.      */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter piOffsetStart as integer   no-undo.
define input        parameter piOffsetEnd   as integer   no-undo.
define input        parameter plDown        as logical   no-undo.
define input-output parameter pcText        as character no-undo.
define       output parameter opiLine       as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i               as integer   no-undo.
define variable iOffset         as integer   no-undo initial 1.
define variable iLineEndOffset  as integer   no-undo.

define variable iStartOffset    as integer   no-undo.
define variable iEndOffset      as integer   no-undo.

define variable cLines          as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do i = 1 to num-entries(pcText, '~n':U):
  
  iLineEndOffset = iOffset + length(entry(i, pcText, '~n':U)).
  
  if    iOffset        <= piOffsetStart
    and iLineEndOffset >= piOffsetStart then
  do:
    
    iStartOffset = iOffset.
    
    if not plDown then
      opiLine = i.
    
  end. /* if    iOffset        <= piOffsetStart ... */
  
  if    iOffset        <= piOffsetEnd
    and iLineEndOffset >= piOffsetEnd then
  do:
    
    iEndOffset = iLineEndOffset + length('~n':U).
    
    if plDown then
      opiLine = i.
    
    leave.
    
  end. /* if iOffset <= piOffsetEnd */
  
  iOffset = iLineEndOffset + length('~n':U). 
  
end. /* do i = 1 to num-entries(pcText, '~n':U) */

if    iStartOffset > 0
  and iEndOffset  >= iStartOffset then
do:
  
  assign
    cLines     = substring(pcText, iStartOffset, iEndOffset - iStartOffset).
    pcText     =   substring(pcText, 1, iEndOffset - 1)
                 + (if iEndOffset > length(pcText)
                      and not pcText matches '*~n':U then
                      '~n':U
                    else
                      '':U)
                 + cLines
                 + substring(pcText, iEndOffset)
                 .
  
  if plDown then
    opiLine = opiLine + 1.
  
end. /* if    iStartOffset > 0 */
  
end procedure. /* qg_DuplicateTextLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_EditFieldValue hQueryWindow 
PROCEDURE qg_EditFieldValue :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Shows a dialog to edit the value of a single table field.                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phField                        = Field handle of the field that should be  */
/*                                  edited.                                   */
/* piIndex                        = Extent index of the field value that      */
/*                                  should be edited.                         */
/* plEditMode                     = If yes then editmode is enabled.          */
/* plRawValue                     = Indicates whether format should be        */
/*                                  applied. If no format should be applied   */
/*                                  then an editor widget will be used        */
/*                                  regardless of the field datatype.         */
/* phParentWindow                 = Parent window handle for the dialog.      */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter pcFieldName as character no-undo.
define input        parameter pcDataType     as character no-undo.
define input        parameter pcFormat       as character no-undo.
define input        parameter pcViewAs       as character no-undo.
define input        parameter plEditor       as logical   no-undo.
define input        parameter plEditMode     as logical   no-undo.
define input-output parameter ioplcValue     as longchar  no-undo.
define input        parameter phParentWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lEditor      as logical   no-undo.
define variable hFieldWidget as handle    no-undo.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fEditFieldValue
    btnOk at row 3.5 col 21
    btnCancel at row 3.5 col 41
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 81 by 5.44
    title '':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fEditFieldValue
  apply 'end-error' to self.

lEditor = (   plEditor
           or pcDataType       = 'CLOB':U
           or ( pcDataType     = 'character':U
            and pcViewAs matches '*editor*':U)).

if not lEditor then
do:
  
  create fill-in hFieldWidget
    assign
      name            = 'xFieldWidget':U
      frame           = frame fEditFieldValue:handle
      data-type       = pcDataType
      format          = pcFormat
      width           = 76
      height          = 1
      row             = 1.5
      col             = 3
      sensitive       = yes
      .
  
end. /* if not lEditor */

else
do:
  
  create editor hFieldWidget
    assign
      name                 = 'xFieldWidget':U
      frame                = frame fEditFieldValue:handle
      width                = 126
      height               = 15
      row                  = 1.5
      col                  = 3
      word-wrap            = no
      scrollbar-horizontal = yes
      scrollbar-vertical   = yes
      sensitive            = yes
      return-inserted      = yes
      .
  
  assign
    frame fEditFieldValue:height             = frame fEditFieldValue:height + 14
    frame fEditFieldValue:width              = frame fEditFieldValue:width + 50
    btnOk:row     in frame fEditFieldValue   = btnOk:row in frame fEditFieldValue + 14
    btnOk:col     in frame fEditFieldValue   = btnOk:col in frame fEditFieldValue + 25
    btnCancel:row in frame fEditFieldValue   = btnCancel:row in frame fEditFieldValue + 14
    btnCancel:col in frame fEditFieldValue   = btnCancel:col in frame fEditFieldValue + 25
    .

end. /* else: if not lEditor */

hFieldWidget:screen-value = (if lEditor then
                               ioplcValue
                             else
                              string(ioplcValue)).

if plEditMode then
  frame fEditFieldValue:title = substitute('&1Edit Value (&2)':T,
                                           gcTitlePrefix,
                                           pcFieldName).

else
  assign
    btnCancel:label in frame fEditFieldValue = 'Close':T
    btnCancel:col   in frame fEditFieldValue = btnCancel:col - 10
    btnOk:hidden    in frame fEditFieldValue = yes
    frame fEditFieldValue:title              = substitute('&1Value details (&2)':T,
                                                          gcTitlePrefix,
                                                          pcFieldName)
    hFieldWidget:read-only                   = yes
    .

/* We do not use the update statement because we would not be able to set the */
/* focus to the input widget. Instead we use display and wait-for.            */
assign
  btnOk:sensitive     in frame fEditFieldValue = yes /* code checked by mth */
  btnCancel:sensitive in frame fEditFieldValue = yes /* code checked by mth */
  .

display unless-hidden
  btnOk
  btnCancel
  with frame fEditFieldValue
    in window phParentWindow. 

if plEditMode then
  apply 'entry':U to hFieldWidget.

wait-for go of frame fEditFieldValue.

if plEditMode then
  ioplcValue = (if pcDataType = 'CLOB':U then
                  hFieldWidget:input-value
                else
                  string(hFieldWidget:input-value)).


finally:
  if valid-handle(hFieldWidget) then
    delete object hFieldWidget.
end finally.

end procedure. /* qg_EditFieldValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_EditRecord hQueryWindow 
PROCEDURE qg_EditRecord :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Shows a dialog that contains all fields and values of the given record and */
/* offers the option to edit field values.                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer                       = Buffer handle of the record that should   */
/*                                  be edited.                                */
/* piEditAction                   = Action that should be performed:          */
/*                                  - {&K_EDITACTION_EDIT}                    */
/*                                  - {&K_EDITACTION_CREATE}                  */
/*                                  - {&K_EDITACTION_DUPLICATE}               */
/* plEditMode                     = If yes then editmode is enabled.          */
/* phParentWindow                 = Parent window for the dialog.             */
/* pcFieldList                    = List/order of browse fields               */
/* oprRowid                       = Rowid of the edited or created record.    */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter phBuffer       as handle    no-undo.
define input  parameter piEditAction   as integer   no-undo.
define input  parameter plEditMode     as logical   no-undo.
define input  parameter phParentWindow as handle    no-undo.
define input  parameter pcFieldList    as character no-undo.
define output parameter oprRowid       as rowid     no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hLockBuffer            as handle    no-undo.
define variable hDataset               as handle    no-undo.
define variable hTempTable             as handle    no-undo.
define variable hTempTableBuffer       as handle    no-undo.
define variable hTempTableBeforeBuffer as handle    no-undo.
define variable iField                 as integer   no-undo.
define variable hField                 as handle    no-undo.

define variable cDatabaseName          as character no-undo.

define variable lOk                    as logical   no-undo.
define variable lDisableTriggers       as logical   no-undo.

define variable lBrowseFields as logical no-undo
  format 'yes/no':U
  view-as radio-set
    radio-buttons
      'Browse fields':T, yes,
      'All fields':T, no
    horizontal
  size 35 by 1.

define variable lRawValues as logical no-undo
  format 'yes/no':U
  view-as radio-set
    radio-buttons
      'Formatted values':T, no,
      'Raw values':T, yes
    horizontal
  size 40 by 1.

define query brRecordBrowse
  for ttQueryWindowField
  scrolling.

define browse brRecordBrowse
  query brRecordBrowse no-lock
    display
      ttQueryWindowField.DisplayName
      ttQueryWindowField.FieldLabel
      ttQueryWindowField.CurrentDisplayValue label 'Value':T
      with no-assign size 156 by 19.5.

if plEditMode then
  define button btnOk
    label 'Ok':T2
    size 20 by 1.14
    auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

define menu m_PopupMenu
  menu-item mi_CopyFieldValue
    label "Copy Value"
  rule
  menu-item mi_EditFieldValue
    label 'Edit Value':T
  menu-item mi_AdoptExternalValue
    label 'Adopt External Value':T
    .

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable            for temp-table ttTable.
define buffer bttField            for temp-table ttField.

define buffer bttQueryWindow      for temp-table ttQueryWindow.
define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fEditRecord
  lBrowseFields at row 1.5 col 3 no-label
  lRawValues at row 1.5 col 3 no-label
  brRecordBrowse at row 3 col 3
  btnOk at row 23.5 col 61
  btnCancel at row 23.5 col 81
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 161 by 25.44
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fEditRecord
  apply 'end-error' to self.

on off-home of brRecordBrowse in frame fEditRecord
do:
  apply 'entry':U to lBrowseFields in frame fEditRecord.
  return no-apply.
end. /* on cursor-down of cProcedureFilter in frame fEditRecord */
  
on cursor-down of lBrowseFields in frame fEditRecord
do:
  apply 'entry':U to brRecordBrowse in frame fEditRecord.
  return no-apply.
end. /* on cursor-down of lBrowseFields in frame fEditRecord */

on cursor-down of lRawValues in frame fEditRecord
do:
  apply 'entry':U to brRecordBrowse in frame fEditRecord.
  return no-apply.
end. /* on cursor-down of lRawValues in frame fEditRecord */

on value-changed of lBrowseFields in frame fEditRecord
do:
  
  if lBrowseFields:hidden in frame fEditRecord then
    lBrowseFields = no.
  
  else
    assign
      lBrowseFields  = input frame fEditRecord lBrowseFields
      glBrowseFields = lBrowseFields.
  
  if lBrowseFields then
    open query brRecordBrowse
      for each ttQueryWindowField
        where ttQueryWindowField.WindowHandle = ?
          and ttQueryWindowField.Order > 0
        no-lock
        by Order.
  
  else
    open query brRecordBrowse
      for each ttQueryWindowField
        where ttQueryWindowField.WindowHandle = ?
        no-lock
        by FieldName.
  
end. /* on 'value-changed':U of lBrowseFields in frame fEditRecord */

on value-changed of lRawValues in frame fEditRecord
do:
  
  define variable clValue as longchar  no-undo.
  
  define buffer bttQueryWindowField for temp-table ttQueryWindowField.
  
  assign
    lRawValues  = input frame fEditRecord lRawValues
    glRawValues = lRawValues
    .
  
  for each bttQueryWindowField
    where bttQueryWindowField.WindowHandle = ?
    on error undo, throw:
    
    run qg_UpdateRecordFieldDisplayValue((buffer bttQueryWindowField:handle),
                                          lRawValues,
                                          255). 
    
  end. /* for each bttQueryWindowField */
  
  if query brRecordBrowse:num-results > 0 then
    browse brRecordBrowse:refresh().
  
end. /* on 'value-changed' of lRawValues in frame fEditRecord */

on value-changed of brRecordBrowse in frame fEditRecord
do:
  
  if available ttQueryWindowField then
    menu-item mi_CopyFieldValue:label in menu m_PopupMenu = substitute('Copy value (&1)':T,
                                                                       (if length(ttQueryWindowField.CurrentDisplayValue) < 100 then
                                                                          ttQueryWindowField.CurrentDisplayValue
                                                                        else
                                                                          substitute('&1 ...':U,
                                                                                     substring(ttQueryWindowField.CurrentDisplayValue, 1, 96)))).
  
  else
    menu-item mi_CopyFieldValue:label in menu m_PopupMenu = 'Copy value':T.
  
end. /* on 'value-changed':U of brRecordBrowse in frame fEditRecord */

on row-display of brRecordBrowse in frame fEditRecord
do:
  
  define variable iColor as integer   no-undo initial ?.
  
  if available ttQueryWindowField then
    
    case ttQueryWindowField.FieldType:
    
    when {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
      
      iColor = {&K_VIRTUAL_DB_FIELD_FGCOLOR}.
    
  end case. /* available ttQueryWindowField */
  
  if iColor <> ? then
  
    assign
      ttQueryWindowField.DisplayName:fgcolor in browse brRecordBrowse         = iColor
      ttQueryWindowField.FieldLabel:fgcolor in browse brRecordBrowse          = iColor
      ttQueryWindowField.CurrentDisplayValue:fgcolor in browse brRecordBrowse = iColor
      .
  
end.

on choose of menu-item mi_CopyFieldValue in menu m_PopupMenu
do:
  
  define variable clValue as longchar  no-undo.
  
  if not available ttQueryWindowField then
    message /* code checked by mth */
      'No field is selected':T skip
      view-as alert-box
      error
      buttons ok.
    
  else
  do:
    
    lRawValues = input frame fEditRecord lRawValues.
    
    if lRawValues then
      copy-lob ttQueryWindowField.CurrentUnformattedValue to clValue.
    
    else
      copy-lob ttQueryWindowField.CurrentFormattedValue to clValue.
    
    clipboard:value = clValue.
      
  end. /* else: if not available ttQueryWindowField */
  
end. /* on choose of menu-item mi_CopyFieldValue in menu m_PopupMenu */

on choose of menu-item mi_EditFieldValue in menu m_PopupMenu
do:
  
  define variable hField  as handle    no-undo.
  define variable clValue as longchar  no-undo.
  
  if not available ttQueryWindowField then
    message /* code checked by mth */
      'No field is selected!':T
      view-as alert-box
      error
      buttons ok
      in window phParentWindow.

  else
  do:
    
    hField = hTempTableBuffer:buffer-field(ttQueryWindowField.FieldName).
    
    if hField:data-type = 'BLOB':U then
      message /* code checked by mth */
        'BLOB fields may not be edited!':T skip
        view-as alert-box
        error
        buttons ok.
      
    else
    do:
      
      if hField:data-type = 'CLOB':U then
        copy-lob hField:buffer-value(ttQueryWindowField.FieldIndex) to clValue.
      
      else
        clValue = string(hField:buffer-value(ttQueryWindowField.FieldIndex)).
      
      run qg_EditFieldValue(hField:name,
                            hField:data-type,
                            hField:format,
                            hField:view-as,
                            input frame fEditRecord lRawValues,
                            plEditMode,
                            input-output clValue,
                            phParentWindow).
      
      if plEditMode then
      do:
        
        if hField:data-type = 'CLOB':U then
          copy-lob clValue to hField:buffer-value(ttQueryWindowField.FieldIndex).
        
        else
          hField:Buffer-value(ttQueryWindowField.FieldIndex) = string(clValue).
        
      end. /* if plEditMode */
      
      /* Update values in ttQueryWindowField */
      
      run qg_UpdateRecordField( hField,
                                ttQueryWindowField.FieldIndex,
                                ( buffer ttQueryWindowField:handle ),
                                no ).
      
      run qg_UpdateRecordFieldDisplayValue((buffer ttQueryWindowField:handle),
                                           input frame fEditRecord lRawValues,
                                           255). 
      
      if query brRecordBrowse:num-results > 0 then
        browse brRecordBrowse:refresh().
      
    end. /* if bttField.DataType = 'BLOB':U */
    
  end. /* else: if not available ttQueryWindowField */
  
end. /* on choose of menu-item mi_EditFieldValue in menu m_PopupMenu */

on choose of menu-item mi_AdoptExternalValue in menu m_PopupMenu
do:
  
  define variable lOk                as logical   no-undo.
  define variable lRecidReference    as logical   no-undo.
  define variable iQuerySeq          as integer   no-undo.
  define variable cBufferName        as character no-undo.
  define variable cFieldName         as character no-undo.
  define variable iFieldIndex        as integer   no-undo.

  define variable hTargetField       as handle    no-undo.
  define variable hSourceBuffer      as handle    no-undo.
  define variable hSourceField       as handle    no-undo.
  define variable clValue            as longchar  no-undo.

  define buffer bttQueryWindow-Parent for temp-table ttQueryWindow.

  if not available ttQueryWindowField then
    message /* code checked by mth */
      'No field is selected!':T
      view-as alert-box
      error
      buttons ok
      in window phParentWindow.

  else
  do:
    
    run qg_SelectExternalReference( ttQueryWindowField.TableName,
                                    ttQueryWindowField.FieldName,
                                    yes,
                                    substitute('!&1,*':U, phParentWindow),
                                    phParentWindow,
                                    output lOk,
                                    output lRecidReference,
                                    output iQuerySeq,
                                    output cBufferName,
                                    output cFieldName,
                                    output iFieldIndex ).
    
    if lOk then
    do:
      
      hTargetField = hTempTableBuffer:buffer-field(ttQueryWindowField.FieldName).

      find bttQueryWindow-Parent
        where bttQueryWindow-Parent.QuerySeq = iQuerySeq
        .
      
      hSourceBuffer = bttQueryWindow-Parent.QueryHandle:get-buffer-handle( cBufferName ).
      
      hSourceField = hSourceBuffer:buffer-field( cFieldName ) no-error.
      
      if    not error-status:error
        and valid-handle( hSourceField ) then
      do:
        
        if hTargetField:data-type = 'CLOB':U then
          copy-lob hSourceField:buffer-value( iFieldIndex ) to hTargetField:buffer-value(ttQueryWindowField.FieldIndex).
        
        else
          hTargetField:Buffer-value( ttQueryWindowField.FieldIndex ) = hSourceField:buffer-value( iFieldIndex ).
        
      end. /* if valid-handle( hSourceField ) */
      
      else
        
        if ttQueryWindowField.IsVirtual then
        do:
          
          clValue = qg_clVirtualFieldValueAsLongchar( ttQueryWindowField.FieldType,
                                                      ttQueryWindowField.DataType,
                                                      ttQueryWindowField.FieldName,
                                                      qg_cObjectIdForBuffer( hSourceBuffer ),
                                                      ? ).
          
          if hTargetField:data-type = 'CLOB':U then
            
            copy-lob clValue to hTargetField:buffer-value( ttQueryWindowField.FieldIndex ).
          
          else
            
            hTargetField:buffer-value( ttQueryWindowField.FieldIndex ) = string( clValue ).
          
        end. /* if ttQueryWindowField.IsVirtual */
      
      /* Update values in ttQueryWindowField */
      
      run qg_UpdateRecordField( hTargetField,
                                ttQueryWindowField.FieldIndex,
                                ( buffer ttQueryWindowField:handle ),
                                no ).
      
      run qg_UpdateRecordFieldDisplayValue((buffer ttQueryWindowField:handle),
                                           input frame fEditRecord lRawValues,
                                           255). 
      
      if query brRecordBrowse:num-results > 0 then
        browse brRecordBrowse:refresh().
      
    end. /* if lOk */
    
  end. /* if not available ttQueryWindowField */ 

end. /* on choose of menu-item mi_AdoptExternalValue in menu m_PopupMenu */

on default-action of brRecordBrowse in frame fEditRecord
  apply 'choose':U to menu-item mi_EditFieldValue in menu m_PopupMenu.

on ' ':U of brRecordBrowse in frame fEditRecord
  apply 'choose':U to menu-item mi_EditFieldValue in menu m_PopupMenu.

on ctrl-c of brRecordBrowse in frame fEditRecord
  apply 'choose':U to menu-item mi_CopyFieldValue in menu m_PopupMenu.

Main:
do
  transaction
  on error  undo, throw
  on endkey undo, leave:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = phParentWindow
    no-error.
  
  if not plEditMode then
    assign
      btnOk:hidden in frame fEditRecord                     = yes
      btnCancel:label in frame fEditRecord                  = 'Close':T5
      btnCancel:col in frame fEditRecord                    = 71
      menu-item mi_EditFieldValue:label in menu m_PopupMenu = 'Value details':T
      .
  
  create buffer hLockBuffer for table phBuffer.
  
  assign
    hLockBuffer:private-data = phBuffer:private-data
    cDatabaseName            = qg_cDatabaseNameForTableOrBuffer( hLockBuffer )
    hLockBuffer:private-data = qg_cParamListWriteCharacter( hLockBuffer:private-data,
                                                            'DatabaseName':U,
                                                            cDatabaseName,
                                                            ',':U )
    .
  
  find bttTable
    where bttTable.DatabaseName = cDatabaseName
      and bttTable.TableName    = hLockBuffer:table
    no-error.
  
  if   piEditAction = {&K_EDITACTION_CREATE}
    or piEditAction = {&K_EDITACTION_DUPLICATE} then
  do:
    
    lDisableTriggers =     available bttTable
                       and bttTable.CreateTrigger         > '':U
                       and search(bttTable.CreateTrigger) = ?.
    
    run qg_ConfirmTriggerChanges(substitute('Confirm creation of &1 record':T,
                                            hLockBuffer:table),
                                 substitute('Please confirm creation of &1 record':T,
                                            hLockBuffer:table),
                                 'Create':T,
                                 (    available bttTable
                                  and search(bttTable.CreateTrigger) <> ?),
                                 phParentWindow,
                                       output lOk,
                                 input-output lDisableTriggers).
    
    if not lOk then
      undo Main, leave Main.
    
    run qg_CreateBuffer(hLockBuffer,
                        lDisableTriggers).
    
  end. /* if   piEditAction = {&K_EDITACTION_CREATE} ... */

  else if piEditAction = {&K_EDITACTION_EDIT}
    and   plEditMode then
    hLockBuffer:find-by-rowid(phBuffer:rowid, exclusive-lock).
  
  else
    hLockBuffer:find-by-rowid(phBuffer:rowid, no-lock).
  
  /* Set dialog title. */
  
  case piEditAction:
    
    when {&K_EDITACTION_CREATE} then
      frame fEditRecord:title = substitute('&1Create &2 record (&3)':T,
                                           gcTitlePrefix,
                                           hLockBuffer:table,
                                           hLockBuffer:rowid).
    
    when {&K_EDITACTION_DUPLICATE} then
      frame fEditRecord:title = substitute('&1Duplicate &2 record (&3)':T,
                                           gcTitlePrefix,
                                           hLockBuffer:table,
                                           hLockBuffer:rowid).
    
    otherwise
    do:
      
      if plEditMode then
        frame fEditRecord:title = substitute('&1Edit &2 record (&3)':T,
                                             gcTitlePrefix,
                                             hLockBuffer:table,
                                             hLockBuffer:rowid).
      
      else
        frame fEditRecord:title = substitute('&1&2 record details (&3)':T,
                                             gcTitlePrefix,
                                             hLockBuffer:table,
                                             hLockBuffer:rowid).
      
    end. /* otherwise */
    
  end case. /* piEditAction */
  
  /* Create temp-table and copy buffer-values. */
  
  create temp-table hTempTable.
  
  hTempTable:create-like-sequential(hLockBuffer).
  
  run qg_AddVirtualFieldsToTempTable( cDatabaseName,
                                      hLockBuffer:table,
                                      hTempTable ).
  
  &IF proversion >= '11.7':U &THEN
    hTempTable:temp-table-prepare( hLockBuffer:table, yes ).
  &ELSE
    hTempTable:temp-table-prepare( hLockBuffer:table ).
  &ENDIF
  
  assign
    hTempTableBuffer              = hTempTable:default-buffer-handle
    hTempTableBuffer:private-data = hLockBuffer:private-data
    hTempTableBeforeBuffer        = hTempTableBuffer:before-buffer
    .
  
  /* We dont really need a dataset. However progress requires a dataset for   */
  /* tracking changes to be used.                                             */
  
  create dataset hDataset.
  
  hDataset:set-buffers( hTempTableBuffer ).
  
  hTempTableBuffer:buffer-create().
  
  hTempTableBuffer:buffer-copy(hLockBuffer).
  
  if qg_lIsPhysicalDatabase( cDatabaseName ) then
    
    run qg_BufferCopyVirtualFieldsFromPhysicalBufferToTempTableBuffer
          ( cDatabaseName,
            hLockBuffer,
            hTempTableBuffer ).
  
  hTempTable:tracking-changes = yes.
  
  if    piEditAction = {&K_EDITACTION_CREATE}
    and available bttQueryWindow then
  do:
    
    do iField = 1 to hTempTableBuffer:num-fields:
      
      hField = hTempTableBuffer:buffer-field( iField ).
      
      if    can-do( {&K_COMPANY_FIELDS}, hField:name )
        and hField:extent    = 0
        and hField:data-type = 'character':U then
        hField:buffer-value = qg_cGetCompany( hTempTableBuffer:table, ? ).
      
    end. /* do iCompanyField = 1 to num-entries( {&K_COMPANY_FIELDS} ) */
    
    run qg_AdoptLinkValues( hTempTableBuffer,
                            bttQueryWindow.QuerySeq ).
    
  end. /* if piEditAction = {&K_EDITACTION_DUPLICATE} */
  
  if piEditAction = {&K_EDITACTION_DUPLICATE} then
  do:
    
    hTempTableBuffer:buffer-copy(phBuffer,
                                 substitute('&1_Obj':U,
                                            phBuffer:table)).
    
    if qg_lIsPhysicalDatabase( cDatabaseName ) then
      
      run qg_BufferCopyVirtualFieldsFromPhysicalBufferToTempTableBuffer
            ( cDatabaseName,
              phBuffer,
              hTempTableBuffer ).
    
    
  end. /* if piEditAction = {&K_EDITACTION_DUPLICATE} */
  
  if pcFieldList = ? then
    assign
      lBrowseFields                             = no
      lBrowseFields:hidden in frame fEditRecord = yes
      .
  
  else
    assign
      lBrowseFields                       = glBrowseFields
      lRawValues:col in frame fEditRecord = lRawValues:col in frame fEditRecord + 45
      .
  
  lRawValues = glRawValues.
  
  /* Create field temp-table entries. */
  
  run qg_QueryWindowUpdateFieldTempTable( hTempTableBuffer, ?, pcFieldList).
  
  /* Set field temp-table display values. */
  
  for each bttQueryWindowField
    where bttQueryWindowField.WindowHandle = ?
    on error undo, throw:
    
    run qg_UpdateRecordField( bttQueryWindowField.FieldHandle,
                              bttQueryWindowField.FieldIndex,
                              ( buffer bttQueryWindowField:handle ),
                              no ).
    
  end. /* for each bttQueryWindowField */
  
  /* Display has to happen before we apply 'value-changed' to avoid an error  */
  /* message due to an invalid screen-value.                                  */
  
  display unless-hidden
    lBrowseFields
    lRawValues
    with frame fEditRecord
      in window phParentWindow. 
  
  apply 'value-changed' to lRawValues in frame fEditRecord.
  apply 'value-changed' to lBrowseFields in frame fEditRecord.
  
  assign
    brRecordBrowse:popup-menu in frame fEditRecord                = menu m_PopupMenu:handle
    brRecordBrowse:num-locked-columns in frame fEditRecord        = 2
    ttQueryWindowField.DisplayName:width in browse brRecordBrowse = 39
    .
  
  run qg_InitBrowse(browse brRecordBrowse:handle).
  
  menu-item mi_AdoptExternalValue:sensitive in menu m_PopupMenu
      = (     plEditMode
          and can-find( first ttQueryWindow
                          where ttQueryWindow.WindowHandle <> phParentWindow
                            and valid-handle( bttQueryWindow.WindowHandle )
                            and valid-handle( bttQueryWindow.QueryHandle ) ) ).
  
  update unless-hidden
    lBrowseFields
    lRawValues
    brRecordBrowse
    btnOk
    btnCancel
    with frame fEditRecord
      in window phParentWindow. 
  
  hTempTable:tracking-changes = no.
  
  if plEditMode then
  do:
    
    /*
    if not hLockBuffer:buffer-compare(hTempTableBuffer,
                                      'binary':U) then
    */
    
    if qg_cBufferCompare(hTempTableBuffer, hTempTableBuffer:before-buffer) > '':U then 
    do:
      
      lDisableTriggers =     available bttTable
                         and bttTable.WriteTrigger         > '':U
                         and search(bttTable.WriteTrigger) = ?.  
      
      run qg_ConfirmRecordChanges(substitute('Confirm changes to &1 record &2':T,
                                             hLockBuffer:table,
                                             string(hLockBuffer:rowid)),
                                  'WARNING: The current record has been changed. Below you will find a list of all changes you made. Please carefully review and confirm your changes!':T,
                                  hTempTableBeforeBuffer,
                                  hTempTableBuffer,
                                  (    available bttTable
                                   and search(bttTable.WriteTrigger) <> ?),
                                  lRawValues,
                                  phParentWindow,
                                        output lOk,
                                  input-output lDisableTriggers).
      
      if lOk then
      do:
        
        if lDisableTriggers then
          
          hLockBuffer:disable-load-triggers(no).
        
        hLockBuffer:buffer-copy(hTempTableBuffer).
        
        run qg_BufferCopyVirtualFieldsFromTempTableBufferToPhysicalBuffer
              ( cDatabaseName,
                hTempTableBuffer,
                hLockBuffer,
                lDisableTriggers ).
        
        hLockBuffer:buffer-validate().
        
      end. /* if lOk */
      
    end. /* if not buffer-compare(hLockBuffer, */
    
    oprRowid = hLockBuffer:rowid.
    
  end. /* if plEditMode */
  
  finally:
    
    if valid-handle(hLockBuffer) then
    do:
      
      hLockBuffer:buffer-release().
      
      delete object hLockBuffer.
      
    end. /* if valid-handle(hLockBuffer) */
    
    if valid-handle( hDataset ) then
      
      delete object hDataset.
    
    if valid-handle(hTempTable) then
      delete object hTempTable no-error.
    
  end finally.
  
end. /* Main */

end procedure. /* qg_EditRecord */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ExecQuery hQueryWindow 
PROCEDURE qg_ExecQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open a new query window and execute the current query.                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTables                       = Commaseparated list of tables that are    */
/*                                  required for this query.                  */
/* pcQueryText                    = Initial query text for this query window. */
/* piQuerySeq                     = Query sequence to use for this window. If */
/*                                  empty then a new id will be generated.    */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter piWindowMode     as integer   no-undo.
define input        parameter piWindowSize     as integer   no-undo.
define input        parameter pcTables         as character no-undo.
define input        parameter pcQueryText      as character no-undo.
define input        parameter plInitMode       as logical   no-undo.
define input        parameter pcParamList      as character no-undo.
define input-output parameter iopiQuerySeq     as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iObjSourceQuerySeq         as integer   no-undo.
define variable lFocusQueryText            as logical   no-undo.
define variable iXPos                      as integer   no-undo.
define variable iYPos                      as integer   no-undo.

define variable cWindowTitle               as character no-undo.

define variable hWindow                    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable       for temp-table ttTable.

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if iopiQuerySeq = ? then
  assign
    giQuerySeq   = giQuerySeq + 1
    iopiQuerySeq = giQuerySeq
    .

else
do:
  
  if can-find(ttQueryWindow
                where ttQueryWindow.QuerySeq = iopiQuerySeq) then
  do:
    
    message /* code checked by mth */
      substitute('The query id &1 is already in use. Query window could not be opened!':T,
                 iopiQuerySeq) skip
      view-as alert-box error
      buttons ok.
    
    return error.
    
  end. /* if can-find(ttQueryWindow */
  
  giQuerySeq = max(iopiQuerySeq, giQuerySeq). 
  
end. /* if iopiQuerySeq = ? */

/* Create dynamic widgets. */

create window hWindow
  assign
    name           = substitute( 'fQuery&1':U, string( giQuerySeq ) )
    hidden         = yes
    width          = 150
    max-width      = 1024
    height         = 18
    max-height     = 1024
    scroll-bars    = no
    status-area    = no
    three-d        = yes
    message-area   = no
    sensitive      = yes
    title          = gcTitlePrefix
  triggers:
    
    on end-error anywhere
      persistent run qg_MoveToTop in target-procedure.
    
    on window-close
      persistent run qg_QueryWindowClose in target-procedure
                       (hWindow,
                        ?).
    
    on window-resized
      persistent run qg_QueryWindowResize in target-procedure
                       (hWindow).
    
    on entry
      persistent run qg_QueryWindowEntry in target-procedure
                       (hWindow).
    
    on shift-alt-cursor-up anywhere /* Dock up */
      persistent run qg_QueryWindowDock in target-procedure
                       (hWindow,
                        {&K_DIRECTION_UP}).
    
    on shift-alt-cursor-down anywhere /* Dock down */
      persistent run qg_QueryWindowDock in target-procedure
                       (hWindow,
                        {&K_DIRECTION_DOWN}).
    
    on shift-alt-cursor-left anywhere /* Dock left */
      persistent run qg_QueryWindowDock in target-procedure
                       (hWindow,
                        {&K_DIRECTION_LEFT}).
    
    on shift-alt-cursor-right anywhere /* Dock right */
      persistent run qg_QueryWindowDock in target-procedure
                       (hWindow,
                        {&K_DIRECTION_RIGHT}).
    
    on shift-f9 anywhere /* Set size small */
      persistent run qg_QueryWindowSetSize in target-procedure
                       (hWindow,
                        {&K_QUERY_SIZE_MODE_DEFAULT_SPLITTER}).
    
    on shift-f10 anywhere /* Set size smaller */
      persistent run qg_QueryWindowSetSize in target-procedure
                       (hWindow,
                        {&K_QUERY_SIZE_MODE_SMALL}).
    
    on shift-f11 anywhere /* Set size minimum */
      persistent run qg_QueryWindowSetSize in target-procedure
                       (hWindow,
                        {&K_QUERY_SIZE_MODE_MINIMUM}).
    
    on shift-f12 anywhere /* Set size default */
      persistent run qg_QueryWindowSetSize in target-procedure
                       (hWindow,
                        {&K_QUERY_SIZE_MODE_BIG}).
    
    on ctrl-f7 anywhere /* Show query window */
      persistent run qg_OpenQueryWindowListWindow in target-procedure.
    
  end triggers.

assign
  iXPos = qg_dParamListReadValue(pcParamList,
                                 'XPos':U,
                                 {&K_PARAM_SPLITTER})
  iYPos = qg_dParamListReadValue(pcParamList,
                                 'YPos':U,
                                 {&K_PARAM_SPLITTER})
  .

if    iXPos > 0
  and iYPos > 0 then
  run qg_SetWindowPos(hWindow, iXPos, iYPos).

create bttQueryWindow.

assign
  bttQueryWindow.WindowHandle = hWindow
  bttQueryWindow.QuerySeq     = iopiQuerySeq
  bttQueryWindow.WindowMode   = piWindowMode
  iObjSourceQuerySeq          = qg_iParamListReadValue(pcParamList,
                                                       'ObjSourceQuerySeq':U,
                                                       {&K_PARAM_SPLITTER}).
  .

if iObjSourceQuerySeq > 0 then
do:
  
  assign
    bttQueryWindow.ObjSourceQuerySeq   = iObjSourceQuerySeq
    bttQueryWindow.ObjSourceBufferName = qg_cParamListReadValue(pcParamList,
                                                                'ObjSourceBufferName':U,
                                                                {&K_PARAM_SPLITTER})
    bttQueryWindow.ObjSourceFieldName  = qg_cParamListReadValue(pcParamList,
                                                                'ObjSourceFieldName':U,
                                                                {&K_PARAM_SPLITTER})
    bttQueryWindow.ObjSourceFieldIndex = qg_iParamListReadValue(pcParamList,
                                                                'ObjSourceFieldIndex':U,
                                                                {&K_PARAM_SPLITTER})
    .
  
end. /* if iObjSourceQuerySeq > 0 */

validate bttQueryWindow.

if bttQueryWindow.ObjSourceQuerySeq > 0 then
  run qg_QueryWindowObjUpdateQuery(bttQueryWindow.WindowHandle).

else
  run qg_QueryWindowUpdateQuery(bttQueryWindow.WindowHandle, pcTables).

lFocusQueryText = qg_lParamListReadValue(pcParamList,
                                         'FocusQueryText':U,
                                         {&K_PARAM_SPLITTER}).

run qg_QueryWindowSetWindowMode(hWindow,
                                piWindowMode,
                                pcQueryText,
                                lFocusQueryText).

if piWindowSize <> ? then
  run qg_QueryWindowSetSize(hWindow, piWindowSize).

if plInitMode then
  run qg_QueryWindowSetQueryText(bttQueryWindow.WindowHandle, pcQueryText).

else
do:
  
  hWindow:hidden = no.
  
  run qg_QueryWindowExecute(bttQueryWindow.WindowHandle, pcQueryText, no).
    
end. /* if plInitMode */

end procedure. /* qg_ExecQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ExecRecentQuery hQueryWindow 
PROCEDURE qg_ExecRecentQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Execute a recent query.                                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/* pcQueryText                    = Query text that should be executed.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow    as handle    no-undo.
define input parameter pcQueryText as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

run qg_AddRecentQuery(bttQueryWindow.WindowHandle).

run qg_QueryWindowQuerySetQueryText(bttQueryWindow.WindowHandle,
                                    pcQueryText,
                                    no).

run qg_QueryWindowExecute(bttQueryWindow.WindowHandle, ?, no).

end procedure. /* qg_ExecRecentQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ExecuteCommand hQueryWindow 
PROCEDURE qg_ExecuteCommand :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Execute command (used for Developer Studio interaction).                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    PKS                                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcParamList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cCommand as character no-undo.
define variable cTableName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cCommand = qg_cParamListReadValue(pcParamList,
                                  'command':U,
                                  {&K_PARAM_SPLITTER}).

case cCommand:
  
  when 'insert_query':U then
    run qg_InsertQueryText.
  
  when 'insert_buffer_definition':U then
    run qg_InsertBufferDefinition.
  
  when 'insert_assign_statement':U then
    run qg_InsertFieldAssignStatement.
  
  when 'insert_field_assignment':U then
    run qg_InsertFieldAssigments.
  
  when 'select_table':U then
  do:
    
    cTableName = qg_cParamListReadValue(pcParamList,
                                        'table_name':U,
                                        {&K_PARAM_SPLITTER}).
    
    if cTableName > '':U then
      run qg_SelectTable(cTableName, yes).
    
  end. /* when 'set_table':U */
  
end case. /* cCommand */

end procedure. /* qg_ExecuteCommand */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ExportBrowse hQueryWindow 
PROCEDURE qg_ExportBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Export all records of the given browse query.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = browse that should be exported.           */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBrowse as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                  as integer   no-undo.
define variable iRecordCount       as int64     no-undo.

define variable hQuery             as handle    no-undo.

define variable cColumnName        as character no-undo.
define variable hColumn            as handle    no-undo.
define variable hColumns           as handle    no-undo extent.
define variable cValue             as character no-undo.
define variable cKeyValues         as character no-undo.
define variable clLine             as longchar  no-undo.
define variable lFirstLine         as logical   no-undo initial yes.
define variable lBuffername        as logical   no-undo.
define variable lOverlayColumns    as logical   no-undo.
define variable lDeep              as logical   no-undo.
define variable lResolved          as decimal   no-undo.

define variable cAvailableColumns  as character no-undo.

define variable rCurrentRecord     as rowid     no-undo extent.

define variable lExportToClipboard as logical   no-undo
  label '':U
  view-as radio-set
    radio-buttons 
      'Export to clipboard':T, yes,
      'Export to file':T, no
  size 40 by 2
  .

define variable cExportFilename as character no-undo
  label 'Export file':T
  format 'x(1024)':U
  view-as fill-in
  size 80 by 1.

define button btnFileDialog
  label '...':T
  size 7 by 1.

define variable cSelectedColumns as character no-undo
  label 'Columns':T
  format 'x(30000)':U
  view-as fill-in
  size 80 by 1
  .

define button btnColumns
  label '...':T
  size 7 by 1.

define variable cSeparator as character no-undo initial ';':U
  label 'Separator':T
  format 'x(1)':U
  view-as fill-in
  size 5 by 1.

define variable lQuoteValues as logical   no-undo initial yes
  label 'Quote values':T
  view-as toggle-box
  size 16 by 1
  .

define variable lExportHeader as logical   no-undo initial yes
  label 'Header':T
  view-as toggle-box
  size 12 by 1.

define variable lLabelHeader as logical   no-undo
  label 'Header':T
  view-as radio-set horizontal expand
    radio-buttons
      'Labels':T, yes,
      'Fieldnames':T, no
      
    size 28 by 1
  .

define variable lIncludeBuffername as logical   no-undo
  label 'Include buffername':T
  view-as toggle-box
  size 25 by 1.

define button btnOk
  label 'Export':T
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow        for temp-table ttQueryWindow.
define buffer bttQueryWindowField   for temp-table ttQueryWindowField.
define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.
define buffer bttFieldOverlay       for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fExport
  lExportToClipboard at row 1.5 col 12 colon-aligned no-label
  cExportFilename at row 4 col 12 colon-aligned
  btnFileDialog at row 4 col 92 colon-aligned
  cSelectedColumns at row 5.5 col 12 colon-aligned
  btnColumns at row 5.5 col 92 colon-aligned
  lExportHeader at row 7 col 12 colon-aligned
  lLabelHeader at row 7 col 30 colon-aligned no-label
  lIncludeBuffername at row 7 col 66 colon-aligned
  cSeparator at row 8.5 col 12 colon-aligned
  lQuoteValues at row 8.5 col 30 colon-aligned
  btnOk at row 10.5 col 31
  btnCancel at row 10.5 col 51
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 103 by 12.44
    title '':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fExport
  apply 'end-error' to self.

on value-changed of lExportToClipboard in frame fExport
do:
  
  assign
    lExportToClipboard                         = input frame fExport lExportToClipboard
    cExportFilename:sensitive in frame fExport = not lExportToClipboard /* code checked by mth 30.07.2015 */
    btnFileDialog:sensitive in frame fExport   = not lExportToClipboard /* code checked by mth 30.07.2015 */
    .
  
end. /* on value-changed of lExportToClipboard in frame fExport */

on choose of btnFileDialog in frame fExport
do:
  
  define variable lOk       as logical   no-undo.
  define variable cFilename as character no-undo.
  
  cFilename = input frame fExport cExportFilename.
  
  system-dialog get-file cFilename
    title             gcTitlePrefix + 'Save file as ...':U
    filters           'Comma-separated values (*.csv)':U '*.csv':U
    default-extension '.csv':U
    ask-overwrite
    save-as
    use-filename
    update lOk
    in window phBrowse:window
    .
    
  if lOk then
  do:
    
    cExportFilename = cFilename.
    
    display unless-hidden
      cExportFilename
      with frame fExport
        in window phBrowse:window.
    
  end. /* if lOk */
  
end. /* on choose of btnFileDialog in frame fExport */

on choose of btnColumns in frame fExport
do:
  
  define variable lOk as logical   no-undo.
  
  run qg_SelectionDialog(cAvailableColumns,
                         cAvailableColumns,
                         input-output cSelectedColumns,
                         'Select columns':T,
                         phBrowse:window,
                         yes,
                         output lOk).
  
  if lOk then
    display unless-hidden
      cSelectedColumns
      with frame fExport.
  
end. /* on choose of btnColumns in frame fExport */

on 'value-changed':U of lExportHeader in frame fExport
do:
  
  lLabelHeader:sensitive in frame fExport /* code checked by mth */
      = input frame fExport lExportHeader.
  
  apply 'value-changed':U to lLabelHeader in frame fExport.
  
end. /* on 'value-changed':U of lExportHeader in frame fExport */

on 'value-changed':U of lLabelHeader in frame fExport
  lIncludeBuffername:sensitive in frame fExport /* code checked by mth */
      =     input frame fExport lExportHeader
        and not input frame fExport lLabelHeader.

assign
  lBuffername        = (phBrowse:query:num-buffers > 1)
  cAvailableColumns  = qg_cBrowseColumnList(phBrowse,
                                            lBuffername,
                                            yes,
                                            no)
  cSelectedColumns   = qg_cBrowseColumnList(phBrowse,
                                            lBuffername,
                                            no,
                                            no)
  cExportFilename    = (if gcExportFilename > '':U then
                          gcExportFilename
                        else
                          substitute(qg_cFileName('%Temp%\&1.csv':U),
                                     phBrowse:query:get-buffer-handle(1):name))
  .

assign
  frame fExport:title                         = gcTitlePrefix + 'Export records':U
  cSelectedColumns:read-only in frame fExport = yes
  .

update unless-hidden
  lExportToClipboard
  cExportFilename
  btnFileDialog
  cSelectedColumns
  btnColumns
  lExportHeader
  lLabelHeader
  lIncludeBuffername
  cSeparator
  lQuoteValues
  btnOk
  btnCancel
  with frame fExport
    in window phBrowse:window.

display unless-hidden
  'Exporting Browse lines ...':T
    @ gcStatusText60
  with frame fStatus
    no-labels
    overlay
    color messages
    centered
    view-as dialog-box
    width 65
    in window phBrowse:window
    .

process events.

/* Get all export columns */

extent( hColumns ) = num-entries( cSelectedColumns ).

do i = 1 to phBrowse:num-columns:
  
  assign
    hColumn     = phBrowse:get-browse-column(i)
    cColumnName = qg_cColumnFieldName(hColumn,
                                      lBuffername)
    .
  
  if lookup(cColumnName, cSelectedColumns) > 0 then
    hColumns[lookup(cColumnName, cSelectedColumns)] = hColumn.
  
end. /* do i = 1 to phBrowse:num-columns */

if lExportToClipboard then
  output stream strExport to 'clipboard':U.

else
  output stream strExport to value(cExportFilename).

clLine = '':U.

/* Expport header. */
if lExportHeader then
do:
  
  do i = 1 to extent(hColumns):
    
    assign
      cValue  = (if lLabelHeader then
                   hColumns[i]:label
                 else
                   qg_cColumnFieldName(hColumns[i],
                                       lIncludeBuffername))
      clLine  = substitute('&1&2&3':U,
                           clLine,
                           (if i = 1 then
                              '':U
                            else
                              cSeparator),
                           (if lQuoteValues then
                              quoter(cValue)
                            else
                              cValue))
      .
    
  end. /* do i = 1 to extent(hColumns) */
  
  clLine = substitute('&1~n':U,
                      clLine).
  
  run qg_WriteExportLine(clLine).
  
end. /* if lExportHeader */

/* Export browser content. */

assign
  hQuery          = phBrowse:query
  lOverlayColumns = can-find( first ttFieldOverlay
                                where ttFieldOverlay.OwnerHandle = hQuery )
  .

if lOverlayColumns then
do:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = phBrowse:window
    no-error.
  
  if available bttQueryWindow then
    lDeep = bttQueryWindow.DeepResolveObjectIds.
  
end. /* if lOverlayColumns */

extent(rCurrentRecord) = hQuery:num-buffers.

do i = 1 to hQuery:num-buffers:
  rCurrentRecord[i] = hQuery:get-buffer-handle(i):rowid.
end. 

hQuery:get-first().

do while not hQuery:query-off-end:
  
  assign
    iRecordCount = iRecordCount + 1
    clLine       = '':U
    .
  
  if iRecordCount mod 5000 = 0 then
  do:
    
    display unless-hidden
      substitute('Exporting Browse lines &1 ...':T,
                 trim(string(iRecordCount, {&K_MAX_INT64_FORMAT})))
        @ gcStatusText60
      with frame fStatus
        no-labels
        overlay
        color messages
        centered
        view-as dialog-box
        width 65
        in window phBrowse:window
        .
    
    process events.
    
  end. /* if iRecordCount mod 5000 = 0 */
  
  BrowseColumn:
  do i = 1 to extent( hColumns )
    on error undo, next:
    
    cValue = '':U.
    
    if valid-handle( hColumns[i]:buffer-field ) then
      
      cValue = hColumns[i]:buffer-field:buffer-value(hColumns[i]:index).
    
    else
    do:
      
      find bttVirtualFieldColumn
        where bttVirtualFieldColumn.OwnerHandle  = hQuery
          and bttVirtualFieldColumn.ColumnHandle = hColumns[i]
        no-error.
      
      if available bttVirtualFieldColumn then
        
        cValue = string( qg_clVirtualFieldValueAsLongchar( bttVirtualFieldColumn.FieldType,
                                                           bttVirtualFieldColumn.DataType,
                                                           bttVirtualFieldColumn.FieldName,
                                                           qg_cObjectIdForBuffer( bttVirtualFieldColumn.BufferHandle ),
                                                           ? ) ).
      
      else
      
        if lOverlayColumns then
        do:
          
          find first bttFieldOverlay
            where bttFieldOverlay.OwnerHandle         = hQuery
              and bttFieldOverlay.OverlayColumnHandle = hColumns[i]
            no-error.
          
          if available bttFieldOverlay then
            
            run qg_GetOverlayColumnValue( buffer bttFieldOverlay,
                                          lDeep,
                                          yes,
                                          output cValue,
                                          output lResolved ).
          
        end. /* if lOverlayColumns */
      
    end. /* else: if valid-handle( hColumns[i]:buffer-field ) */
    
    finally:
      
      clLine  = substitute('&1&2&3':U,
                           clLine,
                           (if i = 1 then
                              '':U
                            else
                              cSeparator),
                           (if lQuoteValues then
                              quoter(cValue)
                            else
                              cValue)).
      
    end finally.
    
  end. /* do i = 1 to extent(hColumns) */
  
  if not lFirstLine then
    clLine = substitute('~n&1':U,
                        clLine).
    
  else
    lFirstLine = no.
  
  run qg_WriteExportLine(clLine).
  
  hQuery:get-next().
  
end. /* do while not hQuery:query-off-end */

hide frame fStatus.

message /* code checked by mth */
  substitute('&1 records have been exported':T,
             iRecordCount) skip
  view-as alert-box
  information
  buttons ok
  in window phBrowse:window.

gcExportFilename = cExportFilename.

hQuery:reposition-to-rowid(rCurrentRecord).

finally:
  output stream strExport close.
end finally.
  
end procedure. /* qg_ExportBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_FillQueryRange hQueryWindow 
PROCEDURE qg_FillQueryRange :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set radio buttons for queryrange radio-set according to selected query     */
/* type.                                                                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabase     as character no-undo.
define variable cTable        as character no-undo.
define variable cIndex        as character no-undo.

define variable cFieldList    as character no-undo.

define variable i             as integer   no-undo.
define variable cRadioButtons as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cDatabase     = (if available ttDatabase then
                     ttDatabase.DatabaseName
                   else
                     '':U)
  cTable        = (if available ttTable then
                     ttTable.TableName
                   else
                     '':U)
  cIndex        = (if available(ttIndex) then
                     ttIndex.IndexName
                   else
                     '':U)
  giQueryType   = (if glSlimMode then
                     {&K_DEFAULT_QUERY_TYPE}
                   else
                     input frame {&FRAME-NAME} giQueryType)
  giDisplayMode = input frame {&FRAME-NAME} giDisplayMode
  cRadioButtons = giQueryTypeModifier:radio-buttons in frame {&FRAME-NAME}
  .

do i = giQueryTypeModifier:num-buttons in frame {&FRAME-NAME} to 1 by -1:
  giQueryTypeModifier:delete(entry(i * 2 - 1, cRadioButtons)) in frame {&FRAME-NAME}.
end. /* do i = num-entries(giQueryTypeModifier:num-items) to 1 by -1 */

case giQueryType:
  
  when {&K_QUERYTYPE_FINDFIRST} then
  do:
    
    giQueryTypeModifier:add-last('unique':T, {&K_QUERYRANGE_DEFAULT}) in frame {&FRAME-NAME}.
    giQueryTypeModifier:add-last('first':T, {&K_QUERYRANGE_FIRST}) in frame {&FRAME-NAME}.
    giQueryTypeModifier:add-last('last':T, {&K_QUERYRANGE_LAST}) in frame {&FRAME-NAME}.
    
  end. /* {&K_QUERYTYPE_FINDFIRST} */
  
  when {&K_QUERYTYPE_FOREACH} then
  do:
    
    giQueryTypeModifier:add-last('each':T, {&K_QUERYRANGE_DEFAULT}) in frame {&FRAME-NAME}.
    giQueryTypeModifier:add-last('first':T, {&K_QUERYRANGE_FIRST}) in frame {&FRAME-NAME}.
    giQueryTypeModifier:add-last('last':T, {&K_QUERYRANGE_LAST}) in frame {&FRAME-NAME}.
    
  end. /* {&K_QUERYTYPE_FOREACH} */
  
  when {&K_QUERYTYPE_CANFIND} then
  do:
    
    giQueryTypeModifier:add-last('unique':T, {&K_QUERYRANGE_DEFAULT}) in frame {&FRAME-NAME}.
    giQueryTypeModifier:add-last('first':T, {&K_QUERYRANGE_FIRST}) in frame {&FRAME-NAME}.
    giQueryTypeModifier:add-last('last':T, {&K_QUERYRANGE_LAST}) in frame {&FRAME-NAME}.
    
  end. /* {&K_QUERYTYPE_CANFIND} */
  
end case. /* giQueryType */

if   giDisplayMode <> {&K_DISPLAYMODE_INDEX} then
  cFieldList = qg_cCurrentFieldList().

giQueryTypeModifier = ( if giQueryType = {&K_QUERYTYPE_FOREACH} then
                          {&K_QUERYRANGE_DEFAULT}
                        else
                          if    ( giQueryType = {&K_QUERYTYPE_FINDFIRST}
                              and glAlwaysUseFindFirst )
                             or ( giQueryType = {&K_QUERYTYPE_CANFIND}
                              and glAlwaysUseCanFindFirst ) then
                            {&K_QUERYRANGE_FIRST}
                        else
                          if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                            and glInvertQuery then
                            ( if    not available ttTableRelationView
                                 or num-entries(ttTableRelationView.RelatedFieldList) = 0
                                 or not qg_lUniqueQuery(ttTableRelationView.DatabaseName,
                                                        ttTableRelationView.RelatedTableName,
                                                        ttTableRelationView.RelatedFieldList) then
                                {&K_QUERYRANGE_FIRST}
                              else
                                {&K_QUERYRANGE_DEFAULT} )
                          else
                            ( if    ( giDisplayMode <> {&K_DISPLAYMODE_INDEX}
                                  and ( num-entries(cFieldList) = 0
                                     or not qg_lUniqueQuery(cDatabase,
                                                            cTable,
                                                            cFieldList) )
                                 or  ( giDisplayMode = {&K_DISPLAYMODE_INDEX}
                                   and ( not available ttIndex
                                      or not ttIndex.IsUnique ) ) ) then
                                {&K_QUERYRANGE_FIRST}
                              else
                                {&K_QUERYRANGE_DEFAULT} ) ).

/* The display statement causes unexpected focus behaviour so just set        */
/* screen-value instead.                                                      */

giQueryTypeModifier:screen-value in frame {&FRAME-NAME} = string(giQueryTypeModifier).

/*
display unless-hidden
  giQueryTypeModifier
  with frame {&FRAME-NAME}.
*/

end procedure. /* qg_FillQueryRange */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_FindObjectIdRecord hQueryWindow 
PROCEDURE qg_FindObjectIdRecord :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phParentWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cObjectIdDatabaseName as character no-undo.
define variable cObjectIdTableName    as character no-undo.

define variable cQueryText            as character no-undo.
define variable cParamList            as character no-undo.

define variable iQuerySeq             as integer   no-undo initial ?.

define variable cObjectId as character no-undo
  format 'x(1024)':U
  view-as fill-in
  size 65 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fObjectId
    'Please enter object id:':T view-as text size 45 by 1 at col 3 row 1.5
    cObjectId at row 2.5 col 3 no-label
    btnOk at row 4.5 col 16
    btnCancel at row 4.5 col 36
  with 1 down keep-tab-order overlay
    view-as dialog-box
    side-labels no-underline three-d 
    size 71 by 6.44
    title gcTitlePrefix + 'Find object id':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fObjectId
  apply 'end-error' to self.

if not available ttDatabase then
do:
  
  message
    'No database selected!':U skip
    view-as alert-box
    error
    buttons ok.
  
  leave.
  
end. /* if not available ttDatabase */

update unless-hidden
  cObjectId
  btnOk
  btnCancel
  with frame fObjectId
    in window phParentWindow.

run qg_GetObjectIdTable(ttDatabase.DatabaseName,
                        cObjectId,
                        output cObjectIdDatabaseName,
                        output cObjectIdTableName).

assign
  cQueryText =   'for each &1'
               + '~n':U + '  where &1.&1_Obj = ~'&2~'':U
  cQueryText = substitute(cQueryText, cObjectIdTableName, cObjectId)
  .

run qg_ExecQuery({&K_QUERY_WINDOW_MODE_Record},
                 {&K_RECORD_SIZE_MODE_DEFAULT},
                 substitute('&1.&2':U,
                            cObjectIdDatabaseName,
                            cObjectIdTableName),
                 cQueryText,
                 no,
                 cParamList,
                 input-output iQuerySeq).


end procedure. /* qg_FindObjectIdRecord */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_FixCase hQueryWindow 
PROCEDURE qg_FixCase :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fix case of content in given widget.                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWidget                       = Widget whose content should be fixed.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWidget       as handle    no-undo.

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

define input parameter piCaseMode     as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                as integer   no-undo.
define variable j                as integer   no-undo.
define variable cWidgetValue     as character no-undo.
define variable cEntry           as character no-undo.
define variable lTempDB          as logical   no-undo.
define variable cChar            as character no-undo.
define variable cEntryPrefix     as character no-undo.
define variable cEntrySuffix     as character no-undo.
define variable cReferenceString as character no-undo.
define variable cNewEntry        as character no-undo.
define variable lQuotes          as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase          for temp-table ttDatabase.
define buffer bttTable             for temp-table ttTable.
define buffer bttField             for temp-table ttField.
define buffer bttIndex             for temp-table ttIndex.
define buffer bttTableRelationView for temp-table ttTableRelationView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cWidgetValue  = phWidget:input-value.

find bttDatabase
  where bttDatabase.DatabaseName = pcDatabaseName
  no-error.

lTempDB = (    available bttDatabase
           and bttDatabase.TempDB).

do i = 1 to num-entries(cWidgetValue):
  
  assign
    cEntry       = trim(entry(i, cWidgetValue))
    lQuotes      = (cWidgetValue matches '"*"':U)
    cEntryPrefix = '':U
    cEntrySuffix = '':U
    .
  
  if lQuotes then
    cEntry = trim(cEntry, '"':U).
  
  else
  do:
    
    /* Extract prefix. */
    j = 1.
    
    do while j <= length(cEntry):
      
      cChar = substring(cEntry, j, 1).
      
      if   cChar = '*':U
        or cChar = '.':U
        or cChar = '!':U then
        cEntryPrefix = cEntryPrefix + cChar.
      
      else
        leave.
      
      j = j + 1.
      
    end. /* do while yes */
    
    cEntry = substring(cEntry, length(cEntryPrefix) + 1).
    
    /* Extract suffix. */
    j = length(cEntry).
    
    do while j >= 1:
      
      cChar = substring(cEntry, j, 1).
      
      if   cChar = '*':U
        or cChar = '.':U
        or cChar = '!':U then
        cEntrySuffix = cEntrySuffix + cChar.
      
      else
        leave.
      
      j = j - 1.
      
    end. /* do while yes */
    
    cEntry = substring(cEntry, 1, length(cEntry) - length(cEntrySuffix)).
    
  end. /* if lQuotes */
  
  /* If entry contains wildcards do nothing. */
  if   length(cEntry)       = 0
    or index(cEntry, '*':U) > 0
    or index(cEntry, '.':U) > 0
    or index(cEntry, '!':U) > 0 then
    next.
  
  cReferenceString = '':U.
  
  case piCaseMode:
    
    when {&K_CASEMODE_TABLE} then
    do:
      
      do j = 0 to integer(lTempDB):
        
        if    j = 1
          and cEntry begins 'tt':U then
          cEntry = substitute('td&1':U, substring(cEntry, 3)).
        
        find first bttTable
          where bttTable.DatabaseName = pcDatabaseName
            and bttTable.TableName    = cEntry
          no-error.
        
        if not lQuotes then
        do:
          
          if not available bttTable then
            find first bttTable
              where bttTable.DatabaseName   = pcDatabaseName
                and bttTable.TableName begins cEntry
              no-error.
          
          if not available bttTable then
            find first bttTable
              where bttTable.DatabaseName    = pcDatabaseName
                and bttTable.TableName matches substitute('*&1*':U, cEntry)
                no-error.
          
        end. /* if not lQuotes */
        
        if available bttTable then
          leave.
        
      end. /* do j = 0 to integer(lTempDB) */
      
      if available bttTable then
        cReferenceString = bttTable.TableName.
        
      
    end. /* when {&K_CASEMODE_TABLE} */
    
    when {&K_CASEMODE_FIELD} then
    do:
      
      find first bttField
        where bttField.DatabaseName = pcDatabaseName
          and bttField.FieldName    = cEntry
        no-error.
      
      if not lQuotes then
      do:
        
        if not available bttField then
          find first bttField
            where bttField.DatabaseName   = pcDatabaseName
              and bttField.FieldName begins cEntry
            no-error.
        
        if not available bttField then
          find first bttField
            where bttField.DatabaseName    = pcDatabaseName
              and bttField.FieldName matches substitute('*&1*':U, cEntry)
              no-error.
        
      end. /* if not lQuotes */
      
      if available bttField then
        cReferenceString = bttField.FieldName.
      
    end. /* when {&K_CASEMODE_FIELD} */
    
    when {&K_CASEMODE_TABLE_FIELD} then
    do:
      
      find first bttField
        where bttField.DatabaseName = pcDatabaseName
          and bttField.TableName    = pcTableName
          and bttField.FieldName    = cEntry
        no-error.
      
      if not lQuotes then
      do:
        
        if not available bttField then
          find first bttField
            where bttField.DatabaseName   = pcDatabaseName
              and bttField.TableName      = pcTableName
              and bttField.FieldName begins cEntry
            no-error.
        
        if not available bttField then
          find first bttField
            where bttField.DatabaseName    = pcDatabaseName
              and bttField.TableName       = pcTableName
              and bttField.FieldName matches substitute('*&1*':U, cEntry)
              no-error.
        
      end. /* if not lQuotes */
      
      if available bttField then
        cReferenceString = bttField.FieldName.
      
    end. /* when {&K_CASEMODE_TABLE_FIELD} */
    
    when {&K_CASEMODE_TABLE_FIELD_LABEL} then
    do:
      
      find first bttField
        where bttField.DatabaseName = pcDatabaseName
          and bttField.TableName    = pcTableName
          and bttField.FieldLabel   = cEntry
        no-error.
      
      if not lQuotes then
      do:
        
        if not available bttField then
          find first bttField
            where bttField.DatabaseName    = pcDatabaseName
              and bttField.TableName       = pcTableName
              and bttField.FieldLabel begins cEntry
            no-error.
        
        if not available bttField then
          find first bttField
            where bttField.DatabaseName     = pcDatabaseName
              and bttField.TableName        = pcTableName
              and bttField.FieldLabel matches substitute('*&1*':U, cEntry)
              no-error.
        
      end. /* if not lQuotes */
      
      if available bttField then
        cReferenceString = bttField.FieldLabel.
      
    end. /* when {&K_CASEMODE_TABLE_FIELD_LABEL} */
    
    when {&K_CASEMODE_TABLE_INDEX} then
    do:
      
      find first bttIndex
        where bttIndex.DatabaseName = pcDatabaseName
          and bttIndex.TableName    = pcTableName
          and bttIndex.IndexName    = cEntry
        no-error.
      
      if not lQuotes then
      do:
        
        if not available bttIndex then
          find first bttIndex
            where bttIndex.DatabaseName   = pcDatabaseName
              and bttIndex.TableName      = pcTableName
              and bttIndex.IndexName begins cEntry
            no-error.
        
        if not available bttIndex then
          find first bttIndex
            where bttIndex.DatabaseName    = pcDatabaseName
              and bttIndex.TableName       = pcTableName
              and bttIndex.IndexName matches substitute('*&1*':U, cEntry)
            no-error.
        
      end. /* if not lQuotes */
      
    end. /* when {&K_CASEMODE_TABLE_INDEX} */
    
    when {&K_CASEMODE_TABLE_RELATION} then
    do:
      
      find first bttTableRelationView
        where bttTableRelationView.DatabaseName       = pcDatabaseName
          and bttTableRelationView.ReferenceTableName = pcTableName
          and bttTableRelationView.RelatedTableName   = cEntry
        no-error.
      
      if not lQuotes then
      do:
        
        if not available bttTableRelationView then
          find first bttTableRelationView
            where bttTableRelationView.DatabaseName          = pcDatabaseName
              and bttTableRelationView.ReferenceTableName    = pcTableName
              and bttTableRelationView.RelatedTableName begins cEntry
            no-error.
        
        if not available bttTableRelationView then
          find first bttTableRelationView
            where bttTableRelationView.DatabaseName           = pcDatabaseName
              and bttTableRelationView.ReferenceTableName     = pcTableName
              and bttTableRelationView.RelatedTableName matches substitute('*&1*':U, cEntry)
            no-error.
        
      end. /* if not lQuotes */
      
      if available bttTableRelationView then
        cReferenceString = bttTableRelationView.RelatedTableName.
      
    end. /* when {&K_CASEMODE_TABLE_RELATION} */
    
  end case. /* phWidget */
  
  if cReferenceString > '':U then
    assign
      cNewEntry              = substring(cReferenceString,
                                         index(cReferenceString, cEntry),
                                         length(cEntry))
      entry(i, cWidgetValue) = (if lQuotes then
                                  quoter(cNewEntry)
                                else
                                  substitute('&1&2&3':U,
                                             cEntryPrefix,
                                             cNewEntry,
                                             cEntrySuffix))
        .
  
end. /* do i = 1 to num-entries(cWidgetValue) */

phWidget:screen-value = cWidgetValue.

end procedure. /* qg_FixCase */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_GetEditorSelectionInfo hQueryWindow 
PROCEDURE qg_GetEditorSelectionInfo :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write given string to the export file.                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* Stream strExport must be open before you call this procedure.              */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pclLine                        = Text line that should be written.         */
/* opiSelectionStart              = Selection Start.                          */
/* opiSelectionEnd                = Selection End.                            */
/* opiSelectionStartLine          = Line number of selection start.           */
/* opiSelectionEndLine            = Line number of selection end.             */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter phEditor              as handle    no-undo.

define output parameter opiSelectionStart     as integer   no-undo.
define output parameter opiSelectionEnd       as integer   no-undo.
define output parameter opiSelectionStartLine as integer   no-undo.
define output parameter opiSelectionEndLine   as integer   no-undo.


/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cEditorText         as character no-undo.
define variable cLine               as character no-undo.

define variable i                   as integer   no-undo.
define variable iOffset             as integer   no-undo.
define variable iLength             as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cEditorText           = phEditor:input-value
  opiSelectionStart     = (if phEditor:selection-start = ? then
                             phEditor:cursor-offset
                           else
                             phEditor:selection-start)
  opiSelectionEnd       = (if phEditor:selection-end = ? then
                             phEditor:cursor-offset
                           else
                             phEditor:selection-end - 1)
  .

do i = 1 to num-entries(cEditorText, '~n':U):
  
  assign
    cLine   = entry(i, cEditorText, '~n':U)
    iLength = length(cLine)
    iOffset = phEditor:convert-to-offset(i, 1)
    .
  
  if    iOffset           <= opiSelectionStart
    and iOffset + iLength >= opiSelectionStart then
    opiSelectionStartLine = i.
  
  if    iOffset           <= opiSelectionEnd
    and iOffset + iLength >= opiSelectionEnd then
    opiSelectionEndLine = i.
  
end. /* do i = 1 to num-entries(cEditorText, '~n':U) */

end procedure. /* qg_GetEditorSelectionInfo */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_GetExternalReference hQueryWindow 
PROCEDURE qg_GetExternalReference :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show selection dialog for external reference.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* pcTableName                    = Table name for reference suggestion.      */
/* pcFieldName                    = Field name for reference suggestion.      */
/* plFieldReference               = Flag to indicate wether a field reference */
/*                                  or a table refenece should be entered.    */
/* pcQueryWindowList              = List of query windows that may be used as */
/*                                  Reference source.                         */
/* phParentWindow                 = Parent window for the dialog.             */
/* opcReferenceText               = contains the selected external reference. */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcTableName       as character no-undo.
define input  parameter pcFieldName       as character no-undo.
define input  parameter plFieldReference  as logical   no-undo.
define input  parameter pcQueryWindowList as character no-undo.
define input  parameter phParentWindow    as handle    no-undo.
define output parameter opcReferenceText  as character no-undo initial ?.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lOk             as logical   no-undo.
define variable lRecidReference as logical   no-undo.
define variable iQuerySeq       as integer   no-undo.
define variable cBufferName     as character no-undo.
define variable cFieldName      as character no-undo.
define variable iFieldIndex     as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_SelectExternalReference( pcTableName,
                                pcFieldName,
                                plFieldReference,
                                pcQueryWindowList,
                                phParentWindow,
                                output lOk,
                                output lRecidReference,
                                output iQuerySeq,
                                output cBufferName,
                                output cFieldName,
                                output iFieldIndex ).

if lOk then
  opcReferenceText = ( if plFieldReference then
                         substitute('$~{&1:&2~}':U,
                                    string( iQuerySeq ),
                                    qg_cFormattedFieldName( ?,
                                                            cBufferName,
                                                            cFieldName,
                                                            iFieldIndex ) )
                       else
                         if lRecidReference then
                                     substitute('$~{&1:recid(&2)~}':U,
                                                string( iQuerySeq ),
                                                cBufferName )
                       else
                         substitute( '$~{&1:rowid(&2)~}':U,
                                     string( iQuerySeq ),
                                     cBufferName ) ).

end procedure. /* qg_GetExternalReference */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_GetObjectIdTable hQueryWindow 
PROCEDURE qg_GetObjectIdTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcDatabaseName  as character no-undo.
define input  parameter pcObjectId      as character no-undo.
define output parameter opcDatabaseName as character no-undo.
define output parameter opcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTableName      as character no-undo.
define variable cTableId        as character no-undo.

define variable hRepTableBuffer as handle    no-undo.
define variable hRepFieldBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase  for temp-table ttDatabase.
define buffer b2ttDatabase for temp-table ttDatabase.
define buffer bttTable     for temp-table ttTable.
define buffer bttField     for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    num-entries(pcObjectId, ':':U) = 1
  and length(pcObjectId) <= 32
  and pcObjectId matches '*_Obj':U then
do:
  
  /*  Find table by table name */
  
  cTableName = substring(pcObjectId, 1, length(pcObjectId) - 4).
  
  find bttDatabase
    where bttDatabase.DatabaseName = pcDatabaseName
    no-error.
  
  if not available bttDatabase then
    leave.
  
  TABLE_SEARCH:
  for each b2ttDatabase
    where b2ttDatabase.DatabaseName = bttDatabase.DatabaseName
       or b2ttDatabase.DatabaseName = bttDatabase.BasisDBName
       or b2ttDatabase.BasisDB      = yes
       or yes
    on error undo, throw:
    
    if not can-find(first ttTable
                      where ttTable.DatabaseName = bttDatabase.DatabaseName) then
      run qg_AddTables(bttDatabase.DatabaseName).
    
    for each bttTable
      where bttTable.DatabaseName = b2ttDatabase.DatabaseName
        and bttTable.TableName    = cTableName,
    first bttField
      where bttField.DatabaseName = bttTable.DatabaseName
        and bttField.TableName    = bttTable.TableName
        and bttField.FieldName    = substitute('&1_Obj':U, bttTable.TableName)
      on error undo, throw:
      
      leave TABLE_SEARCH.
    
    end. /* for each bttTable */
    
  end. /* for each b2ttDatabase */
  
end. /* if num-entries(pcObjectId, ':':U) = 1 */

else if num-entries(pcObjectId, ':':U) = 3 then
do:
  
  cTableId = entry(1, pcObjectId, ':':U).
  
  if   cTableId = ?
    or cTableId = '':U then
    leave.
  
  find bttDatabase
    where bttDatabase.DatabaseName = pcDatabaseName
    no-error.
  
  if not available bttDatabase then
    leave.
  
  /* Step 1: try to find the table in the local cache. */
  
  TABLE_SEARCH:
  for each b2ttDatabase
    where b2ttDatabase.DatabaseName = bttDatabase.DatabaseName
       or b2ttDatabase.DatabaseName = bttDatabase.BasisDBName
       or b2ttDatabase.BasisDB      = yes
       or yes
    on error undo, throw:
    
    if not can-find(first ttTable
                      where ttTable.DatabaseName = bttDatabase.DatabaseName) then
      run qg_AddTables(bttDatabase.DatabaseName).
    
    for each bttTable
      where bttTable.DatabaseName       = b2ttDatabase.DatabaseName
        and bttTable.InternalIdentifier = cTableId,
    first bttField
      where bttField.DatabaseName = bttTable.DatabaseName
        and bttField.TableName    = bttTable.TableName
        and bttField.FieldName    = substitute('&1_Obj':U, bttTable.TableName)
      on error undo, throw:
      
      leave TABLE_SEARCH.
    
    end. /* for each bttTable */
    
  end. /* for each b2ttDatabase */
  
  /* Step 2: try to find the table in the pA repository tables and load it into */
  /*         the cache                                                          */
  
  if not available bttTable then
  do:
    
    TABLE_SEARCH:
    for each b2ttDatabase
      where b2ttDatabase.DatabaseName = bttDatabase.DatabaseName
         or b2ttDatabase.DatabaseName = bttDatabase.BasisDBName
         or b2ttDatabase.BasisDB      = yes
         or yes
      on error undo, throw:
      
      create buffer hRepTableBuffer for table substitute('&1.&2':U,
                                                         b2ttDatabase.DatabaseName,
                                                         'DRC_Table':U) no-error.
      
      if not valid-handle(hRepTableBuffer) then
        next.
      
      hRepTableBuffer:find-first(substitute('where DRC_Table.InternalIdentifier = &1':U,
                                            quoter(cTableId)),
                                 no-lock) no-error.
      
      if hRepTableBuffer:available then
      do:
        
        run qg_AddTableDetails(b2ttDatabase.DatabaseName,
                               hRepTableBuffer::DRC_Table_ID).
        
        for each bttTable
          where bttTable.DatabaseName       = b2ttDatabase.DatabaseName
            and bttTable.InternalIdentifier = cTableId,
        first bttField
          where bttField.DatabaseName = bttTable.DatabaseName
            and bttField.TableName    = bttTable.TableName
            and bttField.FieldName    = substitute('&1_Obj':U, bttTable.TableName)
          on error undo, throw:
          
          leave TABLE_SEARCH.
        
        end. /* for each bttTable */
        
      end. /* if hRepTableBuffer:available */
      
      finally:
        
        if valid-handle(hRepTableBuffer) then
          delete object hRepTableBuffer.
        
      end finally.
      
    end. /* for each b2ttDatabase */
    
  end. /* if not available bttTable */
  
end. /* else if num-entries(pcObjectId, ':':U) = 3 */

if available bttTable then
  assign
    opcDatabaseName = bttTable.DatabaseName
    opcTableName    = bttTable.TableName
    .

end procedure. /* qg_GetObjectIdTable */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_GetOffsetLine hQueryWindow 
PROCEDURE qg_GetOffsetLine :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get line number for given offset.                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcText                         = Text that contains the line.              */
/* piOffset                       = Offset for which the line number should   */
/*                                  be determined.                            */
/* opiLine                        = Line number of offset.                    */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcText   as character no-undo.
define input  parameter piOffset as integer   no-undo extent.
define output parameter opiLine  as integer   no-undo extent.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i           as integer   no-undo.
define variable j           as integer   no-undo.

define variable iLineLength as integer   no-undo.
define variable iOffset     as integer   no-undo initial 1.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

extent(opiLine) = extent(piOffset).

do i = 1 to num-entries(pcText, '~n':U):
  
  iLineLength = length(entry(i, pcText, '~n':U)).
  
  do j = 1 to extent(piOffset):
    
    if    piOffset[j] >= iOffset
      and piOffset[j]  < iOffset + iLineLength + length('~n':U) then
      opiLine[j] = i.
    
  end. /*do j = 1 to extent(piOffset)  */
  
  iOffset = iOffset + iLineLength + length('~n':U).
  
end. /* do i = 1 to num-entries(pcText) */

end procedure. /* qg_GetOffsetLine */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_GetWindowRect hQueryWindow 
PROCEDURE qg_GetWindowRect :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get screen rectangle of window.                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Window handle.                            */
/* opiWindowX1                    = X1 coordinate of window.                  */
/* opiWindowY1                    = Y1 coordinate of window.                  */
/* opiWindowX2                    = X2 coordinate of window.                  */
/* opiWindowY2                    = Y2 coordinate of window.                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter phWindow       as handle    no-undo.

define output parameter opiWindowX1 as integer   no-undo.
define output parameter opiWindowY1 as integer   no-undo.
define output parameter opiWindowX2 as integer   no-undo.
define output parameter opiWindowY2 as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iHwnd                 as int64   no-undo.
define variable mRect                 as memptr  no-undo.
define variable iResult               as integer no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if phWindow:type = 'WINDOW':U then
  run GetParent(phWindow:hwnd,
                output iHwnd).

else
  iHwnd = phWindow:hwnd.

if iHwnd <> 0 then
do:

  set-size(mRect) = 16.
  
  run GetWindowRect(iHwnd,
                    output mRect,
                    output iResult).
  
  assign
    opiWindowX1 = get-long(mRect, 1)
    opiWindowY1 = get-long(mRect, 5)
    opiWindowX2 = get-long(mRect, 9)
    opiWindowY2 = get-long(mRect, 13)
    .
  
end. /* if iHwnd <> 0 */

end procedure. /* qg_GetWindowRect */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_IDE_InsertText hQueryWindow 
PROCEDURE qg_IDE_InsertText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert given text into ide editor.                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcText                         = Text that should be inserted.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcText as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cReturnValue     as character no-undo.

define variable iIDEWindowHandle as int64     no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if (    OEIDEIsRunning
    and glIDECanInsert
    and glInsertMode) then
do:
  
  run qg_IDE_SendRequest({&K_EDITOR_INSERT_REQUEST_HANDLER},
                         pcText,
                         yes /* plWaitForResult */,
                         output cReturnValue).
  
  if cReturnValue <> ? then
  do:
    
    iIDEWindowHandle = qg_iParamListReadValue(cReturnValue,
                                              'IDEWindowHandle':U,
                                              {&K_PARAM_SPLITTER}).
    
    if iIDEWindowHandle > 0 then
      run SetForegroundWindow(iIDEWindowHandle).
    
  end. /* if cReturnValue <> ? */
  
end. /* if (    OEIDEIsRunning ... */

end procedure. /* qg_IDE_InsertText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_IDE_SendRequest hQueryWindow 
PROCEDURE qg_IDE_SendRequest :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Send given Reqest to ide.                                                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* This has to be a procedure (may not be a function) due to progress error   */
/* 2780.                                                                      */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcHandlerName                  = Name of the request handler for the re-   */
/*                                  quest that should be sent.                */
/* pcParmeter                     = String parameter value for the request.   */
/* plWaitForResult                = If false, no result will be returned      */
/*                                  which will avoid the risk of getting      */
/*                                  stuck while waiting for the request       */
/*                                  result                                    */
/* opcReturnValue                 = Output return value.                      */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcHandlerName   as character no-undo.
define input  parameter pcParameter     as character no-undo.
define input  parameter plWaitForResult as logical   no-undo.
define output parameter opcReturnValue  as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hSocketClient as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   not OEIDEIsRunning
  or not valid-handle(hOEIDEService) then
  return ?.

hSocketClient = dynamic-function ('getSocketClient':U in hOEIDEService).

if valid-handle(hSocketClient) then
  if plWaitForResult then
  
    run SendWaitRequest in hSocketClient ( qg_iGetHandlerId(pcHandlerName),
                                           pcParameter,
                                           output opcReturnValue).

  else
    
    run SendRequest in hSocketClient ( qg_iGetHandlerId(pcHandlerName),
                                       pcParameter ).

end procedure. /* qg_IDE_SendRequest */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ImportDefinitionFile hQueryWindow 
PROCEDURE qg_ImportDefinitionFile :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Import File as Snapshot.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piImportType as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTempFileName       as character no-undo.
define variable clImportFileContent as longchar  no-undo.

define variable iMessageCounter     as integer   no-undo.

define variable cImportFilename as character no-undo
  label 'Import file':T
  format 'x(1024)':U
  view-as fill-in
  size 73 by 1.

define button btnSearch
  label '->':T
  tooltip 'Determine full path':T
  size 7 by 1.

define button btnFileDialog
  label '...':T
  size 7 by 1.

define button btnOk
  label 'Import':T
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fImport
  cImportFilename at row 1.5 col 12 colon-aligned
  btnSearch at row 1.5 col 85 colon-aligned
  btnFileDialog at row 1.5 col 92 colon-aligned
  btnOk at row 3.5 col 31
  btnCancel at row 3.5 col 51
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 103 by 5.33
    title 'Import File as Snapshot':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fImport
  apply 'end-error' to self.

on choose of btnSearch in frame fImport
do:
  
  define variable cFilename      as character no-undo.
  define variable cPath          as character no-undo.
  define variable cFilePath      as character no-undo.
  
  cFilename = input frame fImport cImportFilename.
  
  if length( cFilename ) < 2 then
    return.
  
  assign
    cPath     = qg_cModulePathByChar( cFilename )
    cPath     =   cPath
                + ( if cPath > '':U then
                      '/incl':U
                    else
                      'incl':U )
    cFilePath = search( substitute( '&1/&2':U, cPath, cFilename ) )
    .
  
  if cFilePath <> ? then
    
    display unless-hidden
      cFilePath @ cImportFilename
      with frame fImport.
  
end. /* on choose of btnSearch in frame fImport */

on choose of btnFileDialog in frame fImport
do:
  
  define variable lOk       as logical   no-undo.
  define variable cFilename as character no-undo.
  
  cFilename = input frame fImport cImportFilename.
  
  if piImportType = {&K_IMPORT_TYPE_TEMP_TABLE} then
  
    system-dialog get-file cFilename
      title             'Select TDF ...':U
      filters           'TDF-Files (*.tdf)':U '*.tdf':U,
                        'Any File (*.*)':U  '*.*':U
      default-extension '.tdf':U
      use-filename
      update lOk
      in window {&WINDOW-NAME}
      .
  
  else
    
    system-dialog get-file cFilename
      title             'Select PDS ...':U
      filters           'TDF-Files (*.pds)':U '*.pds':U,
                        'Any File (*.*)':U  '*.*':U
      default-extension '.pds':U
      use-filename
      update lOk
      in window {&WINDOW-NAME}
      .
  
  if lOk then
  do:
    
    cImportFilename = cFilename.
    
    display unless-hidden
      cImportFilename
      with frame fImport
        in window {&WINDOW-NAME}.
    
  end. /* if lOk */
  
end. /* on choose of btnFileDialog in frame fImport */

on choose of btnOk in frame fImport
do:
  
  if index( input frame fImport cImportFilename, '/\':U ) = 0 then
    apply 'choose':U to btnSearch in frame fImport.
  
end. /* on choose of btnOk in frame fImport */

frame fImport:title = substitute( '&1 Import &2 as Snapshot':U,
                                  gcTitlePrefix,
                                  ( if piImportType = {&K_IMPORT_TYPE_TEMP_TABLE} then
                                      'TDF':U
                                    else
                                      'PDS':U ) ).

DialogLoop:
do while yes
  on error undo, next
  on endkey undo, leave:
  
  update unless-hidden
    cImportFilename
    btnSearch
    btnFileDialog
    btnOk
    btnCancel
    with frame fImport
      in window {&WINDOW-NAME}.
  
  /* Check if file exists. */
  
  file-info:file-name = cImportFilename.
  
  if file-info:full-pathname = ? then
  do:
    
    message
      substitute( 'File &1 does not exist':T, quoter( cImportFilename ) ) skip
      view-as alert-box
      error
      buttons ok.
    
    apply 'error':U.
    
  end. /* if file-info:full-pathname = ? */
  
  if not file-info:file-type begins 'F':U then
  do:
    
    message
      substitute( '&1 is not a File':T, quoter( cImportFilename ) ) skip
      view-as alert-box
      error
      buttons ok.
    
    apply 'error':U.
    
  end. /* not file-info:file-type begins 'F':U */
  
  do on error undo, throw:
    
    /* Create temp file for import. */
    
    cTempFileName = substitute( qg_cFileName( '%Temp%\qg_Snapshot_&1.p':U ),
                                string( guid( generate-uuid ) ) ).
    
    do on error undo, throw.
      
      /* os-copy did not work for whatever reason. */
      
      output stream strTemp to value( cTempFileName ).
      
      put stream strTemp unformatted
        '&GLOBAL-DEFINE pa-XInclBasisName         DUMMY':U skip
        '&GLOBAL-DEFINE ippNoReferenceOnlySwitch  yes':U skip
        '~{adm/template/incl/dt_pa_00.df}':U skip
        .
      
      output stream strTemp close.
      
      copy-lob from file cImportFilename to clImportFileContent.
      copy-lob from clImportFileContent to file cTempFileName append.
      
      output stream strTemp to value( cTempFileName ) append.
      
      if piImportType = {&K_IMPORT_TYPE_TEMP_TABLE} then
        
        put stream strTemp unformatted
          '&IF defined( ppTempTableName ) &THEN':U skip
          '  publish ~'qgEvt_Snapshot~':U ( ( temp-table ~{&ppTempTableName}:handle ), ~'~{&ppTempTableName}~':U, ? ).':U skip
          '&ELSE':U skip
          '  message':U skip
          substitute( '    ~'Preprocessor "ppTempTableName" is not defined in file &1.~':U skip':U,
                      quoter( cImportFilename ) ) skip
          '    ~' ~':U skip':U skip
          '    ~'The include can not be imported.~':U skip':U skip
          '    view-as alert-box':U skip
          '    error':U skip
          '    buttons ok.':U skip
          '  apply ~'error~'.':U skip
          '&ENDIF':U skip
          .
      
      else
  
        put stream strTemp unformatted
          '&IF defined( ppDatasetName ) &THEN':U skip
          '  publish ~'qgEvt_Snapshot~':U ( ( dataset ~{&ppDatasetName}:handle ), ~'~{&ppDatasetName}~':U, ? ).':U skip
          '&ELSE':U skip
          '  message':U skip
          substitute( '    ~'Preprocessor "ppDatasetName" is not defined in file &1.~':U skip':U,
                      quoter( cImportFilename ) ) skip
          '    ~' ~':U skip':U skip
          '    view-as alert-box':U skip
          '    error':U skip
          '    buttons ok.':U skip
          '  apply ~'error~'.':U skip
          '&ENDIF':U skip
          .
      
      finally:
        
        output stream strTemp close.
        
      end finally.
      
    end.
    
    /* Check if temp file has actually been created. */
    
    file-info:file-name = cTempFileName.
    
    if file-info:full-pathname = ? then
    do:
      
      message
        substitute( 'File &1 could not be created':T, quoter( cTempFileName ) ) skip
        view-as alert-box
        error
        buttons ok.
      
      apply 'error':U.
      
    end. /* if file-info:full-pathname = ? */
    
    /* Check syntax. */
    
    do on error undo, throw:
      
      compile value( cTempFileName ).
      
      catch oError as class progress.lang.error:
        
        do iMessageCounter = 1 to oError:NumMessages:
          
          message
            oError:GetMessage( iMessageCounter ) skip
            view-as alert-box
            error
            buttons ok.
          
        end. /* do iMessageCounter = 1 to oError:NumMessages */
        
        message
          substitute( 'File &1 contains compile errors.':U,
                      quoter( cImportFilename ) ) skip
          ' ':U skip
           'The include can not be imported':T skip
          view-as alert-box
          error
          buttons ok.
        
        apply 'error':U.
        
      end catch. /* progress.lang.error */
      
    end.
    
    /* Run temp file to create the snapshot. */
    
    run value( cTempFileName ).
    
    leave DialogLoop.
    
    finally:
      
      os-delete value( cTempFileName ).
      
    end finally.
    
  end.
  
end. /* do while yes */

end procedure. /* qg_ImportDefinitionFile */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ImportFile hQueryWindow 
PROCEDURE qg_ImportFile :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Import File as Snapshot.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piImportType as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFileExt      as character no-undo.
define variable hDataObject   as handle    no-undo.
define variable cSnapshotName as character no-undo.

define variable cImportFilename as character no-undo
  label 'Import file':T
  format 'x(1024)':U
  view-as fill-in
  size 80 by 1.

define button btnFileDialog
  label '...':T
  size 7 by 1.

define button btnOk
  label 'Import':T
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fImport
  cImportFilename at row 1.5 col 12 colon-aligned
  btnFileDialog at row 1.5 col 92 colon-aligned
  btnOk at row 3.5 col 31
  btnCancel at row 3.5 col 51
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 103 by 5.33
    title '':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fImport
  apply 'end-error' to self.

on choose of btnFileDialog in frame fImport
do:
  
  define variable lOk       as logical   no-undo.
  define variable cFilename as character no-undo.
  
  cFilename = input frame fImport cImportFilename.
  
  system-dialog get-file cFilename
    title             'Open File ...':U
    filters           'XML-Files (*.xml)':U '*.xml':U,
                      'JSON-Files (*.json)':U  '*.json':U,
                      'Any File (*.*)':U  '*.*':U
    default-extension '.xml':U
    ask-overwrite
    use-filename
    update lOk
    in window {&WINDOW-NAME}
    .
  
  if lOk then
  do:
    
    cImportFilename = cFilename.
    
    display unless-hidden
      cImportFilename
      with frame fImport
        in window {&WINDOW-NAME}.
    
  end. /* if lOk */
  
end. /* on choose of btnFileDialog in frame fImport */

frame fImport:title = substitute( '&1 Import &2 from File':U,
                                  gcTitlePrefix,
                                  ( if piImportType = {&K_IMPORT_TYPE_TEMP_TABLE} then
                                      'Temp-Table':U
                                    else
                                      'Dataset':U ) ).

update unless-hidden
  cImportFilename
  btnFileDialog
  btnOk
  btnCancel
  with frame fImport
    in window {&WINDOW-NAME}.

do on error undo, throw:
  
  if piImportType = {&K_IMPORT_TYPE_TEMP_TABLE} then
    create temp-table hDataObject.
  
  else
    create dataset hDataObject.
  
  if cImportFilename matches '*.json':U then
    hDataObject:read-json( 'file':U,
                           cImportFilename,
                           'empty':U ).
    
  else
    hDataObject:read-xml( 'file':U,
                          cImportFilename,
                          'empty':U,
                          '':U,
                          false ).

  cSnapshotName = substitute('&1_&2':U,
                             hDataObject:name,
                             replace(string(time, 'HH:MM:SS':U),
                                     ':':U,
                                     '':U)).                          
  
  run qg_AddSnapshot( hDataObject, cSnapshotName, ? ).
  
  finally:
  
    if valid-handle( hDataObject ) then
      delete object hDataObject.
  
  end finally.
  
end.

end procedure. /* qg_ImportFile */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InitBrowse hQueryWindow 
PROCEDURE qg_InitBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Init given Browse (set properties, add popup menu items ...)               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = Browse that should be initialized.        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBrowse as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hPopupMenu as handle    no-undo.
define variable hDummy     as handle    no-undo.
define variable lPrevMenu  as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  phBrowse:sensitive        = yes /* code checked by mth */
  phBrowse:column-resizable = yes
  phBrowse:column-movable   = yes
  phBrowse:separators       = {&K_SHOW_GRID_ON_BROWSE}
  .

phBrowse:set-repositioned-row(3, 'CONDITIONAL':U).

hPopupMenu = phBrowse:popup-menu.

if not valid-handle(hPopupMenu) then
  create menu hPopupMenu
    assign
      name       = 'm_PopupMenu':U
      popup-only = yes
      sensitive  = yes
      .

else
  lPrevMenu = yes.

if   phBrowse:name = 'brQuery':U 
  or {&K_SELECT_COLUMN_ON_BROWSE}
  or {&K_EXPORT_ON_BROWSE}
  or {&K_RECORD_COUNT_ON_BROWSE} then
do:
  
  if lPrevMenu then
    create menu-item hDummy
      assign
        subtype = 'RULE':U
        parent  = hPopupMenu
        .
  
  if   phBrowse:name = 'brQuery':U
    or {&K_SELECT_COLUMN_ON_BROWSE} then
    create menu-item hDummy
      assign
        name         = 'mi_SelectColumnsMenuItem':U
        parent       = hPopupMenu
        label        = 'Select columns':T
        sensitive    = yes
      triggers:
        on choose
          persistent run qg_SelectBrowseColumns in target-procedure
                           (phBrowse).
      end triggers
      .
  
  if   phBrowse:name = 'brQuery':U
    or {&K_EXPORT_ON_BROWSE} then
    create menu-item hDummy
      assign
        name         = 'mi_Export':U
        parent       = hPopupMenu
        label        = 'Export records':T
        sensitive    = yes
      triggers:
        on choose
          persistent run qg_ExportBrowse in target-procedure
                           (phBrowse).
      end triggers
      .
  
  if   phBrowse:name = 'brQuery':U
    or {&K_RECORD_COUNT_ON_BROWSE} then
    create menu-item hDummy
      assign
        name         = 'mi_RecordCount':U
        parent       = hPopupMenu
        label        = 'Record count':T
        sensitive    = yes
      triggers:
        on choose
          persistent run qg_ShowBrowseRecordCount in target-procedure
                           (phBrowse).
      end triggers
      .
  
  lPrevMenu = yes.
  
end. /* if   {&K_SELECT_COLUMN_ON_BROWSE} */

if   {&K_TOGGLE_GRID_ON_BROWSE}
  or phBrowse:name = 'brQuery':U then
do:
  
  if lPrevMenu then
    create menu-item hDummy
      assign
        subtype = 'RULE':U
        parent  = hPopupMenu
        .
  
  create menu-item hDummy
    assign
      name        = 'mi_ShowGrid':U
      label       = 'Show grid':T
      toggle-box  = yes
      checked     = {&K_SHOW_GRID_ON_BROWSE}
      sensitive   = yes
      parent      = hPopupMenu
    triggers:
      on value-changed
        persistent run qg_ShowBrowseGrid in target-procedure
                         (phBrowse, hDummy).
    end triggers
    .
  
  lPrevMenu = yes.
  
end. /* if {&K_TOGGLE_GRID_ON_BROWSE} */

phBrowse:popup-menu = hPopupMenu.

on ctrl-l of phBrowse
  persistent run qg_SelectBrowseColumns in target-procedure
                   (phBrowse).

on ctrl-e of phBrowse
  persistent run qg_ExportBrowse in target-procedure
                   (phBrowse).

on ctrl-u of phBrowse
  persistent run qg_ShowBrowseRecordCount in target-procedure
                   (phBrowse).

end procedure. /* qg_InitBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_Initialize hQueryWindow 
PROCEDURE qg_Initialize :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Initialize.                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cProcName        as character no-undo.

define variable cEnvironment     as character no-undo.
define variable oDCCAppConfigSvc as class Progress.Lang.Object no-undo.

define variable iStrSize         as integer   no-undo.

define variable cDefaultFont     as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

gcCustomLevel = dynamic-invoke( 'pACStartupSvc':U, 'cParameterValue':U, 'CustomLevel':U ) no-error.

assign
  glInvertQuery:hidden in frame {&FRAME-NAME}
      = yes
  menu-item mi_ShowQueryTypeModifier:checked in menu M_Options
      = {&K_SHOW_QUERY_TYPE_MODIFIER}
  glAlwaysUseFindFirst    = {&K_ALWAYS_USE_FIND_FIRST}
  menu-item mi_AlwaysUseFindFirst:checked in menu M_Options
      = glAlwaysUseFindFirst
  glAlwaysUseCanFindFirst = {&K_ALWAYS_USE_CANFIND_FIRST}
  menu-item mi_AlwaysUseCanFindFirst:checked in menu M_Options
      = glAlwaysUseCanFindFirst
  glUseVirtualIndexApi    = {&K_DEFAULT_USE_VIRTUAL_INDEX_API}
  menu-item mi_UseVirtualIndexApi:checked in menu M_Options
      = glUseVirtualIndexApi
  cProcName               = replace(this-procedure:name, '\':U, '/':U)
  file-info:file-name     = substitute('&1/../icons':U, cProcName)
  .

run qg_SetShowQueryTypeModifier({&K_SHOW_QUERY_TYPE_MODIFIER}).

if file-info:full-pathname = ? then
  file-info:file-name = substitute('&1/../../icons':U, cProcName).

if file-info:full-pathname > '':U then
  gcIconDir = file-info:full-pathname.

if gcIconDir = '':U then
  hQueryWindow:load-icon(substitute('adeicon/sqlexp.ico':U)) no-error.

else
do:
  
  hQueryWindow:load-icon(substitute('&1/32/query_wizard.ico':U,
                                      gcIconDir)) no-error.
  
  hQueryWindow:load-small-icon(substitute('&1/16/query_wizard.ico':U,
                                          gcIconDir)) no-error.
  
end. /* if gcIconDir = '':U */

gcCursorHand = qg_cReadRegistryValue({&K_WIN_CONST_HKEY_CURRENT_USER},
                                     'Control Panel\Cursors':U,
                                     'Hand':U).

if gcCursorHand > '':U then
  run ExpandEnvironmentStringsA(gcCursorHand,
                                output gcCursorHand,
                                length(gcCursorHand),
                                output iStrSize).

get-key-value section "startup" key "DefaultFont" value cDefaultFont.

glUnicode = (session:charset = 'UTF-8':U).

if glUnicode then
  assign
    gcSpace                = chr(14909568)
    gcBulletChar1          = chr(14849926)
    gcBulletChar1White     = chr(14849927)
    gcBulletChar2          = chr(14850181)
    gcBulletChar2White     = chr(14850182)
    gcLineVertical         = chr(14849155)
    gcLineUpAndRight       = chr(14849175)
    gcLineVerticalAndRight = chr(14849187)
    .

else
  if lookup(entry(1, cDefaultFont), 'MS Sans Serif,MS Serif,System,Courier':U) = 0 then
/*  if entry(1, cDefaultFont) = 'Microsoft Sans Serif':U*/
    assign
      gcSpace                = '    ':U
      gcBulletChar1          = '':U
      gcBulletChar1White     = '':U
      gcBulletChar2          = '':U
      gcBulletChar2White     = '':U
      gcLineVertical         = '    ':U 
      gcLineUpAndRight       = '    ':U
      gcLineVerticalAndRight = '    ':U
      .
  
/*else                                                                                   */
/*  if lookup(entry(1, cDefaultFont), 'MS Sans Serif,MS Serif,System,Courier':U) = 0 then*/
  
  else
    assign
      gcSpace                = '    ':U
      gcBulletChar1          = '->':U
      gcBulletChar1White     = '->':U
      gcBulletChar2          = '=>':U
      gcBulletChar2White     = '=>':U
      gcLineVertical         = '    ':U 
      gcLineUpAndRight       = '    ':U
      gcLineVerticalAndRight = '    ':U
      .

if OEIDEIsRunning then
  gcIDEProjectName = getProjectName().

/* Try to get the session title. */
&IF keyword-all('dynamic-property':U) <> ? &THEN
  
  gcSessionTitle = dynamic-property('pACConnectionSvc':U,
                                    'prpcSessionTitle':U) no-error.
  
  &IF   keyword-all('dynamic-invoke':U) <> ?
    and keyword-all('valid-object':U)   <> ? &THEN
    
    if   gcSessionTitle       = ?
      or trim(gcSessionTitle) = '':U then
    do:
      
      cEnvironment = dynamic-invoke('pACStartupSvc',
                                    'cParameterValue':U,
                                    'Environment':U) no-error.
      
      if    not error-status:error
        and cEnvironment > '':U then
      do:
        
        oDCCAppConfigSvc = dynamic-property('adm.config.cls.DCCAppConfigSvc', 'prpoInstance') no-error.
        
        if    not error-status:error
          and valid-object(oDCCAppConfigSvc) then
        do:
        
          gcSessionTitle = trim(dynamic-invoke(oDCCAppConfigSvc,
                                               'cParamValByRefParamVal':U,
                                               'DB_Environment_desc':U,
                                               cEnvironment)) no-error.
          
        end. /* if    not error-status:error */
        
      end. /* if    not error-status:error */
      
    &ENDIF
    
  end. /* if   cSessionTitle       = ? */
  
&ENDIF

if gcSessionTitle = ? then
  gcSessionTitle = dynamic-function('pa_cConfgParameterValue':U in target-procedure,
                                    'SessionTitle':U) no-error.

if gcSessionTitle > '':U then
  gcTitlePrefix = substitute('&1 - ':U,
                             gcSessionTitle).

else if gcIDEProjectName > '':U then
  gcTitlePrefix = substitute('&1 - ':U,
                             gcIDEProjectName).

hQueryWindow:title = trim(substitute('&1Query Generator v&2':U,
                                     gcTitlePrefix,
                                     {&K_Version})).

if not valid-handle(gchMerge) then
  create 'Merge70.Application':U gchMerge no-error.

if not valid-handle(gchMerge) then
  create 'Merge65.Application':U gchMerge no-error.

if not valid-handle(gchMerge) then
  create 'Merge2000.Application':U gchMerge no-error.
/*
if valid-handle(gchMerge) then
  gchMerge:visible = no.
*/

run qg_InitializeVirtualDBFieldFramework.
run qg_InitializeVirtualIndexFramework.

menu-item mi_OpenQueryWindowPersistentTT:checked in menu m_Options = yes.

run qg_InitBrowse(browse brDatabase:handle).
run qg_InitBrowse(browse brTable:handle).
run qg_InitBrowse(browse brField:handle).
run qg_InitBrowse(browse brIndex:handle).
run qg_InitBrowse(browse brRelation:handle).

run qg_SetDefaultValues.

assign
  glSessionTriggerShowMessage = {&K_SESSIONTRIGGER_SHOWMESSAGE} 
  glSessionTriggerWriteLog    = {&K_SESSIONTRIGGER_WRITELOG} 
  gcSessionTriggerLogFileName = {&K_SESSIONTRIGGER_LOGFILENAME} 
  glSessionTriggerIndexValues = {&K_SESSIONTRIGGER_INDEXVALUES} 
  glSessionTriggerStackTrace  = {&K_SESSIONTRIGGER_STACKTRACE} 
  .

if gcSessionTriggerLogFileName = '':U then
  gcSessionTriggerLogFileName = '%Temp%\session-triggers.log':U.

/* Assign buffer prefix button labels. */

assign
  glCompanyViaClass:label in frame {&FRAME-NAME} = '{&K_CLASS_COMPANY_STATEMENT}':U
  btnBuffer1:label in frame {&FRAME-NAME}        = qg_cSubstituteChar({&K_BUFFER_PATTERN_LABEL_1}, '#':U, '':U)
  btnBuffer1:hidden in frame {&FRAME-NAME}       = ({&K_BUFFER_PATTERN_1} = '':U)
  btnBuffer2:label in frame {&FRAME-NAME}        = qg_cSubstituteChar({&K_BUFFER_PATTERN_LABEL_2}, '#':U, '':U)
  btnBuffer2:hidden in frame {&FRAME-NAME}       = ({&K_BUFFER_PATTERN_2} = '':U)
  btnBuffer3:label in frame {&FRAME-NAME}        = qg_cSubstituteChar({&K_BUFFER_PATTERN_LABEL_3}, '#':U, '':U)
  btnBuffer3:hidden in frame {&FRAME-NAME}       = ({&K_BUFFER_PATTERN_3} = '':U)
  btnBuffer4:label in frame {&FRAME-NAME}        = qg_cSubstituteChar({&K_BUFFER_PATTERN_LABEL_4}, '#':U, '':U)
  btnBuffer4:hidden in frame {&FRAME-NAME}       = ({&K_BUFFER_PATTERN_4} = '':U)
  btnBlock1:label in frame {&FRAME-NAME}         = {&K_BLOCK_PATTERN_LABEL_1}
  btnBlock1:hidden in frame {&FRAME-NAME}        = ({&K_BLOCK_PATTERN_1} = '':U)
  btnBlock2:label in frame {&FRAME-NAME}         = {&K_BLOCK_PATTERN_LABEL_2}
  btnBlock2:hidden in frame {&FRAME-NAME}        = ({&K_BLOCK_PATTERN_2} = '':U)
  btnBlock3:label in frame {&FRAME-NAME}         = {&K_BLOCK_PATTERN_LABEL_3}
  btnBlock3:hidden in frame {&FRAME-NAME}        = ({&K_BLOCK_PATTERN_3} = '':U)
  btnBlock4:label in frame {&FRAME-NAME}         = {&K_BLOCK_PATTERN_LABEL_4}
  btnBlock4:hidden in frame {&FRAME-NAME}        = ({&K_BLOCK_PATTERN_4} = '':U)
  .

&IF {&K_NUM_BUFFER_PATTERN_INDICES} > 0 &THEN

  run qg_CreateBufferButtonMenu(btnBuffer1:handle,
                                {&K_BUFFER_PATTERN_1},
                                {&K_BUFFER_PATTERN_LABEL_1}).
  
  run qg_CreateBufferButtonMenu(btnBuffer2:handle,
                                {&K_BUFFER_PATTERN_2},
                                {&K_BUFFER_PATTERN_LABEL_2}).
  
  run qg_CreateBufferButtonMenu(btnBuffer3:handle,
                                {&K_BUFFER_PATTERN_3},
                                {&K_BUFFER_PATTERN_LABEL_3}).
  
  run qg_CreateBufferButtonMenu(btnBuffer4:handle,
                                {&K_BUFFER_PATTERN_4},
                                {&K_BUFFER_PATTERN_LABEL_4}).

&ENDIF

/* Set display mode. */
run qg_SetDisplayMode({&K_DISPLAYMODE_INDEX}).

assign
  btnClearTableFilter:height in frame {&FRAME-NAME}         = gcTableFilter:height in frame {&FRAME-NAME}
  gcTableFilter:delimiter in frame {&FRAME-NAME}            = chr(1)
  btnClearTableFieldFilter:height in frame {&FRAME-NAME}    = gcTableFieldFilter:height in frame {&FRAME-NAME}
  gcTableFieldFilter:delimiter in frame {&FRAME-NAME}       = chr(1)
  btnClearFieldFilter:height in frame {&FRAME-NAME}         = gcFieldFilter:height in frame {&FRAME-NAME}
  gcFieldFilter:delimiter in frame {&FRAME-NAME}            = chr(1)
  btnClearFieldLabelFilter:height in frame {&FRAME-NAME}    = gcFieldLabelFilter:height in frame {&FRAME-NAME}
  gcFieldLabelFilter:delimiter in frame {&FRAME-NAME}       = chr(1)
  btnClearIndexFilter:height in frame {&FRAME-NAME}         = gcIndexFilter:height in frame {&FRAME-NAME}
  gcIndexFilter:delimiter in frame {&FRAME-NAME}            = chr(1)
  btnClearIndexFieldFilter:height in frame {&FRAME-NAME}    = gcIndexFieldFilter:height in frame {&FRAME-NAME}
  gcIndexFieldFilter:delimiter in frame {&FRAME-NAME}       = chr(1)
  btnClearRelationFilter:height in frame {&FRAME-NAME}      = gcRelationFilter:height in frame {&FRAME-NAME}
  gcRelationFilter:delimiter in frame {&FRAME-NAME}         = chr(1)
  btnClearRelationFieldFilter:height in frame {&FRAME-NAME} = gcRelationFieldFilter:height in frame {&FRAME-NAME}
  gcRelationFieldFilter:delimiter in frame {&FRAME-NAME}    = chr(1)
  .

assign
  hQueryWindow:max-width-pixels      = session:width-pixels
  hQueryWindow:virtual-width-pixels  = hQueryWindow:max-width-pixels
  hQueryWindow:max-height-pixels     = session:height-pixels
  hQueryWindow:virtual-height-pixels = hQueryWindow:max-height-pixels
  .

run qg_InitWidgetConstraints(frame {&FRAME-NAME}:handle).

assign
  gdOriginalWidth  = hQueryWindow:width-chars
  gdOriginalHeight = hQueryWindow:height-chars
  .

if {&K_SET_SLIM_MODE_ON_STARTUP} then
  run qg_SetSlimMode(yes).

/* Init temp-tables and selection-list widgets. */
run qg_LoadCache(?).

/*
assign
  hQueryWindow:width-chars  = maximum(minimum(hQueryWindow:width-chars,
                                              session:width-chars),
                                      {&K_WINDOW_MIN_WIDTH})
  hQueryWindow:height-chars = maximum(minimum(hQueryWindow:height-chars,
                                              session:height-chars),
                                      {&K_WINDOW_MIN_HEIGHT})
  .

apply 'window-resized':U to hQueryWindow.
*/

/* -> Performance-Test */

/*
etime(yes).

define buffer bttTable for temp-table ttTable.
define variable i as integer       no-undo.

for each bttTable
  where bttTable.DatabaseName = {&K_BASE_DB_NAME}
  on error undo, throw:
  
  run qg_AddTableDetails(bttTable.DatabaseName, bttTable.TableName).
  i = i + 1.
  
end. /* for each bttTable */

message
  string(etime / 1000) skip
  i skip
  view-as alert-box
  title program-name(1).
*/

/* <- Performance-Test */

/* Subscribe to snapshot events. */

subscribe
  to 'qgEvt_Snapshot':U
  anywhere
  run-procedure 'qg_AddSnapshot':U.

subscribe
  to 'qgEvt_SnapshotLine':U
  anywhere
  run-procedure 'qg_AddSnapshotLine':U.

apply 'entry':U to gcTableFilter in frame {&FRAME-NAME}.

end procedure. /* qg_Initialize */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InitWidgetConstraints hQueryWindow 
PROCEDURE qg_InitWidgetConstraints :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Adds widget size and position information to its private data. Children    */
/* of given handle are added recursively.                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWidget                       = Widget handle.                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWidget as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hChild as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if can-query(phWidget, 'private-data':U) then
do:
  
  assign
    phWidget:private-data = qg_cParamListWriteDecimal(phWidget:private-data,
                                                      'OriginalCol':U,
                                                      phWidget:col,
                                                      ',':U)
      when can-query(phWidget, 'col':U)
    phWidget:private-data = qg_cParamListWriteDecimal(phWidget:private-data,
                                                      'OriginalRow':U,
                                                      phWidget:row,
                                                      ',':U)
      when can-query(phWidget, 'row':U)
    phWidget:private-data = qg_cParamListWriteDecimal(phWidget:private-data,
                                                      'OriginalWidth':U,
                                                      phWidget:width-chars,
                                                      ',':U)
      when can-query(phWidget, 'width':U)
    phWidget:private-data = qg_cParamListWriteDecimal(phWidget:private-data,
                                                      'OriginalHeight':U,
                                                      phWidget:height-chars,
                                                      ',':U)
      when can-query(phWidget, 'height':U)
    .

  /* Adjust side label position. */
  if    can-query(phWidget, 'side-label-handle':U)
    and valid-handle(phWidget:side-label-handle)
    and can-query(phWidget:side-label-handle, 'private-data':U) then
    assign
      phWidget:side-label-handle:private-data = qg_cParamListWriteDecimal(phWidget:side-label-handle:private-data,
                                                                          'OriginalCol':U,
                                                                          phWidget:side-label-handle:col,
                                                                          ',':U)
        when can-query(phWidget:side-label-handle, 'col':U)
      phWidget:side-label-handle:private-data = qg_cParamListWriteDecimal(phWidget:side-label-handle:private-data,
                                                                          'OriginalRow':U,
                                                                          phWidget:side-label-handle:row,
                                                                          ',':U)
        when can-query(phWidget:side-label-handle, 'row':U)
        .
  
end. /* if can-query(phWidget, 'private-data':U) */

if    can-query(phWidget, 'first-child':U)
  and can-query(phWidget, 'next-sibling':U) then
do:
  
  hChild = phWidget:first-child.

  do while valid-handle(hChild):
    run qg_InitWidgetConstraints(hChild).
    hChild = hChild:next-sibling.
  end. /* do while valid-handle */
  
end. /* if    can-query(phWidget, 'first-child':U) */

end procedure. /* qg_InitWidgetConstraints */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InsertBufferDefinition hQueryWindow 
PROCEDURE qg_InsertBufferDefinition :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert buffer definition for current table into ide.                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if glInsertMode then
  run qg_IDE_InsertText(substitute('define buffer $~{&1~} $~{cursor}for &2.':U,
                                   (if glSlimMode then
                                      substitute({&K_DEFAULT_BUFFER_PATTERN},
                                                 qg_cGetBufferBaseName(no))
                                    else
                                      input frame {&FRAME-NAME} gcBufferName),
                                   ttTable.TableName)).

end procedure. /* qg_InsertBufferDefinition */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InsertFieldAssigments hQueryWindow 
PROCEDURE qg_InsertFieldAssigments :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert field assignments into ide.                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cAssigments as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cAssigments = qg_cFieldAssignments(yes).

if cAssigments > '':U then
  run qg_IDE_InsertText(cAssigments).

end procedure. /* qg_InsertFieldAssigments */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InsertFieldAssignStatement hQueryWindow 
PROCEDURE qg_InsertFieldAssignStatement :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert field assign statement into ide.                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cAssignStatement as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cAssignStatement = qg_cFieldAssignStatement(yes).

if cAssignStatement > '':U then
  run qg_IDE_InsertText(cAssignStatement).

end procedure. /* qg_InsertFieldAssignStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InsertPutStatement hQueryWindow 
PROCEDURE qg_InsertPutStatement :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert field assign statement into ide.                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cPutStatement as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cPutStatement = qg_cPutStatement(yes).

if cPutStatement > '':U then
  run qg_IDE_InsertText(cPutStatement).

end procedure. /* qg_InsertPutStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InsertQueryText hQueryWindow 
PROCEDURE qg_InsertQueryText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Insert current query text.                                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    OEIDEIsRunning
  and glIDECanInsert
  and glInsertMode then
  run qg_IDE_InsertText( qg_cCreateQueryText( /* pcFieldList */ qg_cCurrentFieldList(),
                                              /* plAddTags   */ yes ) ).

end procedure. /* qg_InsertQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_InsertTextLines hQueryWindow 
PROCEDURE qg_InsertTextLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Inserts given Text after line of given offset index.                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcLines                        = Text that should be inserted.             */
/* piOffset                       = offset of the line after that the text    */
/*                                  should be inserted.                       */
/* iopcText                       = Text in which the line should be inser-   */
/*                                  ted.                                      */
/* opiLine                        = Line number of the inserted line.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter pcLines  as character no-undo.
define input        parameter piOffset as integer   no-undo.
define input-output parameter iopcText as character no-undo.
define       output parameter opiLine  as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i       as integer   no-undo.
define variable iOffset as integer   no-undo initial 1.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if length(iopcText) = 0 then
  assign
    opiLine  = 1
    iopcText = pcLines
    .

else
do:
  
  do i = 1 to num-entries(iopcText, '~n':U):
    
    if iOffset > piOffset then
      leave.
    
    iOffset = iOffset + length(entry(i, iopcText, '~n':U)) + length('~n':U). 
    
  end. /* do i = 1 to num-entries(iopcText, '~n':U) */
  
  if    iOffset - 1 > length(iopcText)
    and not iopcText matches '*~n':U then
    iopcText = substitute('&1~n':U, iopcText).
  
  assign
    opiLine = i
    iopcText  = substitute('&1&2&3':U,
                         substring(iopcText, 1, iOffset - 1),
                         (if pcLines matches('*~n':U) then
                            pcLines
                          else
                            substitute('&1~n':U, pcLines)),
                         substring(iopcText, iOffset)).
    .
    
end. /* else: if length(iopcText) = 0 */

end procedure. /* qg_InsertTextLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_LoadCache hQueryWindow 
PROCEDURE qg_LoadCache :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fill temp-tables for all connected Databases.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase   for temp-table ttDatabase.
define buffer bttTable      for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cDatabaseName = (if pcDatabaseName <> ? then
                   pcDatabaseName
                 else if available ttDatabase then
                   ttDatabase.DatabaseName
                 else
                   ?).

if pcDatabaseName > '':U then
  run qg_RemoveDatabase(pcDatabaseName).

else
do:
  
  for each bttDatabase
    where bttDatabase.PhysicalDB = yes
    on error undo, throw:
    
    run qg_RemoveDatabase(bttDatabase.DatabaseName).
    
  end. /* for each bttDatabase */
  
  /* Remove all invalid virtual tables. */
  
  for each bttTable
    where bttTable.PhysicalTable = no
      and not valid-handle(bttTable.TableHandle)
    on error undo, throw:
    
    run qg_RemoveTable(bttTable.DatabaseName, bttTable.TableName).
    
  end. /* for each bttTable */
  
  /* Remove all virtual databases without temp-tables. */
  
  for each bttDatabase
    where bttDatabase.PhysicalDB = no
      and not can-find(first ttTable
                         where ttTable.DatabaseName = bttDatabase.DatabaseName)
    on error undo, throw:
    
    run qg_RemoveDatabase(bttDatabase.DatabaseName).
    
  end. /* for each bttDatabase */
  
end. /* else: if pcDatabaseName > '':U then */

run qg_RefreshDatabaseBrowse(cDatabaseName).

end procedure. /* qg_LoadCache */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_LoadDataDefinitions hQueryWindow 
PROCEDURE qg_LoadDataDefinitions :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Loads a df file.                                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phParentWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName as character no-undo.

define variable cOptions      as character no-undo.
define variable cWarnings     as character no-undo.

define variable cDataDefinitionFileName as character no-undo
  format 'x(255)':U
  label 'Filename':t
  view-as fill-in
  size 60 by 1.

define button btnFileDialog
  label '...':T
  size 7 by 1.

define variable lAddObjectsOnline as logical   no-undo
  format 'yes/no':U
  label 'Load new tables and sequences on-line':T
  view-as toggle-box
  size 50 by 1.

define variable lForceCommit as logical   no-undo
  format 'yes/no':U
  label 'Commit even with errors':T
  view-as toggle-box
  size 50 by 1.

define variable lForceIndexDeactivate as logical   no-undo
  format 'yes/no':U
  label 'Create new indexes inactive':T
  view-as toggle-box
  size 50 by 1.

define variable lForceSharedSchema as logical   no-undo
  format 'yes/no':U
  label 'Ignore multi-tenant properties':T
  view-as toggle-box
  size 50 by 1.

define button btnOk
  label 'Ok':T6
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T6
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fDataDefintionsSettings
  cDataDefinitionFileName at row 1.5 col 12 colon-aligned
  btnFileDialog at row 1.5 col 72 colon-aligned
  lAddObjectsOnline at row 3 col 12 colon-aligned
  lForceCommit at row 4 col 12 colon-aligned
  lForceIndexDeactivate at row 5 col 12 colon-aligned
  lForceSharedSchema at row 6 col 12 colon-aligned
  btnOk at row 8 col 22
  btnCancel at row 8 col 42
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 83 by 9.94
    title '':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fDataDefintionsSettings
  apply 'end-error' to self.

on choose of btnFileDialog in frame fDataDefintionsSettings
do:
  
  define variable lOk       as logical   no-undo.
  define variable cFilename as character no-undo.
  
  cFilename = input frame fDataDefintionsSettings cDataDefinitionFileName.
  
  system-dialog get-file cFileName
    title             substitute('&1Select df file for database "&2" ...':U,
                                 gcTitlePrefix,
                                 cDatabaseName)
    filters           'Data definitions (*.df)':U '*.df':U
    default-extension '.df':U
    use-filename
    update lOk
    .
  
  if lOk then
  do:
    
    cDataDefinitionFileName = cFilename.
    
    display unless-hidden
      cDataDefinitionFileName
      with frame fDataDefintionsSettings
        in window phParentWindow.
    
  end. /* if lOk */
  
end. /* on choose of btnFileDialog in frame fDataDefintionsSettings */


if available ttDatabase then
do:
  
  cDatabaseName = ttDatabase.DatabaseName.
  
  frame fDataDefintionsSettings:title = substitute('&1Load data definition for database "&2"':U,
                                                   gcTitlePrefix,
                                                   cDatabaseName).
  
  &IF   keyword-all('dynamic-invoke':U) <> ?
    and keyword-all('valid-object':U)   <> ? &THEN
    
    cDataDefinitionFileName = dynamic-invoke('pACStartupSvc',
                                             'cParameterValue':U,
                                             'DumpDir':U) no-error.
      
  &ENDIF
  
  cDataDefinitionFileName = ( if cDataDefinitionFileName > '':U then
                                substitute( '&1\&2.df':U,
                                            cDataDefinitionFileName,
                                            ttDatabase.PhysicalName )
                              else
                                substitute( '&1.df':U, ttDatabase.PhysicalName ) ).
  
  update unless-hidden
    cDataDefinitionFileName
    btnFileDialog
    lAddObjectsOnline
    lForceCommit
    lForceIndexDeactivate
    lForceSharedSchema
    btnOk
    btnCancel
    with frame fDataDefintionsSettings
      in window phParentWindow. 
  
  assign
    cOptions = substitute('&1,&2':U,
                          cOptions,
                          'AddObjectsOnline':U)
        when lAddObjectsOnline
    cOptions = substitute('&1,&2':U,
                          cOptions,
                          'ForceCommit':U)
        when lForceCommit
    cOptions = substitute('&1,&2':U,
                          cOptions,
                          'ForceIndexDeactivate':U)
        when lForceIndexDeactivate
    cOptions = substitute('&1,&2':U,
                          cOptions,
                          'ForceSharedSchema':U)
        when lForceSharedSchema
    .
  
  run qg_SetWorkingDatabase.
  
  run prodict/load_df_silent.p (cDataDefinitionFileName, /* code checked by mth 30.07.2015 */
                                cOptions,
                                output cWarnings).
  
  /* Reload cache. */
  run qg_LoadCache(cDatabaseName).
  
  find bttDatabase
    where bttDatabase.DatabaseName = cDatabaseName
    no-error.
  
  if available bttDatabase then
  do:
    reposition brDatabase to rowid rowid(bttDatabase).
    apply 'value-changed':U to brDatabase in frame fQuery.
  end. /* if available bttDatabase */
  
end. /* if available ttDatabase.DatabaseName */
  
end procedure. /* qg_LoadDataDefinitions */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_LoadIDESetting hQueryWindow 
PROCEDURE qg_LoadIDESetting :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Loads given setting for current project.                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* This has to be a procedure (may not be a function) due to progress error   */
/* 2780.                                                                      */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcSettingName                  = Name of the setting that should be        */
/*                                  loaded.                                   */
/* opcSettingValue                = Output of setting value.                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcSettingName   as character no-undo.
define output parameter opcSettingValue as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cParamString  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    OEIDEIsRunning
  and glIDECanLoadSetting then
do:
  
  assign
    cParamString = qg_cParamListWriteCharacter(cParamString,
                                               'ProjectName':U,
                                               (if gcIDEProjectName <> ? then
                                                  gcIDEProjectName
                                                else
                                                  '':U),
                                               {&K_PARAM_SPLITTER})
    cParamString = qg_cParamListWriteCharacter(cParamString,
                                               'ParameterName':U,
                                               pcSettingName,
                                               {&K_PARAM_SPLITTER})
    .
  
  run qg_IDE_SendRequest({&K_LOAD_PLUGIN_SETTING_HANDLER},
                         cParamString,
                         yes /* plWaitForResult */,
                         output opcSettingValue).
  
end. /* if    OEIDEIsRunning ... */

end procedure. /* qg_LoadIDESetting */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_LoadQueryScenario hQueryWindow 
PROCEDURE qg_LoadQueryScenario :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Load a previously stored query scenario.                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFileName                     = Filename that contains the scenario. If ? */
/*                                  the scenario will be loaded from          */
/*                                  clipboard.                                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcFileName          as character no-undo.
define input parameter plCloseQueryWindows as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/


define variable i                as integer   no-undo.

define variable clText           as longchar  no-undo.

define variable cBufferList      as character no-undo.
define variable cTargetQueryText as character no-undo.
define variable cParamList       as character no-undo.

define variable iWindowMode      as integer   no-undo.
define variable iWindowSize      as integer   no-undo.

define variable hSplitter1       as handle    no-undo.
define variable hRawValues       as handle    no-undo.

define variable lFieldOverlay    as logical   no-undo.
define variable cWindowList      as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow             for temp-table ttQueryWindow.
define buffer bttRecentQuery             for temp-table ttRecentQuery.
define buffer bttFieldOverlay            for temp-table ttFieldOverlay.

define buffer bttQueryWindowExport       for temp-table ttQueryWindowExport.
define buffer btt2QueryWindowExport      for temp-table ttQueryWindowExport.
define buffer bttQueryBufferExport       for temp-table ttQueryBufferExport.
define buffer bttQueryFieldOverlayExport for temp-table ttQueryFieldOverlayExport.
define buffer bttRecentQueryExport       for temp-table ttRecentQueryExport.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if pcFileName <> ? then
  dataset dsQueryWindowExport:read-xml('File':U,
                                        pcFileName,
                                        'empty':U,
                                        ?,
                                        no).
  
else if lookup('PRO_TEXT':U, clipboard:available-formats) > 0 then
do:
  
  clText = qg_lcClipboardValue().
  
  if clText > '':U then
    dataset dsQueryWindowExport:read-xml('longchar':U,
                                          clText,
                                          'empty':U,
                                          ?,
                                          no).
    
end. /* else: if pcFileName <> ? */

else
  return.

if    plCloseQueryWindows <> no
  and can-find(first ttQueryWindow) then
do:
  
  if plCloseQueryWindows = ? then
    message /* code checked by mth */
      'Do you want to close all currenty open query windows?':U
      view-as alert-box question
      buttons yes-no-cancel
      update plCloseQueryWindows
      in window hQueryWindow
      .
  
  if plCloseQueryWindows = ? then
    return.
  
  else if plCloseQueryWindows then
  do:
    
    for each bttQueryWindow
      on error undo, throw:
      
      if valid-handle(bttQueryWindow.WindowHandle) then
        run qg_QueryWindowClose(bttQueryWindow.WindowHandle, no).
      
    end. /* for each bttQueryWindow */
    
  end. /* else if lOk */
  
end. /* if can-find(first ttQueryWindow) */

/* Generate new seqence numbers. */
for each bttQueryWindowExport
  on error undo, throw:
  
  assign
    giQuerySeq                       = giQuerySeq + 1
    bttQueryWindowExport.NewQuerySeq = giQuerySeq
    .
  
end. /* bttQueryWindowExport */

/* Now update external references in the query texts. */

for each bttQueryWindowExport
  on error undo, throw:
  
  assign
    cBufferList   = '':U
    cParamList    = '':U
    lFieldOverlay = no
    .
  
  /* Fix external references. */
  
  cTargetQueryText = qg_cFixQuerySeq(bttQueryWindowExport.QueryText,
                                     bttQueryWindowExport.QuerySeq).
  
  /* If the query scenario contains window state information for a            */
  /* different window mode than the active mode the corresponding frame has   */
  /* to be created as well. If this is the case then we start the query       */
  /* window with the not avtivce window mode and switch it later to ensure    */
  /* all needed frames are available.                                         */
  
  iWindowMode = (if bttQueryWindowExport.WindowMode = {&K_QUERY_WINDOW_MODE_RECORD_STR} then
                   {&K_QUERY_WINDOW_MODE_RECORD}
                 else
                   {&K_QUERY_WINDOW_MODE_QUERY}).
  
  if      iWindowMode = {&K_QUERY_WINDOW_MODE_RECORD}
    and ( num-entries(bttQueryWindowExport.BrowseColumns) > 0
       or bttQueryWindowExport.HideFieldList
       or bttQueryWindowExport.Splitter1Pos > 0 ) then
    assign
      iWindowMode = {&K_QUERY_WINDOW_MODE_QUERY}
      iWindowSize = {&K_QUERY_SIZE_MODE_DEFAULT}
      .
  
  else
    if    iWindowMode = {&K_QUERY_WINDOW_MODE_QUERY}
      and ( num-entries(bttQueryWindowExport.RecordBrowseColumns) > 0
         or num-entries(bttQueryWindowExport.RecordBrowseFields) > 0
         or bttQueryWindowExport.DisplayRawValues) then
      assign
        iWindowMode = {&K_QUERY_WINDOW_MODE_RECORD}.
        iWindowSize = {&K_RECORD_SIZE_MODE_DEFAULT}
        .
  
  /* Create buffer list. */
  
  for each bttQueryBufferExport
    where bttQueryBufferExport.QuerySeq = bttQueryWindowExport.QuerySeq
    on error undo, throw:
    
    cBufferList = substitute('&1,&2.&3:&4':U,
                             cBufferList,
                             bttQueryBufferExport.DatabaseName,
                             bttQueryBufferExport.TableName,
                             bttQueryBufferExport.BufferName).
    
  end. /* for each bttQueryBufferExport */
  
  cBufferList = trim(cBufferList, ',':U).
  
  /* Add object field value parameters */
  
  if bttQueryWindowExport.ObjSourceQuerySeq > 0 then
  do:
    
    find btt2QueryWindowExport
      where btt2QueryWindowExport.QuerySeq = bttQueryWindowExport.ObjSourceQuerySeq
      no-error.
    
    if available btt2QueryWindowExport then
      assign
        cParamList = qg_cParamListWriteInteger(cParamList,
                                               'ObjSourceQuerySeq':U,
                                                btt2QueryWindowExport.NewQuerySeq,
                                               {&K_PARAM_SPLITTER})
        cParamList = qg_cParamListWriteCharacter(cParamList,
                                                 'ObjSourceBufferName':U,
                                                  bttQueryWindowExport.ObjSourceBufferName,
                                                 {&K_PARAM_SPLITTER})
        cParamList = qg_cParamListWriteCharacter(cParamList,
                                                 'ObjSourceFieldName':U,
                                                  bttQueryWindowExport.ObjSourceFieldName,
                                                 {&K_PARAM_SPLITTER})
        cParamList = qg_cParamListWriteInteger(cParamList,
                                               'ObjSourceFieldIndex':U,
                                                bttQueryWindowExport.ObjSourceFieldIndex,
                                               {&K_PARAM_SPLITTER})
        .
    
  end. /* if bttQueryWindowExport.ObjSourceQuerySeq > 0 */
  
  run qg_ExecQuery(iWindowMode,
                   iWindowSize,
                   cBufferList,
                   cTargetQueryText,
                   yes,  /* Init mode */
                   cParamList,
                   input-output bttQueryWindowExport.NewQuerySeq).
  
  find bttQueryWindow
    where bttQueryWindow.QuerySeq = bttQueryWindowExport.NewQuerySeq
    no-error.
  
  if available bttQueryWindow then
  do:
    
    /* Restore Overlay columns. */
    
    for each bttQueryFieldOverlayExport
      where bttQueryFieldOverlayExport.QuerySeq = bttQueryWindowExport.QuerySeq,
    first bttQueryBufferExport
      where bttQueryBufferExport.QuerySeq = bttQueryFieldOverlayExport.QuerySeq
        and bttQueryBufferExport.BufferId = bttQueryFieldOverlayExport.BufferId
      on error undo, throw:
    
      create bttFieldOverlay.
      
      assign
        bttFieldOverlay.OwnerHandle  = bttQueryWindow.QueryHandle
        bttFieldOverlay.DatabaseName = bttQueryBufferExport.DatabaseName
        bttFieldOverlay.BufferName   = bttQueryBufferExport.BufferName
        bttFieldOverlay.FieldName    = bttQueryFieldOverlayExport.FieldName
        bttFieldOverlay.FieldIndex   = bttQueryFieldOverlayExport.FieldIndex
        .
      
      validate bttFieldOverlay.
      
      lFieldOverlay = yes.
      
    end. /* for each bttQueryFieldOverlayExport */
    
    if lFieldOverlay then
      run qg_QueryWindowCreateFieldTempTableOverlayEntries(bttQueryWindow.WindowHandle,
                                                           '':U).
    
    /* Restore window window mode specific features. */
    
    do i = 1 to 2:
      
      if    bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_QUERY}
        and valid-handle(bttQueryWindow.QueryFrameHandle) then
      do:
        
        if lFieldOverlay then
          run qg_QueryWindowRefreshBrowseColumns(bttQueryWindow.WindowHandle).
    
        if num-entries(bttQueryWindowExport.BrowseColumns) > 0 then
          run qg_SetBrowseColumns(bttQueryWindow.QueryBrowseHandle,
                                  bttQueryWindowExport.BrowseColumns).
        
        if bttQueryWindowExport.Splitter1Pos > 0 then
          assign
            hSplitter1     = qg_hGetWidgetByName(bttQueryWindow.WindowHandle,
                                                 'btnSplitter1':U)
            hSplitter1:row = bttQueryWindowExport.Splitter1Pos
            .
        
        if bttQueryWindowExport.HideFieldList then
          run qg_QueryWindowToggleFieldList(bttQueryWindow.WindowHandle).
        
      end. /* if    iWindowMode = {&K_QUERY_WINDOW_MODE_QUERY} ... */
      
      if    bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_RECORD}
        and valid-handle(bttQueryWindow.RecordFrameHandle) then
      do:
        
        if num-entries(bttQueryWindowExport.RecordBrowseColumns) > 0 then
          run qg_SetBrowseColumns(bttQueryWindow.RecordBrowseHandle,
                                  bttQueryWindowExport.RecordBrowseColumns).
        
        if num-entries(bttQueryWindowExport.RecordBrowseFields) > 0 then
          run qg_QueryWindowRecordSetFields(bttQueryWindow.WindowHandle,
                                            bttQueryWindowExport.RecordBrowseFields).
        
        else
          if lFieldOverlay then
            run qg_QueryWindowRecordOpenQuery(bttQueryWindow.WindowHandle).
        
        bttQueryWindow.DisplayRawValues = bttQueryWindowExport.DisplayRawValues.
        
        if bttQueryWindowExport.DisplayRawValues then
        do:
          
          hRawValues = qg_hGetWidgetByName(bttQueryWindow.WindowHandle,
                                           'lRawValues':U).
          
          if valid-handle(hRawValues) then
            hRawValues:screen-value = string(bttQueryWindow.DisplayRawValues).
          
        end. /* if bttQueryWindowExport.RecordRawValue */
        
      end. /* if    iWindowMode = {&K_QUERY_WINDOW_MODE_RECORD} */
      
      iWindowMode = (if bttQueryWindowExport.WindowMode = {&K_QUERY_WINDOW_MODE_RECORD_STR} then
                       {&K_QUERY_WINDOW_MODE_RECORD}
                     else
                       {&K_QUERY_WINDOW_MODE_QUERY}).
      
      if iWindowMode = bttQueryWindow.WindowMode then
        leave.
      
      run qg_QueryWindowSetWindowMode(bttQueryWindow.WindowHandle,
                                      iWindowMode,
                                      cTargetQueryText,
                                      no).
      
    end. /* do i = 1 to 2 */
    
    /* Restore window size. */
    
    assign
      bttQueryWindow.WindowHandle:width-chars  = bttQueryWindowExport.WindowWidth
          when bttQueryWindowExport.WindowWidth > 0
      bttQueryWindow.WindowHandle:height-chars = bttQueryWindowExport.WindowHeight
          when bttQueryWindowExport.WindowHeight > 0
      bttQueryWindow.WindowHandle:column       = bttQueryWindowExport.WindowColumn
          when bttQueryWindowExport.WindowColumn > 0
      bttQueryWindow.WindowHandle:row          = bttQueryWindowExport.WindowRow
          when bttQueryWindowExport.WindowRow > 0
      bttQueryWindow.WindowHandle:window-state = (if bttQueryWindowExport.WindowState = {&K_WINDOW_MAXIMIZED_STR} then
                                                    {&K_WINDOW_MAXIMIZED}
                                                  else if bttQueryWindowExport.WindowState = {&K_WINDOW_MINIMIZED_STR} then
                                                    {&K_WINDOW_MINIMIZED}
                                                  else
                                                    {&K_WINDOW_NORMAL})
      .
    
    apply 'window-resized':U to bttQueryWindow.WindowHandle.
    
    /* Restore Query history entries. */
    
    for each bttRecentQueryExport
      where bttRecentQueryExport.QuerySeq = bttQueryWindowExport.QuerySeq
      on error undo, throw:
      
      /* Fix external references */
      
      cTargetQueryText = qg_cFixQuerySeq(bttRecentQueryExport.QueryText,
                                         bttRecentQueryExport.QuerySeq).
      
      /* Add history entry */

      find bttRecentQuery
        where bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
          and bttRecentQuery.QueryText    = cTargetQueryText
        no-error.
      
      if not available(bttRecentQuery) then
      do:
        
        create bttRecentQuery.
        
        assign
          giRecentQueriesSeq          = giRecentQueriesSeq + 1
          bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
          bttRecentQuery.QueryText    = cTargetQueryText
          bttRecentQuery.QueryLabel   = qg_cQueryLabel(cTargetQueryText)
          . 
        
        validate bttRecentQuery.
        
      end. /* if not available(bttRecentQuery) */
      
      assign
        giRecentQueriesSeq   = giRecentQueriesSeq + 1
        bttRecentQuery.Order = giRecentQueriesSeq
        .
      
      validate bttRecentQuery.
      
    end. /* for each bttRecentQueryExport */
    
  end. /* if available bttQueryWindow */
  
end. /* bttQueryWindowExport */

/* Now finisch initialisation by unhding the query windows and execute their  */
/* Query.                                                                     */

for each bttQueryWindowExport,
first bttQueryWindow
  where bttQueryWindow.QuerySeq = bttQueryWindowExport.NewQuerySeq
  on error undo, throw:

  bttQueryWindow.WindowHandle:hidden = no.

  cWindowList = substitute('&1,&2':U,
                           cWindowList,
                           string(bttQueryWindow.QuerySeq)).
  
end. /* first bttQueryWindow */

cWindowList = trim(cWindowList, ',':U).

run qg_UpdateQueryWindowView.

if    valid-handle(ghQueryWindowListWindow)
  and ghQueryWindowListBrowse:query:num-results > 0 then
  ghQueryWindowListBrowse:refresh().

run qg_QueryWindowUpdateAll(cWindowList).

end procedure. /* qg_LoadQueryScenario */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_MoveTextLines hQueryWindow 
PROCEDURE qg_MoveTextLines :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Inserts given Text after line of given offset index.                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */  
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcLine                         = Text that should be inserted.             */
/* piOffset                       = offset of the line after that the text    */
/*                                  should be inserted.                       */
/* iopcText                       = Text in which the line should be inser-   */
/*                                  ted.                                      */
/* opiLine                        = Line number of the inserted line.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter piOffsetStart as integer   no-undo.
define input        parameter piOffsetEnd   as integer   no-undo.
define input        parameter plDown        as logical   no-undo.
define input-output parameter iopcText      as character no-undo.
define       output parameter opiLine       as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i               as integer   no-undo.
define variable iOffset         as integer   no-undo initial 1.
define variable iLineEndOffset  as integer   no-undo.

define variable iStartOffset    as integer   no-undo.
define variable iEndOffset      as integer   no-undo.

define variable lLineBreak      as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do i = 1 to num-entries(iopcText, '~n':U):
  
  iLineEndOffset = iOffset + length(entry(i, iopcText, '~n':U)).
  
  if    iOffset        <= piOffsetStart
    and iLineEndOffset >= piOffsetStart then
    assign
      iStartOffset = iOffset
      opiLine      = i
      .
  
  if    iOffset        <= piOffsetEnd
    and iLineEndOffset >= piOffsetEnd then
  do:
    
    iEndOffset = iLineEndOffset + length('~n':U).
    leave.
    
  end. /* if iOffset <= piOffsetEnd */
  
  iOffset = iLineEndOffset + length('~n':U). 
  
end. /* do i = 1 to num-entries(iopcText, '~n':U) */

if    iStartOffset > 0
  and iEndOffset  >= iStartOffset then
do:
  
  if plDown then
  do:
    
    iOffset = index(iopcText, '~n':U, iEndOffset).
    
    if    iOffset    = 0
      and iEndOffset < length(iopcText) + 1 then
      iOffset = length(iopcText) + 1.
    
    lLineBreak = (length(iopcText) >= iOffset).
    
  end. /* if plDown */
  
  else
  do:
    
    if iStartOffset - length('~n':U) > 1 then
      iOffset = r-index(iopcText, '~n':U, iStartOffset - length('~n':U) - 1).
    
    if    iOffset      = 0
      and iStartOffset > 1 then
      iOffset = 1.
    
    if iOffset > 1 then
      iOffset = iOffset + length('~n':U).
    
    lLineBreak = (length(iopcText) >= iEndOffset).
    
  end. /* if plDown */
  
  if iOffset > 0 then
  do:
    
    if    plDown
      and iOffset > iEndOffset then
      assign
        iOffset = iOffset + length('~n':U)
        iopcText  = substitute('&1&2~n&3&4&5':U,
                               substring(iopcText, 1, iStartOffset - 1),
                               right-trim(substring(iopcText,
                                                    iEndOffset,
                                                    iOffset - iEndOffset),
                                          '~n':U),
                               right-trim(substring(iopcText,
                                                    iStartOffset,
                                                    iEndOffset - iStartOffset),
                                          '~n':U),
                               (if lLineBreak then
                                  '~n':U
                                else
                                  '':U),
                               substring(iopcText, iOffset))
        opiLine = opiLine + 1
        .
    
    else
      if    not plDown
        and iOffset < iStartOffset then
      assign
        iopcText  = substitute('&1&2~n&3&4&5':U,
                               substring(iopcText, 1, iOffset - 1),
                               right-trim(substring(iopcText,
                                                    iStartOffset,
                                                    iEndOffset - iStartOffset),
                                          '~n':U),
                               right-trim(substring(iopcText,
                                                   iOffset,
                                                   iStartOffset - iOffset),
                                         '~n':U),
                               (if lLineBreak then
                                  '~n':U
                                else
                                  '':U),
                               substring(iopcText, iEndOffset))
        opiLine = opiLine - 1
        .
    
  end. /* if iOffset > 0 */
  
end. /* if    iStartOffset > 0 */

end procedure. /* qg_MoveTextLines */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_MoveToTop hQueryWindow 
PROCEDURE qg_MoveToTop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Bring main window to front.                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Make sure the main window isn't minimized. */
if    hQueryWindow:window-state <> {&K_WINDOW_NORMAL}
  and hQueryWindow:window-state <> {&K_WINDOW_MAXIMIZED} then
  hQueryWindow:window-state = {&K_WINDOW_NORMAL}.

process events.
hQueryWindow:move-to-top().

if not hQueryWindow:top-only then
do:
  /* move-to-top() doesn't work that well on windows 10. Setting top-only     */
  /* however seems to reliably bring the window to the top. Therefore we      */
  /* shortly set and reset the top-only property.                             */
  hQueryWindow:top-only = yes.
  hQueryWindow:top-only = no.
end.

apply 'entry':U to gcTableFilter in frame {&FRAME-NAME}.

return no-apply.

end procedure. /* qg_MoveToTop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_OpenEditor hQueryWindow 
PROCEDURE qg_OpenEditor :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open given file in external editor.                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFilename                     = Filename.                                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcFilename as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    OEIDEIsRunning
  and gcIDEProjectName > '':U then
  openEditor(gcIDEProjectName,
             pcFilename,
             ?,
             ?).

else
  os-command no-wait value(pcFilename).

end procedure. /* qg_OpenEditor */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_OpenFile Method-Library
procedure qg_OpenFile :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcFilename as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  pcFilename          = qg_cFilename(pcFilename)
  file-info:file-name = pcFilename
  .

if file-info:full-pathname = ? then
  message /* code checked by mth 30.07.2015 */
    substitute('File ~'&1~' does not exist!':T,
               pcFilename) skip
    view-as alert-box
    error
    buttons ok.

else
  os-command no-wait value(pcFilename).

end procedure. /* qg_OpenFile */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_OpenQueryWindowListWindow hQueryWindow 
PROCEDURE qg_OpenQueryWindowListWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame      as handle    no-undo.

define variable hBuffer     as handle    no-undo.
define variable hQuery      as handle    no-undo.
define variable hColumn     as handle    no-undo.
define variable hTemp       as handle    no-undo.

define variable hMenuBar    as handle    no-undo.
define variable hSubMenu    as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghQueryWindowListWindow) then
  run qg_ActivateWindow(ghQueryWindowListWindow, ghQueryWindowListBrowse).

else
do:
  
  /* Create Window. */
  
  create window ghQueryWindowListWindow
    assign
      hidden         = yes
      width          = 60
      max-width      = 1024
      height         = 15
      max-height     = 1024
      scroll-bars    = no
      status-area    = no
      three-d        = yes
      message-area   = no
      sensitive      = yes
      max-button     = no
      title          = gcTitlePrefix + 'Query windows':U
      .
  
  create frame hFrame
    assign
      name           = 'fQueryWindows':U
      box            = no
      three-d        = yes
      width          = ghQueryWindowListWindow:width
      virtual-width  = ghQueryWindowListWindow:width
      height         = ghQueryWindowListWindow:height
      virtual-height = ghQueryWindowListWindow:height
      drop-target    = yes
      sensitive      = yes
      parent         = ghQueryWindowListWindow
    triggers:
      
      on drop-file-notify
        persistent run qg_QueryWindowListDropFileNotify in target-procedure.
      
    end triggers
    .
  
  create menu hMenuBar.
  
  create sub-menu hSubMenu
    assign
      name      = 'm_File':U
      label     = 'File':T
      sensitive = yes
      parent    = hMenuBar
    triggers:
      
      on menu-drop
        persistent run qg_QueryWindowListFileMenuDrop in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_SaveQueryScenario':U
      label     = 'Save query Scenario':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_QueryWindowListSaveQueryScenario in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_LoadQueryScenario':U
      label     = 'Load query Scenario':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_QueryWindowListLoadQueryScenario in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hSubMenu
      .
  
  create menu-item hTemp
    assign
      name      = 'mi_Close':U
      label     = 'Close':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_QueryWindowListWindowClose in target-procedure.
      
    end triggers
    .
  
  create sub-menu hSubMenu
    assign
      name      = 'm_Edit':U
      label     = 'Edit':T
      sensitive = yes
      parent    = hMenuBar
    triggers:
      
      on menu-drop
        persistent run qg_QueryWindowListEditMenuDrop in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_CopyQueryScenario':U
      label     = 'Copy query scenario':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_QueryWindowListCopyQueryScenario in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_PasteQueryScenario':U
      label     = 'Paste query scenario':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_QueryWindowListPasteQueryScenario in target-procedure.
      
    end triggers
    .
  
  create sub-menu hSubMenu
    assign
      name      = 'm_Tools':U
      label     = 'Tools':T
      sensitive = yes
      parent    = hMenuBar
    triggers:
      
      on menu-drop
        persistent run qg_QueryWindowListToolsMenuDrop in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_MinimizeAll':U
      parent       = hSubMenu
      label        = 'Minimize all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListSetWindowStates in target-procedure
                         ({&K_WINDOW_MINIMIZED}).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_RestoreAll':U
      parent       = hSubMenu
      label        = 'Restore all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListSetWindowStates in target-procedure
                         ({&K_WINDOW_NORMAL}).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hSubMenu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_HideAll':U
      parent       = hSubMenu
      label        = 'Hide all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListSetVisibleStates in target-procedure
                         (no).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_ShowAll':U
      parent       = hSubMenu
      label        = 'Show all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListSetVisibleStates in target-procedure
                         (yes).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hSubMenu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_CloseAll':U
      parent       = hSubMenu
      label        = 'Close all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListCloseAllQueryWindows in target-procedure.
      
    end triggers
    .
      
  create sub-menu hSubMenu
    assign
      name      = 'm_View':U
      label     = 'View':T
      sensitive = yes
      parent    = hMenuBar
      .
  
  create menu-item hTemp
    assign
      name      = 'mi_Refresh':U
      label     = 'Refresh':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_QueryWindowListRefresh in target-procedure.
      
    end triggers
    .
  
  create sub-menu hSubMenu
    assign
      name      = 'm_Window':U
      label     = 'Window':T
      sensitive = yes
      parent    = hMenuBar
    triggers:
      
      on menu-drop
        persistent run qg_QueryWindowListWindowMenuDrop in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name       = 'mi_AlwaysOnTop':U
      label      = 'Always on top':T
      sensitive  = yes
      toggle-box = yes
      parent     = hSubMenu
    triggers:
      
      on value-changed
        persistent run qg_QueryWindowListToggleAlwaysOnTop in target-procedure.
      
    end triggers
    .
  
  ghQueryWindowListWindow:menu-bar = hMenuBar.

  create buffer hBuffer for table 'ttQueryWindowView':U. /* code checked by mth 30.07.2015 */
  
  create query hQuery.
  hQuery:set-buffers(hBuffer).
  
  create browse ghQueryWindowListBrowse
    assign
      name                   = 'brQueryWindowList':U
      frame                  = hFrame
      width                  = hFrame:width
      height                 = hFrame:height
      row                    = 1
      col                    = 1
      read-only              = yes
      row-markers            = no
      allow-column-searching = no
      multiple               = no
      fit-last-column        = yes
    triggers:
      
      on default-action
        persistent run qg_QueryWindowListActivateQueryWindow in target-procedure.
      
      on mouse-extend-dblclick
        persistent run qg_QueryWindowListCloseQueryWindow in target-procedure
                         (no).
      
      on del
        persistent run qg_QueryWindowListCloseQueryWindow in target-procedure
                         (no).
      
      on shift-del
        persistent run qg_QueryWindowListCloseQueryWindow in target-procedure
                         (yes).
      
      on ctrl-r
        persistent run qg_QueryWindowListOpenRelatedQuery in target-procedure.
      
    end triggers
    .
  
  create menu hTemp
    assign
      name       = 'm_QueryWindowListBrowsePopupMenu':U
      popup-only = yes
      sensitive  = yes
    triggers:
      
      on menu-drop
        persistent run qg_QueryWindowListBrowsePopupMenuDrop in target-procedure.
      
    end triggers.
  
  ghQueryWindowListBrowse:popup-menu = hTemp.
  
  create menu-item hTemp
    assign
      name         = 'mi_Activate':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Activate':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListActivateQueryWindow in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghQueryWindowListBrowse:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_Minimize':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Minimize':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListMinimizeQueryWindow in target-procedure
                         (no).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Hide':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Hide':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListHideQueryWindow in target-procedure
                         (no).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_Close':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Close':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListCloseQueryWindow in target-procedure
                         (no).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghQueryWindowListBrowse:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_MinimizeBranch':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Minimize branch':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListMinimizeQueryWindow in target-procedure
                         (yes).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_HideBranch':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Hide branch':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListHideQueryWindow in target-procedure
                         (yes).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_CloseBranch':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Close branch':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListCloseQueryWindow in target-procedure
                         (yes).
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghQueryWindowListBrowse:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_CloseAll':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Close all':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListCloseAllQueryWindows in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghQueryWindowListBrowse:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_AlwaysOnTop':U
      parent       = ghQueryWindowListBrowse:popup-menu
      toggle-box   = yes
      label        = 'Always on top':T
      sensitive    = yes
    triggers:
      
      on value-changed
        persistent run qg_QueryWindowListQueryWindowAlwaysOnTop in target-procedure.
      
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghQueryWindowListBrowse:popup-menu
      .
  
  create menu-item hTemp
    assign
      name         = 'mi_OpenRelatedQuery':U
      parent       = ghQueryWindowListBrowse:popup-menu
      label        = 'Open related query':T
      sensitive    = yes
    triggers:
      
      on choose
        persistent run qg_QueryWindowListOpenRelatedQuery in target-procedure.
      
    end triggers
    .
  
  on window-close of ghQueryWindowListWindow
    persistent run qg_QueryWindowListWindowClose in target-procedure.
  
  on window-resized of ghQueryWindowListWindow
    persistent run qg_QueryWindowListWindowResize in target-procedure.
  
  on end-error of ghQueryWindowListWindow anywhere
    persistent run qg_MoveToTop in target-procedure.
  
  on end-error of ghQueryWindowListWindow anywhere
    persistent run qg_MoveToTop in target-procedure.
  
  assign
    ghQueryWindowListBrowse:query = hQuery
    hColumn                       = ghQueryWindowListBrowse:add-like-column('ttQueryWindowView.LineText':U)
    .
  
  on row-display of ghQueryWindowListBrowse
    persistent run qg_QueryWindowListBrowseOnRowDisplay in target-procedure
                     (hColumn,
                      hBuffer).
  
  run qg_AddHelpMenu(ghQueryWindowListWindow:menu-bar).
  
  run qg_InitBrowse(ghQueryWindowListBrowse).
  
  assign
    ghQueryWindowListBrowse:labels          = no
    ghQueryWindowListBrowse:fit-last-column = yes
    .
  
  if gcIconDir = '':U then
    ghQueryWindowListWindow:load-icon('adeicon/results%.ico':U) no-error.
    
  else
  do:
  
    ghQueryWindowListWindow:load-icon(substitute('&1/32/table_multiple.ico':U,
                                      gcIconDir)) no-error.
    
    ghQueryWindowListWindow:load-small-icon(substitute('&1/16/table_multiple.ico':U,
                                            gcIconDir)) no-error.
  
  end. /* if gcIconDir = '':U */
  
  assign
    hFrame:hidden                  = no
    ghQueryWindowListWindow:hidden = no
    .
  
  run qg_QueryWindowListRefresh.
  
  apply 'window-resized':U to ghQueryWindowListWindow.
  
  if valid-handle(ghActiveQueryWindow) then
    run qg_QueryWindowListSelectQueryWindow(ghActiveQueryWindow).
  
  apply 'entry':U to ghQueryWindowListBrowse.
  
end. /* else: if valid-handle(ghSessionTriggersWindow) */

end procedure. /* qg_OpenQueryWindowListWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_OpenRelatedQueryWindow hQueryWindow 
PROCEDURE qg_OpenRelatedQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow         as handle    no-undo.
define input parameter piRelationId     as integer   no-undo.
define input parameter plParentRelation as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer          as handle    no-undo.
define variable cDatabaseName    as character no-undo.
define variable cTargetTableName as character no-undo.

define variable lParent          as logical   no-undo.
define variable i                as integer   no-undo.
define variable cQueryText       as character no-undo.

define variable cParamList       as character no-undo.

define variable iQuerySeq        as integer   no-undo initial ?.
define variable cDummyQueryText  as character no-undo.
define variable cIndexInfo       as character no-undo.
define variable lOk              as logical   no-undo.

define variable iParentX1        as integer   no-undo.
define variable iParentY1        as integer   no-undo.
define variable iParentX2        as integer   no-undo.
define variable iParentY2        as integer   no-undo.

define variable iTempX1          as integer   no-undo.
define variable iTempY1          as integer   no-undo.
define variable iTempX2          as integer   no-undo.
define variable iTempY2          as integer   no-undo.

define variable iReferenceX1     as integer   no-undo.
define variable iReferenceY1     as integer   no-undo.
define variable iReferenceX2     as integer   no-undo.
define variable iReferenceY2     as integer   no-undo.

define variable iChildX1         as integer   no-undo.
define variable iChildY1         as integer   no-undo.
define variable iChildX2         as integer   no-undo.
define variable iChildY2         as integer   no-undo.

define variable iWindowSize      as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow        for temp-table ttQueryWindow.
define buffer b2ttQueryWindow       for temp-table ttQueryWindow.

define buffer bttQueryLink          for temp-table ttQueryLink.
define buffer bttTableRelation      for temp-table ttTableRelation.
define buffer bttTableRelationField for temp-table ttTableRelationField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if   not available bttQueryWindow then
  leave.

if not valid-handle(bttQueryWindow.QueryHandle) then
  leave.

assign
  hBuffer       = bttQueryWindow.QueryHandle:get-buffer-handle(1)
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
  .

find bttTableRelation
  where bttTableRelation.RelationId = piRelationId
  no-error.

if not available bttTableRelation then
  leave.

assign
  lParent          = (bttTableRelation.ParentTableName = hBuffer:table)
  cTargetTableName = (if lParent then
                        bttTableRelation.ChildTableName
                      else
                        bttTableRelation.ParentTableName)
  cQueryText       = substitute('for each &1~n&2':U,
                                cTargetTableName,
                                qg_cCreateRelatedWhereClause(buffer bttTableRelation,
                                                             plParentRelation,
                                                             cTargetTableName,
                                                             hBuffer:name,
                                                             bttQueryWindow.QuerySeq))
  .

/* Replace tokens with dummy text. */

assign
  giQueryParserSeq = 0
  gcQPQueryText    = cQueryText
  giQPOffset       = 1
  giQPTokenStart   = 1
  giQPTokenEnd     = 0
  gcQPToken        = '':U
  giQPTokenType    = {&K_QP_TOKEN_TYPE_UNDEFINED}
  .

run qg_QueryParserGetNextToken.

do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF}:
  
  assign
    cDummyQueryText = (if    giQPTokenType = {&K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE}
                         and num-entries(gcQPToken, ':':U) = 2 then
                           cDummyQueryText
                         + substring(cQueryText,
                                     giQPOffset,
                                     giQPTokenStart - giQPOffset)
                         + '~'~'':U
                       else
                          cDummyQueryText
                        + substring(cQueryText,
                                    giQPOffset,
                                    giQPTokenEnd - giQPOffset))
    giQPOffset      = giQPTokenEnd
    .
  
  run qg_QueryParserGetNextToken.
  
end. /* do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF} */

cDummyQueryText = cDummyQueryText + substring(cQueryText, giQPOffset).

/* Check for full table scan. */

cIndexInfo = qg_cQueryIndexInfo(cDatabaseName,
                                cTargetTableName,
                                cDummyQueryText).

if    num-entries(cIndexInfo) > 0
  and entry(1, cIndexInfo)    = 'WHOLE-INDEX':U then
do:
  
  message
    'You are about to open a query window that will result in a full table scan. Do you want to continue?':T
    view-as alert-box
    warning
    buttons ok-cancel
    update lOk
    in window bttQueryWindow.WindowHandle.
  
  if not lOk then
    leave.
  
end. /* if    num-entries(cQueryText) > 0 */

/* Determine position for query window. */

run qg_GetWindowRect(bttQueryWindow.WindowHandle,
                     output iParentX1,
                     output iParentY1,
                     output iParentX2,
                     output iParentY2).

for each bttQueryLink
  where bttQueryLink.SourceSeq = bttQueryWindow.QuerySeq,
first b2ttQueryWindow
  where b2ttQueryWindow.QuerySeq = bttQueryLink.TargetSeq
  on error undo, throw:
  
  run qg_GetWindowRect(b2ttQueryWindow.WindowHandle,
                       output iTempX1,
                       output iTempY1,
                       output iTempX2,
                       output iTempY2).
  
  if    iTempX1 = iParentX1
    and iTempX2 = iParentX2
    and (iReferenceY2 = 0
      or iTempY2      > iReferenceY2) then
    assign
      iReferenceX1 = iTempX1
      iReferenceY1 = iTempY1
      iReferenceX2 = iTempX2
      iReferenceY2 = iTempY2
      .
  
end. /* for each bttQueryLink */

if iReferenceY2 = 0 then
  assign
    iReferenceX1 = iParentX1
    iReferenceY1 = iParentY1
    iReferenceX2 = iParentX2
    iReferenceY2 = iParentY2
    .

/* Execute the query. */

if iReferenceY2 < session:height-pixels then
  assign
    cParamList = qg_cParamListWriteInteger(cParamList,
                                           'XPos':U,
                                           iReferenceX1,
                                           {&K_PARAM_SPLITTER})
    cParamList = qg_cParamListWriteInteger(cParamList,
                                           'XPos':U,
                                           iReferenceX1,
                                           {&K_PARAM_SPLITTER})
    .
    
iWindowSize = (if    num-entries(bttTableRelation.RelationType, ':':U)                 > 1
                 and entry(integer(lParent) + 1, bttTableRelation.RelationType, ':':U) = '1':U then
                 {&K_QUERY_SIZE_MODE_SMALL}
               else
                 ?).

run qg_ExecQuery({&K_QUERY_WINDOW_MODE_QUERY},
                 iWindowSize,
                 substitute('&1.&2':U, cDatabaseName, cTargetTableName),
                 cQueryText,
                 no,  /* Init mode */
                 cParamList,
                 input-output iQuerySeq).

end procedure. /* qg_OpenRelatedQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_OpenSessionTriggerWindow hQueryWindow 
PROCEDURE qg_OpenSessionTriggerWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open session trigger window (or acitivate it if its already runnung).      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame               as handle    no-undo.
define variable hMenuBar             as handle    no-undo.
define variable hSubMenu             as handle    no-undo.
define variable hBuffer              as handle    no-undo.
define variable hQuery               as handle    no-undo.
define variable hChooseLogFileButton as handle    no-undo.
define variable hOpenLogFileButton   as handle    no-undo.
define variable hDeleteLogFileButton as handle    no-undo.

define variable hTemp                as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggersWindow) then
  run qg_ActivateWindow(ghSessionTriggersWindow, ?).

else
do:
  
  create window ghSessionTriggersWindow
    assign
      hidden         = yes
      width          = 104
      max-width      = 1024
      height         = 20.5
      max-height     = 1024
      scroll-bars    = no
      status-area    = no
      three-d        = yes
      message-area   = no
      sensitive      = yes
      max-button     = no
      title          = gcTitlePrefix + 'Session triggers':U
      .
  
  create frame hFrame
    assign
      name           = 'fSessionTriggers':U
      box            = no
      three-d        = yes
      width          = 104
      virtual-width  = 104
      height         = 20.5
      virtual-height = 20.5
      sensitive      = yes
      parent         = ghSessionTriggersWindow
      .
  
  create menu hMenuBar.
  
  create sub-menu hSubMenu
    assign
      name      = 'm_File':U
      label     = 'File':T
      sensitive = yes
      parent    = hMenuBar
      .
  
  create menu-item hTemp
    assign
      name      = 'mi_Close':U
      label     = 'Close':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      
      on choose
        persistent run qg_SessionTriggersWindowClose in target-procedure.
      
    end triggers
    .
  
  create sub-menu hSubMenu
    assign
      name      = 'm_Edit':U
      label     = 'Edit':T
      sensitive = yes
      parent    = hMenuBar
    triggers:
      on menu-drop
        persistent run qg_SessionTriggersEditMenuDrop in target-procedure.
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_TriggerProperties':U
      label     = 'Trigger properties':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      on choose
        persistent run qg_SessionTriggersEditTriggerSettings in target-procedure.
    end triggers
    .
  
  create sub-menu hSubMenu
    assign
      name      = 'm_Tools':U
      label     = 'Tools':T
      sensitive = yes
      parent    = hMenuBar
    triggers:
      on menu-drop
        persistent run qg_SessionTriggersToolsMenuDrop in target-procedure.
    end triggers
      .
  
  
  create menu-item hTemp
    assign
      name      = 'mi_Activate':U
      label     = 'Activate session trigger':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      on choose
        persistent run qg_SessionTriggersActivate in target-procedure
                         (?).
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_ActivateAll':U
      label     = 'Activate all session triggers':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      on choose
        persistent run qg_SessionTriggersActivate in target-procedure
                         (yes).
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_DeactivateAll':U
      label     = 'Dectivate all session triggers':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      on choose
        persistent run qg_SessionTriggersActivate in target-procedure
                         (no).
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = hSubMenu
      .
  
  create menu-item hTemp
    assign
      name      = 'mi_RemoveSessionTrigger':U
      label     = 'Remove session trigger':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      on choose
        persistent run qg_SessionTriggersRemoveSessionTrigger in target-procedure.
    end triggers
    .
  
  create menu-item hTemp
    assign
      name      = 'mi_RemoveAllSessionTriggers':U
      label     = 'Remove all session triggers':T
      sensitive = yes
      parent    = hSubMenu
    triggers:
      on choose
        persistent run qg_SessionTriggersRemoveAllSessionTriggers in target-procedure.
    end triggers
    .
  
  ghSessionTriggersWindow:menu-bar = hMenuBar.
  
  create toggle-box ghSessionTriggerShowMessage
    assign
      name      = 'lShowMessage':U
      frame     = hFrame
      width     = 30
      height    = 1
      row       = 1.5
      col       = 3
      label     = 'Show message':T
      tooltip   = 'Show message on trigger event.':T
      sensitive = yes
    triggers:
      on value-changed
        persistent run qg_SessionTriggersShowMessageChanged in target-procedure.
    end triggers
    .
  
  create toggle-box ghSessionTriggerWriteLog
    assign
      name      = 'lWriteLog':U
      frame     = hFrame
      width     = 15
      height    = 1
      row       = ghSessionTriggerShowMessage:row + 1
      col       = ghSessionTriggerShowMessage:col
      label     = 'Write logfile':T
      tooltip   = 'Add logfile entry on trigger event.':T
      sensitive = yes
    triggers:
      on value-changed
        persistent run qg_SessionTriggersWriteLogChanged in target-procedure.
    end triggers
    .
  
  create fill-in ghSessionTriggerLogFileName
    assign
      name      = 'cFileName':U
      frame     = hFrame
      data-type = 'character':U
      format    = 'x(1024)':U
      width     = 30
      height    = 1
      row       = ghSessionTriggerWriteLog:row + 1.5
      col       = ghSessionTriggerWriteLog:col + 12
      sensitive = yes
    triggers:
      on value-changed
        persistent run qg_SessionTriggersLogFileNameChanged in target-procedure.
    end triggers
    .
  
  create text hTemp
    assign
      format        = 'x(9)':U
      screen-value  = 'Filename:':U
      frame         = hFrame
      width         = font-table:get-text-width-chars('Filename:':U)
      row           = ghSessionTriggerLogFileName:row
      height        = 1
      col           = 1
      .
  
  assign
    hTemp:col = ghSessionTriggerLogFileName:col - hTemp:width - 1
    ghSessionTriggerLogFileName:side-label-handle = hTemp
    .
  
  create button hChooseLogFileButton
    assign
      name                 = 'btnChooseLogFile':U
      frame                = hFrame
      width                = 7
      height               = 1
      row                  = ghSessionTriggerLogFileName:row
      col                  =   ghSessionTriggerLogFileName:col
                             + ghSessionTriggerLogFileName:width
      label                = '...':T
      tooltip              = 'Choose log file':T
      sensitive            = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersChooseLogFileChoose in target-procedure.
    end triggers
    .
  
  create button hOpenLogFileButton
    assign
      name                 = 'btnOpenLogFile':U
      frame                = hFrame
      width                = 10
      height               = 1
      row                  = hChooseLogFileButton:row
      col                  =   hChooseLogFileButton:col
                             + hChooseLogFileButton:width
                             + 1
      label                = 'Open':T
      tooltip              = 'Open log file with default application':T
      sensitive            = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersOpenLogFile in target-procedure.
    end triggers
    .
  
  create button hDeleteLogFileButton
    assign
      name                 = 'btnDeleteLogFile':U
      frame                = hFrame
      width                = 10
      height               = 1
      row                  = hOpenLogFileButton:row
      col                  =   hOpenLogFileButton:col
                             + hOpenLogFileButton:width
      label                = 'Delete':T
      tooltip              = 'Delete log file':T
      sensitive            = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersDeleteLogFile in target-procedure.
    end triggers
    .
  
  create toggle-box ghSessionTriggerIndexValues
    assign
      name      = 'lIndexValues':U
      frame     = hFrame
      width     = 30
      height    = 1
      row       = ghSessionTriggerLogFileName:row + 1.5
      col       = ghSessionTriggerWriteLog:col
      label     = 'Show index values':T
      tooltip   = 'Show index values in message and/or logfile.':T
      sensitive = yes
    triggers:
      on value-changed
        persistent run qg_SessionTriggersShowIndexValuesChanged in target-procedure.
    end triggers
    .
  
  create toggle-box ghSessionTriggerStackTrace
    assign
      name      = 'lStackTrace':U
      frame     = hFrame
      width     = 30
      height    = 1
      row       = ghSessionTriggerIndexValues:row
      col       = ghSessionTriggerIndexValues:col + 30
      label     = 'Show stack trace':T
      tooltip   = 'Show stack trace in message and/or logfile.':T
      sensitive = yes
    triggers:
      on value-changed
        persistent run qg_SessionTriggersShowStackTraceChanged in target-procedure.
    end triggers
    .
  
  create buffer hBuffer for table 'ttSessionTrigger':U. /* code checked by mth 30.07.2015 */
  
  create query hQuery.
  hQuery:set-buffers(hBuffer).
  
  create browse ghSessionTriggersBrowse
    assign
      name                   = 'brSessionTrigger':U
      frame                  = hFrame
      width                  = 100
      height                 = 14
      row                    = 7
      col                    = 3
      read-only              = yes
      row-markers            = no
      allow-column-searching = no
      multiple               = no
      fit-last-column        = yes
      .
  
  create menu hTemp
    assign
      name       = 'm_SessionTriggersBrowsePopupMenu':U
      popup-only = yes
      sensitive  = yes
    triggers:
      on menu-drop
        persistent run qg_SessionTriggersBrowsePopupMenuDrop in target-procedure.
    end triggers.
  
  ghSessionTriggersBrowse:popup-menu = hTemp.
  
  create menu-item hTemp
    assign
      name         = 'mi_TriggerProperties':U
      parent       = ghSessionTriggersBrowse:popup-menu
      label        = 'Trigger properties':T
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersEditTriggerSettings in target-procedure.
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghSessionTriggersBrowse:popup-menu
      .

  create menu-item hTemp
    assign
      name         = 'mi_Activate':U
      parent       = ghSessionTriggersBrowse:popup-menu
      label        = 'Activate':T
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersActivate in target-procedure
                         (?).
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_ActivateAll':U
      parent       = ghSessionTriggersBrowse:popup-menu
      label        = 'Activate all':T
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersActivateAll in target-procedure
                         (yes).
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_DeactivateAll':U
      parent       = ghSessionTriggersBrowse:popup-menu
      label        = 'Deactivate all':T
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersActivateAll in target-procedure
                         (no).
    end triggers
    .
  
  create menu-item hTemp
    assign
      subtype = 'RULE':U
      parent  = ghSessionTriggersBrowse:popup-menu
      .

  create menu-item hTemp
    assign
      name         = 'mi_RemoveSessionTrigger':U
      parent       = ghSessionTriggersBrowse:popup-menu
      label        = 'Remove session trigger':T
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersRemoveSessionTrigger in target-procedure.
    end triggers
    .
  
  create menu-item hTemp
    assign
      name         = 'mi_RemoveAllSessionTriggers':U
      parent       = ghSessionTriggersBrowse:popup-menu
      label        = 'Remove all session triggers':T
      sensitive    = yes
    triggers:
      on choose
        persistent run qg_SessionTriggersRemoveAllSessionTriggers in target-procedure.
    end triggers
    .
  
  on window-close of ghSessionTriggersWindow
    persistent run qg_SessionTriggersWindowClose in target-procedure.
  
  on window-resized of ghSessionTriggersWindow
    persistent run qg_SessionTriggersWindowResized in target-procedure.
  
  on end-error of ghSessionTriggersWindow anywhere
    persistent run qg_MoveToTop in target-procedure.
  
  on ctrl-w of ghSessionTriggersWindow anywhere
    persistent run qg_SessionTriggersWindowClose in target-procedure.
  
  on default-action of ghSessionTriggersBrowse
    persistent run qg_SessionTriggersEditTriggerSettings in target-procedure.
  
  on ' ':U of ghSessionTriggersBrowse
    persistent run qg_SessionTriggersEditTriggerSettings in target-procedure.
  
  on '+':U of ghSessionTriggersBrowse
    persistent run qg_SessionTriggersActivate in target-procedure
                     (yes).
  
  on '-':U of ghSessionTriggersBrowse
    persistent run qg_SessionTriggersActivate in target-procedure
                     (no).
  
  on del of ghSessionTriggersBrowse
    persistent run qg_SessionTriggersRemoveSessionTrigger in target-procedure.
  
  run qg_AddHelpMenu(ghSessionTriggersWindow:menu-bar).
  
  ghSessionTriggersBrowse:query = hQuery.
  
  ghSessionTriggersBrowse:add-like-column('ttSessionTrigger.TriggerActive':U,
                                          0,
                                          'TOGGLE-BOX':U).
  ghSessionTriggersBrowse:add-like-column('ttSessionTrigger.DatabaseName':U).
  ghSessionTriggersBrowse:add-like-column('ttSessionTrigger.TableName':U).
  ghSessionTriggersBrowse:add-like-column('ttSessionTrigger.FieldName':U).
  ghSessionTriggersBrowse:add-like-column('ttSessionTrigger.TriggerEvent':U).
  
  ghSessionTriggersBrowse:get-browse-column(1):width = 4.
  ghSessionTriggersBrowse:get-browse-column(2):width = 10.
  
  run qg_InitBrowse(ghSessionTriggersBrowse).
  
  if gcIconDir = '':U then
    ghSessionTriggersWindow:load-icon('adeicon/icfdev.ico':U) no-error.
    
  else
  do:
  
    ghSessionTriggersWindow:load-icon(substitute('&1/32/script_lightning.ico':U,
                                      gcIconDir)) no-error.
    
    ghSessionTriggersWindow:load-small-icon(substitute('&1/16/script_lightning.ico':U,
                                            gcIconDir)) no-error.
  
  end. /* if gcIconDir = '':U */
  
  assign
    hFrame:hidden                  = no
    ghSessionTriggersWindow:hidden = no
    ghSessionTriggerShowMessage:screen-value = string(glSessionTriggerShowMessage)
    ghSessionTriggerWriteLog:screen-value    = string(glSessionTriggerWriteLog)
    ghSessionTriggerLogFileName:screen-value = string(gcSessionTriggerLogFileName)
    ghSessionTriggerIndexValues:screen-value = string(glSessionTriggerIndexValues)
    ghSessionTriggerStackTrace:screen-value  = string(glSessionTriggerStackTrace)
    .
  
  run qg_SessionTriggersOpenQuery.
  
  apply 'value-changed':U to ghSessionTriggerWriteLog.
  apply 'window-resized':U to ghSessionTriggersWindow.
  apply 'entry':U to ghSessionTriggersBrowse.
  
end. /* else: if valid-handle(ghSessionTriggersWindow) then */

end procedure. /* qg_OpenSessionTriggerWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_OpenWindowRecords hQueryWindow 
PROCEDURE qg_OpenExternalRecord :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hWindow                as handle    no-undo.
define variable hSelfProcedure         as handle    no-undo.
define variable hContainerProcedure    as handle    no-undo.
define variable hChildProcedures       as handle    no-undo extent.
define variable lLinks                 as logical   no-undo.
define variable cContainerSource       as character no-undo.
define variable hContainerSource       as handle    no-undo.
define variable cChildProcedures       as character no-undo.
define variable iChildProcedureCounter as integer   no-undo.
define variable hChildFrame            as handle    no-undo.
define variable hChildFieldGroup       as handle    no-undo.
define variable hChildWidget           as handle    no-undo.
define variable iBrowseBuffercounter   as integer   no-undo.

define variable hTempTable             as handle    no-undo.
define variable iTempTableCounter      as integer   no-undo.
define variable cProcedureName         as character no-undo.

define variable hBuffer                as handle    no-undo.
define variable cTables                as character no-undo.
define variable iTableCounter          as integer   no-undo.
define variable cTableName             as character no-undo.
define variable cRowIds                as character no-undo.
define variable rRowId                 as rowid     no-undo.
define variable cDatabaseName          as character no-undo.

define variable iRecordId              as integer   no-undo.

define variable cIndexInformation      as character no-undo.
define variable iIndexCounter          as integer   no-undo.

define variable cQueryText             as character no-undo.
define variable cFieldList             as character no-undo.
define variable cValueList             as character no-undo.
define variable cValue                 as character no-undo.
define variable hField                 as handle    no-undo.

define variable iQuerySeq              as integer   no-undo initial ?.

/* Buffers -------------------------------------------------------------------*/

define buffer bttExternalRecord for temp-table ttExternalRecord.

define buffer bttTable          for temp-table ttTable.
define buffer bttIndex          for temp-table ttIndex.
define buffer bttIndexField     for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define query brExternalRecord
  for bttExternalRecord
  scrolling.

define browse brExternalRecord
  query brExternalRecord no-lock
    display
      bttExternalRecord.TableName
      bttExternalRecord.RecordKey
      with no-assign fit-last-column size 96 by 10.

define variable lFindByIndex as logical no-undo initial yes
  format 'yes/no':U
  view-as radio-set
    radio-buttons
      'Find by primary index':T, yes,
      'Find by rowid':T, no
    horizontal
  size 45 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Define frame. */

define frame fExternalRecord
  brExternalRecord at row 1.5 col 3
  lFindByIndex at row 12 col 3 no-label
  btnOk at row 14 col 31
  btnCancel at row 14 col 51
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    title gcTitlePrefix + 'Open external record':U
    side-labels no-underline three-d 
    size 101 by 15.83
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fExternalRecord
  apply 'end-error' to self.

on default-action of browse brExternalRecord
  apply 'go':U to frame fExternalRecord.

on value-changed of browse brExternalRecord
do:
  
  define buffer bttTable for temp-table ttTable.
  
  if    not available bttExternalRecord
     or ( valid-handle( hWindow )
      and hWindow:type = 'dialog-box':U ) then
    
    assign
      lFindByIndex                                    = no
      lFindByIndex:sensitive in frame fExternalRecord = no
      .
  
  else
  do:
    
    assign
      iIndexCounter = 1
      lFindByIndex  = no
      .
    
    do while bttExternalRecord.BufferHandle:index-information( iIndexCounter ) <> ?:
      
      cIndexInformation = bttExternalRecord.BufferHandle:index-information( iIndexCounter ).
      
      if    logical( entry( 3, cIndexInformation ), '1/0':U ) /* Index is primary */
        and logical( entry( 2, cIndexInformation ), '1/0':U ) /* Index is unqiue  */ then
      do:
        
        lFindByIndex = yes.
        
        leave.
        
      end. /* if    logical( entry( 3, cIndexInfo ), '1/0':U ) /* Index is primary */ */
      
      iIndexCounter = iIndexCounter + 1.
      
    end. /* do while bttExternalRecord.BufferHandle:index-information( iIndexCounter ) <> ? */
    
    lFindByIndex:sensitive in frame fExternalRecord = lFindByIndex.
    
  end. /* else: if not available bttExternalRecord */
  
  display unless-hidden
    lFindByIndex
    with frame fExternalRecord.
  
end. /* on value-changed of browse brExternalRecord */

empty temp-table ttExternalRecord.

if not can-query(self, 'instantiating-procedure':U) then
  
  leave.

hSelfProcedure = self:instantiating-procedure.

run get-link-handle in hSelfProcedure ( hSelfProcedure,
                                        'container-source':U,
                                        output cContainerSource ) no-error.

assign
  hContainerProcedure = ( if    not error-status:error
                            and cContainerSource > '':U then
                            handle( cContainerSource )
                          else
                            hSelfProcedure )
  hWindow             = hContainerProcedure:current-window
  .

run get-attribute in hContainerProcedure ( 'adm-object-handle':U ) no-error.

if    not error-status:error
  and return-value > '':U then
  
  hWindow = handle( return-value ).

/* The procedure get-link-handle is defined in a super procedure of           */
/* hContainerProcedure and will not show up in its internal-entries. We could */
/* of of course travel through all super procedures and do the check but it   */
/* is much easier to just run the procedure and check if it worked.           */

run get-link-handle in hContainerProcedure ( hContainerProcedure,
                                             'container-target':U,
                                             output cChildProcedures ) no-error.

if error-status:error then
  
  assign
    extent(hChildProcedures) = 1
    hChildProcedures[1]      = hContainerProcedure
    .

else
do:
  
  assign
    extent(hChildProcedures) = num-entries(cChildProcedures) + 1
    hChildProcedures[1]      = hContainerProcedure
    .
  
  do iChildProcedureCounter = 1 to num-entries(cChildProcedures):
    
    hChildProcedures[iChildProcedureCounter + 1] = handle(entry(iChildProcedureCounter, cChildProcedures)).
    
  end. /* do iChildProcedureCounter = 1 to num-entries(cChildProcedures) */
  
end. /* else: if error-status:error */

do iChildProcedureCounter = 1 to extent(hChildProcedures):
  
  if valid-handle( hChildProcedures[iChildProcedureCounter] ) then
  do:
    
    /* Get external Records */
    
    run get-attribute in hChildProcedures[iChildProcedureCounter] ( 'external-tables':U ) no-error.
    
    if not error-status:error
      and return-value > '':U then
    do:
      
      cTables = replace(trim(return-value), ' ':U, ',':U).
      
      if    cTables = ?
         or cTables = '':U then
        next.
      
      run send-records in hChildProcedures[iChildProcedureCounter] (cTables, output cRowIds) no-error.
      
      if error-status:error then
        next.
      
      do iTableCounter = 1 to num-entries(cTables):
        
        assign
          cTableName    = entry(iTableCounter, cTables)
          cDatabaseName = '':U
          .
        
        for each bttTable
          where ( bttTable.DatabaseName = {&K_BASE_DB_NAME}
              and bttTable.TableName    = cTableName )
             or ( bttTable.TableName    = cTableName )
          on error undo, throw:
          
          cDatabaseName = bttTable.DatabaseName.
          
        end. /* for each bttTable */
        
        if cDatabaseName = '':U then
          next.
        
        rRowId = (if num-entries(cRowIds) >= iTableCounter then
                    to-rowid(entry(iTableCounter, cRowIds))
                  else
                    ?).
        
        if can-find(first ttExternalRecord
                      where ttExternalRecord.TableName   = cTableName
                        and ttExternalRecord.RecordRowId = rRowId ) then
          next.
      
        create bttExternalRecord.
        
        assign
          iRecordId                      = iRecordId + 1
          bttExternalRecord.Id           = iRecordId
          bttExternalRecord.DatabaseName = cDatabaseName
          bttExternalRecord.TableName    = cTableName
          bttExternalRecord.RecordRowId  = rRowId
          .
        
        create buffer bttExternalRecord.BufferHandle
          for table substitute('&1.&2':U,
                               bttExternalRecord.DatabaseName,
                               bttExternalRecord.TableName).
        
        if rRowId <> ? then
          bttExternalRecord.BufferHandle:find-by-rowid(bttExternalRecord.RecordRowId) no-error.
        
        bttExternalRecord.RecordKey = (if not bttExternalRecord.BufferHandle:available then
                                         ?
                                       else
                                         qg_cGetPrimaryKeyValues(bttExternalRecord.BufferHandle,
                                                                 ' | ':U,
                                                                 no,
                                                                 no,
                                                                 no,
                                                                 ?)).
        
        validate bttExternalRecord.
        
      end. /* if cTables > '':U */
      
    end. /* if not error-status:error ... */
    
    /* Get Browse buffers. */
    
    run get-attribute in hChildProcedures[iChildProcedureCounter] ( 'adm-object-handle':U ) no-error.

    if    not error-status:error
      and return-value > '':U then
    do:
      
      assign
        hChildFrame = handle( return-value )
        hChildFieldGroup = hChildFrame:first-child
        .
      
      do while valid-handle( hChildFieldGroup )
        on error undo, throw:
        
        hChildWidget = hChildFieldGroup:first-child.
        
        do while valid-handle( hChildWidget )
          on error undo, throw:
          
          if    hChildWidget:type <> 'browse':U
             or not valid-handle( hChildWidget:query ) then
            
            next.
          
          BrowseBuffer:
          do iBrowseBuffercounter = 1 to hChildWidget:query:num-buffers:
            
            hBuffer = hChildWidget:query:get-buffer-handle( iBrowseBuffercounter ).
            
            if can-find( first ttExternalRecord
                           where ttExternalRecord.TableName   = hBuffer:table
                             and ttExternalRecord.RecordRowId = hBuffer:rowid ) then
              
              next.
            
            if valid-handle( hBuffer:table-handle ) then
              
              cDatabaseName = {&K_PERSISTENT_TT_DBNAME}.
            
            else
            do:
              
              cDatabaseName = '':U.
              
              for each bttTable
                where ( bttTable.DatabaseName = {&K_BASE_DB_NAME}
                    and bttTable.TableName    = cTableName )
                   or ( bttTable.TableName    = cTableName )
                on error undo, throw:
                
                cDatabaseName = bttTable.DatabaseName.
                
              end. /* for each bttTable */
              
              if cDatabaseName = '':U then
                
                next BrowseBuffer.
              
            end. /* if valid-handle( hBuffer:table-handle ) */
            
            create bttExternalRecord.
            
            assign
              iRecordId                      = iRecordId + 1
              bttExternalRecord.Id           = iRecordId
              bttExternalRecord.DatabaseName = cDatabaseName
              bttExternalRecord.TableName    = hBuffer:table
              bttExternalRecord.RecordRowId  = hBuffer:rowid
              bttExternalRecord.TableHandle  = hBuffer:table-handle
              .
            
            create buffer bttExternalRecord.BufferHandle for table hBuffer.
            
            if bttExternalRecord.RecordRowId <> ? then
              
              bttExternalRecord.BufferHandle:find-by-rowid( bttExternalRecord.RecordRowId ) no-error.
            
            bttExternalRecord.RecordKey = ( if not bttExternalRecord.BufferHandle:available then
                                              ?
                                            else
                                              qg_cGetPrimaryKeyValues( bttExternalRecord.BufferHandle,
                                                                       ' | ':U,
                                                                       no,
                                                                       no,
                                                                       no,
                                                                       ? ) ).
            
            validate bttExternalRecord.
            
          end. /* do iBrowseBuffercounter = 1 to hChildWidget:query:num-buffers */
          
          finally:
            
            hChildWidget = hChildWidget:next-sibling.
          
          end finally.
          
        end. /* do while valid-handle( hChildWidget ) */
        
        finally:
          
          hChildFieldGroup = hChildFieldGroup:next-sibling.
          
        end finally.
        
      end. /* do while valid-handle( hChildWidget ) */
      
    end. /* if    not error-status:error */
    
  end. /* if valid-handle(hChildProcedures[iChildProcedureCounter]) */
  
end. /* do iChildProcedureCounter = 1 to extent(hChildProcedures) */

&IF proversion >= '11.2':U &THEN
  
  /* Add persistent temp-tables */
  
  do iTempTableCounter = 1 to Progress.Database.TempTableInfo:TempTableCount:
    
    /* Sometimes this invocation fails with an progress runtime error         */
    /* "Invalid value specified for Progress.Database.TempTableInfo:          */
    /* GetTableInfoByPosition (15246)" even though we queried TempTableCount  */
    /* just one line above. To avoid that we call GetTableInfoByPosition with */
    /* no-error and continue with the next entry in case of an error.         */
    
    Progress.Database.TempTableInfo:GetTableInfoByPosition
      ( iTempTableCounter, output hTempTable, output cProcedureName ) no-error.
    
    if error-status:error then
      
      next.
    
    /* Ignore before tables. */
    
    if valid-handle( hTempTable:after-table ) then
      
      next.
    
    do iChildProcedureCounter = 1 to extent( hChildProcedures ):
      
      if hChildProcedures[iChildProcedureCounter]:name <> cProcedureName then
        
        next.
      
      if can-find( first ttExternalRecord
                     where ttExternalRecord.TableName   = hTempTable:name
                       and ttExternalRecord.RecordRowId = hTempTable:default-buffer-handle:rowid ) then
        
        next.
      
      create bttExternalRecord.
      
      assign
        iRecordId                      = iRecordId + 1
        bttExternalRecord.Id           = iRecordId
        bttExternalRecord.DatabaseName = {&K_PERSISTENT_TT_DBNAME}
        bttExternalRecord.TableName    = hTempTable:name
        bttExternalRecord.RecordRowId  = hTempTable:default-buffer-handle:rowid
        bttExternalRecord.TableHandle  = hTempTable
        .
      
      create buffer bttExternalRecord.BufferHandle for table hTempTable.
      
      if bttExternalRecord.RecordRowId <> ? then
        
        bttExternalRecord.BufferHandle:find-by-rowid( bttExternalRecord.RecordRowId ) no-error.
      
      bttExternalRecord.RecordKey = ( if not bttExternalRecord.BufferHandle:available then
                                        ?
                                      else
                                        qg_cGetPrimaryKeyValues( bttExternalRecord.BufferHandle,
                                                                 ' | ':U,
                                                                 no,
                                                                 no,
                                                                 no,
                                                                 ? ) ).
      
      validate bttExternalRecord.
      
    end. /* do iChildProcedureCounter = 1 to extent( hChildProcedures ) */
    
  end. /* do iTempTableCounter = 1 to Progress.Database.TempTableInfo:TempTableCount */
  
&ENDIF

if valid-handle( hWindow ) then
  
  frame fExternalRecord:title = substitute('&1 for window &2':U,
                                           frame fExternalRecord:title,
                                           quoter(trim(if hWindow:title begins gcSessionTitle then
                                                         substring(hWindow:title, length(gcSessionTitle) + 1)
                                                       else
                                                         hWindow:title))).

run qg_InitBrowse(browse brExternalRecord:handle).

open query brExternalRecord
  for each bttExternalRecord
  .

display unless-hidden
  brExternalRecord
  with frame fExternalRecord.

/*
if valid-handle( hWindow ) then
  
  run qg_SetWindowPos( frame fExternalRecord:handle,
                       hWindow:x + hWindow:width-pixels / 2 - frame fExternalRecord:width-pixels / 2,
                       hWindow:y + hWindow:height-pixels / 2 - frame fExternalRecord:height-pixels / 2 ).
*/

if query brExternalRecord:num-results > 0 then
  browse brExternalRecord:select-focused-row().

apply 'value-changed':U to browse brExternalRecord.

update unless-hidden
  brExternalRecord
  lFindByIndex
    when lFindByIndex
  btnOk
  btnCancel
  with frame fExternalRecord
    in window {&WINDOW-NAME}.

if not available bttExternalRecord then
  leave.

if    valid-handle( hWindow )
  and hWindow:type                  = 'dialog-box':U
  and bttExternalRecord.RecordRowId = ? then
  
  leave.

if valid-handle( bttExternalRecord.TableHandle ) then
  
run qg_AddTableHandle( /* phTable         */ bttExternalRecord.TableHandle,
                       /* phOriginalTable */ bttExternalRecord.TableHandle,
                       /* plSnapshot      */ no,
                       /* pcDatabaseName  */ {&K_PERSISTENT_TT_DBNAME},
                       /* pcPhysicalName  */ {&K_PERSISTENT_TT_PHYSICALNAME} ).

if    valid-handle( hWindow )
  and hWindow:type = 'dialog-box':U then
  
  run qg_EditRecord( /* phBuffer       */ bttExternalRecord.BufferHandle,
                     /* piEditAction   */ {&K_EDITACTION_EDIT},
                     /* plEditMode     */ no,
                     /* phParentWindow */ hQueryWindow,
                     /* pcFieldList    */ ?,
                     /* oprRowid       */ output bttExternalRecord.RecordRowId ).
  
else
do:
  
  if not lFindByIndex then
    
    cQueryText = substitute('for each &1~n  where rowid(&1) = to-rowid(~'&2~')':U,
                            bttExternalRecord.TableName,
                            string(bttExternalRecord.RecordRowId)).
  
  else
  do:
    
    cQueryText = substitute('for each &1':U, bttExternalRecord.TableName).
    
    find bttIndex
      where bttIndex.DatabaseName = bttExternalRecord.DatabaseName
        and bttIndex.TableName    = bttExternalRecord.TableName
        and bttIndex.IsPrimary    = yes
      no-error.
  
    for each bttIndexField
      where bttIndexField.DatabaseName = bttIndex.DatabaseName
        and bttIndexField.TableName    = bttIndex.TableName
        and bttIndexField.IndexName    = bttIndex.IndexName
      by bttIndexField.IndexSequence
      on error undo, throw:
      
      cFieldList = substitute('&1,&2':U,
                              cFieldList,
                              bttIndexField.FieldName).
      
      if not bttExternalRecord.BufferHandle:available then
        
        cValue = '?':U.
      
      else
      do:
        
        hField = bttExternalRecord.BufferHandle:buffer-field(bttIndexField.FieldName).
        
        case hField:data-type:
          
          when 'rowid':U then
            
            cValue = substitute( 'to-rowid( &1 )':U, quoter( hField:buffer-value ) ).
          
          when 'datetime':U then 
            
            cValue = substitute( 'datetime( &1 )':U, quoter( hField:buffer-value ) ).
          
          when 'datetime-tz':U then 
            
            cValue = substitute( 'datetime-tz( &1 )':U, quoter( hField:buffer-value ) ).
          
          otherwise
            
            cValue = quoter( hField:buffer-value ).
          
        end case. /* hField:data-type */
        
      end. /* if not bttExternalRecord.BufferHandle:available */
      
      cValueList = substitute( '&1&2&3':U,
                               cValueList,
                               {&K_PARAM_SPLITTER},
                               cValue ).
      
    end. /* for each bttIndexField */
    
    assign
      cFieldList = trim(cFieldList, ',':U)
      cValueList = trim(cValueList, {&K_PARAM_SPLITTER})
      cQueryText = substitute( '&1~n&2~n':U,
                               cQueryText,
                               qg_cCreateWhereClause( /* pcDatabaseName   */ bttExternalRecord.DatabaseName,
                                                      /* pcTableNames     */ bttExternalRecord.TableName,
                                                      /* pcBufferNames    */ bttExternalRecord.TableName,
                                                      /* pcFieldList      */ cFieldList,
                                                      /* pcFieldLabelList */ ?,
                                                      /* plStartWithWhere */ yes,
                                                      /* piValueMode      */ {&K_VALUE_MODE_PARAMETER},
                                                      /* pcValueList      */ cValueList,
                                                      /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                                      /* plAddTags        */ no,
                                                      /* piIndentBlanks   */ 2 ) )
      .
    
  end. /* bttExternalRecord.TableName */
  
  run qg_ExecQuery( {&K_QUERY_WINDOW_MODE_RECORD},
                    {&K_RECORD_SIZE_MODE_DEFAULT},
                    substitute('&1.&2':U,
                               bttExternalRecord.DatabaseName,
                               bttExternalRecord.TableName),
                    trim(cQueryText),
                    no,  /* Init mode */
                    '':U,
                    input-output iQuerySeq).
  
end. /* if    valid-handle( hWindow ) */

finally:
  
  for each bttExternalRecord
    on error undo, throw:
    
    if valid-handle(bttExternalRecord.BufferHandle) then
      delete object bttExternalRecord.BufferHandle no-error.
    
  end. /* for each bttExternalRecord */
  
end finally.

end procedure. /* qg_OpenExternalRecord */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ParseQueryConditions hQueryWindow 
PROCEDURE qg_ParseQueryConditions :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Find conditions in given query text. The result will be stored in           */
/* ttQueryCondition.                                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcQueryText                    = Query text that should be parsed.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcQueryText as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lConditionRight  as logical   no-undo.

define variable iOffset          as integer   no-undo.
define variable iTokenId         as integer   no-undo.
define variable iParentId        as integer   no-undo.

define variable iMaxOffset       as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST       for temp-table ttQueryAST.
define buffer b2ttQueryAST      for temp-table ttQueryAST.
define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

empty temp-table ttQueryCondition.

run qg_QueryParserParseQuery(pcQueryText).

find first bttQueryAST
  where bttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
    and bttQueryAST.TokenStart >= iOffset
    and bttQueryAST.TokenType  <> {&K_QP_TOKEN_TYPE_COMMENT}
  no-error.

do while available bttQueryAST:
  
  if    ( bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
      and bttQueryAST.TokenText = 'WHERE':U )
     or ( bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
      and lookup(bttQueryAST.TokenText, 'WHERE,AND,OR':U) > 0 ) then
  do:
    
    assign
      lConditionRight = no
      iOffset         = bttQueryAST.TokenEnd
      .
    
    /*------------------------------------------------------------------------*/
    /* Left side                                                              */
    /*------------------------------------------------------------------------*/
    
    /* Try to detect the correct parent id. */
    
    run qg_QueryParserFindToken(bttQueryAST.ParentId,
                                bttQueryAST.TokenEnd,
                                {&K_QP_TOKEN_TYPE_OPERATOR},
                                {&K_QP_COMPARATOR_OPERATORS},
                                output iTokenId,
                                output iParentId).
    
    if iParentId = ? then
      run qg_QueryParserFindToken(bttQueryAST.ParentId,
                                  bttQueryAST.TokenEnd,
                                  {&K_QP_TOKEN_TYPE_OPERATOR},
                                  'AND,OR':U,
                                  output iTokenId,
                                  output iParentId).
    
    if iParentId = ? then
      run qg_QueryParserFindToken(bttQueryAST.ParentId,
                                  bttQueryAST.TokenEnd,
                                  {&K_QP_TOKEN_TYPE_KEYWORD},
                                  'WHERE':U,
                                  output iTokenId,
                                  output iParentId).
    
    if iParentId = ? then
      run qg_QueryParserFindToken(bttQueryAST.ParentId,
                                  bttQueryAST.TokenEnd,
                                  ?,        /* any token type */
                                  '!(,*':U, /* first token that is not a opening parenthese */
                                  output iTokenId,
                                  output iParentId).
    
    if iParentId = ? then
      iParentId = bttQueryAST.ParentId.
    
    /* Get condition min offset. */
    
    find first b2ttQueryAST
      where b2ttQueryAST.ParentId    = iParentId
        and b2ttQueryAST.TokenStart >= iOffset
        and b2ttQueryAST.TokenType  <> {&K_QP_TOKEN_TYPE_COMMENT}
      use-index ParentId
      no-error.
    
    if available b2ttQueryAST then
      iOffset = b2ttQueryAST.TokenStart.
    
    /* Get condition max offset. */
    
    find last b2ttQueryAST
      where b2ttQueryAST.ParentId    = iParentId
        and b2ttQueryAST.TokenStart >= iOffset
        and b2ttQueryAST.TokenType  <> {&K_QP_TOKEN_TYPE_COMMENT}
      use-index ParentId
      no-error.
    
    if available b2ttQueryAST then
    do:
      
      iMaxOffset = b2ttQueryAST.TokenEnd.
      
      create bttQueryCondition.
      
      for each b2ttQueryAST
        where b2ttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
          and b2ttQueryAST.TokenStart >= iOffset
          and b2ttQueryAST.TokenEnd   <= iMaxOffset
          and b2ttQueryAST.TokenType  <> {&K_QP_TOKEN_TYPE_COMMENT}
        by b2ttQueryAST.TokenStart by b2ttQueryAST.TokenEnd
        on error undo, throw:
        
        if    b2ttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_PUNCTUATION}
           or ( b2ttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
            and lookup(b2ttQueryAST.TokenText, {&K_QP_CONDITION_BREAK_KEYWORDS}) > 0)
           or ( b2ttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
            and b2ttQueryAST.ParentId  = iParentId
            and lookup(b2ttQueryAST.TokenText, 'AND,OR':U) > 0 ) then
          leave.
        
        if bttQueryCondition.LeftStartPos = 0 then
          bttQueryCondition.LeftStartPos = b2ttQueryAST.TokenStart.
        
        if    b2ttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
          and lookup(b2ttQueryAST.TokenText, {&K_QP_COMPARATOR_OPERATORS}) > 0 then
        do:
          
          assign
            bttQueryCondition.ComparatorStartPos = b2ttQueryAST.TokenStart
            bttQueryCondition.ComparatorEndPos   = b2ttQueryAST.TokenEnd
            lConditionRight                      = yes
            .
          
          leave.
          
        end. /* if    b2ttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR} ... */
        
        bttQueryCondition.LeftEndPos = b2ttQueryAST.TokenEnd.
        
      end. /* for each b2ttQueryAST */
      
      assign
        bttQueryCondition.LeftEndPos       = max(bttQueryCondition.LeftStartPos,
                                                 bttQueryCondition.LeftEndPos)
        bttQueryCondition.ComparatorEndPos = max(bttQueryCondition.ComparatorStartPos,
                                                 bttQueryCondition.ComparatorEndPos)
        iOffset                            = max(iOffset,
                                                 bttQueryCondition.LeftEndPos,
                                                 bttQueryCondition.ComparatorEndPos)
        .
      
      /* Get right side */
      
      if lConditionRight then
      do:
        
        for each b2ttQueryAST
          where b2ttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
            and b2ttQueryAST.TokenStart >= iOffset
            and b2ttQueryAST.TokenEnd   <= iMaxOffset
            and b2ttQueryAST.TokenType  <> {&K_QP_TOKEN_TYPE_COMMENT}
          use-index ParentId
          by b2ttQueryAST.TokenStart by b2ttQueryAST.TokenEnd
          on error undo, throw:
          
          if    b2ttQueryAST.TokenType   = {&K_QP_TOKEN_TYPE_PUNCTUATION}
             or ( b2ttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
              and lookup(b2ttQueryAST.TokenText, {&K_QP_CONDITION_BREAK_KEYWORDS}) > 0)
             or ( b2ttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
              and b2ttQueryAST.ParentId  = iParentId
              and lookup(b2ttQueryAST.TokenText, 'AND,OR':U) > 0 ) then
            leave.
          
          if bttQueryCondition.RightStartPos = 0 then
            bttQueryCondition.RightStartPos = b2ttQueryAST.TokenStart.
          
          bttQueryCondition.RightEndPos = b2ttQueryAST.TokenEnd.
          
        end. /* for each b2ttQueryAST */
        
        if bttQueryCondition.RightStartPos = 0 then
          bttQueryCondition.RightStartPos  = ( if not can-find(first ttQueryAST
                                                                 where ttQueryAST.NodeType = {&K_QP_NODE_TYPE_TOKEN}
                                                                   and ttQueryAST.TokenStart <= bttQueryCondition.ComparatorEndPos + 1
                                                                   and ttQueryAST.TokenEnd   >= bttQueryCondition.ComparatorEndPos + 1) then
                                                 bttQueryCondition.ComparatorEndPos + 1
                                               else
                                                 bttQueryCondition.ComparatorEndPos ).
        
        assign
          bttQueryCondition.RightEndPos = max(bttQueryCondition.RightStartPos,
                                              bttQueryCondition.RightEndPos)
          iOffset                       = max(iOffset,
                                              bttQueryCondition.RightEndPos)
          lConditionRight               = no
          .
        
      end. /* if lConditionRight */
      
      assign
        bttQueryCondition.StartPos = bttQueryCondition.LeftStartPos
        bttQueryCondition.EndPos   = max(bttQueryCondition.LeftEndPos,
                                         bttQueryCondition.ComparatorEndPos,
                                         bttQueryCondition.RightEndPos)
        .
      
    end. /* if    bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR} */
  
  end. /* if available b2ttQueryAST */
  
  find next bttQueryAST
    where bttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
      and bttQueryAST.TokenStart >= iOffset
      and bttQueryAST.TokenType  <> {&K_QP_TOKEN_TYPE_COMMENT}
    no-error.
  
end. /* for each bttQueryAST */
  
end procedure. /* qg_ParseQueryConditions */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ParseQueryLinks hQueryWindow 
PROCEDURE qg_ParseQueryLinks :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Parse query text for external references.                                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcQueryText                    = Query text that should be parsed.         */
/* piTargetSeq                    = Sequence number of the query window that  */
/*                                  the query text belongs to.                */
/* phTempTable                    = Handle of the temp-table that will be     */
/*                                  used to store the parses.                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcQueryText as character no-undo.
define input parameter piTargetSeq as integer   no-undo.
define input parameter phTempTable as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hTempTableBuffer as handle    no-undo.
define variable hQuery           as handle    no-undo.

define variable cRefText        as character no-undo.
define variable cTokenFieldText as character no-undo.
define variable iTokenStartPos  as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create buffer hTempTableBuffer for table phTempTable.

if phTempTable:has-records then
do:
  
  /* Delete all entries to given target sequence number. */
  
  create query hQuery.
  hQuery:add-buffer(hTempTableBuffer).
  
  hQuery:query-prepare(substitute('for each &1 where &1.TargetSeq = &2':U,
                                  hTempTableBuffer:name,
                                  quoter(piTargetSeq))).
  
  hQuery:query-open().
  hQuery:get-first().
  
  do while not hQuery:query-off-end:
    
    hTempTableBuffer:buffer-delete().
    hQuery:get-next().
    
  end. /* do while not hQuery:query-off-end */
  
end. /* if phTempTable:has-records */

/* Find external references. */

assign
  giQueryParserSeq = 0
  gcQPQueryText    = pcQueryText
  giQPOffset       = 1
  giQPTokenStart   = 1
  giQPTokenEnd     = 0
  gcQPToken        = '':U
  giQPTokenType    = {&K_QP_TOKEN_TYPE_UNDEFINED}
  .

run qg_QueryParserGetNextToken.

do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF}:
  
  if    giQPTokenType = {&K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE}
    and num-entries(gcQPToken, ':':U) = 2 then
  do:
    
    hTempTableBuffer:buffer-create().
    
    assign
      hTempTableBuffer::StartPos  = giQPTokenStart
      hTempTableBuffer::EndPos    = giQPTokenEnd
      hTempTableBuffer::TargetSeq = piTargetSeq
      cRefText                    = substring(gcQPToken, 3, length(gcQPToken) - 3)
      hTempTableBuffer::SourceSeq = integer(entry(1, cRefText, ':':U))
      cTokenFieldText             = entry(2, cRefText, ':':U)
      .
    
    if   trim(cTokenFieldText) matches 'recid(*)':U
      or trim(cTokenFieldText) matches 'rowid(*)':U then
      assign
        iTokenStartPos               = index(cTokenFieldText, '(':U)
        hTempTableBuffer::BufferName = trim(substring(cTokenFieldText,
                                                      iTokenStartPos + 1,
                                                        index(cTokenFieldText,
                                                              ')':U,
                                                              iTokenStartPos)
                                                      - 1
                                                      - iTokenStartPos))
        hTempTableBuffer::FieldName  = substitute('$&1':U,
                                                  trim(substring(cTokenFieldText,
                                                                 1,
                                                                 iTokenStartPos - 1)))
        .
      
    else if num-entries(cTokenFieldText, '.':U) = 2 then
      assign
        hTempTableBuffer::BufferName = entry(1, cTokenFieldText, '.':U)
        cTokenFieldText              = entry(2, cTokenFieldText, '.':U)
        iTokenStartPos               = index(cTokenFieldText, '[':U)
        hTempTableBuffer::FieldIndex = (if iTokenStartPos = 0 then
                                          0
                                        else
                                          integer(substring(cTokenFieldText,
                                                            iTokenStartPos + 1,
                                                              index(cTokenFieldText,
                                                                    ']':U,
                                                                    iTokenStartPos)
                                                            - 1
                                                            - iTokenStartPos)))
        hTempTableBuffer::FieldName  = (if iTokenStartPos = 0 then
                                          cTokenFieldText
                                        else
                                          substring(cTokenFieldText,
                                                    1,
                                                    iTokenStartPos - 1))
        .
    
    hTempTableBuffer:buffer-validate().
    
  end. /* if giQPTokenType = {&K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE} */
  
  giQPOffset = giQPTokenEnd.
  
  run qg_QueryParserGetNextToken.
  
end. /* do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF} */

finally:
  
  if valid-handle(hQuery) then
    delete object hQuery no-error.
  
  if valid-handle(hTempTableBuffer) then
    delete object hTempTableBuffer no-error.
  
end finally.
  
end procedure. /* qg_ParseQueryLinks */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ProcessBlockNameChange hQueryWindow 
PROCEDURE qg_ProcessBlockNameChange :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Necessary processing when blockname changed.                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  gcBufferName   = (if glSlimMode then
                      substitute({&K_DEFAULT_BUFFER_PATTERN},
                                 qg_cGetBufferBaseName(no))
                    else
                      input frame {&FRAME-NAME} gcBufferName)
  gcBlockName    = (if glSlimMode then
                      substitute({&K_DEFAULT_BLOCK_PATTERN},
                                 gcBufferName)
                    else
                      input frame {&FRAME-NAME} gcBlockName)
  .

if    not glSlimMode
  and gcBufferName > '':U then
  gcBlockPattern = replace(gcBlockName,
                           gcBufferName,
                           '&1':U).
  
run qg_WidgetState('!gcBlockName,*':U).
run qg_UpdateQueryText.

end procedure. /* qg_ProcessBlockNameChange */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ProcessBufferNameChange hQueryWindow 
PROCEDURE qg_ProcessBufferNameChange :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Necessary processing when buffername changed.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  gcBufferName     = (if glSlimMode then
                        substitute({&K_DEFAULT_BUFFER_PATTERN},
                                   qg_cGetBufferBaseName(no))
                      else
                        input frame {&FRAME-NAME} gcBufferName)
  gcBufferBaseName = qg_cGetBufferBaseName(   glDefineBuffer
                                           or (  gcBufferPattern  > '':U
                                             and gcBufferPattern <> '&1':U))
  .

if    not glSlimMode
  and gcBufferBaseName > '':U then
  gcBufferPattern = replace(gcBufferName,
                            gcBufferBaseName,
                            '&1':U).

run qg_UpdateBlockName.
run qg_UpdateQueryText.

end procedure. /* qg_ProcessBufferNameChange */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserAddLeaf hQueryWindow 
PROCEDURE qg_QueryParserAddLeaf :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add leaf node.                                                             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piParentId                     = Id of the parent node.                    */
/* piLevel                        = Level of the node.                        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piParentId as integer   no-undo.
define input parameter piLevel    as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST for temp-table ttQueryAST.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create bttQueryAST.

assign
  giQueryParserSeq       = giQueryParserSeq + 1
  bttQueryAST.Id         = giQueryParserSeq 
  bttQueryAST.ParentId   = piParentId
  bttQueryAST.TokenStart = giQPTokenStart
  bttQueryAST.TokenEnd   = giQPTokenEnd
  bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_TOKEN}
  bttQueryAST.TokenText  = gcQPToken
  bttQueryAST.TokenType  = giQPTokenType
  bttQueryAST.Level      = piLevel
  .

validate bttQueryAST.

giQPOffset = giQPTokenEnd.

end procedure. /* qg_QueryParserAddLeaf */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserFindToken hQueryWindow 
PROCEDURE qg_QueryParserFindToken :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Find given token.                                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piParentId                     = Parent id.                                */
/* piOffset                       = Offset.                                   */
/* piTokenType                    = Token type.                               */
/* pcTokenText                    = Token text                                */
/* opiTokenId                     = Token id (? if none has been found).      */
/* opiParentId                    = Parent Node (? if none has been found).   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter piParentId  as integer   no-undo.
define input  parameter piOffset    as integer   no-undo.
define input  parameter piTokenType as integer   no-undo.
define input  parameter pcTokenText as character no-undo.
define output parameter opiTokenId  as integer   no-undo initial ?.
define output parameter opiParentId as integer   no-undo initial ?.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST for temp-table ttQueryAST.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttQueryAST
  where bttQueryAST.ParentId   = piParentId
    and bttQueryAST.TokenStart > piOffset
  by bttQueryAST.TokenStart by bttQueryAST.TokenEnd
  on error undo, throw:
  
  if    bttQueryAST.NodeType = {&K_QP_NODE_TYPE_TOKEN}
    and ( piTokenType = ?
       or bttQueryAST.TokenType = piTokenType )
    and ( pcTokenText = ?
       or can-do(pcTokenText, bttQueryAST.TokenText) ) then
  do:
    
    assign
      opiTokenId  = bttQueryAST.Id
      opiParentId = bttQueryAST.ParentId
      .
    
    leave.
    
  end. /* if   pcTokenText           = ? */
  
  else
  do:
    
    run qg_QueryParserFindToken(bttQueryAST.Id,
                                piOffset,
                                piTokenType,
                                pcTokenText,
                                output opiTokenId,
                                output opiParentId).
    
    if opiTokenId <> ? then
      leave.
    
  end. /* if   pcTokenText           = ? */
  
end. /* for each bttQueryAST */

end procedure. /* qg_QueryParserFindToken */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserGetNextToken hQueryWindow 
PROCEDURE qg_QueryParserGetNextToken :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get next token of query text.                                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iOffset       as integer   no-undo.

define variable cChar         as character no-undo extent 2.

define variable cStringChar   as character no-undo.
define variable lEscape       as logical   no-undo.

define variable iCommentLevel as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  iOffset  = giQPOffset
  cChar[1] = substring(gcQPQueryText, iOffset, 1).

/*----------------------------------------------------------------------------*/
/* Remove white spaces                                                        */
/*----------------------------------------------------------------------------*/

do while index(' ~t~n':U, cChar[1]) > 0:
  
  assign
    iOffset  = iOffset + 1
    cChar[1] = substring(gcQPQueryText, iOffset, 1)
    .
  
end. /* do while index(' ~t~n':U, cChar[1]) > 0 */

/*----------------------------------------------------------------------------*/
/* Determin token type                                                        */
/*----------------------------------------------------------------------------*/

assign
  giQPTokenStart = iOffset
  gcQPToken      = cChar[1]
  .

if length(cChar[1]) = 0 then
  giQPTokenType = {&K_QP_TOKEN_TYPE_EOF}.

else if index('~'"':U, cChar[1]) > 0 then
  giQPTokenType = {&K_QP_TOKEN_TYPE_STRING}.

else if cChar[1] = '/':U then
  assign
    cChar[2]      = substring(gcQPQueryText, iOffset + 1, 1)
    giQPTokenType = (if cChar[2] = '*':U then
                       {&K_QP_TOKEN_TYPE_COMMENT}
                     else
                       {&K_QP_TOKEN_TYPE_OPERATOR})
    .

else if index('-.':U, cChar[1]) > 0 then
  assign
    cChar[2]      = substring(gcQPQueryText, iOffset + 1, 1)
    giQPTokenType = (if    cChar[1] <> cChar[2]
                       and index('0123456789.':U, cChar[2]) > 0 then
                       {&K_QP_TOKEN_TYPE_NUMBER}
                     else if cChar[1] = '.':U then
                       {&K_QP_TOKEN_TYPE_PUNCTUATION}
                     else
                       {&K_QP_TOKEN_TYPE_OPERATOR})
    .
else if cChar[1] = '~{':U then
  assign
    cChar[2]      = substring(gcQPQueryText, iOffset + 1, 1)
    giQPTokenType = (if cChar[2] = '&':U then
                       {&K_QP_TOKEN_TYPE_PREPROCESSOR}
                     else
                       {&K_QP_TOKEN_TYPE_BRACE_OPEN})
    .

else if cChar[1] = '}':U then
  giQPTokenType = {&K_QP_TOKEN_TYPE_BRACE_CLOSE}.

else if cChar[1] = '[':U then
  giQPTokenType = {&K_QP_TOKEN_TYPE_BRACKET_OPEN}.

else if cChar[1] = ']':U then
  giQPTokenType = {&K_QP_TOKEN_TYPE_BRACKET_CLOSE}.

else if cChar[1] = '(':U then
  giQPTokenType = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}.

else if cChar[1] = ')':U then
  giQPTokenType = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}.

else if index(':,':U, cChar[1]) > 0 then
  giQPTokenType = {&K_QP_TOKEN_TYPE_PUNCTUATION}.

else if index('0123456789':U, cChar[1]) > 0 then
  giQPTokenType = {&K_QP_TOKEN_TYPE_NUMBER}.

else if cChar[1] = '$':U then
  assign
    cChar[2]      = substring(gcQPQueryText, iOffset + 1, 1)
    giQPTokenType = (if cChar[2] = '~{':U then
                       {&K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE}
                     else
                       {&K_QP_TOKEN_TYPE_UNDEFINED})
    .

else if index('+*=<>':U, cChar[1]) > 0 then
  giQPTokenType = {&K_QP_TOKEN_TYPE_OPERATOR}.

else if index('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_':U, cChar[1]) > 0 then
  giQPTokenType = {&K_QP_TOKEN_TYPE_IDENTIFIER}.

else
  giQPTokenType = {&K_QP_TOKEN_TYPE_UNDEFINED}.

/*----------------------------------------------------------------------------*/
/* Read token                                                                 */
/*----------------------------------------------------------------------------*/

case giQPTokenType:
  
  when {&K_QP_TOKEN_TYPE_STRING} then
  do:
    
    assign
      cStringChar = cChar[1]
      iOffset     = iOffset + 1
      cChar[1]    = substring(gcQPQueryText, iOffset, 1)
      .
    
    /* Get complete string */
    
    do while length(cChar[1]) > 0:
      
      assign
        gcQPToken = gcQPToken + cChar[1]
        iOffset   = iOffset + 1.
        .
      
      if lEscape then
        lEscape = no.
      
      else
      do:
        
        if cChar[1] = '~~':U then
          lEscape = yes.
        
        else if cChar[1] = cStringChar then
        do:
          
          cChar[2] = substring(gcQPQueryText, iOffset, 1).
          
          if cChar[2] = cStringChar then
            lEscape = yes.
          
          else
            leave.
            
        end. /* else if cChar[1] = cStringChar */
        
      end. /* if lEscape */
      
      cChar[1] = substring(gcQPQueryText, iOffset, 1).
      
    end. /* do while length(cChar[1]) > 0 */
    
    /* Add translation attribute to string token. */
    
    assign
      cChar[1] = substring(gcQPQueryText, iOffset, 1)
      cChar[2] = substring(gcQPQueryText, iOffset + 1, 1)
      .
    
    if    cChar[1] = ':':U
      and index('RLCTU':U, cChar[2])  > 0 then
    do:
      
      assign
        gcQPToken = gcQPToken + cChar[1] + cChar[2]
        iOffset   = iOffset + 2.
        .
      
      do while yes:
        
        cChar[1] = substring(gcQPQueryText, iOffset, 1).
        
        if index('1234567890':U, cChar[1]) = 0 then
          leave.
        
        assign
          gcQPToken = gcQPToken + cChar[1]
          iOffset   = iOffset + 1.
          .
        
      end. /* do while yes */
      
    end. /* if cChar[1] = ':':U */
    
  end. /* when {&K_QP_TOKEN_TYPE_STRING} */
  
  when {&K_QP_TOKEN_TYPE_COMMENT} then
  do:
    
    assign
      iCommentLevel = 1
      iOffset       = iOffset + 1
      cChar[1]      = substring(gcQPQueryText, iOffset, 1)
      .
    
    do while length(cChar[1]) > 0:
      
      assign
        gcQPToken = gcQPToken + cChar[1].
        iOffset   = iOffset + 1
        .
      
      if cChar[1] = '/':U then
      do:
        
        cChar[2] = substring(gcQPQueryText, iOffset, 1).
        
        if cChar[2] = '*':U then
        do:
          
          assign
            iCommentLevel = iCommentLevel + 1
            gcQPToken     = gcQPToken + cChar[2]
            iOffset       = iOffset + 1
            .
          
          next.
          
        end. /* if cChar[2] = '*':U */
        
      end. /* if cChar[1] '/':U */
      
      else if cChar[1] = '*':U then
      do:
        
        cChar[2] = substring(gcQPQueryText, iOffset, 1).
        
        if cChar[2] = '/':U then
        do:
          
          assign
            iCommentLevel = iCommentLevel - 1
            gcQPToken     = gcQPToken + cChar[2]
            iOffset       = iOffset + 1
            .
          
          if iCommentLevel = 0 then
            leave.
          
          else
            next.
          
        end. /* if cChar[2] = '/':U */
        
      end. /* else if cChar[1] = '*':U */
      
      cChar[1] = substring(gcQPQueryText, iOffset, 1).
      
    end. /* do while length(cChar[1]) > 0 */
    
  end. /* when {&K_QP_TOKEN_TYPE_COMMENT} */
  
  when {&K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE} then
  do:
    
    assign
      iOffset  = iOffset + 1
      cChar[1] = substring(gcQPQueryText, iOffset, 1)
      .
    
    do while length(cChar[1]) > 0:
      
      assign
        gcQPToken = gcQPToken + cChar[1]
        iOffset   = iOffset + 1.
        .
      
      if cChar[1] = '}':U then
        leave.
      
      cChar[1] = substring(gcQPQueryText, iOffset, 1).
      
    end. /* do while length(cChar[1]) > 0 */
    
  end. /* when {&K_QP_TOKEN_TYPE_EXTERNAL_REFERENCE} */
  
  when      {&K_QP_TOKEN_TYPE_NUMBER}
    or when {&K_QP_TOKEN_TYPE_IDENTIFIER} then
  do:
    
    iOffset = iOffset + 1.
    
    do while yes:
      
      cChar[1] = substring(gcQPQueryText, iOffset, 1).
      
      if length(cChar[1]) = 0 then
        leave.
      
      if index(' ~t~n()[]~{}<>=,+*':U, cChar[1]) > 0 then
        leave.
      
      else
        if index('.:':U, cChar[1]) > 0 then
        do:
          
          cChar[2] = substring(gcQPQueryText, iOffset + 1, 1).
          
          if   index(' ~t~n':U, cChar[2]) > 0
            or length(cChar[2]) = 0 then
            leave.
          
        end. /* else if index('.:':U, cChar[1]) > 0 ... */
      
      case giQPTokenType:
        
        when {&K_QP_TOKEN_TYPE_NUMBER} then
        do:
          
          if cChar[1] = '/':U then
          do:
            
            if index('-.':U, gcQPToken) = 0 then
              giQPTokenType = {&K_QP_TOKEN_TYPE_DATE}.
            
          end. /* if cChar[1] = '/':U */
          
        end. /* when {&K_QP_TOKEN_TYPE_NUMBER} */
        
        when {&K_QP_TOKEN_TYPE_DATE} then
        do:
          
          if index('123456789/':U, cChar[1]) = 0 then
            leave.
          
        end. /* when {&K_QP_TOKEN_TYPE_DATE} */
        
      end case. /* giQPTokenType */
      
      assign
        gcQPToken = gcQPToken + cChar[1].
        iOffset   = iOffset + 1
        .
      
    end. /* do while length(cChar[1]) > 0 */
    
  end. /* when {&K_QP_TOKEN_TYPE_NUMBER} */
  
  when {&K_QP_TOKEN_TYPE_OPERATOR} then 
  do:
    
    iOffset = iOffset + 1.
    
    if cChar[1] = '<':U then
    do:
      
      cChar[2] = substring(gcQPQueryText, iOffset, 1).
      
      if index('>=':U, cChar[2]) > 0 then
        assign
          gcQPToken = gcQPToken + cChar[2]
          iOffset   = iOffset + 1
          .
      
    end. /* if cChar[1] = '<':U */
    
    else if cChar[1] = '>':U then
    do:
      
      cChar[2] = substring(gcQPQueryText, iOffset, 1).
      
      if cChar[2] = '=':U then
        assign
          gcQPToken = gcQPToken + cChar[2]
          iOffset   = iOffset + 1
          .
      
    end. /* if cChar[1] = '>':U */
    
  end. /* when {&K_QP_TOKEN_TYPE_OPERATOR} */
  
  otherwise
    iOffset = iOffset + 1.
  
end case. /* case giQPTokenType */

if giQPTokenType = {&K_QP_TOKEN_TYPE_IDENTIFIER} then
do:
  
  if lookup(gcQPToken, 'AND,OR,NOT,EQ,LT,LE,GE,GT,NE,BEGINS,MATCHES,CONTAINS,MODULO':U) > 0 then
    giQPTokenType = {&K_QP_TOKEN_TYPE_OPERATOR}.
  
  else if keyword(gcQPToken) <> ? then
    giQPTokenType = {&K_QP_TOKEN_TYPE_KEYWORD}.
  
end. /* if giQPTokenType = {&K_QP_TOKEN_TYPE_IDENTIFIER} */

giQPTokenEnd = iOffset.

end procedure. /* qg_QueryParserGetNextToken */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserParseBracket hQueryWindow 
PROCEDURE qg_QueryParserParseBracket :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Parse bracket node.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* For easier handling later on two subnodes will be created for bracket      */
/* nodes. One will contain all contents including the brackets and one will   */
/* contain only the contents within the brackets but excluding the brackets.  */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piParentId                     = Id of the parent node.                    */
/* piLevel                        = Level of the node                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piParentId as integer   no-undo.
define input parameter piLevel    as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iTokenType as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST  for temp-table ttQueryAST.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    giQPTokenType <> {&K_QP_TOKEN_TYPE_BRACE_OPEN}
  and giQPTokenType <> {&K_QP_TOKEN_TYPE_BRACKET_OPEN}
  and giQPTokenType <> {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
  and giQPTokenType <> {&K_QP_TOKEN_TYPE_PREPROCESSOR} then
  leave.

iTokenType = giQPTokenType.

/* Add bracket node. */

create bttQueryAST.

assign
  giQueryParserSeq       = giQueryParserSeq + 1
  bttQueryAST.Id         = giQueryParserSeq
  bttQueryAST.ParentId   = piParentId
  bttQueryAST.TokenStart = giQPTokenStart
  bttQueryAST.Level      = piLevel
  bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_UNDEFINED}
  bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_NODE}
  .

validate bttQueryAST.

run qg_QueryParserAddLeaf(bttQueryAST.Id, piLevel).

run qg_QueryParserGetNextToken.

do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF}:
  
  run qg_QueryParserParseTokens(bttQueryAST.Id, piLevel + 1).
  
  if     (iTokenType    = {&K_QP_TOKEN_TYPE_BRACE_OPEN}
      and giQPTokenType = {&K_QP_TOKEN_TYPE_BRACE_CLOSE})
    or   (iTokenType    = {&K_QP_TOKEN_TYPE_BRACKET_OPEN}
      and giQPTokenType = {&K_QP_TOKEN_TYPE_BRACKET_CLOSE})
    or   (iTokenType    = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
      and giQPTokenType = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE})
    or   (iTokenType    = {&K_QP_TOKEN_TYPE_PREPROCESSOR}
      and giQPTokenType = {&K_QP_TOKEN_TYPE_BRACE_CLOSE}) then
  do:
    
    run qg_QueryParserAddLeaf(bttQueryAST.Id, piLevel).
    leave.
    
  end. /* if     (iTokenType    = {&K_QP_TOKEN_TYPE_BRACE_OPEN} */
  
  run qg_QueryParserAddLeaf(bttQueryAST.Id, piLevel).
  run qg_QueryParserGetNextToken.
  
end. /* do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF} */

/* Complete bracket node information. */

bttQueryAST.TokenEnd  = giQPTokenEnd.

if    bttQueryAST.TokenStart > 0
  and bttQueryAST.TokenEnd   > bttQueryAST.TokenStart then
  bttQueryAST.TokenText = substring(gcQPQueryText,
                                    bttQueryAST.TokenStart,
                                    bttQueryAST.TokenEnd - bttQueryAST.TokenStart)
  .

end procedure. /* qg_QueryParserParseBracket */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserParseIfStatement hQueryWindow 
PROCEDURE qg_QueryParserParseIfStatement :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Parse bracket node.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piParentId                     = Id of the parent node.                    */
/* piLevel                        = Level of the node                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piParentId as integer   no-undo.
define input parameter piLevel    as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST  for temp-table ttQueryAST.
define buffer b2ttQueryAST for temp-table ttQueryAST.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    giQPTokenType <> {&K_QP_TOKEN_TYPE_KEYWORD}
   or gcQPToken     <> 'IF':U then
  leave.

/* Add if statement node. */

create bttQueryAST.

assign
  giQueryParserSeq       = giQueryParserSeq + 1
  bttQueryAST.Id         = giQueryParserSeq
  bttQueryAST.ParentId   = piParentId
  bttQueryAST.TokenStart = giQPTokenStart
  bttQueryAST.Level      = piLevel
  bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_UNDEFINED}
  bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_NODE}
  .

validate bttQueryAST.

run qg_QueryParserAddLeaf(bttQueryAST.Id, piLevel).

run qg_QueryParserGetNextToken.

do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF}:
  
  run qg_QueryParserParseTokens(bttQueryAST.Id, piLevel + 1).
  
  if    piParentId        > 0
    and ( giQPTokenType   = {&K_QP_TOKEN_TYPE_BRACE_CLOSE}
       or giQPTokenType   = {&K_QP_TOKEN_TYPE_BRACKET_CLOSE}
       or giQPTokenType   = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}
       or ( giQPTokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
        and lookup(gcQPToken, {&K_QP_CONDITION_BREAK_KEYWORDS}) > 0 ) ) then
    leave.
  
  run qg_QueryParserAddLeaf(bttQueryAST.Id, piLevel).
  run qg_QueryParserGetNextToken.
  
end. /* do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF} */

/* Complete if statement node information. */

find last b2ttQueryAST
  where b2ttQueryAST.ParentId = bttQueryAST.Id
  use-index ParentId
  no-error.

bttQueryAST.TokenEnd = (if available b2ttQueryAST then
                          b2ttQueryAST.TokenEnd
                        else
                          b2ttQueryAST.TokenStart).

if    bttQueryAST.TokenStart > 0
  and bttQueryAST.TokenEnd   > bttQueryAST.TokenStart then
  bttQueryAST.TokenText = substring(gcQPQueryText,
                                    bttQueryAST.TokenStart,
                                    bttQueryAST.TokenEnd - bttQueryAST.TokenStart)
  .

end procedure. /* qg_QueryParserParseIfStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserParseQuery hQueryWindow 
PROCEDURE qg_QueryParserParseQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Parse query text. The result will be stored in ttQueryAST.                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcQueryText                    = Query text that should be parsed.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcQueryText as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

empty temp-table ttQueryAST.

assign
  giQueryParserSeq = 0
  gcQPQueryText    = pcQueryText
  giQPOffset       = 1
  giQPTokenStart   = 1
  giQPTokenEnd     = 0
  gcQPToken        = '':U
  giQPTokenType    = {&K_QP_TOKEN_TYPE_UNDEFINED}
  .

run qg_QueryParserGetNextToken.
run qg_QueryParserParseTokens(0, 0).

end procedure. /* qg_QueryParserParseQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryParserParseTokens hQueryWindow 
PROCEDURE qg_QueryParserParseTokens :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Parse Tokens.                                                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piParentId                     = Id of the parent node.                    */
/* piLevel                        = Level of the tokens.                      */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piParentId as integer   no-undo.
define input parameter piLevel    as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST  for temp-table ttQueryAST.
define buffer b2ttQueryAST for temp-table ttQueryAST.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create bttQueryAST.

assign
  giQueryParserSeq       = giQueryParserSeq + 1
  bttQueryAST.Id         = giQueryParserSeq
  bttQueryAST.ParentId   = piParentId
  bttQueryAST.TokenStart = giQPTokenStart
  bttQueryAST.Level      = piLevel
  bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_UNDEFINED}
  bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_NODE}
  .

validate b2ttQueryAST.

do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF}:
  
  if    piParentId        > 0
    and ( giQPTokenType   = {&K_QP_TOKEN_TYPE_BRACE_CLOSE}
       or giQPTokenType   = {&K_QP_TOKEN_TYPE_BRACKET_CLOSE}
       or giQPTokenType   = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}
       or ( giQPTokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
        and ( lookup(gcQPToken, 'THEN,ELSE':U)              > 0 )
           or lookup(gcQPToken, {&K_QP_CONDITION_BREAK_KEYWORDS}) > 0 ) ) then
    leave.
  
  else
    if   giQPTokenType = {&K_QP_TOKEN_TYPE_BRACE_OPEN}
      or giQPTokenType = {&K_QP_TOKEN_TYPE_BRACKET_OPEN}
      or giQPTokenType = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
      or giQPTokenType = {&K_QP_TOKEN_TYPE_PREPROCESSOR} then
      run qg_QueryParserParseBracket(bttQueryAST.Id, piLevel).
  
  else
    if    giQPTokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
      and gcQPToken     = 'IF':U then
      run qg_QueryParserParseIfStatement(bttQueryAST.Id, piLevel).
      
  else
    run qg_QueryParserAddLeaf(bttQueryAST.Id, piLevel).
    
  run qg_QueryParserGetNextToken.
  
end. /* do while giQPTokenType <> {&K_QP_TOKEN_TYPE_EOF} */

/* Complete node information. */

find last b2ttQueryAST
  where b2ttQueryAST.ParentId = bttQueryAST.Id
  use-index ParentId
  no-error.

bttQueryAST.TokenEnd = (if available b2ttQueryAST then
                          b2ttQueryAST.TokenEnd
                        else
                          bttQueryAST.TokenStart).

if    bttQueryAST.TokenStart > 0
  and bttQueryAST.TokenEnd   > bttQueryAST.TokenStart then
  bttQueryAST.TokenText = substring(gcQPQueryText,
                                    bttQueryAST.TokenStart,
                                    bttQueryAST.TokenEnd - bttQueryAST.TokenStart)
  .

end procedure. /* qg_QueryParserParseTokens */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RefreshDatabaseBrowse hQueryWindow 
PROCEDURE qg_RefreshDatabaseBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fill temp-table ttDatabase if necessary and refresh browse brDatabase.     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcSelectedDatabaseName         = Name of the database that shuld be        */
/*                                  selected after refresh. If ? then the     */
/*                                  first database will be selected.          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcSelectedDatabaseName as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i             as integer   no-undo.
define variable cDatabaseName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Try to load the base db first so it is already present in the cache when   */
/* loading other databases.                                                   */

if connected( {&K_BASE_DB_NAME} ) then
  run qg_AddDatabase( {&K_BASE_DB_NAME} ).

do i = 1 to num-dbs:
  
  cDatabaseName = ldbname(i).
  
  if not can-find(first ttDatabase
                    where ttDatabase.DatabaseName = cDatabaseName) then
    run qg_AddDatabase(cDatabaseName).
  
end. /* do i = 1 to num-dbs */

{&OPEN-QUERY-brDatabase}

if pcSelectedDatabaseName <> ? then
do:
  
  find bttDatabase
    where bttDatabase.DatabaseName =  pcSelectedDatabaseName
    no-error.
  
  if available bttDatabase then
    reposition brDatabase to rowid rowid(bttDatabase).
  
end. /* if pcSelectedDatabaseName <> ? */

apply 'value-changed':U to brDatabase in frame fQuery.

end procedure. /* qg_RefreshDatabaseBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RefreshFieldBrowse hQueryWindow 
PROCEDURE qg_RefreshFieldBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Refresh content of the field browse.                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabase         as character no-undo.
define variable cTable            as character no-undo.

define variable i                 as integer   no-undo.

define variable cFilterEntry      as character no-undo.
define variable cFieldFilter      as character no-undo.
define variable cFieldLabelFilter as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   not glRefreshFieldBrowse
  or giDisplayMode <> {&K_DISPLAYMODE_FIELD} then
  leave.

assign
  cDatabase           = (if available(ttDatabase) then
                           ttDatabase.DatabaseName
                         else
                           '':U)
  cTable              = (if available(ttTable) then
                           ttTable.TableName
                         else
                           '':U)
  gcFieldFilter      = input frame {&FRAME-NAME} gcFieldFilter
  gcFieldLabelFilter = input frame {&FRAME-NAME} gcFieldLabelFilter
  .

do i = 1 to num-entries(gcFieldFilter, ',':U):
  
  assign
    cFilterEntry = entry(i, gcFieldFilter, ',':U)
    cFieldFilter = substitute('&1,&2':U,
                              cFieldFilter,
                              qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcFieldFilter, ',':U) */

cFieldFilter = (if cFieldFilter = '':U then
                  '*':U
                else
                  trim(cFieldFilter, ',':U)).

do i = 1 to num-entries(gcFieldLabelFilter, ',':U):
  
  assign
    cFilterEntry      = entry(i, gcFieldLabelFilter, ',':U)
    cFieldLabelFilter = substitute('&1,&2':U,
                                   cFieldLabelFilter,
                                   qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcFieldFilter, ',':U) */

cFieldLabelFilter = (if cFieldLabelFilter = '':U then
                       '*':U
                     else
                       trim(cFieldLabelFilter, ',':U)).

for each bttField
  where bttField.DatabaseName = cDatabase
    and bttField.TableName    = cTable
  on error undo, throw:
  
  bttField.FieldFilterMatches =     can-do(cFieldFilter, bttField.FieldName)
                                and can-do(cFieldLabelFilter, bttField.FieldLabel)
                                and can-do(gcFieldDatatypeFilter, bttField.DataType).
  
end. /* for each ttField */

{&OPEN-QUERY-brField}

apply 'value-changed':U to brField in frame {&FRAME-NAME}.

glRefreshFieldBrowse = no.

end procedure. /* qg_RefreshFieldBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RefreshIndexBrowse hQueryWindow 
PROCEDURE qg_RefreshIndexBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fill index selection-list widget with all cached inidces of the currently  */
/* selected table.                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabase         as character no-undo.
define variable cTable            as character no-undo.

define variable cFilterEntry      as character no-undo.
define variable cIndexFilter      as character no-undo.
define variable cIndexFieldFilter as character no-undo.

define variable i                 as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndex for temp-table ttIndex.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   not glRefreshIndexBrowse
  or giDisplayMode <> {&K_DISPLAYMODE_INDEX} then
  leave.

assign
  cDatabase          = (if available ttDatabase then
                          ttDatabase.DatabaseName
                        else
                          '':U)
  cTable             = (if available ttTable then
                          ttTable.TableName
                        else
                          '':U)
  gcIndexFilter      = input frame {&FRAME-NAME} gcIndexFilter
  gcIndexFieldFilter = input frame {&FRAME-NAME} gcIndexFieldFilter
  .

do i = 1 to num-entries(gcIndexFilter, ',':U):
  
  assign
    cFilterEntry = entry(i, gcIndexFilter, ',':U)
    cIndexFilter = substitute('&1,&2':U,
                              cIndexFilter,
                              qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcIndexFilter, ',':U) */

cIndexFilter = (if cIndexFilter = '':U then
                  '*':U
                else
                  trim(cIndexFilter, ',':U)).

do i = 1 to num-entries(gcIndexFieldFilter):
  
  assign
    cFilterEntry      = entry(i, gcIndexFieldFilter, ',':U)
    cIndexFieldFilter = substitute('&1,&2':U,
                                   cIndexFieldFilter,
                                   qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(cIndexFieldFilter) */

cIndexFieldFilter = (if cIndexFieldFilter = '':U then
                       '*':U
                     else
                       trim(cIndexFieldFilter, ',':U)).

for each bttIndex
  where bttIndex.DatabaseName = cDatabase
    and bttIndex.TableName    = cTable
  on error undo, throw:
  
  assign
    bttIndex.IndexFilterMatches      = can-do(cIndexFilter, bttIndex.IndexName)
    bttIndex.IndexFieldFilterMatches = yes
    .
  
  do i = 1 to num-entries(cIndexFieldFilter):
    
    assign
      cFilterEntry                     = entry(i, cIndexFieldFilter, ',':U)
      bttIndex.IndexFieldFilterMatches =     bttIndex.IndexFieldFilterMatches
                                         and can-find(first ttIndexField
                                                        where ttIndexField.DatabaseName = cDatabase
                                                          and ttIndexField.TableName    = bttIndex.TableName
                                                          and ttIndexField.IndexName    = bttIndex.IndexName
                                                          and can-do(cFilterEntry, ttIndexField.FieldName))
      .
    
    if not bttIndex.IndexFieldFilterMatches then
      leave.
    
  end. /* do i = 1 to num-entries(cIndexFieldFilter) */
    
end. /* for each bttIndex */

{&OPEN-QUERY-brIndex}

find first bttIndex
  where bttIndex.DatabaseName            = cDatabase
    and bttIndex.TableName               = cTable
    and bttIndex.IsPrimary               = yes
    and bttIndex.IndexFilterMatches      = yes
    and bttIndex.IndexFieldFilterMatches = yes
  no-error.

if available(bttIndex) then
  reposition brIndex to rowid rowid(bttIndex).

apply 'value-changed':U to brIndex in frame {&FRAME-NAME}.

glRefreshIndexBrowse = no.

end procedure. /* qg_RefreshIndexBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RefreshRelationBrowse hQueryWindow 
PROCEDURE qg_RefreshRelationBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fill relation selection-list widget with all cached relations of the       */
/* currently selected table.                                                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabase            as character no-undo.
define variable cTable               as character no-undo.

define variable cFilterEntry         as character no-undo.
define variable cRelationFilter      as character no-undo.
define variable cRelationFieldFilter as character no-undo.

define variable i                    as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelation     for temp-table ttTableRelation.
define buffer bttTableRelationView for temp-table ttTableRelationView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   not glRefreshRelationBrowse
  or giDisplayMode <> {&K_DISPLAYMODE_RELATION} then
  leave.


assign
  cDatabase             = (if available ttDatabase then
                             ttDatabase.DatabaseName
                           else
                             '':U)
  cTable                = (if available ttTable then
                             ttTable.TableName
                           else
                             '':U)
  gcRelationFilter      = input frame {&FRAME-NAME} gcRelationFilter
  gcRelationFieldFilter = input frame {&FRAME-NAME} gcRelationFieldFilter
  .

do i = 1 to num-entries(gcRelationFilter, ',':U):
  
  assign
    cFilterEntry    = entry(i, gcRelationFilter, ',':U)
    cRelationFilter = substitute('&1,&2':U,
                                 cRelationFilter,
                                 qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcRelationFilter, ',':U) */

cRelationFilter = (if cRelationFilter = '':U then
                     '*':U
                   else
                     trim(cRelationFilter, ',':U)).

do i = 1 to num-entries(gcRelationFieldFilter):
  
  assign
    cFilterEntry         = entry(i, gcRelationFieldFilter, ',':U)
    cRelationFieldFilter = substitute('&1,&2':U,
                                      cRelationFieldFilter,
                                      qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcRelationFieldFilter) */

cRelationFieldFilter = (if cRelationFieldFilter = '':U then
                          '*':U
                        else
                          trim(cRelationFieldFilter, ',':U)).

for each bttTableRelationView
  where bttTableRelationView.DatabaseName       = cDatabase
    and bttTableRelationView.ReferenceTableName = cTable,
first bttTableRelation
  where bttTableRelation.RelationId = bttTableRelationView.RelationId
  on error undo, throw:
  
  assign
    bttTableRelationView.TableFilterMatches = can-do(cRelationFilter, bttTableRelationView.RelatedTableName)
    bttTableRelationView.FieldFilterMatches = yes
    .
  
  do i = 1 to num-entries(cRelationFieldFilter):
    
    assign
      cFilterEntry                            = entry(i, cRelationFieldFilter, ',':U)
      bttTableRelationView.FieldFilterMatches =     bttTableRelationView.FieldFilterMatches
                                                and can-find(first ttTableRelationField
                                                               where ttTableRelationField.RelationId             = bttTableRelation.Relationid
                                                                 and ( ( bttTableRelationView.ReferenceTableName = bttTableRelation.ParentTableName
                                                                     and can-do(cFilterEntry, ttTableRelationField.ChildFieldName) )
                                                                    or ( bttTableRelationView.ReferenceTableName = bttTableRelation.ChildTableName
                                                                     and can-do(cFilterEntry, ttTableRelationField.ParentFieldName) ) ))
      .
    
    if not bttTableRelationView.FieldFilterMatches then
      leave.
    
  end. /* do i = 1 to num-entries(cRelationFieldFilter) */
  
  bttTableRelationView.ParentRelationFilterMatches
      = (     ( glShowChildRelations
            and not bttTableRelationView.ParentRelation )
           or ( glShowParentRelations
            and bttTableRelationView.ParentRelation  ) ).
  
end. /* for each bttTableRelationView */

{&OPEN-QUERY-brRelation}

apply 'value-changed':U to brRelation in frame {&FRAME-NAME}.

glRefreshRelationBrowse = no.

end procedure. /* qg_RefreshRelationBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RefreshTableBrowse hQueryWindow 
PROCEDURE qg_RefreshTableBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fill table selection-list widget with all cached tables of the currently   */
/* selected database.                                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName     as character no-undo.

define variable i                 as integer   no-undo.
define variable cFilterEntry      as character no-undo.
define variable cTableFilter      as character no-undo.
define variable cTableFieldFilter as character no-undo.

define variable cTableNames       as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.
define buffer bttTable    for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cDatabaseName      = (if available ttDatabase then
                          ttDatabase.DatabaseName
                        else
                          '':U)
  gcTableFilter      = input frame {&FRAME-NAME} gcTableFilter
  gcTableFieldFilter = input frame {&FRAME-NAME} gcTableFieldFilter
  .

find first bttDatabase
  where bttDatabase.DatabaseName = cDatabasename
  no-error.

if    available(bttDatabase)
  and bttDatabase.PhysicalDB
  and not can-find(first ttTable
                     where ttTable.DatabaseName = bttDatabase.DatabaseName) then
  run qg_AddTables(bttDatabase.DatabaseName).

/* Tune table filter. */

do i = 1 to num-entries(gcTableFilter):
  
  assign
    cFilterEntry = entry(i, gcTableFilter, ',':U)
    cTableFilter = substitute('&1,&2':U,
                              cTableFilter,
                              qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcTableFilter) */

cTableFilter = (if cTableFilter = '':U then
                  '*':U
                else
                  trim(cTableFilter, ',':U)).

/* Tune table field filter. */
do i = 1 to num-entries(gcTableFieldFilter):
  
  assign
    cFilterEntry      = entry(i, gcTableFieldFilter, ',':U)
    cTableFieldFilter = substitute('&1,&2':U,
                                   cTableFieldFilter,
                                   qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(gcTableFieldFilter) */

cTableFieldFilter = (if cTableFieldFilter = '':U then
                       '*':U
                     else
                       trim(cTableFieldFilter, ',':U)).

/* Check ttTable for filter matches und update flags. */

for each bttTable
  where bttTable.DatabaseName = cDatabaseName
  on error undo, throw:
  
  cTableNames = bttTable.TableName.
  
  if    available ttDatabase
    and ttDatabase.TempDB
    and bttTable.TableName begins 'td':U then
    cTableNames = substitute('&1,tt&2':U,
                             cTableNames,
                             substring(cTableNames, 3)).
  
  bttTable.TableFilterMatches = no.
  
  do i = 1 to num-entries(cTableNames):
    
    if can-do(cTableFilter, entry(i, cTableNames)) then
    do:
      bttTable.TableFilterMatches = yes. 
      leave.
    end. /* if can-do(cTableFilter, entry(i, cTableNames)) */
    
  end. /* do i = 1 to num-entries(cTableNames) */
  
  bttTable.TableFieldFilterMatches = yes.
  
  do i = 1 to num-entries(cTableFieldFilter):
    
    assign
      cFilterEntry                     = entry(i, cTableFieldFilter, ',':U)
      bttTable.TableFieldFilterMatches =       bttTable.TableFieldFilterMatches
                                         and can-find(first ttField
                                                        where ttField.DatabaseName = cDatabaseName
                                                          and ttField.TableName    = bttTable.TableName
                                                          and can-do(cFilterEntry, ttField.FieldName))
      .
    
    if not bttTable.TableFieldFilterMatches then
      leave.
    
  end. /* do i = 1 to num-entries(cTableFieldFilter) */
  
end. /* for each bttTable */

{&OPEN-QUERY-brTable}

apply 'value-changed':U to brTable in frame {&FRAME-NAME}.

end procedure. /* qg_RefreshTableBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowApply hQueryWindow 
PROCEDURE qg_RelationWindowApply :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all session triggers.                                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piFilterId as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBrowse       as handle    no-undo.
define variable hFillIn       as handle    no-undo.
define variable hBuffer       as handle    no-undo.

define variable lVirtualIndex as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  hFillIn              = qg_hGetWidgetByName(ghRelationWindow, 'cBufferName':U)
  gcRelationBufferName = hFillIn:input-value
  lVirtualIndex = (     giDisplayMode = {&K_DISPLAYMODE_INDEX}
                    and available ttIndex
                    and ttIndex.IsVirtual )
  .

if    ( not lVirtualIndex
     or glUseVirtualIndexApi )
  and giDisplayMode <> {&K_DISPLAYMODE_RELATION} then
do:
  
  assign
    hBrowse = qg_hGetWidgetByName(ghRelationWindow, 'brRelation':U)
    hBuffer = hBrowse:query:get-buffer-handle(1)
    .
  
  if hBuffer:available then
    
    assign
      giRelationId     = hBuffer::RelationId
      glParentRelation = hBuffer::ParentRelation
      .
  
end. /* if    not lVirtualIndex */

run qg_UpdateQueryText.

run qg_RelationWindowClose(piFilterId).

end procedure. /* qg_RelationWindowApply */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowClear hQueryWindow 
PROCEDURE qg_RelationWindowClear :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all session triggers.                                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piFilterId as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBrowse       as handle    no-undo.
define variable hBuffer       as handle    no-undo.

define variable lVirtualIndex as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

lVirtualIndex = (     giDisplayMode = {&K_DISPLAYMODE_INDEX}
                  and available ttIndex
                  and ttIndex.IsVirtual ).

if    lVirtualIndex
  and not glUseVirtualIndexApi then
  
  gcRelationBufferName = gcVirtualIndexDataTableName.

else
  
  if giDisplayMode = {&K_DISPLAYMODE_RELATION} then
    
    gcRelationBufferName = ( if available ttTableRelationView then
                               ttTableRelationView.RelatedTableName
                             else
                               '?':U ).

else
  assign
    giRelationId         = 0
    glParentRelation     = no
    gcRelationBufferName = '':U
    .

run qg_UpdateQueryText.

run qg_RelationWindowClose(piFilterId).

end procedure. /* qg_RelationWindowClear */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowClearFilter hQueryWindow 
PROCEDURE qg_RelationWindowClearFilter :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Clear relation table filter.                                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFilterFillIn as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghRelationWindow) then
  leave.

hFilterFillIn = qg_hGetWidgetByName(ghRelationWindow, 'cFilter':U).

hFilterFillIn:screen-value = '':U.

apply 'value-changed':U to hFilterFillIn.

end procedure. /* qg_RelationWindowClearFilter */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowClose hQueryWindow 
PROCEDURE qg_RelationWindowClose :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piFilterId as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttFilterMatch for temp-table ttFilterMatch.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttFilterMatch
  where bttFilterMatch.FilterId = piFilterId
  on error undo, next:
  
  delete bttFilterMatch.
  
end. /* bttFilterMatch */

run qg_DeleteWidgetTree(ghRelationWindow, yes).

btnOf:sensitive in frame {&FRAME-NAME} = yes.

end procedure. /* qg_RelationWindowClose */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowEnterBrowse hQueryWindow 
PROCEDURE qg_RelationWindowEnterBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBrowse as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle( ghRelationWindow ) then
  return.

hBrowse = qg_hGetWidgetByName( ghRelationWindow, 'brRelation':U ).
apply 'entry':U to hBrowse.
hBrowse:select-focused-row().
return no-apply.

end procedure. /* qg_RelationWindowEnterBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowEnterEnterFilterFillIn hQueryWindow 
PROCEDURE qg_RelationWindowEnterEnterFilterFillIn :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFillIn as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle( ghRelationWindow ) then
  return.

hFillIn = qg_hGetWidgetByName( ghRelationWindow, 'cFilter':U ).
apply 'entry':U to hFillIn.
return no-apply.

end procedure. /* qg_RelationWindowEnterEnterFilterFillIn */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowRefreshRelationBrowse hQueryWindow 
PROCEDURE qg_RelationWindowRefreshRelationBrowse :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Refresh relation browse of relation selection window.                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piFilterId     as integer   no-undo.
define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFilterFillIn   as handle    no-undo.
define variable hRelationBrowse as handle    no-undo.

define variable cDatabaseName   as character no-undo.
define variable cTableName      as character no-undo.
define variable cFilter         as character no-undo.

define variable i               as integer   no-undo.
define variable cFilterEntry    as character no-undo.
define variable cPrepFilter     as character no-undo.

define variable cQueryText      as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelationView for temp-table ttTableRelationView.
define buffer bttFilterMatch       for temp-table ttFilterMatch.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghRelationWindow) then
  leave.

assign
  hFilterFillIn   = qg_hGetWidgetByName(ghRelationWindow, 'cFilter':U)
  cFilter         = hFilterFillIn:input-value
  hRelationBrowse = qg_hGetWidgetByName(ghRelationWindow, 'brRelation':U)
  .

do i = 1 to num-entries(cFilter):
  
  assign
    cFilterEntry = entry(i, cFilter).
    cPrepFilter  = substitute('&1,&2':U,
                              cPrepFilter,
                              qg_cFilterEntryMatchcode(cFilterEntry))
    .
  
end. /* do i = 1 to num-entries(cFilter) */

cPrepFilter = (if cPrepFilter = '':U then
                 '*':U
               else
                 trim(cPrepFilter, ',':U)).

for each bttTableRelationView
  where bttTableRelationView.DatabaseName       = pcDatabaseName
    and bttTableRelationView.ReferenceTableName = pcTableName,
first bttFilterMatch
  where bttFilterMatch.FilterId    = piFilterId
    and bttFilterMatch.RecordRowId = rowid(bttTableRelationView)
  on error undo, throw:
  
  bttFilterMatch.RecordMatches = can-do(cPrepFilter, bttTableRelationView.RelatedTableName).
  
end. /* for each bttTableRelationView */

assign
  cQueryText =            'for each ttTableRelationView':U
               + '~n':U + '  where ttTableRelationView.DatabaseName       = &1':U
               + '~n':U + '    and ttTableRelationView.ReferenceTableName = &2':U
               + (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                    and available ttTableRelationView then
                    '~n':U + '    and rowid(ttTableRelationView)             = to-rowid(&3)':U
                  else
                    '':U)
               + '~n':U + '  use-index TableName,':U
               + '~n':U + 'first ttFilterMatch':U
               + '~n':U + '  where ttFilterMatch.FilterId      = &4':U
               + '~n':U + '    and ttFilterMatch.RecordRowId   = rowid(ttTableRelationView)':U
               + '~n':U + '    and ttFilterMatch.RecordMatches = yes':U
  cQueryText = substitute(cQueryText,
                          quoter(pcDatabaseName),
                          quoter(pcTableName),
                          (if available ttTableRelationView then
                             quoter(rowid(ttTableRelationView))
                           else
                             '':U),
                          piFilterId)
  .
  
qg_lQueryOpen(hRelationBrowse:query, cQueryText, ghRelationWindow).

apply 'value-changed':U to hRelationBrowse.

end procedure. /* qg_RelationWindowRefreshRelationBrowse */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RelationWindowRelationBrowseValueChanged hQueryWindow 
PROCEDURE qg_RelationWindowRelationBrowseValueChanged :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBrowse as handle    no-undo.
define variable hFillIn as handle    no-undo.
define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  hBrowse = qg_hGetWidgetByName(ghRelationWindow, 'brRelation':U)
  hBuffer = hBrowse:query:get-buffer-handle(1)
  hFillIn = qg_hGetWidgetByName(ghRelationWindow, 'cBufferName':U)
  .

if hBuffer:available then
  hFillIn:screen-value = hBuffer::RelatedTableName.

end procedure. /* qg_RelationWindowRelationBrowseValueChanged */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveAllSessionTriggers hQueryWindow 
PROCEDURE qg_RemoveAllSessionTriggers :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all session triggers.                                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttSessionTrigger
  on error undo, throw:
  
  if valid-handle(bttSessionTrigger.ProcedureHandle) then
    delete object bttSessionTrigger.ProcedureHandle.
  
  os-delete value(bttSessionTrigger.TriggerFileName).
  
  delete bttSessionTrigger.
  
end. /* for each bttSessionTrigger */

if valid-handle(ghSessionTriggersWindow) then
  run qg_SessionTriggersOpenQuery.

end procedure. /* qg_RemoveAllSessionTriggers */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveDatabase hQueryWindow 
PROCEDURE qg_RemoveDatabase :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove given database from cache.                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = logical name of database that should be   */
/*                                  removed.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabase as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase  for temp-table ttDatabase.
define buffer b2ttDatabase for temp-table ttDatabase.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find first bttDatabase
  where bttDatabase.DatabaseName = pcDatabase
  no-error.

if available bttDatabase then
do:
  
  if bttDatabase.BasisDB then
  do:
    
    for each b2ttDatabase
      where b2ttDatabase.BasisDBName = bttDatabase.DatabaseName
      on error undo, throw:
      
      b2ttDatabase.BasisDBName = '':U.
      
    end. /* for each b2ttDatabase */
    
  end. /* if bttDatabase.BasisDB */
  
  run qg_RemoveTables(bttDatabase.DatabaseName).
  
  delete bttDatabase.
  
end. /* if available bttDatabase */

end procedure. /* qg_RemoveDatabase */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveIndices hQueryWindow 
PROCEDURE qg_RemoveIndices :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all indices of given table from cache.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = Database that contains the Table of the   */
/*                                  indices that should be removed.           */
/* pcTable                        = Table that contains the indices that      */
/*                                  should be removed.                        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndex      for temp-table ttIndex.
define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttIndex
  where bttIndex.DatabaseName = pcDatabaseName
    and bttIndex.TableName    = pcTableName
  on error undo, throw:

  for each bttIndexField
    where bttIndexField.DatabaseName = bttIndex.DatabaseName
      and bttIndexField.TableName    = bttIndex.TableName
      and bttIndexField.IndexName    = bttIndex.IndexName
    on error undo, throw:
  
    delete bttIndexField.
    
  end. /* for each bttIndexField */
  
  delete bttIndex.
  
end. /* for each bttIndex */

end procedure. /* qg_RemoveIndices */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveRelations hQueryWindow 
PROCEDURE qg_RemoveRelations :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all Relations of given table from cache.                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = Database that contains the Table of the   */
/*                                  indices that should be removed.           */
/* pcTable                        = Table that contains the indices that      */
/*                                  should be removed.                        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelation      for temp-table ttTableRelation.
define buffer bttTableRelationField for temp-table ttTableRelationField.
define buffer bttTableRelationView  for temp-table ttTableRelationView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttTableRelation
  where ( bttTableRelation.DatabaseName    = pcDatabaseName
      and bttTableRelation.ParentTableName = pcTableName )
     or ( bttTableRelation.DatabaseName    = pcDatabaseName
      and bttTableRelation.ChildTableName  = pcTableName )
  on error undo, throw:
  
  for each bttTableRelationField
    where bttTableRelationField.RelationId = bttTableRelation.RelationId
    on error undo, throw:
    
    delete bttTableRelationField.
    
  end. /* for each bttTableRelationField */
  
  for each bttTableRelationView
    where bttTableRelationView.RelationId = bttTableRelation.RelationId
    on error undo, throw:
    
    delete bttTableRelationView.
    
  end. /* for each bttTableRelationView */
  
  delete bttTableRelation.
  
end. /* for each bttTableRelation */

end procedure. /* qg_RemoveRelations */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveSessionTrigger hQueryWindow 
PROCEDURE qg_RemoveSessionTrigger :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove given session trigger.                                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTriggerEvent                 = Trigger event of the session trigger that */
/*                                  should be removed.                        */
/* pcDatabaseName                 = Database name of the session trigger that */
/*                                  should be removed.                        */
/* pcTableName                    = Table name of the session trigger that    */
/*                                  should be removed.                        */
/* pcFieldName                    = Field name of the session trigger that    */
/*                                  should be removed.                        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcTriggerEvent as character no-undo.
define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.
define input parameter pcFieldName    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable rCurrentRecord as rowid     no-undo.

define variable hBrowseBuffer  as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggersWindow) then
  assign
    hBrowseBuffer  = ghSessionTriggersBrowse:query:get-buffer-handle(1)
    rCurrentRecord = hBrowseBuffer:rowid
    .

for each bttSessionTrigger
  where bttSessionTrigger.TriggerEvent = pcTriggerEvent
    and bttSessionTrigger.DatabaseName = pcDatabaseName
    and bttSessionTrigger.TableName    = pcTableName
    and bttSessionTrigger.FieldName    = pcFieldName
  on error undo, throw:
  
  if    valid-handle(ghSessionTriggersWindow)
    and rowid(bttSessionTrigger) = rCurrentRecord then
  do:
    
    ghSessionTriggersBrowse:query:get-next().
    
    if not hBrowseBuffer:available then
    do:
      
      ghSessionTriggersBrowse:query:reposition-to-rowid(rCurrentRecord).
      ghSessionTriggersBrowse:query:get-prev().
      
    end. /* if not hBrowseBuffer:available */
    
    if hBrowseBuffer:available then
      rCurrentRecord = hBrowseBuffer:rowid.
    
  end. /* if    valid-handle(ghSessionTriggersWindow) */
  
  if valid-handle(bttSessionTrigger.ProcedureHandle) then
    delete object bttSessionTrigger.ProcedureHandle.
  
  os-delete value(bttSessionTrigger.TriggerFileName).
  
  delete bttSessionTrigger.
  
end. /* for each bttSessionTrigger */

if valid-handle(ghSessionTriggersWindow) then
do:
  
  run qg_SessionTriggersOpenQuery.
  
  if rCurrentRecord <> ? then
    ghSessionTriggersBrowse:query:reposition-to-rowid(rCurrentRecord) no-error.
  
end. /* if valid-handle(ghSessionTriggersWindow) */

end procedure. /* qg_RemoveSessionTrigger */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveTable hQueryWindow 
PROCEDURE qg_RemoveTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove given Table from Cache.                                             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Database name of Table.                   */
/* pcTableName                    = Table name                                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter pcTableName    as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable          for temp-table ttTable.
define buffer bttField          for temp-table ttField.
define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttTable
  where bttTable.DatabaseName = pcDatabaseName
    and bttTable.TableName    = pcTableName
  no-error.

if not available(bttTable) then
  leave.

/* Remove relations. */

run qg_RemoveRelations(bttTable.DatabaseName,
                       bttTable.TableName).

/* Remove indices. */

run qg_RemoveIndices(bttTable.DatabaseName,
                     bttTable.TableName).

/* Remove fields. */

for each bttField
  where bttField.DatabaseName = bttTable.DatabaseName
    and bttField.TableName    = bttTable.TableName
  on error undo, throw:
  
  delete bttField.
  
end. /* for each bttField */

/* Delete the dynamically created temp-table. */

if    bttTable.Snapshot
  and valid-handle(bttTable.TableHandle) then 
  delete object bttTable.TableHandle.

/* Remove session triggers for table. */

for each bttSessionTrigger
  where bttSessionTrigger.DatabaseName = bttTable.DatabaseName
    and bttSessionTrigger.TableName    = bttTable.TableName
  on error undo, throw:

  run qg_RemoveSessionTrigger(bttSessionTrigger.TriggerEvent,
                              bttSessionTrigger.DatabaseName,
                              bttSessionTrigger.TableName,
                              bttSessionTrigger.FieldName).
  
end. /* for each bttSessionTrigger */

/* And finally delete the table entry. */

delete bttTable.

end procedure. /* qg_RemoveTable */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_RemoveTables hQueryWindow 
PROCEDURE qg_RemoveTables :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all tables of the given database from cache.                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabase                     = Database that contains the tables that    */
/*                                  should be removed.                        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabase as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttTable
  where bttTable.DatabaseName = pcDatabase
  on error undo, throw:
  
  run qg_RemoveTable(bttTable.DatabaseName,
                     bttTable.TableName).
  
end. /* for each bttTable */

end procedure. /* qg_RemoveTables */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SaveIDESetting hQueryWindow 
PROCEDURE qg_SaveIDESetting :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Save given setting for currently active project.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcSettingName                  = Setting that should be saved.             */
/* pcSettingValue                 = Value that should be saved.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcSettingName  as character no-undo.
define input parameter pcSettingValue as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cParamString as character no-undo.
define variable cDummy       as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    OEIDEIsRunning
  and glIDECanSaveSetting then
do:

  assign
    cParamString = qg_cParamListWriteCharacter(cParamString,
                                               'ProjectName':U,
                                               /*  */
                                               (if gcIDEProjectName <> ? then
                                                  gcIDEProjectName
                                                else
                                                  '':U),
                                               {&K_PARAM_SPLITTER})
    cParamString = qg_cParamListWriteCharacter(cParamString,
                                               'ParameterName':U,
                                               pcSettingName,
                                               {&K_PARAM_SPLITTER})
    cParamString = qg_cParamListWriteCharacter(cParamString,
                                               'ParameterValue':U,
                                               pcSettingValue,
                                               {&K_PARAM_SPLITTER})
    .
  
  run qg_IDE_SendRequest({&K_SAVE_PLUGIN_SETTING_HANDLER},
                         cParamString,
                         no /* plWaitForResult */,
                         output cDummy).
  
end. /* if    OEIDEIsRunning ... */

end procedure. /* qg_SaveIDESetting */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SaveQueryScenario hQueryWindow 
PROCEDURE qg_SaveQueryScenario :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Save all currently running quey windows.                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFileName                     = Filename to save the scenario. If ? the   */
/*                                  scenario will be copied to clipboard.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcFileName as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName as character no-undo.

define variable i             as integer   no-undo.

define variable hBuffer       as handle    no-undo.
define variable clText        as longchar  no-undo.

define variable cBufferList   as character no-undo.

define variable hSplitter1    as handle    no-undo.
define variable hRawValues    as handle    no-undo.

define query brQueryWindowBrowse
  for ttQueryWindowExport
  scrolling.

define browse brQueryWindowBrowse
  query brQueryWindowBrowse no-lock
    display
      ttQueryWindowExport.WindowSelected view-as toggle-box
      ttQueryWindowExport.QuerySeq
      ttQueryWindowExport.BufferList
      with no-assign size 100 by 12.

define variable lExportWindowState as logical no-undo
  initial yes
  label 'Save window state':T
  view-as toggle-box
  size 50 by 1.

define variable lExportQueryHistory as logical no-undo
  initial no
  label 'Save query history':T
  view-as toggle-box
  size 50 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

define menu m_PopupMenu
  menu-item mi_Select
    label "Select"
  rule
  menu-item mi_SelectAll
    label "Select all"
  menu-item mi_DeselectAll
    label 'Deselect all':T
    .

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow             for temp-table ttQueryWindow.
define buffer bttFieldOverlay            for temp-table ttFieldOverlay.
define buffer bttRecentQuery             for temp-table ttRecentQuery.

define buffer bttQueryWindowExport       for temp-table ttQueryWindowExport.
define buffer bttQueryBufferExport       for temp-table ttQueryBufferExport.
define buffer bttQueryFieldOverlayExport for temp-table ttQueryFieldOverlayExport.
define buffer bttRecentQueryExport       for temp-table ttRecentQueryExport.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fSelectQueryWindows
  brQueryWindowBrowse at row 1.5 col 3
  lExportWindowState at row 14 col 3
  lExportQueryHistory at row 14 col 30
  btnOk at row 16 col 33
  btnCancel at row 16 col 53
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 105 by 17.94
    title gcTitlePrefix + 'Save query scenario':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSelectQueryWindows
  apply 'end-error' to self.

on 'menu-drop':U of menu m_PopupMenu
do:
  
  if available ttQueryWindowExport then
    menu-item mi_Select:label in menu m_PopupMenu
      = (if ttQueryWindowExport.WindowSelected then
           'Deselect':T
         else
           'Select':T).
  
end. /* on 'menu-drop':U of menu m_PopupMenu */

on choose of menu-item mi_Select in menu m_PopupMenu
do:

  if available ttQueryWindowExport then
  do:
    
    ttQueryWindowExport.WindowSelected = not ttQueryWindowExport.WindowSelected.
    
    if query brQueryWindowBrowse:num-results > 0 then
      browse brQueryWindowBrowse:refresh().
    
  end. /* if available ttQueryWindowExport */
  
  btnOk:sensitive in frame fSelectQueryWindows /* code checked by mth */
      = can-find(first ttQueryWindowExport
                   where ttQueryWindowExport.WindowSelected = yes).
  
end. /* on choose of menu-item mi_Select in menu m_PopupMenu */

on default-action of brQueryWindowBrowse in frame fSelectQueryWindows
  apply 'choose':U to menu-item mi_Select in menu m_PopupMenu.

on choose of menu-item mi_SelectAll in menu m_PopupMenu
do:
  
  define buffer bttQueryWindowExport for temp-table ttQueryWindowExport.
  
  for each bttQueryWindowExport
    where bttQueryWindowExport.WindowSelected = no
    on error undo, throw:
    
    bttQueryWindowExport.WindowSelected = yes.
    
  end. /* for each bttQueryWindowExport */ 
  
  if query brQueryWindowBrowse:num-results > 0 then
    browse brQueryWindowBrowse:refresh().
  
  btnOk:sensitive in frame fSelectQueryWindows /* code checked by mth */
      = can-find(first ttQueryWindowExport
                   where ttQueryWindowExport.WindowSelected = yes).
  
end. /* on choose of menu-item mi_SelectAll in menu m_PopupMenu */

on choose of menu-item mi_DeselectAll in menu m_PopupMenu
do:
  
  define buffer bttQueryWindowExport for temp-table ttQueryWindowExport.
  
  for each bttQueryWindowExport
    where bttQueryWindowExport.WindowSelected = yes
    on error undo, throw:
    
    bttQueryWindowExport.WindowSelected = no.
    
  end. /* for each bttQueryWindowExport */ 
  
  if query brQueryWindowBrowse:num-results > 0 then
    browse brQueryWindowBrowse:refresh().
  
  btnOk:sensitive in frame fSelectQueryWindows /* code checked by mth */
      = can-find(first ttQueryWindowExport
                   where ttQueryWindowExport.WindowSelected = yes).
  
end. /* on choose of menu-item mi_DeselectAll in menu m_PopupMenu */

dataset dsQueryWindowExport:empty-dataset().

for each bttQueryWindow
  on error undo, throw:
  
  if not valid-handle(bttQueryWindow.WindowHandle) then
    next.
  
  create bttQueryWindowExport.
  
  assign
    bttQueryWindowExport.QuerySeq             = bttQueryWindow.QuerySeq
    bttQueryWindowExport.WindowMode           = (if bttQueryWindow.WindowMode = {&K_QUERY_WINDOW_MODE_RECORD} then
                                                   {&K_QUERY_WINDOW_MODE_RECORD_STR}
                                                 else
                                                   {&K_QUERY_WINDOW_MODE_QUERY_STR})
    bttQueryWindowExport.QueryText            = bttQueryWindow.QueryText
    bttQueryWindowExport.WindowWidth          = bttQueryWindow.WindowHandle:width-chars
    bttQueryWindowExport.WindowHeight         = bttQueryWindow.WindowHandle:height-chars
    bttQueryWindowExport.WindowColumn         = bttQueryWindow.WindowHandle:column
    bttQueryWindowExport.WindowRow            = bttQueryWindow.WindowHandle:row
    bttQueryWindowExport.WindowState          = (if bttQueryWindow.WindowHandle:window-state = {&K_WINDOW_MAXIMIZED} then
                                                   {&K_WINDOW_MAXIMIZED_STR}
                                                 else if bttQueryWindow.WindowHandle:window-state = {&K_WINDOW_MINIMIZED} then
                                                   {&K_WINDOW_MINIMIZED_STR}
                                                 else
                                                   {&K_WINDOW_NORMAL_STR})
    bttQueryWindowExport.DeepResolveObjectIds = bttQueryWindow.DeepResolveObjectIds
    bttQueryWindowExport.ObjSourceQuerySeq    = bttQueryWindow.ObjSourceQuerySeq
    bttQueryWindowExport.ObjSourceBufferName  = bttQueryWindow.ObjSourceBufferName
    bttQueryWindowExport.ObjSourceFieldName   = bttQueryWindow.ObjSourceFieldName
    bttQueryWindowExport.ObjSourceFieldIndex  = bttQueryWindow.ObjSourceFieldIndex
    cBufferList                               = '':U
    .
  
  if valid-handle(bttQueryWindow.QueryHandle) then
    
    do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
        
      hBuffer = bttQueryWindow.QueryHandle:get-buffer-handle(i).
        
      cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffer ).
      
      if    cDatabaseName = ?
         or cDatabaseName = '':U then
        cDatabaseName = hBuffer:dbname.
      
      create bttQueryBufferExport.
      
      assign
        bttQueryBufferExport.QuerySeq       = bttQueryWindowExport.QuerySeq
        bttQueryBufferExport.BufferId       = i
        bttQueryBufferExport.DatabaseName   = cDatabaseName
        bttQueryBufferExport.TableName      = hBuffer:table
        bttQueryBufferExport.BufferName     = hBuffer:name
        cBufferList                         = substitute('&1,&2':U,
                                                         cBufferList,
                                                         hBuffer:name)
        .
      
      validate bttQueryBufferExport.
      
      for each bttFieldOverlay
        where bttFieldOverlay.OwnerHandle = bttQueryWindow.QueryHandle
          and bttFieldOverlay.BufferName  = bttQueryBufferExport.BufferName
        on error undo, throw:
        
        create bttQueryFieldOverlayExport.
        
        assign
          bttQueryFieldOverlayExport.QuerySeq    = bttQueryBufferExport.QuerySeq
          bttQueryFieldOverlayExport.BufferId    = bttQueryBufferExport.BufferId
          bttQueryFieldOverlayExport.FieldName   = bttFieldOverlay.FieldName
          bttQueryFieldOverlayExport.FieldIndex  = bttFieldOverlay.FieldIndex
          bttQueryFieldOverlayExport.OverlayType = {&K_OVERLAY_TYPE_OBJ_STR}
          .
        
        validate  bttQueryFieldOverlayExport.
        
      end. /* for each bttFieldOverlay */
      
    end. /* do i = 1 to bttQueryWindow:QueryHandle:num-buffers */
  
  bttQueryWindowExport.BufferList = trim(cBufferList, ',':U).
  
  if valid-handle(bttQueryWindow.QueryFrameHandle) then
    assign
      bttQueryWindowExport.BrowseColumns  = qg_cBrowseColumnList(bttQueryWindow.QueryBrowseHandle,
                                                                 yes,
                                                                 no,
                                                                 yes)
      bttQueryWindowExport.HideFieldList  = bttQueryWindow.QueryFieldBrowseHandle:hidden
      hSplitter1                          = qg_hGetWidgetByName(bttQueryWindow.QueryFrameHandle,
                                                                'btnSplitter1':U)
      bttQueryWindowExport.Splitter1Pos   = hSplitter1:row
      .
  
  if valid-handle(bttQueryWindow.RecordFrameHandle) then
    assign
      bttQueryWindowExport.RecordBrowseColumns = qg_cBrowseColumnList(bttQueryWindow.RecordBrowseHandle,
                                                                      yes,
                                                                      no,
                                                                      yes)
      bttQueryWindowExport.RecordBrowseFields  = qg_cQueryWindowFieldList(bttQueryWindow.WindowHandle,
                                                                          yes,
                                                                          no)
      bttQueryWindowExport.DisplayRawValues     = bttQueryWindow.DisplayRawValues
      .
  
  validate bttQueryWindowExport.
  
end. /* for each bttQueryWindow */

brQueryWindowBrowse:popup-menu in frame fSelectQueryWindows = menu m_PopupMenu:handle.
run qg_InitBrowse(browse brQueryWindowBrowse:handle).

if pcFilename = ? then
  assign
    frame fSelectQueryWindows:title
        = gcTitlePrefix + 'Copy query scenario':T
    lExportWindowState:label in frame fSelectQueryWindows
        = 'Copy window state':T
    lExportQueryHistory:label in frame fSelectQueryWindows
        = 'Copy query history':T
    .

display unless-hidden
  brQueryWindowBrowse
  with frame fSelectQueryWindows
    in window hQueryWindow. 

open query brQueryWindowBrowse
  for each ttQueryWindowExport
    no-lock.

update unless-hidden
  brQueryWindowBrowse
  lExportWindowState
  lExportQueryHistory
  btnOk
  btnCancel
  with frame fSelectQueryWindows
    in window hQueryWindow. 

for each bttQueryWindowExport,
first bttQueryWindow
  where bttQueryWindow.QuerySeq = bttQueryWindowExport.QuerySeq
  on error undo, throw:
  
  if bttQueryWindowExport.WindowSelected = no then
  do:
    
    /* Delete all Window records that have not been selected. */
    
    for each bttQueryBufferExport
      where bttQueryBufferExport.QuerySeq = bttQueryWindowExport.QuerySeq
      on error undo, throw:
      
      delete bttQueryBufferExport.
      
    end. /* for each bttQueryBufferExport */
    
    delete bttQueryWindowExport.
    
  end. /* if bttQueryWindowExport.WindowSelected = no */
  
  else if input frame fSelectQueryWindows lExportQueryHistory then
  do:
    
    /* Add Recent query entries if according option has been selected. */
    
    for each bttRecentQuery
      where bttRecentQuery.WindowHandle = bttQueryWindow.WindowHandle
      on error undo, throw:
      
      create bttRecentQueryExport.
      
      assign
        bttRecentQueryExport.QuerySeq  = bttQueryWindow.QuerySeq
        bttRecentQueryExport.Order     = bttRecentQuery.Order
        bttRecentQueryExport.QueryText = bttRecentQuery.QueryText
        .
      
    end. /* for each bttRecentQuery */
    
  end. /* if bttQueryWindowExport.WindowSelected = no */
  
end. /* for each bttQueryWindowExport */

if can-find(first ttQueryWindowExport) then
do:
  
  &IF proversion >= '11.2':U &THEN
    assign
      buffer ttQueryWindowExport:buffer-field('WindowState':U):serialize-hidden         = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('BrowseColumns':U):serialize-hidden       = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('WindowWidth':U):serialize-hidden         = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('WindowHeight':U):serialize-hidden        = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('WindowColumn':U):serialize-hidden        = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('WindowRow':U):serialize-hidden           = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('HideFieldList':U):serialize-hidden       = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('Splitter1Pos':U):serialize-hidden        = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('RecordBrowseColumns':U):serialize-hidden = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('RecordBrowseFields':U):serialize-hidden  = not lExportWindowState
      buffer ttQueryWindowExport:buffer-field('DisplayRawValues':U):serialize-hidden     = not lExportWindowState
      .
    
    &ELSE
      
      if lExportWindowState then
        assign
          buffer ttQueryWindowExport:buffer-field('WindowState':U):xml-node-type         = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('BrowseColumns':U):xml-node-type       = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('WindowWidth':U):xml-node-type         = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('WindowHeight':U):xml-node-type        = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('WindowColumn':U):xml-node-type        = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('WindowRow':U):xml-node-type           = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('HideFieldList':U):xml-node-type       = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('Splitter1Pos':U):xml-node-type        = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('RecordBrowseColumns':U):xml-node-type = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('RecordBrowseFields':U):xml-node-type  = 'ELEMENT':U
          buffer ttQueryWindowExport:buffer-field('DisplayRawValues':U):xml-node-type     = 'ELEMENT':U
          .
      
      else
        assign
          buffer ttQueryWindowExport:buffer-field('WindowState':U):xml-node-type         = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('BrowseColumns':U):xml-node-type       = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('WindowWidth':U):xml-node-type         = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('WindowHeight':U):xml-node-type        = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('WindowColumn':U):xml-node-type        = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('WindowRow':U):xml-node-type           = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('HideFieldList':U):xml-node-type       = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('Splitter1Pos':U):xml-node-type        = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('RecordBrowseColumns':U):xml-node-type = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('RecordBrowseFields':U):xml-node-type  = 'HIDDEN':U
          buffer ttQueryWindowExport:buffer-field('DisplayRawValues':U):xml-node-type     = 'HIDDEN':U
          .
        
    &ENDIF
  
  if pcFileName <> ? then
    dataset dsQueryWindowExport:write-xml('File':U,
                                          pcFileName,
                                          yes).
  
  else
  do:
    
    dataset dsQueryWindowExport:write-xml('longchar':U,
                                          clText,
                                          yes).
    
    clipboard:value = clText.
    
  end. /* else: if plFile */
  
end. /* if can-find(first ttQueryWindowExport) */
  
end procedure. /* qg_SaveQueryScenario */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectBrowseColumns hQueryWindow 
PROCEDURE qg_SelectBrowseColumns :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select Order and visibility of columns in the given browse.                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = Browse for which columns should be        */
/*                                  selected.                                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBrowse as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cAvailableColumns as character no-undo.
define variable cSelectedColumns  as character no-undo.

define variable lBuffernames      as logical   no-undo.
define variable lOk               as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

lBuffernames = (phBrowse:query:num-buffers > 1).

assign
  cSelectedColumns  = qg_cBrowseColumnList(phBrowse,
                                           lBuffernames,
                                           no,
                                           no)
  cAvailableColumns = qg_cBrowseColumnList(phBrowse,
                                           lBuffernames,
                                           yes,
                                           no)
  .

run qg_SelectionDialog(cAvailableColumns,
                       cAvailableColumns,
                       input-output cSelectedColumns,
                       'Select columns':T,
                       phBrowse:window,
                       yes,
                       output lOk).

if lOk then
  run qg_SetBrowseColumns(phBrowse,
                          cSelectedColumns).

end procedure. /* qg_SelectBrowseColumns */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectExternalReference hQueryWindow 
PROCEDURE qg_SelectExternalReference :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show selection dialog for external reference.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* pcTableName                    = Table name for reference suggestion.      */
/* pcFieldName                    = Field name for reference suggestion.      */
/* plFieldReference               = Flag to indicate wether a field reference */
/*                                  or a table refenece should be entered.    */
/* pcQueryWindowList              = List of query windows that may be used as */
/*                                  Reference source.                         */
/* phParentWindow                 = Parent window for the dialog.             */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcTableName       as character no-undo.
define input  parameter pcFieldName       as character no-undo.
define input  parameter plFieldReference  as logical   no-undo.
define input  parameter pcQueryWindowList as character no-undo.
define input  parameter phParentWindow    as handle    no-undo.
define output parameter oplOk             as logical   no-undo initial ?.
define output parameter oplRecidReference as logical   no-undo initial ?.
define output parameter opiQuerySeq       as integer   no-undo initial ?.
define output parameter opcBufferName     as character no-undo initial ?.
define output parameter opcFieldName      as character no-undo initial ?.
define output parameter opiFieldIndex     as integer   no-undo initial ?.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                    as integer   no-undo.
define variable cTableSoundex        as character no-undo.
define variable cQueryBufferSoundex  as character no-undo.
define variable rQueryBuffer         as rowid     no-undo extent 8.

define variable lRecidReference as logical no-undo initial yes
  view-as radio-set
    horizontal expand
    radio-buttons
      'Recid':U, yes,
      'rowid':U, no
    size 30 by 1.

define query brQueryBufferBrowse
  for ttQueryBuffer
  scrolling.

define browse brQueryBufferBrowse
  query brQueryBufferBrowse no-lock
    display
      ttQueryBuffer.QuerySeq
      ttQueryBuffer.BufferName
      with no-assign size 70 by 17 fit-last-column.

define query brQueryBufferFieldBrowse
  for ttQueryBufferField
  scrolling.

define browse brQueryBufferFieldBrowse
  query brQueryBufferFieldBrowse no-lock
    display
      ttQueryBufferField.DisplayName
      with no-assign size 70 by 18.5 fit-last-column.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.
define buffer bttQueryBuffer for temp-table ttQueryBuffer.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fSelectExternalReference
  lRecidReference at row 1.5 col 3 no-label
  brQueryBufferBrowse at row 3 col 3
  brQueryBufferFieldBrowse at row 1.5 col 75
  btnOk at row 20.5 col 54
  btnCancel at row 20.5 col 74
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 147 by 22.44
    title gcTitlePrefix + 'Select external buffer field':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSelectExternalReference
  apply 'end-error' to self.

on 'value-changed':U of brQueryBufferBrowse in frame fSelectExternalReference
do:
  
  define variable hBufferfield       as handle    no-undo.
  define variable cDatabaseName      as character no-undo.
  define variable iFieldCounter      as integer   no-undo.
  define variable iFieldIndexCounter as integer   no-undo.
  
  define variable rMatch             as rowid     no-undo extent 4.
  
  define buffer bttQueryBufferField for temp-table ttQueryBufferField.
  
  if not plFieldReference then
    leave.
  
  empty temp-table ttQueryBufferField.
  
  if available ttQueryBuffer then
    
    run qg_FillQueryBufferFieldsTempTable( buffer ttQueryBuffer,
                                           pcFieldName,
                                           yes,
                                           input-output rMatch ).
  
  open query brQueryBufferFieldBrowse
    for each ttQueryBufferField
      no-lock.
  
  do i = 1 to extent(rMatch):
    
    if rMatch[i] <> ? then
    do:
      reposition brQueryBufferFieldBrowse to rowid rMatch[i] no-error.
      leave.
    end. /* if rMatch[i] <> ? */
    
  end. /* do i = 1 to extent(rMatch) */
  
end. /* on 'value-changed':U of brQueryBufferBrowse in frame fSelectExternalReference */

on 'default-action':U of brQueryBufferBrowse in frame fSelectExternalReference
do:
  
  if not plFieldReference then
    apply 'go':U to frame fSelectExternalReference.
  
end. /* on 'default-action':U of brQueryBufferBrowse in frame fSelectExternalReference */

on 'default-action':U of brQueryBufferFieldBrowse in frame fSelectExternalReference
  apply 'go':U to frame fSelectExternalReference.

on 'row-display':U of brQueryBufferFieldBrowse in frame fSelectExternalReference
do:
  
  if available ttQueryBufferField
    and ttQueryBufferField.isVirtual then
    
    ttQueryBufferField.DisplayName:fgcolor in browse brQueryBufferFieldBrowse = {&K_VIRTUAL_DB_FIELD_FGCOLOR}.
  
end. /* on 'row-display':U of brQueryBufferFieldBrowse in frame fSelectExternalReference */

empty temp-table ttQueryBuffer.

for each bttQueryWindow
  on error undo, throw:
  
  if    not valid-handle(bttQueryWindow.WindowHandle)
     or not can-do(pcQueryWindowList, string(bttQueryWindow.WindowHandle))
     or not valid-handle(bttQueryWindow.QueryHandle) then
    next.
  
  do i = 1 to bttQueryWindow.QueryHandle:num-buffers:
    
    create bttQueryBuffer.
    
    assign
      bttQueryBuffer.QuerySeq     = bttQueryWindow.QuerySeq
      bttQueryBuffer.BufferHandle = bttQueryWindow.QueryHandle:get-buffer-handle(i)
      bttQueryBuffer.BufferName   = bttQueryBuffer.BufferHandle:name
      .
    
  end. /* do i = 1 to bttQueryWindow.QueryHandle:num-buffers */
  
end. /* for each bttQueryWindow */

/* If no buffers are available nothing has to be done. */
if not can-find(first bttQueryBuffer) then
  leave.

if not plFieldReference then
  assign
    brQueryBufferFieldBrowse:hidden in frame fSelectExternalReference
        = yes
    brQueryBufferBrowse:height in frame fSelectExternalReference
        = brQueryBufferBrowse:height in frame fSelectExternalReference - 5
    frame fSelectExternalReference:width
        = frame fSelectExternalReference:width - 72
    frame fSelectExternalReference:virtual-width
        = frame fSelectExternalReference:virtual-width - 72
    frame fSelectExternalReference:height
        = frame fSelectExternalReference:height - 5
    frame fSelectExternalReference:virtual-height
        = frame fSelectExternalReference:virtual-height - 5
    frame fSelectExternalReference:title
        = gcTitlePrefix + 'Select external buffer':T
    btnOk:col in frame fSelectExternalReference
        = btnOk:col in frame fSelectExternalReference - 36
    btnOk:row in frame fSelectExternalReference
        = btnOk:row in frame fSelectExternalReference - 5
    btnCancel:col in frame fSelectExternalReference
        = btnCancel:col in frame fSelectExternalReference - 36
    btnCancel:row in frame fSelectExternalReference
        = btnCancel:row in frame fSelectExternalReference - 5
    .

else
do:
  
  assign
    lRecidReference:hidden in frame fSelectExternalReference
        = yes
    brQueryBufferBrowse:row in frame fSelectExternalReference
        = brQueryBufferBrowse:row in frame fSelectExternalReference - 1.5
    brQueryBufferBrowse:height in frame fSelectExternalReference
        = brQueryBufferBrowse:height in frame fSelectExternalReference + 1.5
    .
  
  /* Find first table with matching field. */
  
  if pcFieldName > '':U then
  do:
    
    cTableSoundex = qg_cSoundexCode(pcTableName).
    
    QueryBuffer:
    for each bttQueryBuffer
      on error undo, throw:
      
      cQueryBufferSoundex = qg_cSoundexCode(bttQueryBuffer.BufferHandle:table).
      
      /* Try different things to match table name. */
      if    rQueryBuffer[1] = ?
        and bttQueryBuffer.BufferHandle:table begins pcTableName then
        rQueryBuffer[1] = rowid(bttQueryBuffer).
    
      if    rQueryBuffer[2] = ?
        and cTableSoundex   = cQueryBufferSoundex then
        rQueryBuffer[2] = rowid(bttQueryBuffer).
    
      if    rQueryBuffer[3] = ?
        and bttQueryBuffer.BufferHandle:table matches substitute('*&1*':U, substring(pcTableName, index(pcTableName, '_':U) + 1)) then
        rQueryBuffer[3] = rowid(bttQueryBuffer).
    
      if    rQueryBuffer[4] = ?
        and cTableSoundex begins substring(cQueryBufferSoundex, 1, 3) then
        rQueryBuffer[4] = rowid(bttQueryBuffer).
    
      if    rQueryBuffer[5] = ?
        and bttQueryBuffer.BufferHandle:table matches substitute('*&1*':U, pcTableName) then
        rQueryBuffer[5] = rowid(bttQueryBuffer).
    
      if    rQueryBuffer[6] = ?
        and cTableSoundex begins substring(cQueryBufferSoundex, 1, 2) then
        rQueryBuffer[6] = rowid(bttQueryBuffer).
    
      if    rQueryBuffer[7] = ?
        and cTableSoundex begins substring(cQueryBufferSoundex, 1, 1) then
        rQueryBuffer[7] = rowid(bttQueryBuffer).
        
      if rQueryBuffer[8] = ? then
        rQueryBuffer[8] = rowid(bttQueryBuffer).
        
    end. /* bttQueryBuffer */
    
  end. /* if pcFieldName > '':U */
  
end. /* if not plFieldReference */

run qg_InitBrowse(browse brQueryBufferBrowse:handle).
run qg_InitBrowse(browse brQueryBufferFieldBrowse:handle).

display unless-hidden
  brQueryBufferBrowse
  with frame fSelectExternalReference
    in window phParentWindow. 

open query brQueryBufferBrowse
  for each ttQueryBuffer
    no-lock.

if plFieldReference then
do:
  
  do i = 1 to extent(rQueryBuffer):
    
    if rQueryBuffer[i] <> ? then
    do:
      reposition brQueryBufferBrowse to rowid rQueryBuffer[i] no-error.
      leave.
    end. /* if rQueryBuffer <> ? */
    
  end. /* do i = 1 to extent(rQueryBuffer) */
  
end. /* if plFieldReference */

apply 'value-changed':U to brQueryBufferBrowse in frame fSelectExternalReference.

update unless-hidden
  lRecidReference
  brQueryBufferBrowse
  brQueryBufferFieldBrowse
  btnOk
  btnCancel
  with frame fSelectExternalReference
    in window phParentWindow. 

if available ttQueryBuffer then
  assign
    oplRecidReference = lRecidReference
    opiQuerySeq       = ttQueryBuffer.QuerySeq
    opcBufferName     = ttQueryBuffer.BufferName
    opcFieldName      = ttQueryBufferField.FieldName
    opiFieldIndex     = ttQueryBufferField.FieldIndex
    oplOk             = yes
    .
  
end procedure. /* qg_SelectExternalReference */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectFieldList hQueryWindow 
PROCEDURE qg_SelectFieldList :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Filters and selects a list of fields in the field browser.                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcFieldList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i           as integer   no-undo.

define variable cFieldEntry as character no-undo.
define variable rRowidEntry as rowid     no-undo.
define variable cRowidList  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

gcFieldFilter = '':U.

do i = 1 to num-entries(pcFieldList):
  
  cFieldEntry = entry(i, pcFieldList).
  
  find first bttField
    where bttField.DatabaseName = ttDatabase.DatabaseName
      and bttField.TableName    = ttTable.TableName
      and bttField.FieldName    = cFieldEntry
    no-error.
  
  if available bttField then
    assign
      cRowidList    = substitute('&1,&2':U,
                                 cRowidList,
                                 string(rowid(bttField)))
      gcFieldFilter = substitute('&1,"&2"':U,
                                 gcFieldFilter,
                                 cFieldEntry)
      .
  
end. /* do i = 1 to num-entries(pcFieldList) */

gcFieldFilter = trim(gcFieldFilter, ',':U).

display unless-hidden
  gcFieldFilter
  with frame {&FRAME-NAME}.

glRefreshFieldBrowse = yes.
run qg_RefreshFieldBrowse.

do i = 1 to num-entries(cRowidList):
  
  rRowidEntry = to-rowid(entry(i, cRowidList)).
  
  reposition brField to rowid rRowidEntry no-error.
  
  if rowid(ttField) = rRowidEntry then
    browse brField:select-focused-row().
  
end. /* do i = 1 to num-entries(cRowidList) */

end procedure. /* qg_SelectFieldList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectIndex hQueryWindow 
PROCEDURE qg_SelectIndex :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Shows a selection dialog with all indices of given table.                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Database name of the table.               */
/* pcTableName                    = Table name.                               */
/* iopcIndexName                  = Index name the user selected. If an index */
/*                                  name is passed to this procedure then     */
/*                                  given index will be preselected.          */
/* oplOk                          = Flag to indicate if the user approved     */
/*                                  the dialog.                               */
/* phParentWindow                 = Handle of the parent window for the       */
/*                                  dialog.                                   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter pcDatabaseName as character no-undo.
define input        parameter pcTableName    as character no-undo.
define input-output parameter iopcIndexName  as character no-undo.
define       output parameter oplOk          as logical   no-undo.
define input        parameter phParentWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iFilterId as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable       for temp-table ttTable.
define buffer bttIndex       for temp-table ttIndex.
define buffer b2ttIndex      for temp-table ttIndex.

define buffer bttFilterMatch for temp-table ttFilterMatch.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Define widgets. */

define variable cFilter as character no-undo
  format 'x(1024)':U
  view-as fill-in
  tooltip "Filter for indices that contain fields matching given name pattern (comma separated)"
  size 139 by 1.

define button btnClearFilter
  label '':T
  tooltip "Clear filter"
  size 7 by 1.

define query brSelectIndex
  for bttIndex,
      bttFilterMatch
  scrolling.

define browse brSelectIndex
  query brSelectIndex no-lock
    display
      bttIndex.IsPrimary
      bttIndex.IndexName
      bttIndex.IsUnique
      bttIndex.IndexFields
      with no-assign size 146 by 20 fit-last-column.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Define frame. */

define frame fSelectIndex
  cFilter at row 1.5 col 3 no-label
  btnClearFilter at row 1.5 col 142
  brSelectIndex at row 2.5 col 3
  btnOk at row 23.5 col 56
  btnCancel at row 23.5 col 76
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    title gcTitlePrefix + 'Select Index':U
    side-labels no-underline three-d 
    size 151 by 25.44
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSelectIndex
  apply 'end-error' to self.

on off-home of brSelectIndex in frame fSelectIndex
do:
  apply 'entry':U to cFilter in frame fSelectIndex.
  return no-apply.
end. /* on cursor-down of cProcedureFilter in frame fTableRelation */

on cursor-down of cFilter in frame fSelectIndex
do:
  apply 'entry':U to brSelectIndex in frame fSelectIndex.
  browse brSelectIndex:select-focused-row().
  return no-apply.
end. /* on cursor-down of cFilter in frame fSelectIndex */

on cursor-down of btnClearFilter in frame fSelectIndex
do:
  apply 'entry':U to brSelectIndex in frame fSelectIndex.
  browse brSelectIndex:select-focused-row().
  return no-apply.
end. /* on cursor-down of btnClearFilter in frame fSelectIndex */

on value-changed of cFilter in frame fSelectIndex
do:
  
  define variable cFilterEntry        as character no-undo.
  define variable cPrepFilter         as character no-undo.
  
  define variable iFilterEntryCounter as integer       no-undo.
  
  cFilter = input frame fSelectIndex cFilter.
  
  do iFilterEntryCounter = 1 to num-entries(cFilter):
    
    assign
      cFilterEntry = entry(iFilterEntryCounter, cFilter).
      cPrepFilter  = substitute('&1,&2':U,
                                cPrepFilter,
                                qg_cFilterEntryMatchcode(cFilterEntry))
      .
    
  end. /* do i = 1 to num-entries(cFilter) */
  
  cPrepFilter = (if cPrepFilter = '':U then
                   '*':U
                 else
                   trim(cPrepFilter, ',':U)).
  
  for each bttIndex
    where bttIndex.DatabaseName = pcDatabaseName
      and bttIndex.TableName    = pcTableName
      and bttIndex.IsVirtual    = no,
  first bttFilterMatch
    where bttFilterMatch.FilterId    = iFilterId
      and bttFilterMatch.RecordRowId = rowid(bttIndex)
    on error undo, throw:
    
    bttFilterMatch.RecordMatches = yes.
    
    do iFilterEntryCounter = 1 to num-entries(cPrepFilter):
      
      assign
        cFilterEntry                     = entry(iFilterEntryCounter, cPrepFilter, ',':U)
        bttFilterMatch.RecordMatches     =     bttFilterMatch.RecordMatches
                                           and can-find(first ttIndexField
                                                          where ttIndexField.DatabaseName = bttIndex.DatabaseName
                                                            and ttIndexField.TableName    = bttIndex.TableName
                                                            and ttIndexField.IndexName    = bttIndex.IndexName
                                                            and can-do(cFilterEntry, ttIndexField.FieldName))
        .
      
      if not bttIndex.IndexFieldFilterMatches then
        leave.
      
    end. /* do iFilterEntryCounter = 1 to num-entries(cPrepFilter) */
    
  end. /* for each bttTableRelationView */
  
  open query brSelectIndex
    for each bttIndex
      where bttIndex.DatabaseName = pcDatabaseName
        and bttIndex.TableName    = pcTableName
        and bttIndex.IsVirtual    = no,
    first bttFilterMatch
      where bttFilterMatch.FilterId      = iFilterId
        and bttFilterMatch.RecordRowId   = rowid(bttIndex)
        and bttFilterMatch.RecordMatches = yes
      .
  
  apply 'value-changed':U to browse brSelectIndex.
  
end. /* on value-changed of cFilter in frame fSelectIndex */

on choose of btnClearFilter in frame fSelectIndex
do:
  
  display unless-hidden
    '':U @ cFilter
    with frame fSelectIndex.
  
  apply 'value-changed':U to cFilter in frame fSelectIndex.
  
end. /* on choose of btnClearFilter in frame fSelectIndex */

on default-action of browse brSelectIndex
  apply 'go':U to frame fSelectIndex.

find bttTable
  where bttTable.DatabaseName = pcDatabaseName
    and bttTable.TableName    = pcTableName
  no-error.

if not available bttTable then
  leave.

run qg_InitBrowse(browse brSelectIndex:handle).

iFilterId = qg_iFilterSeq().

for each bttIndex
  where bttIndex.DatabaseName = pcDatabaseName
    and bttIndex.TableName    = pcTableName
    and bttIndex.IsVirtual    = no
  on error undo, throw:
  
  create bttFilterMatch.
  
  assign
    bttFilterMatch.FilterId      = iFilterId
    bttFilterMatch.RecordRowId   = rowid(bttIndex)
    bttFilterMatch.RecordMatches = yes
    .
  
  validate bttFilterMatch.
  
end. /* for each bttIndex */

open query brSelectIndex
  for each bttIndex
    where bttIndex.DatabaseName = pcDatabaseName
      and bttIndex.TableName    = pcTableName
      and bttIndex.IsVirtual    = no,
  first bttFilterMatch
    where bttFilterMatch.FilterId      = iFilterId
      and bttFilterMatch.RecordRowId   = rowid(bttIndex)
      and bttFilterMatch.RecordMatches = yes
      .

if iopcIndexName > '':U then
  find first b2ttIndex
    where b2ttIndex.DatabaseName = pcDatabaseName
      and b2ttIndex.TableName    = pcTableName
      and b2ttIndex.IndexName    = iopcIndexName
    no-error.

else
  find first b2ttIndex
    where b2ttIndex.DatabaseName = pcDatabaseName
      and b2ttIndex.TableName    = pcTableName
      and b2ttIndex.IsPrimary    = yes
    no-error.

if available b2ttIndex then
do:
  
  find first bttFilterMatch
    where bttFilterMatch.FilterId      = iFilterId
      and bttFilterMatch.RecordRowId   = rowid(b2ttIndex)
      and bttFilterMatch.RecordMatches = yes
    no-error.
  
  if available bttFilterMatch then
    
    reposition brSelectIndex to rowid rowid(b2ttIndex), rowid( bttFilterMatch ).
  
end.

update unless-hidden
  cFilter
  btnClearFilter
  brSelectIndex
  btnOk
  btnCancel
  with frame fSelectIndex
    in window phParentWindow. 

if available bttIndex then
  assign
    iopcIndexName = bttIndex.IndexName
    oplOk         = yes
    .

finally:
  
  if iFilterId > 0 then
  do:
    
    for each bttFilterMatch
      where bttFilterMatch.FilterId = iFilterId
      on error undo, throw:
      
      delete bttFilterMatch.
      
    end. /* for each bttFilterMatch */
    
  end. /* if iFilterId > 0 */
  
end finally.

end procedure. /* qg_SelectIndex */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectionDialog hQueryWindow 
PROCEDURE qg_SelectionDialog :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show a selection dialog.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcAvailableItems               = All items that are available (including   */
/*                                  selected ones)                            */
/* pcSelectedItems                = Items that are selected.                  */
/* pcTitle                        = Title for the dialog box.                 */
/* phParentWindow                 = Parent window for the dialog.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input        parameter pcAvailableItem_Keys   as character no-undo.
define input        parameter pcAvailableItem_Labels as character no-undo.
define input-output parameter iopcSelectedItem_Keys  as character no-undo.
define input        parameter pcTitle                as character no-undo.
define input        parameter phParentWindow         as handle    no-undo.
define input        parameter plShowOrderButtons     as logical   no-undo.
define       output parameter oplOk                  as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i           as integer   no-undo.
define variable cItem_Key   as character no-undo.
define variable cItem_Label as character no-undo.

define variable cAvailableColumns as character no-undo
  view-as selection-list
    multiple sort scrollbar-horizontal scrollbar-vertical
    list-item-pairs '':U, '':U
  size 50 by 16.

define variable cSelectedColumns as character no-undo
  view-as selection-list
    multiple scrollbar-horizontal scrollbar-vertical
    list-item-pairs '':U, '':U
  size 50 by 16.

define button btnAdd
  label '>':U
  size 10 by 1.5.

define button btnAddAll
  label '>>':U
  size 10 by 1.5.

define button btnRemove
  label '<':U
  size 10 by 1.5.

define button btnRemoveAll
  label '<<':U
  size 10 by 1.5.

define button btnTop
  label 'Top':U
  size 10 by 1.5.

define button btnUp
  label 'Up':U
  size 10 by 1.5.

define button btnDown
  label 'Down':U
  size 10 by 1.5.

define button btnBottom
  label 'Bottom':U
  size 10 by 1.5.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T6
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fColumns
  cAvailableColumns at row 1.5 col 3 no-labels
  btnAdd at row 1.5 col 55
  btnAddAll at row 3 col 55
  btnRemove at row 5 col 55
  btnRemoveAll at row 6.5 col 55
  btnTop at row 10.5 col 55
  btnUp at row 12.5 col 55
  btnDown at row 14 col 55
  btnBottom at row 16 col 55
  cSelectedColumns at row 1.5 col 67 no-labels
  btnOk at row 18.5 col 40
  btnCancel at row 18.5 col 60
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 119 by 20.44
    title 'Select Items':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fColumns
  apply 'end-error' to self.

on choose of btnAdd in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItemList   as character no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  cItemList = cAvailableColumns:screen-value in frame fColumns.
  
  do i = 1 to num-entries(cItemList):
    
    assign
      cItem_Key   = entry(i, cItemList)
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      .
    
    cAvailableColumns:delete(cItem_Key).
    cSelectedColumns:add-last(cItem_Label, cItem_Key).
    
  end. /* do i = 1 to num-entries(cItemList) */
  
  cSelectedColumns:screen-value in frame fColumns = cItemList.
  
end. /* on choose of button btnAdd */

on ctrl-k of cAvailableColumns in frame fColumns
  apply 'choose':U to btnAdd in frame fColumns.

on ctrl-cursor-right of cAvailableColumns in frame fColumns
  apply 'choose':U to btnAdd in frame fColumns.

on choose of btnAddAll in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  do i = 1 to cAvailableColumns:num-items in frame fColumns:
    
    assign
      cItem_Key   = cAvailableColumns:entry(i) in frame fColumns
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      .
    
    cAvailableColumns:delete(cItem_Key).
    cSelectedColumns:add-last(cItem_Label, cItem_Key).
    
    i = i - 1.
    
  end. /* do i = 1 to num-entries(cItemList) */
  
end. /* on choose of button btnAdd */

on choose of btnRemove in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItemList   as character no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  cItemList = cSelectedColumns:screen-value  in frame fColumns.
  
  do i = 1 to num-entries(cItemList):
    
    assign
      cItem_Key   = entry(i, cItemList)
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      .
    
    if cSelectedColumns:is-selected(cItem_Key) in frame fColumns then
    do:
      cSelectedColumns:delete(cItem_Key).
      cAvailableColumns:add-last(cItem_Label, cItem_Key).
    end. /* if cSelectedColumn:is-selected(i) in frame fColumns */
    
  end. /* do i = cSelectedColumn:num-items to 1 by -1 in frame fColumns */
  
  cAvailableColumns:screen-value in frame fColumns = cItemList.
  
end. /* on choose of button btnRemove */

on ctrl-m of cSelectedColumns in frame fColumns
  apply 'choose':U to btnRemove in frame fColumns.

on ctrl-cursor-left of cSelectedColumns in frame fColumns
  apply 'choose':U to btnRemove in frame fColumns.

on choose of btnRemoveAll in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  do i = cSelectedColumns:num-items in frame fColumns to 1 by -1:
    
    assign
      cItem_Key   = cSelectedColumns:entry(i) in frame fColumns.
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      .
    
    cSelectedColumns:delete(cItem_Key).
    cAvailableColumns:add-last(cItem_Label, cItem_Key).
    
  end. /* do i = cSelectedColumn:num-items to 1 by -1 in frame fColumns */
  
end. /* on choose of button btnRemoveAll */

on 'mouse-select-dblclick':U of cAvailableColumns in frame fColumns
  apply 'choose':U to btnAdd in frame fColumns.

on 'mouse-select-dblclick':U of cSelectedColumns in frame fColumns
  apply 'choose':U to btnRemove in frame fColumns.

on choose of btnTop in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItemList   as character no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  cItemList = cSelectedColumns:screen-value in frame fColumns.
  
  do i = num-entries(cItemList) to 1 by -1:
    
    assign
      cItem_Key   = entry(i, cItemList)
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      .
    
    cSelectedColumns:delete(cItem_Key) in frame fColumns.
    cSelectedColumns:add-first(cItem_Label, cItem_Key) in frame fColumns.
    
  end. /* do i = 1 to num-entries(cItemList) */
  
  cSelectedColumns:screen-value in frame fColumns = cItemList.
  
end. /* on choose of button btnTop */

on ctrl-home of cSelectedColumns in frame fColumns
  apply 'choose':U to btnTop in frame fColumns.

on choose of btnUp in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItemList   as character no-undo.
  define variable iIndex      as integer   no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  cItemList = cSelectedColumns:screen-value in frame fColumns.
  
  do i = 1 to num-entries(cItemList):
    
    assign
      cItem_Key   = entry(i, cItemList)
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      iIndex      = cSelectedColumns:lookup(cItem_Key) in frame fColumns
      .
    
    if iIndex > i then
    do:
      cSelectedColumns:delete(iIndex) in frame fColumns.
      cSelectedColumns:insert(cItem_Label, cItem_Key, iIndex - 1) in frame fColumns.
    end. /* if iIndex > 1 */
    
  end. /* do i = 1 to num-entries(cItemList) */
  
  cSelectedColumns:screen-value in frame fColumns = cItemList.
  
end. /* on choose of button btnUp */

on ctrl-cursor-up of cSelectedColumns in frame fColumns
  apply 'choose':U to btnUp in frame fColumns.

on choose of btnDown in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItemList   as character no-undo.
  define variable iIndex      as integer   no-undo.
  define variable iMaxIndex   as integer   no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  assign
    cItemList = cSelectedColumns:screen-value in frame fColumns
    iMaxIndex = cSelectedColumns:num-items in frame fColumns
    .
  
  do i = num-entries(cItemList) to 1 by -1:
    
    assign
      cItem_Key   = entry(i, cItemList)
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      iIndex      = cSelectedColumns:lookup(cItem_Key) in frame fColumns
      .
    
    if iIndex < iMaxIndex - num-entries(cItemList) + i then
    do:
      cSelectedColumns:delete(iIndex) in frame fColumns.
      cSelectedColumns:insert(cItem_Label, cItem_Key, iIndex + 1) in frame fColumns.
    end. /* iIndex <= cSelectedColumns:num-items in frame fColumns - i */
    
  end. /* do i = num-entries(cItemList) to 1 by -1 */
  
  cSelectedColumns:screen-value in frame fColumns = cItemList.
  
end. /* on choose of button btnDown */

on ctrl-cursor-down of cSelectedColumns in frame fColumns
  apply 'choose':U to btnDown in frame fColumns.

on choose of btnBottom in frame fColumns
do:
  
  define variable i           as integer   no-undo.
  define variable cItemList   as character no-undo.
  define variable cItem_Key   as character no-undo.
  define variable cItem_Label as character no-undo.
  
  cItemList = cSelectedColumns:screen-value in frame fColumns
    .
  
  do i = 1 to num-entries(cItemList):
    
    assign
      cItem_Key   = entry(i, cItemList)
      cItem_Label = entry(lookup(cItem_Key, pcAvailableItem_Keys), pcAvailableItem_Labels)
      .
    
    cSelectedColumns:delete(cItem_Key) in frame fColumns.
    cSelectedColumns:add-last(cItem_Label, cItem_Key) in frame fColumns.
    
  end. /* do i = 1 to num-entries(cItemList) */
  
  cSelectedColumns:screen-value in frame fColumns = cItemList.
  
end. /* on choose of button btnBottom */

on ctrl-end of cSelectedColumns in frame fColumns
  apply 'choose':U to btnBottom in frame fColumns.

frame fColumns:title = gcTitlePrefix + pcTitle.

/* for some unknown reaseon the "in window" option of the update statement    */
/* does not do the trick for this specific dialog. As a workaround we set the */
/* parent attribute.                                                          */

frame fColumns:parent = phParentWindow.

if not plShowOrderButtons then
  assign
    btnTop:hidden                           = yes
    btnUp:hidden                            = yes
    btnDown:hidden                          = yes
    btnBottom:hidden                        = yes
    cSelectedColumns:sort in frame fColumns = yes
    .

assign
  cAvailableColumns:list-item-pairs in frame fColumns = ?
  cSelectedColumns:list-item-pairs in frame fColumns  = ?
  .

do i = 1 to num-entries(pcAvailableItem_Keys):
  
  assign
    cItem_Key   = entry(i, pcAvailableItem_Keys)
    cItem_Label = entry(i, pcAvailableItem_Labels)
    .
  
  if lookup(cItem_Key, iopcSelectedItem_Keys) > 0 then
    cSelectedColumns:add-last(cItem_Label, cItem_Key) in frame fColumns.
  
  else
    cAvailableColumns:add-last(cItem_Label, cItem_Key) in frame fColumns.
    
end. /* do i = 1 to num-entries(iopcSelectedItem_Keys) */

update unless-hidden
  cAvailableColumns
  btnAdd
  btnAddAll
  btnRemove
  btnRemoveAll
  cSelectedColumns
  btnTop
  btnUp
  btnDown
  btnBottom
  btnOk
  btnCancel
  with frame fColumns
    in window phParentWindow.

iopcSelectedItem_Keys = '':U.

do i = 1 to cSelectedColumns:num-items in frame fColumns:
  iopcSelectedItem_Keys = substitute('&1,&2':U,
                                     iopcSelectedItem_Keys,
                                     cSelectedColumns:entry(i) in frame fColumns).
end. /* do i = 1 to cSelectedColumns:num-items in frame fColumns */

assign
  iopcSelectedItem_Keys = trim(iopcSelectedItem_Keys, ',':U)
  oplOk                 = yes
  .

end procedure. /* qg_SelectionDialog */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectQueryBuffer hQueryWindow 
PROCEDURE qg_SelectQueryBuffer :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter phQuery   as handle    no-undo.
define output parameter ophBuffer as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i       as integer   no-undo.
define variable hBuffer as handle    no-undo.

define variable cQueryBuffer as character
  view-as selection-list
    list-item-pairs '':U, '':U
  size 66 by 8
  .

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fSelectQueryBuffer
  cQueryBuffer at row 1.5 col 3 no-label
  btnOk at row 10.5 col 15
  btnCancel at row 10.5 col 35
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    side-labels no-underline three-d 
    size 71 by 12.44
    title gcTitlePrefix + 'Select qurey bufffer':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSelectQueryBuffer
  apply 'end-error' to self.

on default-action of cQueryBuffer in frame fSelectQueryBuffer
  apply 'go' to frame fSelectQueryBuffer.

cQueryBuffer:delete(1).

do i = 1 to phQuery:num-buffers:
  
  hBuffer = phQuery:get-buffer-handle(i).
  
  cQueryBuffer:add-last((if hBuffer:name = hBuffer:table then
                           hBuffer:name
                         else
                           substitute('&1 (&2)':U, hBuffer:name, hBuffer:table)),
                        hBuffer:name).
  
  if i = 1 then
    cQueryBuffer = hBuffer:name.
  
end. /* do i = 1 to phQuery:num-buffers */

update unless-hidden
  cQueryBuffer
  btnOk
  btnCancel
  with frame fSelectQueryBuffer.

ophBuffer = phQuery:get-buffer-handle(cQueryBuffer) no-error.

end procedure. /* qg_SelectQueryBuffer */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectRelation hQueryWindow 
PROCEDURE qg_SelectRelation :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select given Table.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabasename      as character no-undo.
define variable cTableName         as character no-undo.
define variable iFilterId          as integer   no-undo.

define variable hFrame             as handle    no-undo.
define variable hFilterFillIn      as handle    no-undo.
define variable hRelationQuery     as handle    no-undo.
define variable hRelationBuffer    as handle    no-undo.
define variable hFilterMatchBuffer as handle    no-undo.
define variable hRelationBrowse    as handle    no-undo.
define variable hBufferFillIn      as handle    no-undo.
define variable hApplyButton       as handle    no-undo.
define variable hClearButton       as handle    no-undo.
define variable hTemp              as handle    no-undo.

define variable lVirtualIndex      as logical   no-undo.

define variable cQueryText         as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelationView for temp-table ttTableRelationView.
define buffer bttFilterMatch       for temp-table ttFilterMatch.
/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   valid-handle(ghRelationWindow)
  or not available ttDatabase
  or not available ttTable then
  leave.

assign
  cDatabaseName = ttDatabase.DatabaseName
  cTableName    = ttTable.TableName
  lVirtualIndex = (     giDisplayMode = {&K_DISPLAYMODE_INDEX}
                    and available ttIndex
                    and ttIndex.IsVirtual ).

if    ( not lVirtualIndex
     or glUseVirtualIndexApi )
  and giDisplayMode <> {&K_DISPLAYMODE_RELATION} then
  
  iFilterId = qg_iFilterSeq().

btnOf:sensitive in frame {&FRAME-NAME} = no.

create window ghRelationWindow
  assign
    hidden          = yes
    width           = 80
    max-width       = 1024
    height          = ( if    ( lVirtualIndex
                            and not glUseVirtualIndexApi )
                           or giDisplayMode = {&K_DISPLAYMODE_RELATION} then
                          1.3
                        else
                          15 )
    max-height      = 1024
    scroll-bars     = no
    status-area     = no
    three-d         = yes
    message-area    = no
    control-box     = no
    small-title     = yes
    show-in-taskbar = no
    top-only        = yes
    sensitive       = yes
    resize          = no
    parent          = hQueryWindow
    title           = substitute('&1Select relation':U, gcTitlePrefix)
  triggers:
    
    on leave
      persistent run qg_RelationWindowClose in target-procedure
                       (iFilterId).
    
    on window-close
      persistent run qg_RelationWindowClose in target-procedure
                       (iFilterId).
    
  end triggers.

create frame hFrame
  assign
    name           = 'fRelation':U
    box            = no
    three-d        = yes
    width          = ghRelationWindow:width
    virtual-width  = ghRelationWindow:width
    height         = ghRelationWindow:height
    virtual-height = ghRelationWindow:height
    sensitive      = yes
    parent         = ghRelationWindow
    .

if    ( not lVirtualIndex
     or glUseVirtualIndexApi )
  and giDisplayMode <> {&K_DISPLAYMODE_RELATION} then
do:
  
  create fill-in hFilterFillIn
    assign
      name            = 'cFilter':U
      frame           = hFrame
      data-type       = 'character':U
      format          = 'x(1024)':U
      width           = hFrame:width - 9
      height          = 1
      row             = 1.25
      col             = 2
      tooltip         = 'Filter for related tables that match given name pattern (comma separated)':T
      sensitive       = yes
      
    triggers:
      
      on cursor-down
        persistent run qg_RelationWindowEnterBrowse in target-procedure.
      
      on value-changed
        persistent run qg_RelationWindowRefreshRelationBrowse in target-procedure
                         (iFilterId,
                          cDatabaseName,
                          cTableName).
      
    end triggers
    .

  create button hTemp
    assign
      name            = 'btnClear':U
      frame           = hFrame
      width           = 7
      height          = 1
      row             = hFilterFillIn:row
      col             = hFilterFillIn:col + hFilterFillIn:width
      label           = '':U
      tooltip         = 'Reset related table filter':T
      sensitive       = yes
    triggers:
      
      on cursor-down
        persistent run qg_RelationWindowEnterBrowse in target-procedure.
      
      on choose
        persistent run qg_RelationWindowClearFilter in target-procedure.
      
    end triggers
    .
  
  create browse hRelationBrowse
    assign
      name                   = 'brRelation':U
      frame                  = hFrame
      width                  = hFrame:width - 2
      height                 = hFrame:height - 2.6
      row                    = hFilterFillIn:row + 1
      col                    = hFilterFillIn:col
      read-only              = yes
      row-markers            = no
      allow-column-searching = no
    triggers:
      
      on off-home
        persistent run qg_RelationWindowEnterEnterFilterFillIn in target-procedure.
      
      on value-changed
        persistent run qg_RelationWindowRelationBrowseValueChanged in target-procedure.
      
      on default-action
        persistent run qg_RelationWindowApply in target-procedure
                         (iFilterId).
      
    end triggers
    .
  
end. /* if    not lVirtualIndex */

create fill-in hBufferFillIn
  assign
    name      = 'cBufferName':U
    frame     = hFrame
    data-type = 'character':U
    format    = 'x(32)':U
    width     = (if valid-handle(hRelationBrowse) then
                   hRelationBrowse:width - 31
                 else
                   hFrame:width - 33)
    height    = 1
    row       = (if valid-handle(hRelationBrowse) then
                   hRelationBrowse:row + hRelationBrowse:height + 0.25
                 else
                   1.25)
    col       = 12
    sensitive = yes
    .

create text hTemp
  assign
    format        = 'x(6)':U
    frame         = hFrame
    width         = font-table:get-text-width-chars('Buffer:':U)
    row           = hBufferFillIn:row
    height        = 1
    col           = 1
    .

assign
  hTemp:col           = hBufferFillIn:col - hTemp:width - 1
  hTemp:screen-value  = 'Buffer:':U
  hBufferFillIn:side-label-handle = hTemp
  .

create button hApplyButton
  assign
    name      = 'btnApply':U
    frame     = hFrame
    width     = 10
    height    = 1
    row       = hBufferFillIn:row
    col       = hBufferFillIn:col + hBufferFillIn:width + 1
    label     = 'Apply':T
    default   = yes
    auto-go   = yes
    sensitive = yes
  triggers:
    
    on choose
      persistent run qg_RelationWindowApply in target-procedure
                       (iFilterId).
    
  end triggers
  .

create button hClearButton
  assign
    name        = 'btnReset':U
    frame       = hFrame
    width       = 10
    height      = 1
    row         = hBufferFillIn:row
    col         = hApplyButton:col + hApplyButton:width
    label       = 'Reset':T
    sensitive   = yes
  triggers:
    
    on choose
      persistent run qg_RelationWindowClear in target-procedure
                       (iFilterId).
    
  end triggers
  .

on end-error of hFrame anywhere
  persistent run qg_RelationWindowClose in target-procedure
                   (iFilterId).

run qg_DropDownWindow(ghRelationWindow,
                      btnOf:handle in frame {&FRAME-NAME},
                      {&K_DIRECTION_RIGHT}).

if valid-handle(hRelationBrowse) then
do:
  
  create buffer hRelationBuffer for table 'ttTableRelationView':U.
  create buffer hFilterMatchBuffer for table 'ttFilterMatch':U.
  
  create query hRelationQuery.
  hRelationQuery:set-buffers(hRelationBuffer, hFilterMatchBuffer).
  
  run qg_InitBrowse(hRelationBrowse).
  
end. /* if valid-handle(hRelationBrowse) */

hFrame:default-button = hApplyButton.

/*----------------------------------------------------------------------------*/
/* Fill Temp-Table for relation browse.                                       */
/*----------------------------------------------------------------------------*/

assign
  ghRelationWindow:hidden = no
  hFrame:hidden           = no
  .

if valid-handle(hRelationBrowse) then
do:
  
  hRelationBrowse:query = hRelationQuery.
  hRelationBrowse:add-like-column('ttTableRelationView.RelatedTableName':U).
  hRelationBrowse:add-like-column('ttTableRelationView.RelationType':U).
  hRelationBrowse:add-like-column('ttTableRelationView.RelatedFields':U).
  hRelationBrowse:get-browse-column(2):width = 8.
  
  assign
    hRelationBrowse:labels          = no
    hRelationBrowse:fit-last-column = yes
    .
  
  for each bttTableRelationView
    where bttTableRelationView.DatabaseName       = cDatabaseName
      and bttTableRelationView.ReferenceTableName = cTableName
    on error undo, throw:
    
    create bttFilterMatch.
    
    assign
      bttFilterMatch.FilterId      = iFilterId
      bttFilterMatch.RecordRowId   = rowid(bttTableRelationView)
      bttFilterMatch.RecordMatches = yes
      .
    
    validate bttFilterMatch.
    
  end. /* for each bttTableRelationView */
  
  apply 'value-changed':U to hFilterFillIn.
  
  if giRelationId > 0 then
  do:
    
    find first bttTableRelationView
      where bttTableRelationView.RelationId         = giRelationId
        and bttTableRelationView.DatabaseName       = cDatabaseName
        and bttTableRelationView.ReferenceTableName = cTableName
      no-error.
    
    if available bttTableRelationView then
    do:
      hRelationBrowse:query:reposition-to-rowid(rowid(bttTableRelationView)) no-error.
      apply 'value-changed':U to hRelationBrowse.
    end. /* if available bttTableRelationView */
    
  end. /* if giRelationId > 0 */
  
end. /* if valid-handle(hRelationBrowse) */

if    ( lVirtualIndex
    and not glUseVirtualIndexApi )
   or ( giRelationId > 0
    and ( available bttTableRelationView
       or giDisplayMode = {&K_DISPLAYMODE_RELATION} ) ) then
  
  hBufferFillIn:screen-value = gcRelationBuffername.

if valid-handle(hRelationBrowse) then
  
  apply 'entry':U to hFilterFillIn.

else
  apply 'entry':U to hBufferFillIn.

end procedure. /* qg_SelectRelation */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectRepositoryLanguage Method-Library
procedure qg_SelectRepositoryLanguage :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cRepositoryLanguage as character no-undo
  format 'x(32)':U
  view-as fill-in
  size 45 by 1.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define frame fRepositoryLanguage
    'Please enter repository language:':T view-as text size 45 by 1 at col 3 row 1.5
    cRepositoryLanguage at row 2.5 col 3 no-label
    btnOk at row 4.5 col 6
    btnCancel at row 4.5 col 26
  with 1 down keep-tab-order overlay
    view-as dialog-box
    side-labels no-underline three-d 
    size 51 by 6.44
    title gcTitlePrefix + 'Select repository language':T
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fRepositoryLanguage
  apply 'end-error' to self.

cRepositoryLanguage = gcRepositoryLanguage.

update unless-hidden
  cRepositoryLanguage
  btnOk
  btnCancel
  with frame fRepositoryLanguage.

if cRepositoryLanguage <> gcRepositoryLanguage then
do:
  
  gcRepositoryLanguage = cRepositoryLanguage.
  
  for each bttTable
    where bttTable.DescriptionLoaded = yes
    on error undo, throw:
    
    assign
      bttTable.ShortDescription  = '':U
      bttTable.DescriptionLoaded = no
      .
    
    validate bttTable.
    
  end. /* for each ttTable */
  
  if query brTable:num-results > 0 then
    browse brTable:refresh().
  
end. /* if cRepositoryLanguage <> gcRepositoryLangauge */

end procedure. /* qg_SelectRepositoryLanguage */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SelectTable hQueryWindow 
PROCEDURE qg_SelectTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select given Table.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcTableName as character no-undo.
define input parameter plSetBuffer as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName           as character no-undo.
define variable cTableName              as character no-undo.

define variable iTableNameLength        as integer   no-undo.
define variable iLongestTableNameLength as integer   no-undo.

define variable i                       as integer   no-undo.
define variable cSuffix                 as character no-undo.

define variable iTablenameStart         as integer   no-undo.
define variable iBuffernameStart        as integer   no-undo.
define variable iBuffernameEnd          as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.
define buffer bttTable    for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

pcTableName = trim(pcTableName).

/* First priority: exact table match in active database. */

if available ttDatabase then
do:
  
  find bttTable
    where bttTable.DatabaseName = ttDatabase.DatabaseName
      and bttTable.TableName    = pcTableName
    no-error.
  
  if    not available bttTable
    and ttDatabase.TempDB
    and pcTableName begins 'tt':U then
    find bttTable
      where bttTable.DatabaseName = ttDatabase.DatabaseName
        and bttTable.TableName    = substitute('td&1':U, substring(pcTableName, 3))
      no-error.
  
  if available bttTable then
    assign
      cDatabaseName = bttTable.DatabaseName
      cTableName    = bttTable.TableName
      .
  
end. /* if available ttDatabase */

/* Second priority: exact table match in any database. */

if cTableName = '':U then
do:
  
  for each bttDatabase
    on error undo, throw:
    
    /* Make sure, that cache for Database is loaded. */
    
    if not can-find(first ttTable
                      where ttTable.DatabaseName = bttDatabase.DatabaseName) then
      run qg_AddTables(bttDatabase.DatabaseName).
    
    find bttTable
      where bttTable.DatabaseName = bttDatabase.DatabaseName
        and bttTable.TableName    = pcTableName
      no-error.
    
    if    not available bttTable
      and bttDatabase.TempDB
      and pcTableName begins 'tt':U then
      find bttTable
        where bttTable.DatabaseName = bttDatabase.DatabaseName
          and bttTable.TableName    = substitute('td&1':U, substring(pcTableName, 3))
        no-error.
    
    if available bttTable then
    do:
      
      assign
        cDatabaseName = bttTable.DatabaseName
        cTableName    = bttTable.TableName
        .
      
      leave.
      
    end. /* if available bttTable */
    
  end. /* for each bttDatabase */
  
end. /* if cTableName = '':U */

/* Third priority: shortest wildcard table match in active database. */

if    cTableName = '':U
  and available ttDatabase then
do:
  
  for each bttTable
    where bttTable.DatabaseName = ttDatabase.DatabaseName
      and pcTableName     matches substitute('*&1*':U, bttTable.TableName)
    on error undo, throw:
    
    iTableNameLength = length(bttTable.TableName).
    
    if   iLongestTableNameLength = 0
      or iTableNameLength > iLongestTableNameLength then
      assign
        iLongestTableNameLength = iTableNameLength
        cDatabaseName           = bttTable.DatabaseName
        cTableName              = bttTable.TableName
        .

  end. /* for each bttTable */
  
  if    ttDatabase.TempDB
    and pcTableName begins 'tt':U then
  do:
    
    for each bttTable
      where bttTable.DatabaseName = ttDatabase.DatabaseName
        and pcTableName     matches substitute('*td&1*':U, substring(pcTableName, 3))
      on error undo, throw:
      
      iTableNameLength = length(bttTable.TableName).
      
      if   iLongestTableNameLength = 0
        or iTableNameLength > iLongestTableNameLength then
        assign
          iLongestTableNameLength = iTableNameLength
          cDatabaseName           = bttTable.DatabaseName
          cTableName              = bttTable.TableName
          .
  
    end. /* for each bttTable */
    
  end. /* if ttDatabase.TempDB */
  
end. /* if    cTableName = '':U */

/* Fourth priority: shortest wildcard table match in any database. */

if cTableName = '':U then
do:
  
  for each bttDatabase
    on error undo, throw:
    
    for each bttTable
      where bttTable.DatabaseName = bttDatabase.DatabaseName
        and pcTableName     matches substitute('*&1*':U, bttTable.TableName)
      on error undo, throw:
      
      iTableNameLength = length(bttTable.TableName).
      
      if   iLongestTableNameLength = 0
        or iTableNameLength > iLongestTableNameLength then
        assign
          iLongestTableNameLength = iTableNameLength
          cDatabaseName           = bttTable.DatabaseName
          cTableName              = bttTable.TableName
          .
  
    end. /* for each bttTable */
    
    if    ttDatabase.TempDB
      and pcTableName begins 'tt':U then
    do:
      
      for each bttTable
        where bttTable.DatabaseName = bttDatabase.DatabaseName
          and pcTableName     matches substitute('*td&1*':U, substring(pcTableName, 3))
        on error undo, throw:
        
        iTableNameLength = length(bttTable.TableName).
        
        if   iLongestTableNameLength = 0
          or iTableNameLength > iLongestTableNameLength then
          assign
            iLongestTableNameLength = iTableNameLength
            cDatabaseName           = bttTable.DatabaseName
            cTableName              = bttTable.TableName
            .
    
      end. /* for each bttTable */
      
    end. /* if    ttDatabase.TempDB */
    
  end. /*for each bttDatabase  */
  
end. /* if cTableName = '':U */

/* Select table (if necessary). */

if    cDatabaseName > '':U
  and cTableName    > '':U then
do:
  
  if   not available ttDatabase
    or ttDatabase.DatabaseName <> cDatabaseName then
  do:
    
    find bttDatabase
      where bttDatabase.DatabaseName = cDatabaseName
      no-error.
    
    if not available bttDatabase then
    leave.
    
    reposition brDatabase to rowid rowid(bttDatabase).
    apply 'value-changed':U to brDatabase in frame {&FRAME-NAME}.
    
  end. /* if   not available ttDatabase ... */
  
  if input frame {&FRAME-NAME} gcTableFilter <> cTableName then
  do:
    
    gcTableFilter = (if    ttDatabase.TempDB
                       and cTableName begins 'TD_':U
                       and pcTableName matches substitute('*TT_&1*':U, substring(pcTableName, 4)) then
                       substitute('TT_&1':U, substring(pcTableName, 4))
                     else
                       cTableName).
    
    do i = 1 to num-entries({&K_AUTOFILTER_OMIT_TABLE_SUFFIX}):
      
      cSuffix = entry(i, {&K_AUTOFILTER_OMIT_TABLE_SUFFIX}).
      
      if cTableName matches substitute('*&1':U, cSuffix) then
      do:
        
        gcTableFilter = substring(cTableName, 1, length(cTableName) - length(cSuffix)).
        leave.
        
      end. /* if cTableName matches substitute('*&1':U, cSuffix) */
      
    end. /* do i = 1 to num-entries({&K_AUTOFILTER_OMIT_TABLE_SUFFIX}) */
    
    gcTableFilter:screen-value in frame {&FRAME-NAME} = gcTableFilter.
    apply 'value-changed':U to gcTableFilter in frame {&FRAME-NAME}.
    run qg_AddFieldHistoryEntry(gcTableFilter:handle in frame {&FRAME-NAME}).
    
  end. /* if input frame {&FRAME-NAME} gcTableFilter <> quoter(cTableName) */
  
  if   not available ttTable
    or ttTable.TableName <> cTableName then
  do:
    
    find bttTable
      where bttTable.DatabaseName = cDatabaseName
        and bttTable.TableName    = cTableName
      no-error.
    
    if available bttTable then
    do:
      
      reposition brTable to rowid rowid(bttTable) no-error.
      apply 'value-changed':U to brTable in frame {&FRAME-NAME}.
      
    end. /* if available bttTable */
    
  end. /* if   not available ttTable ... */
  
  if plSetBuffer then
  do:
    
    /* Limit Buffer to parts that contain valid buffername characters. */
    
    assign
      iTablenameStart  = index((if    ttDatabase.TempDB
                                  and cTableName begins 'td':U
                                  and pcTableName begins 'tt':U then
                                  substitute('td&1':U, substring(pcTableName, 3))
                                else
                                  pcTableName),
                               ttTable.TableName)
      iBuffernameStart = iTablenameStart
      iBuffernameEnd   = iTablenameStart + length(ttTable.TableName)
      .
    
    do i = iBuffernameStart to 1 by -1:
      
      if   i = 1
        or index('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&-_':U,
                 substring(pcTableName, i -  1, 1)) = 0 then
      do:
        
        iBuffernameStart = i.
        leave.
        
      end. /* if index('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&-_':U, */
      
    end. /* do i = iTablenameStart to 1 by -1 */
    
    do i = iBuffernameEnd to length(pcTableName) + 1:
      
      if index('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&-_':U,
               substring(pcTableName, i, 1)) = 0 then
      do:
        
        iBuffernameEnd = i.
        leave.
        
      end. /* if index('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$%&-_':U, */
      
    end. /* do i = iTablenameStart to 1 by -1 */
    
    gcBufferName:screen-value in frame {&FRAME-NAME} = (if iBuffernameEnd > iBuffernameStart then
                                                          substring(pcTableName,
                                                                    iBuffernameStart,
                                                                    iBuffernameEnd - iBuffernameStart)
                                                        else
                                                          ttTable.TableName).
    
    apply 'value-changed':U to gcBufferName.
    
  end. /* if plSetBuffer */
  
end. /* if    cDatabaseName > '':U */

end procedure. /* qg_SelectTable */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerAddLogEntry hQueryWindow 
PROCEDURE qg_SessionTriggerAddLogEntry :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add session trigger log entry with given information.                      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTitle                        = Title for session trigger event.          */
/* pcText                         = Text for session trigger event.           */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcTitle as character no-undo.
define input parameter pcText  as character no-undo.
define input parameter pcLogfileName as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

output stream strSeTrigger to value(pcLogfileName) append.

put stream strSeTrigger unformatted
  substitute('~n~n*&1*~n* &2 &3*~n*&1*~n~n&4~n':U,
             fill('-':U, 78),
             pcTitle,
             fill(' ':U, 80 - length(pcTitle) - 4),
             pctext).

finally:
  
  output stream strSeTrigger close.
  
end finally.

end procedure. /* qg_SessionTriggerAddLogEntry */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerActions hQueryWindow 
PROCEDURE qg_SessionTriggerActions :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Perform session trigger actions                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId as integer   no-undo.
define input parameter phBuffer    as handle    no-undo.
define input parameter pcTitle     as character no-undo.
define input parameter pcText      as character no-undo.
define input parameter piDebugLine as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cLogfileName  as character no-undo.
define variable cSnapshotName as character no-undo.

define variable lDebug        as logical   no-undo.

define variable cMessageTitle as character no-undo
  format 'x(1024)':U
  view-as text
  size 146 by 1
  font 0.

  define variable cMessageText as character no-undo
  view-as editor
  no-word-wrap
  scrollbar-horizontal
  scrollbar-vertical
  size 146 by 19.5
  font 0.

define variable lDisableMsg as logical   no-undo
  label 'Disable Messages for this Session-Trigger':U 
  view-as toggle-box
  size 50 by 1.

define button btnShowRecord
  label 'Show Record':T
  size 20 by 1.

define button btnCopyMessage
  label 'Copy Message':T
  size 20 by 1.

define button btnOk
  label 'Ok':T
  size 20 by 1.14
  auto-go.

define button btnDebug
  label 'Debug':T
  size 20 by 1.14.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  leave.

assign
  giSessionTriggerInstSeq = giSessionTriggerInstSeq + 1
  pcTitle                 = replace(pcTitle,
                                    '%TriggerInstSeq%':U,
                                    string(giSessionTriggerInstSeq, '9999999999':U)).
  pcText                  = replace(pcText,
                                    '%TriggerInstSeq%':U,
                                    string(giSessionTriggerInstSeq, '9999999999':U)).
  .

/* Add snapshots. */

if bttSessionTrigger.AddSnapshot then
do:
  
  cSnapshotName = replace(bttSessionTrigger.SnapshotName,
                          '@':U,
                          string(giSessionTriggerInstSeq, '9999999999':U)).
  
  case bttSessionTrigger.SnapshotScope:
    
    when {&K_SNAPSHOT_SCOPE_RECORD} then
      run qg_AddSnapshotLine(phBuffer, cSnapshotName, yes).
    
    when {&K_SNAPSHOT_SCOPE_ALL} then
      run qg_AddSnapshot(phBuffer, cSnapshotName, ?).
    
  end case. /* bttSessionTrigger.SnpshotScope */
  
end. /* if bttSessionTrigger.AddSnapshot */

/* Show message. */

if    glSessionTriggerShowMessage
  and bttSessionTrigger.ShowMessage then
SESSION-TRIGGER-MESSAGE:
do on error  undo SESSION-TRIGGER-MESSAGE, leave SESSION-TRIGGER-MESSAGE
   on endkey undo SESSION-TRIGGER-MESSAGE, leave SESSION-TRIGGER-MESSAGE:
  
  define frame fMessage
    cMessageTitle at row 1.5 col 3 no-labels
    btnShowRecord at row 1.5 column 109
    btnCopyMessage at row 1.5 column 129
    cMessageText at row 3 col 3 no-labels
    lDisableMsg at row 23 col 3
    btnOk at row 24.5 col 56
    btnDebug at row 24.5 col 76
    with 1 down keep-tab-order overlay
      view-as dialog-box 
      side-labels no-underline three-d 
      size 151 by 26.33
      title gcTitlePrefix + 'Session-Trigger':U
      default-button btnOk.
  
  on window-close of frame fMessage
    apply 'end-error' to self.
  
  on ctrl-c of frame fMessage anywhere
  do:
    
    if    valid-handle( focus )
      and focus:name = 'cMessageText':U then
      focus:edit-copy().
    
    else
      apply 'choose':U to btnCopyMessage in frame fMessage.
    
  end. /* on ctrl-c of frame fMessage anywhere */
  
  on choose of btnCopyMessage in frame fMessage
    clipboard:value = substitute( '&1~n&2~n&1~n&3~n':U,
                                  fill( '-':U, 25 ),
                                  pcTitle,
                                  pcText ).
  
  on choose of btnShowRecord in frame fMessage
  do:
    
    define variable rDummy as rowid     no-undo.

    run qg_EditRecord( phBuffer,
                       {&K_EDITACTION_EDIT},
                       no,
                       frame fMessage:window,
                       ?,
                       output rDummy ).
    
  end. /* on choose of btnShowRecord in frame fMessage */
  
  on choose of btnDebug in frame fMessage
  do:
    
    debugger:initiate().
    debugger:set-break( bttSessionTrigger.TriggerFileName, piDebugLine + 1 ).
    
    apply 'go':U to frame fMessage.
    
  end. /* on choose of btnDebug in frame fMessage */
  
  assign
    cMessageText = pcText
    cMessageText:read-only in frame fMessage = yes
    cMessageTitle = pcTitle
    cMessageTitle:read-only in frame fMessage = yes
    .
  
  update unless-hidden
    btnOk
    btnDebug
    btnShowRecord
    btnCopyMessage
    cMessageTitle
    cMessageText
    lDisableMsg
    with frame fMessage.
  
  if lDisableMsg then
  do:
    bttSessionTrigger.ShowMessage = no.
    validate bttSessionTrigger.
  end. /* if lDisableMsg */
  
end. /* if    glSessionTriggerShowMessage ... */

/* Add log entry. */

if    glSessionTriggerWriteLog
  and bttSessionTrigger.WriteLogfile then
do:
  
  assign
    cLogfileName = (if    bttSessionTrigger.LogfileName > '':U
                      and bttSessionTrigger.LogfileName <> '<default>':U then
                      bttSessionTrigger.LogfileName
                    else
                      gcSessionTriggerLogFileName)
    cLogfileName = qg_cFileName(cLogfileName)
    .
  
  run qg_SessionTriggerAddLogEntry(pcTitle, pcText, cLogfileName).
  
end. /* if    glSessionTriggerWriteLog ... */

end procedure. /* qg_SessionTriggerActions */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerAssign hQueryWindow 
PROCEDURE qg_SessionTriggerAssign :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Session trigger procedure for assign event.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piTriggerId                    = Session trigger id.                       */
/* phBuffer                       = Buffer handle.                            */
/* pcOldValue                     = Old value.                                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId      as integer   no-undo.
define input parameter phBuffer         as handle    no-undo.
define input parameter pcOldValue       as character no-undo.
define input parameter pcAdditionalInfo as character no-undo.
define input parameter piDebugLine      as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTitle                as character no-undo.
define variable cText                 as character no-undo.

define variable hField                as handle    no-undo.

define variable cOldValue             as character no-undo.
define variable cNewValue             as character no-undo.
define variable cResolved             as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField          for temp-table ttField.
define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  leave.

find bttField
  where bttField.DatabaseName = bttSessionTrigger.DatabaseName
    and bttField.TableName    = bttSessionTrigger.TableName
    and bttField.FieldName    = bttSessionTrigger.FieldName.

cOldValue = quoter( pcOldValue ).

if    num-entries( pcOldValue, ':':U ) <> 3
   or bttSessionTrigger.FieldName = substitute( '&1_Obj':U, bttSessionTrigger.TableName ) then
  
  cOldValue = quoter( pcOldValue ).

else
  
  assign
    cResolved = qg_cResolveObjectId( bttSessionTrigger.DatabaseName,
                                     bttSessionTrigger.FieldName,
                                     pcOldValue,
                                     yes,
                                     yes )
    cOldValue = ( if    cResolved  > '':U
                    and cResolved <> pcOldValue then
                    substitute( '&1 <resolved: &2>':U,
                                quoter( pcOldValue ),
                                ( if lookup(bttField.DataType, 'CHARACTER,LONGCHAR':U) > 0 then
                                    quoter( cResolved )
                                  else
                                    cResolved ) )
                  else
                    quoter( pcOldValue ) )
    .

hField = phBuffer:buffer-field( bttSessionTrigger.FieldName ) no-error.

if    not error-status:error
  and valid-handle( hField ) then
  
  cNewValue = hField:buffer-value.

else

  if    available bttField
    and bttField.IsVirtual then
    
    cNewValue = string( qg_clVirtualFieldValueAsLongchar( bttField.FieldType,
                                                          bttField.DataType,
                                                          bttField.FieldName,
                                                          qg_cObjectIdForBuffer( phBuffer ),
                                                          ? ) ).

if    num-entries( cNewValue, ':':U ) <> 3
   or bttSessionTrigger.FieldName = substitute( '&1_Obj':U, bttSessionTrigger.TableName ) then
  
  cNewValue = quoter( cNewValue ).

else
  
  assign
    cResolved = qg_cResolveObjectId( bttSessionTrigger.DatabaseName,
                                     bttSessionTrigger.FieldName,
                                     cNewValue,
                                     yes,
                                     yes )
    cNewValue = ( if    cResolved  > '':U
                    and cResolved <> cNewValue then
                    substitute( '&1 <resolved: &2>':U,
                                quoter( cNewValue ),
                                ( if lookup(bttField.DataType, 'CHARACTER,LONGCHAR':U) > 0 then
                                    quoter( cResolved )
                                  else
                                    cResolved ) )
                  else
                    quoter( cNewValue ) )
    .

assign
  cTitle = substitute('&1 &2 - &3.&4 (assign / id %TriggerInstSeq%)':T, ~
                      string(today, '99.99.9999':U), ~
                      string(time, 'HH:MM:SS':U), ~
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName)
  cText  =            'Session-Trigger (assign) for table &1.&2.':T
           + '~n':U
           + '~n':U + 'Value of &1.&2.&3 has changed:':T
           + '~n':U + '-> old value: &4':T
           + '~n':U + '-> new value: &5':T
  cText  =   cText
           + '~n':U
           + '~n':U + 'Primary index of record:':T
           + '~n':U + '&6':U
    when glSessionTriggerIndexValues
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info fields:':T
           + '~n':U + '&7':U
    when bttSessionTrigger.AdditionalInfoFields > '':U
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info:':T
           + '~n':U + '&8':U
    when bttSessionTrigger.AdditionalInfo
  cText  =   cText
           + '~n':U
           + '~n':U + 'Stacktrace:':T
           + '~n':U + '&9':U
    when glSessionTriggerStackTrace
  cText  = substitute(cText,
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName,
                      bttSessionTrigger.FieldName,
                      cOldValue,
                      cNewValue,
                      qg_cIndexFieldValues(phBuffer, ?),
                      qg_cFieldValues(phBuffer,
                                      ?,
                                      bttSessionTrigger.AdditionalInfoFields),
                      pcAdditionalInfo,
                      qg_cStacktrace())
  .

run qg_SessionTriggerActions(bttSessionTrigger.Id,
                             phBuffer,
                             cTitle,
                             cText,
                             piDebugLine).

end procedure. /* qg_SessionTriggerAssign */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerCreate hQueryWindow 
PROCEDURE qg_SessionTriggerCreate :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Session trigger procedure for create event.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piTriggerId                    = Session trigger id.                       */
/* phBuffer                       = Buffer handle.                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId      as integer   no-undo.
define input parameter phBuffer         as handle    no-undo. /* code checked by mth 30.07.2015 */
define input parameter pcAdditionalInfo as character no-undo.
define input parameter piDebugLine      as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTitle as character no-undo.
define variable cText  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  leave.

assign
  cTitle = substitute('&1 &2 - &3.&4 (create / id %TriggerInstSeq%)':T,
                      string(today, '99.99.9999':U),
                      string(time, 'HH:MM:SS':U),
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName)
  cText  = 'Session-Trigger (create) for table &1.&2.':T
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info fields:':T
           + '~n':U + '&3':U
    when bttSessionTrigger.AdditionalInfoFields > '':U
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info:':T
           + '~n':U + '&4':U
    when bttSessionTrigger.AdditionalInfo
  cText  =   cText
           + '~n':U
           + '~n':U + 'Stacktrace:':T
           + '~n':U + '&5':U
    when glSessionTriggerStackTrace
  cText  = substitute(cText,
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName,
                      qg_cFieldValues(phBuffer,
                                      ?,
                                      bttSessionTrigger.AdditionalInfoFields),
                      pcAdditionalInfo,
                      qg_cStacktrace())
  .

run qg_SessionTriggerActions(bttSessionTrigger.Id,
                             phBuffer,
                             cTitle,
                             cText,
                             piDebugLine).

end procedure. /* qg_SessionTriggerCreate */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerDelete hQueryWindow 
PROCEDURE qg_SessionTriggerDelete :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Session trigger procedure for delete event.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piTriggerId                    = Session trigger id.                       */
/* phBuffer                       = Buffer handle.                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId      as integer   no-undo.
define input parameter phBuffer         as handle    no-undo. /* code checked by mth 30.07.2015 */
define input parameter pcAdditionalInfo as character no-undo.
define input parameter piDebugLine      as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTitle as character no-undo.
define variable cText  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  leave.

assign
  cTitle = substitute('&1 &2 - &3.&4 (delete / id %TriggerInstSeq%)':T, ~
                      string(today, '99.99.9999':U), ~
                      string(time, 'HH:MM:SS':U), ~
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName)
  cText  = 'Session-Trigger (delete) for table &1.&2.':T
  cText  =   cText
           + '~n':U
           + '~n':U + 'Primary index of record:':T
           + '~n':U + '&3':U
    when glSessionTriggerIndexValues
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info fields:':T
           + '~n':U + '&4':U
    when bttSessionTrigger.AdditionalInfoFields > '':U
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info:':T
           + '~n':U + '&5':U
    when bttSessionTrigger.AdditionalInfo
  cText  =   cText
           + '~n':U
           + '~n':U + 'Stacktrace:':T
           + '~n':U + '&6':U
    when glSessionTriggerStackTrace
  cText  = substitute(cText,
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName,
                      qg_cIndexFieldValues(phBuffer, ?),
                      qg_cFieldValues(phBuffer,
                                      ?,
                                      bttSessionTrigger.AdditionalInfoFields),
                      pcAdditionalInfo,
                      qg_cStacktrace())
  .

run qg_SessionTriggerActions(bttSessionTrigger.Id,
                             phBuffer,
                             cTitle,
                             cText,
                             piDebugLine).

end procedure. /* qg_SessionTriggerDelete */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersActivate hQueryWindow 
PROCEDURE qg_SessionTriggersActivate :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plTriggerActive as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersWindow) then
  leave.

hBuffer = ghSessionTriggersBrowse:query:get-buffer-handle(1).

if hBuffer:available then
do:
  
  if plTriggerActive = ? then
    plTriggerActive = not hBuffer::TriggerActive.
  
  if    plTriggerActive
    and not valid-handle(handle(hBuffer::ProcedureHandle)) then
    assign
      hBuffer::ProcedureHandle = qg_hStartSessionTrigger(hBuffer::Id)
      hBuffer::TriggerActive   = valid-handle(handle(hBuffer::ProcedureHandle))
      .
    
  else
    if    not plTriggerActive
      and valid-handle(handle(hBuffer::ProcedureHandle)) then
    do:
      
      delete object hBuffer::ProcedureHandle.
      hBuffer::TriggerActive = no.
      
    end. /* else: if plTriggerActive */
  
  if ghSessionTriggersBrowse:query:num-results > 0 then
    ghSessionTriggersBrowse:refresh().
  
end. /* if hBuffer:available */

end procedure. /* qg_SessionTriggersActivate */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersActivateAll hQueryWindow 
PROCEDURE qg_SessionTriggersActivateAll :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plTriggerActive as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if   not valid-handle(ghSessionTriggersWindow)
  or plTriggerActive = ? then
  leave.

for each bttSessionTrigger
  on error undo, throw:
  
  if    plTriggerActive
    and not valid-handle(bttSessionTrigger.ProcedureHandle) then
    assign
      bttSessionTrigger.ProcedureHandle = qg_hStartSessionTrigger(bttSessionTrigger.Id)
      bttSessionTrigger.TriggerActive   = valid-handle(bttSessionTrigger.ProcedureHandle)
      .
    
  else
    if    not plTriggerActive
      and valid-handle(bttSessionTrigger.ProcedureHandle) then
    do:
      
      delete object bttSessionTrigger.ProcedureHandle.
      bttSessionTrigger.TriggerActive = no.
      
    end. /* else: if plTriggerActive */
  
end. /* for each bttSessionTrigger */

if ghSessionTriggersBrowse:query:num-results > 0 then
  ghSessionTriggersBrowse:refresh().

end procedure. /* qg_SessionTriggersActivateAll */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersBrowsePopupMenuDrop hQueryWindow 
PROCEDURE qg_SessionTriggersBrowsePopupMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* See also qg_SessionTriggersEditMenuDrop.                                   */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer                           as handle    no-undo.

define variable hMenu                             as handle    no-undo.

define variable hTriggerPropertiesMenuItem        as handle    no-undo.
define variable hActivateMenuItem                 as handle    no-undo.
define variable hActivateAllMenuItem              as handle    no-undo.
define variable hDeactivateAllMenuItem            as handle    no-undo.
define variable hRemoveSessionTriggerMenuItem     as handle    no-undo.
define variable hRemoveAllSessionTriggersMenuItem as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersBrowse) then
  leave.

assign
  hBuffer = ghSessionTriggersBrowse:query:get-buffer-handle(1)
  hMenu   = ghSessionTriggersBrowse:popup-menu
  hTriggerPropertiesMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_TriggerProperties':U)
  hActivateMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_Activate':U)
  hActivateAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_ActivateAll':U)
  hDeactivateAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_DeactivateAll':U)
  hRemoveSessionTriggerMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_RemoveSessionTrigger':U)
  hRemoveAllSessionTriggersMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_RemoveAllSessionTriggers':U)
  hTriggerPropertiesMenuItem:sensitive
      = hBuffer:available
  hActivateMenuItem:sensitive
      = hBuffer:available
  hActivateMenuItem:label
      = (if    hBuffer:available
           and valid-handle(handle(hBuffer::ProcedureHandle)) then
           'Deactivate':T
         else
           'Activate':T)
  hActivateAllMenuItem:sensitive
      = hBuffer:available
  hDeactivateAllMenuItem:sensitive
      = hBuffer:available
  hRemoveSessionTriggerMenuItem:sensitive
      = hBuffer:available
  hRemoveAllSessionTriggersMenuItem:sensitive
      = hBuffer:available
  .

end procedure. /* qg_SessionTriggersBrowsePopupMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersChooseLogFileChoose hQueryWindow 
PROCEDURE qg_SessionTriggersChooseLogFileChoose :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show file open dialog for session trigger log file.                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTempDir  as character no-undo.
define variable cFileName as character no-undo.
define variable lOk       as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cFileName = qg_cFileName(gcSessionTriggerLogFileName).

system-dialog get-file cFileName
  title             'Choose log file':U
  filters           'Log files (*.log)':U '*.log':U
  default-extension '.log':U
  ask-overwrite
  save-as
  use-filename
  update lOk
  in window ghSessionTriggersWindow
  .

if lOk then
do:
  
  assign
    cTempDir                                 = trim(session:temp-dir, '/\':U)
    ghSessionTriggerLogFileName:screen-value = replace(cFileName, cTempDir, '%Temp%':U)
    .
  
  apply 'value-changed':U to ghSessionTriggerLogFileName.
  
end. /* if lOk */

end procedure. /* qg_SessionTriggersChooseLogFileChoose */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersDeleteLogFile hQueryWindow 
PROCEDURE qg_SessionTriggersDeleteLogFile :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Delete session trigger log file.                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/


/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_DeleteFile(gcSessionTriggerLogFileName).

end procedure. /* qg_SessionTriggersDeleteLogFile */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersEditMenuDrop hQueryWindow 
PROCEDURE qg_SessionTriggersEditMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window close event of query window list window.      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* See also qg_SessionTriggersBrowsePopupMenuDrop.                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer                           as handle    no-undo.

define variable hMenu                       as handle    no-undo.

define variable hTriggerPropertiesMenuItem        as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersWindow) then
  leave.

assign
  hBuffer = ghSessionTriggersBrowse:query:get-buffer-handle(1)
  hMenu   = ghSessionTriggersWindow:menubar
  hTriggerPropertiesMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_TriggerProperties':U)
  hTriggerPropertiesMenuItem:sensitive
      = hBuffer:available
  .

end procedure. /* qg_SessionTriggersEditMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersEditTriggerSettings hQueryWindow 
PROCEDURE qg_SessionTriggersEditTriggerSettings :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

define variable lShowMessage as logical   no-undo
  label 'Show message':T
  view-as toggle-box
    tooltip 'Show message on trigger event.':T
  size 30 by 1.

define variable lWriteLogfile as logical   no-undo
  label 'Write logfile':T
  view-as toggle-box
    tooltip 'Add logfile entry on trigger event.':T
  size 30 by 1.

define variable cLogfileName as character no-undo
  label 'Filename':T
  format 'x(1024)':U
  view-as fill-in
    tooltip 'Use given log file for this session trigger ("<default>" will use the globally defined session trigger logifle)':T
  size 59 by 1
  .

define button btnChooseLogfile
  label '...':T
  tooltip 'Choose log file':T
  size 7 by 1.

define button btnOpenLogfile
  label 'Open':T
  tooltip 'Open log file with default application':T
  size 10 by 1.

define button btnDeleteLogfile
  label 'Delete':T
  tooltip 'Delete log file':T
  size 10 by 1.

define variable lAddSnapshot as logical   no-undo
  label 'Add snapshot':T
  view-as toggle-box
  tooltip 'Add snapshot on trigger event.':T
  size 30 by 1.

define variable cSnapshotName as character no-undo
  label 'Snapshot name':T
  format 'x(32)':U
  view-as fill-in
  tooltip 'Use this as snapshot name ("@" will be replaced with trigger invocation id / "#" will be replaced with unique timestamp).':T
  size 41 by 1
  .

define variable cSnapshotScope as character no-undo
  label 'Snapshot scope':T
  format 'x(3)':U
  view-as radio-set horizontal
    radio-buttons
      'Current record':T, 'rec':U,
      'Entire table':T, 'all':U
  tooltip 'Select snapshot scope.':T
  size 35 by 1
  .

define variable cAdditionalFields as character no-undo
  label 'Additional fields':T
  format 'x(30000)':U
  view-as fill-in
    tooltip 'Show value of given fiels on trigger event.':T
  size 80 by 1
  .

define button btnSelectFields
  label '...':T
  size 7 by 1.

define variable lAdditionalInfo as logical   no-undo
  label 'Show additional info':T
  view-as toggle-box
    tooltip 'Show additional info on trigger event.':T
  size 30 by 1.

define variable cAdditionalInfo as character
  label 'Additional info':T
  view-as editor
    no-word-wrap
    tooltip 'Must be a single Progress ABL expression that will result in a string value.':T
  size 87 by 5 no-undo.

define variable lCondition as logical   no-undo
  label 'Only show on condition':T
  view-as toggle-box
    tooltip 'Only show trigger event on given condition':T
  size 30 by 1.

define variable cCondition as character
  label 'Condition':T
  view-as editor
    no-word-wrap
    tooltip 'Must be a single Progress ABL expression that will result in a logical value.':T
  size 87 by 5 no-undo.

define variable lCustomCode as logical   no-undo
  label 'Run custom code':T
  view-as toggle-box
    tooltip 'Run arbitary code on trigger event':T
  size 30 by 1.

define variable cCustomCode as character
  label 'Custom code':T
  view-as editor
    no-word-wrap
    tooltip 'Must be one or more valid Progress ABL statements.':T
  size 87 by 5 no-undo.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersWindow) then
  leave.

define frame fSessionTriggerProperties
  lShowMessage at row 1.5 col 18 colon-aligned
  lWriteLogfile at row 2.5 col 18 colon-aligned
  cLogfileName at row 4 col 18 colon-aligned
  btnChooseLogfile at row 4 col 77 colon-aligned
  btnOpenLogfile at row 4 col 85 colon-aligned
  btnDeleteLogfile at row 4 col 95 colon-aligned
  lAddSnapshot at row 5.5 col 18 colon-aligned
  cSnapshotName at row 7 col 18 colon-aligned
  cSnapshotScope at row 7 col 64 colon-aligned no-label
  cAdditionalFields at row 9 col 18 colon-aligned no-tab-stop
  btnSelectFields at row 9 col 98 colon-aligned
  lAdditionalInfo at row 11 col 18 colon-aligned
  cAdditionalInfo at row 12.5 col 18 colon-aligned
  lCondition at row 18 col 18 colon-aligned
  cCondition at row 19.5 col 18 colon-aligned
  lCustomCode at row 25 col 18 colon-aligned
  cCustomCode at row 26.5 col 18 colon-aligned
  btnOk at row 32 col 35
  btnCancel at row 32 col 55
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    title gcTitlePrefix + 'Session trigger preferences':U
    side-labels no-underline three-d 
    size 109 by 33.94
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSessionTriggerProperties
  apply 'end-error' to self.

on choose of btnSelectFields in frame fSessionTriggerProperties
do:
  
  define variable cFieldList as character no-undo.
  define variable lOk        as logical   no-undo.
  
  define buffer bttField for temp-table ttField.
  define buffer bttIndex for temp-table ttIndex.
  
  find first bttIndex
    where bttIndex.DatabaseName = hBuffer::DatabaseName
      and bttIndex.TableName    = hBuffer::TableName
      and bttIndex.IsPrimary    = yes
    no-error.
  
  for each bttField
    where bttField.DatabaseName = hBuffer::DatabaseName
      and bttField.TableName    = hBuffer::TableName
    on error undo, throw:
    
    if    available bttIndex
      and can-find(first ttIndexField
                     where ttIndexField.DatabaseName = bttIndex.DatabaseName
                       and ttIndexField.TableName    = bttIndex.TableName
                       and ttIndexField.IndexName    = bttIndex.IndexName
                       and ttIndexField.FieldName    = bttField.FieldName) then
      next.
    
    cFieldList = substitute('&1,&2':U, cFieldList, bttField.FieldName).
    
  end. /* for each bttField */
  
  cFieldList = trim(cFieldList, ',':U).
  
  run qg_SelectionDialog(cFieldList,
                         cFieldList,
                         input-output cAdditionalFields,
                         'Select additional infor fields':U,
                         ghSessionTriggersWindow,
                         yes,
                         output lOk).
  
  if lOk then
    display unless-hidden
      cAdditionalFields
      with frame fSessionTriggerProperties.
  
end. /* on choose of btnSelectFields in frame fSessionTriggerProperties */

on value-changed of lWriteLogfile in frame fSessionTriggerProperties
  assign
    cLogfileName:read-only in frame fSessionTriggerProperties     = not input frame fSessionTriggerProperties lWriteLogfile
    btnChooseLogfile:sensitive in frame fSessionTriggerProperties = input frame fSessionTriggerProperties lWriteLogfile
    btnOpenLogfile:sensitive in frame fSessionTriggerProperties   = input frame fSessionTriggerProperties lWriteLogfile
    btnDeleteLogfile:sensitive in frame fSessionTriggerProperties = input frame fSessionTriggerProperties lWriteLogfile
    .

on choose of btnChooseLogfile in frame fSessionTriggerProperties
do:
  
  define variable cTempDir  as character no-undo.
  define variable cFilename as character no-undo.
  define variable lOk       as logical   no-undo.
  
  cFilename = input frame fSessionTriggerProperties cLogfileName.
  
  if cFilename = '<default>':U then
    cFilename =  gcSessionTriggerLogFileName.
  
  cFilename = qg_cFilename(cFilename).
  
  system-dialog get-file cFilename
    title             'Choose log file':U
    filters           'Log files (*.log)':U '*.log':U
    default-extension '.log':U
    ask-overwrite
    save-as
    use-filename
    update lOk
    in window ghSessionTriggersWindow
    .
  
  if lOk then
  do:
    
    assign
      cTempDir  = trim(session:temp-dir, '/\':U)
      cFilename = replace(cFilename, cTempDir, '%Temp%':U)
      .
    
    if cFilename = gcSessionTriggerLogFileName then
      cFilename = '<default>':U.
    
    display unless-hidden
      cFilename
        @ cLogfileName
      with frame fSessionTriggerProperties.
    
  end. /* if lOk */
  
end. /* on choose of btnChooseLogfile */

on choose of btnOpenLogfile in frame fSessionTriggerProperties
  run qg_OpenFile(input frame fSessionTriggerProperties cLogfileName).
  
on choose of btnDeleteLogfile in frame fSessionTriggerProperties
  run qg_DeleteFile(input frame fSessionTriggerProperties cLogfileName).

on value-changed of lAddSnapshot in frame fSessionTriggerProperties
do:
  
  assign
    cSnapshotName:sensitive in frame fSessionTriggerProperties  = input frame fSessionTriggerProperties lAddSnapshot
    cSnapshotScope:sensitive in frame fSessionTriggerProperties = input frame fSessionTriggerProperties lAddSnapshot
    .
  
  if    input frame fSessionTriggerProperties lAddSnapshot
    and input frame fSessionTriggerProperties cSnapshotName = '':U then
    display unless-hidden
      substring(substitute('ST@_&1':U, hBuffer::TableName), 1, 23)
        @ cSnapshotName
      with frame fSessionTriggerProperties.
  
end. /* on value-changed of lAddSnapshot */

on value-changed of lAdditionalInfo in frame fSessionTriggerProperties
  cAdditionalInfo:sensitive in frame fSessionTriggerProperties = input frame fSessionTriggerProperties lAdditionalInfo.

on value-changed of lCondition in frame fSessionTriggerProperties
  cCondition:sensitive in frame fSessionTriggerProperties = input frame fSessionTriggerProperties lCondition.

on value-changed of lCustomCode in frame fSessionTriggerProperties
  cCustomCode:sensitive in frame fSessionTriggerProperties = input frame fSessionTriggerProperties lCustomCode.

hBuffer = ghSessionTriggersBrowse:query:get-buffer-handle(1).

if hBuffer:available then
do:
  
  assign
    lShowMessage      = hBuffer::ShowMessage
    lWriteLogfile     = hBuffer::WriteLogfile
    cLogfileName      = hBuffer::LogfileName
    lAddSnapshot      = hBuffer::AddSnapshot
    cSnapshotName     = hBuffer::SnapshotName
    cSnapshotScope    = hBuffer::SnapshotScope
    cAdditionalFields = hBuffer::AdditionalInfoFields
    lAdditionalInfo   = hBuffer::AdditionalInfo
    cAdditionalInfo   = hBuffer::AdditionalInfoText
    lCondition        = hBuffer::Condition
    cCondition        = hBuffer::ConditionText
    lCustomCode       = hBuffer::CustomCode
    cCustomCode       = hBuffer::CustomCodeText
    cLogfileName:read-only in frame fSessionTriggerProperties          = not lWriteLogfile
    cAdditionalFields:read-only in frame fSessionTriggerProperties     = yes
    cAdditionalInfo:auto-indent in frame fSessionTriggerProperties     = yes
    cAdditionalInfo:large in frame fSessionTriggerProperties           = yes
    cAdditionalInfo:return-inserted in frame fSessionTriggerProperties = yes
    cAdditionalInfo:font in frame fSessionTriggerProperties            = 0
    cCondition:auto-indent in frame fSessionTriggerProperties          = yes
    cCondition:large in frame fSessionTriggerProperties                = yes
    cCondition:return-inserted in frame fSessionTriggerProperties      = yes
    cCondition:font in frame fSessionTriggerProperties                 = 0
    cCustomCode:auto-indent in frame fSessionTriggerProperties         = yes
    cCustomCode:large in frame fSessionTriggerProperties               = yes
    cCustomCode:return-inserted in frame fSessionTriggerProperties     = yes
    cCustomCode:font in frame fSessionTriggerProperties                = 0
    .
  
  display unless-hidden
    cSnapshotName
    cSnapshotScope
    cAdditionalInfo
    cCondition
    cCustomCode
    with frame fSessionTriggerProperties.
  
  update unless-hidden
    lShowMessage
    lWriteLogfile
    cLogfileName
    btnChooseLogfile when lWriteLogfile
    btnOpenLogfile when lWriteLogfile
    btnDeleteLogfile when lWriteLogfile
    cAdditionalFields
    btnSelectFields
    lAddSnapshot
    cSnapshotName when lAddSnapshot
    cSnapshotScope when lAddSnapshot
    lAdditionalInfo
    cAdditionalInfo when lAdditionalInfo
    lCondition
    cCondition when lCondition
    lCustomCode
    cCustomCode when lCustomCode
    btnOk
    btnCancel
    with frame fSessionTriggerProperties
      in window hQueryWindow.
  
  apply 'entry':U to ghSessionTriggersWindow.
  
  assign
    hBuffer::ShowMessage          = input frame fSessionTriggerProperties lShowMessage
    hBuffer::WriteLogfile         = input frame fSessionTriggerProperties lWriteLogfile
    hBuffer::LogfileName          = input frame fSessionTriggerProperties cLogfileName
    hBuffer::AddSnapshot          = input frame fSessionTriggerProperties lAddSnapshot
    hBuffer::SnapshotName         = input frame fSessionTriggerProperties cSnapshotName
    hBuffer::SnapshotScope        = input frame fSessionTriggerProperties cSnapshotScope
    hBuffer::AdditionalInfoFields = input frame fSessionTriggerProperties cAdditionalFields 
    hBuffer::AdditionalInfo       = input frame fSessionTriggerProperties lAdditionalInfo 
    hBuffer::AdditionalInfoText   = input frame fSessionTriggerProperties cAdditionalInfo 
    hBuffer::Condition            = input frame fSessionTriggerProperties lCondition 
    hBuffer::ConditionText        = input frame fSessionTriggerProperties cCondition 
    hBuffer::CustomCode           = input frame fSessionTriggerProperties lCustomCode 
    hBuffer::CustomCodeText       = input frame fSessionTriggerProperties cCustomCode
    . 
  
  if not hBuffer::TriggerActive then
    run qg_WriteSessionTriggerProc(hBuffer::Id).
  
  else
  do:
    
    if valid-handle(handle(hBuffer::ProcedureHandle)) then
      delete object hBuffer::ProcedureHandle.
    
    assign
      hBuffer::ProcedureHandle = qg_hStartSessionTrigger(hBuffer::Id)
      hBuffer::TriggerActive   = valid-handle(handle(hBuffer::ProcedureHandle))
      .
    
  end. /* else: if not hBuffer::TriggerActive */

  if ghSessionTriggersBrowse:query:num-results > 0 then
    ghSessionTriggersBrowse:refresh().
  
end. /* if hBuffer:available */

end procedure. /* qg_SessionTriggersEditTriggerSettings */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerFind hQueryWindow 
PROCEDURE qg_SessionTriggerFind :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Session trigger procedure for delete event.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piTriggerId                    = Session trigger id.                       */
/* phBuffer                       = Buffer handle.                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId      as integer   no-undo.
define input parameter phBuffer         as handle    no-undo. /* code checked by mth 30.07.2015 */
define input parameter pcAdditionalInfo as character no-undo.
define input parameter piDebugLine      as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTitle as character no-undo.
define variable cText  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  leave.

assign
  cTitle = substitute('&1 &2 - &3.&4 (find / id %TriggerInstSeq%)':T, ~
                      string(today, '99.99.9999':U), ~
                      string(time, 'HH:MM:SS':U), ~
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName)
  cText  = 'Session-Trigger (find) for table &1.&2.':T
  cText  =   cText
           + '~n':U
           + '~n':U + 'Primary index of record:':T
           + '~n':U + '&3':U
    when glSessionTriggerIndexValues
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info fields:':T
           + '~n':U + '&4':U
    when bttSessionTrigger.AdditionalInfoFields > '':U
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info:':T
           + '~n':U + '&5':U
    when bttSessionTrigger.AdditionalInfo
  cText  =   cText
           + '~n':U
           + '~n':U + 'Stacktrace:':T
           + '~n':U + '&6':U
    when glSessionTriggerStackTrace
  cText  = substitute(cText,
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName,
                      qg_cIndexFieldValues(phBuffer, ?),
                      qg_cFieldValues(phBuffer,
                                      ?,
                                      bttSessionTrigger.AdditionalInfoFields),
                      pcAdditionalInfo,
                      qg_cStacktrace())
  .

run qg_SessionTriggerActions(bttSessionTrigger.Id,
                             phBuffer,
                             cTitle,
                             cText,
                             piDebugLine).

end procedure. /* qg_SessionTriggerFind */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersLogFileNameChanged hQueryWindow 
PROCEDURE qg_SessionTriggersLogFileNameChanged :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for session trigger log file fill-in.                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggerLogFileName) then
  gcSessionTriggerLogFileName = ghSessionTriggerLogFileName:input-value.

end procedure. /* qg_SessionTriggersLogFileNameChanged */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersOpenLogFile hQueryWindow 
PROCEDURE qg_SessionTriggersOpenLogFile :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open session trigger log file with default application.                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/


/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_OpenFile(gcSessionTriggerLogFileName).

end procedure. /* qg_SessionTriggersOpenLogFile */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersOpenQuery hQueryWindow 
PROCEDURE qg_SessionTriggersOpenQuery :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open query for session trigger browse.                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggersWindow) then
  qg_lQueryOpen(ghSessionTriggersBrowse:query,
                'for each ttSessionTrigger use-index TriggerObject':U,
                ghSessionTriggersWindow).

end procedure. /* qg_SessionTriggersOpenQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersRemoveAllSessionTriggers hQueryWindow 
PROCEDURE qg_SessionTriggersRemoveAllSessionTriggers :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove all session triggers.                                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_RemoveAllSessionTriggers.

end procedure. /* qg_SessionTriggersRemoveAllSessionTriggers */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersRemoveSessionTrigger hQueryWindow 
PROCEDURE qg_SessionTriggersRemoveSessionTrigger :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Remove currently selected session trigger.                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersWindow) then
  leave.

hBuffer = ghSessionTriggersBrowse:query:get-buffer-handle(1).

if hBuffer:available then
  run qg_RemoveSessionTrigger(hBuffer::TriggerEvent,
                              hBuffer::DatabaseName,
                              hBuffer::TableName,
                              hBuffer::FieldName).

end procedure. /* qg_SessionTriggersRemoveSessionTrigger */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersShowIndexValuesChanged hQueryWindow 
PROCEDURE qg_SessionTriggersShowIndexValuesChanged :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for value changed event of session trigger show index    */
/* toggle-box.                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggerIndexValues) then
  glSessionTriggerIndexValues = ghSessionTriggerIndexValues:input-value.

end procedure. /* qg_SessionTriggersShowIndexValuesChanged */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersShowMessageChanged hQueryWindow 
PROCEDURE qg_SessionTriggersShowMessageChanged :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for value changed event of session trigger show message  */
/* toggle-box.                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggerShowMessage) then
  glSessionTriggerShowMessage = ghSessionTriggerShowMessage:input-value.

end procedure. /* qg_SessionTriggersShowMessageChanged */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersShowStackTraceChanged hQueryWindow 
PROCEDURE qg_SessionTriggersShowStackTraceChanged :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for value changed event of session trigger show stack    */
/* trace toggle-box.                                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggerStackTrace) then
  glSessionTriggerStackTrace = ghSessionTriggerStackTrace:input-value.

end procedure. /* qg_SessionTriggersShowStackTraceChanged */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersToolsMenuDrop hQueryWindow 
PROCEDURE qg_SessionTriggersToolsMenuDrop :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window close event of session trigger window.        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer                           as handle    no-undo.

define variable hMenu                       as handle    no-undo.

define variable hActivateMenuItem                 as handle    no-undo.
define variable hActivateAllMenuItem              as handle    no-undo.
define variable hDeactivateAllMenuItem            as handle    no-undo.
define variable hRemoveSessionTriggerMenuItem     as handle    no-undo.
define variable hRemoveAllSessionTriggersMenuItem as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersWindow) then
  leave.

assign
  hBuffer = ghSessionTriggersBrowse:query:get-buffer-handle(1)
  hMenu   = ghSessionTriggersWindow:menubar
  hActivateMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_Activate':U)
  hActivateAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_ActivateAll':U)
  hDeactivateAllMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_DeactivateAll':U)
  hRemoveSessionTriggerMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_RemoveSessionTrigger':U)
  hRemoveAllSessionTriggersMenuItem
      = qg_hGetWidgetByName(hMenu,
                            'mi_RemoveAllSessionTriggers':U)
  hActivateMenuItem:sensitive
      = hBuffer:available
  hActivateMenuItem:label
      = (if    hBuffer:available
           and valid-handle(handle(hBuffer::ProcedureHandle)) then
           'Deactivate session trigger':T
         else
           'Activate session trigger':T)
  hActivateAllMenuItem:sensitive
      = hBuffer:available
  hDeactivateAllMenuItem:sensitive
      = hBuffer:available
  hRemoveSessionTriggerMenuItem:sensitive
      = hBuffer:available
  hRemoveAllSessionTriggersMenuItem:sensitive
      = hBuffer:available
  .

end procedure. /* qg_SessionTriggersToolsMenuDrop */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersWindowClose hQueryWindow 
PROCEDURE qg_SessionTriggersWindowClose :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window close event of session trigger window.        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggersWindow) then
  run qg_DeleteWidgetTree(ghSessionTriggersWindow, yes).

end procedure. /* qg_SessionTriggersWindowClose */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersWindowResized hQueryWindow 
PROCEDURE qg_SessionTriggersWindowResized :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for window resized event of session trigger window.      */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hFrame               as handle    no-undo.
define variable hChooseLogFileButton as handle    no-undo.
define variable hOpenLogFileButton   as handle    no-undo.
define variable hDeleteLogFileButton as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(ghSessionTriggersWindow) then
  leave.

assign
  ghSessionTriggersWindow:width     = max(60, ghSessionTriggersWindow:width)
  ghSessionTriggersWindow:height    = max(10, ghSessionTriggersWindow:height)
  hFrame                            = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                          'fSessionTriggers':U)
  hFrame:width                      = ghSessionTriggersWindow:width
  hFrame:virtual-width              = ghSessionTriggersWindow:width
  hFrame:height                     = ghSessionTriggersWindow:height
  hFrame:virtual-height             = ghSessionTriggersWindow:height
  ghSessionTriggerLogFileName:width = hFrame:width - 44
  hChooseLogFileButton              = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                          'btnChooseLogFile':U)
  hChooseLogFileButton:col          =   ghSessionTriggerLogFileName:col
                                      + ghSessionTriggerLogFileName:width
  hOpenLogFileButton                = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                          'btnOpenLogFile':U)
  hOpenLogFileButton:col            =   hChooseLogFileButton:col
                                      + hChooseLogFileButton:width
                                      + 1
  hDeleteLogFileButton              = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                          'btnDeleteLogFile':U)
  hDeleteLogFileButton:col          =   hOpenLogFileButton:col
                                      + hOpenLogFileButton:width
  ghSessionTriggersBrowse:width     = hFrame:width - 4
  ghSessionTriggersBrowse:height    = hFrame:height - 6.5
  .

end procedure. /* qg_SessionTriggersWindowResized */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggersWriteLogChanged hQueryWindow 
PROCEDURE qg_SessionTriggersWriteLogChanged :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Trigger procedure for value changed event of session trigger write log     */
/* toggle-box.                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hChooseLogFileButton as handle    no-undo.
define variable hOpenLogFileButton   as handle    no-undo.
define variable hDeleteLogFileButton as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle(ghSessionTriggerWriteLog) then
  assign
    glSessionTriggerWriteLog              = ghSessionTriggerWriteLog:input-value
    ghSessionTriggerLogFileName:read-only = not glSessionTriggerWriteLog
    hChooseLogFileButton                  = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                                'btnChooseLogFile':U)
    hChooseLogFileButton:sensitive        = glSessionTriggerWriteLog /* code checked by mth 30.07.2015 */
    hOpenLogFileButton                    = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                                'btnOpenLogFile':U)
    hOpenLogFileButton:sensitive          = glSessionTriggerWriteLog /* code checked by mth 30.07.2015 */
    hDeleteLogFileButton                  = qg_hGetWidgetByName(ghSessionTriggersWindow,
                                                                'btnDeleteLogFile':U)
    hDeleteLogFileButton:sensitive        = glSessionTriggerWriteLog /* code checked by mth 30.07.2015 */
    .
  
end procedure. /* qg_SessionTriggersWriteLogChanged */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SessionTriggerWrite hQueryWindow 
PROCEDURE qg_SessionTriggerWrite :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Session trigger procedure for write event.                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piTriggerId                    = Session trigger id.                       */
/* phBuffer                       = Buffer handle.                            */
/* phOldBuffer                    = Old buffer handle.                        */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId      as integer   no-undo.
define input parameter phBuffer         as handle    no-undo.
define input parameter phOldBuffer      as handle    no-undo.
define input parameter pcAdditionalInfo as character no-undo.
define input parameter piDebugLine      as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTitle     as character no-undo.
define variable cText      as character no-undo.

define variable cFieldList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  leave.

cFieldList = qg_cBufferCompare(phBuffer, phOldBuffer).

assign
  cTitle = substitute('&1 &2 - &3.&4 (write / id %TriggerInstSeq%)':T, ~
                      string(today, '99.99.9999':U), ~
                      string(time, 'HH:MM:SS':U), ~
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName)
  cText  =            'Session-Trigger (write) for table &1.&2.':T
           + '~n':U
           + '~n':U + 'Changed fields:':T
           + '~n':U + '&3':U
  cText  =   cText
           + '~n':U
           + '~n':U + 'Primary index of record:':T
           + '~n':U + '&4':U
    when glSessionTriggerIndexValues
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info fields:':T
           + '~n':U + '&5':U
    when bttSessionTrigger.AdditionalInfoFields > '':U
  cText  =   cText
           + '~n':U
           + '~n':U + 'Additional info:':T
           + '~n':U + '&6':U
    when bttSessionTrigger.AdditionalInfo
  cText  =   cText
           + '~n':U
           + '~n':U + 'Stacktrace:':T
           + '~n':U + '&7':U
    when glSessionTriggerStackTrace
  cText  = substitute(cText,
                      bttSessionTrigger.DatabaseName,
                      bttSessionTrigger.TableName,
                      qg_cFieldValues(phBuffer, phOldBuffer, cFieldList),
                      qg_cIndexFieldValues(phBuffer, ?),
                      qg_cFieldValues(phBuffer,
                                      ?,
                                      bttSessionTrigger.AdditionalInfoFields),
                      pcAdditionalInfo,
                      qg_cStacktrace())
  .

run qg_SessionTriggerActions(bttSessionTrigger.Id,
                             phBuffer,
                             cTitle,
                             cText,
                             piDebugLine).

end procedure. /* qg_SessionTriggerWrite */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetBlockPattern hQueryWindow 
PROCEDURE qg_SetBlockPattern :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set block pattern und update input field.                                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcBlockPattern as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

gcBlockPattern = pcBlockPattern.

run qg_UpdateBlockName.

apply 'entry':U to gcBlockName in frame {&FRAME-NAME}.

end procedure. /* qg_SetBlockPattern */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetBrowseColumns hQueryWindow 
PROCEDURE qg_SetBrowseColumns :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set browse column visible state and order.                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = Browse whose colums should be set.        */
/* pcColumnList                   = List of visible colums.                   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBrowse     as handle    no-undo.
define input parameter pcColumnList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lHidden      as logical   no-undo.

define variable i            as integer   no-undo.
define variable j            as integer   no-undo.
define variable iColumnIndex as integer   no-undo.
define variable hColumn      as handle    no-undo.

define variable lBufferName  as logical   no-undo.
define variable cColumnName  as character no-undo.
define variable dColumnWidth as decimal   no-undo.
define variable cColumnList  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Hide Browse to increase speed. */

assign
  lHidden         = phBrowse:hidden
  phBrowse:hidden = yes
  .

/* Change column order. */

do i = num-entries(pcColumnList) to 1 by -1:
  
  assign
    iColumnIndex = 0
    cColumnName  = entry(i, pcColumnList)
    dColumnWidth = ?
    .
  
  if num-entries(cColumnName, ':':U) > 1 then
  do:
    
    dColumnWidth = decimal(replace(entry(2, cColumnName, ':':U),
                                   '.':U,
                                   session:numeric-decimal-point)) no-error.
    cColumnName  = entry(1, cColumnName, ':':U).
    
  end. /* if num-entries(cColumnName, ':':U) > 1 */
  
  if num-entries(cColumnName, '.':U) > 1 then
    lBufferName = yes.
  
  /* Find column. */
  do j = 1 to phBrowse:num-columns:
    
    if qg_cColumnFieldName(phBrowse:get-browse-column(j),
                           lBufferName) = cColumnName then
    do:
      iColumnIndex = j.
      leave.
    end. /* if qg_cColumnFieldName(phBrowse:get-browse-column(j), */
    
  end. /* do j = 1 to browse brQuery:num-columns */
  
  if iColumnIndex > 0 then
  do:
    
    phBrowse:move-column(iColumnIndex, 1).
    
    if dColumnWidth > 0 then
      phBrowse:get-browse-column(1):width-chars = dColumnWidth.
    
    cColumnList = substitute('&1,&2':U,
                             cColumnList,
                             cColumnName).
    
  end. /* if iColumnIndex > 0 */
  
end. /* do i = 1 to num-entries() */

cColumnList = trim(cColumnList, ',':U).

/* Hide unselected columns. */
do i = 1 to phBrowse:num-columns:
  
  assign
    hColumn         = phBrowse:get-browse-column(i)
    hColumn:visible = (lookup(qg_cColumnFieldName(hColumn,
                                                  lBufferName),
                              cColumnList) <> 0)
    .
  
end. /* do i = 1 to num-entries() */

finally:
  
  phBrowse:hidden = lHidden.
  
end finally.

end procedure. /* qg_SetBrowseColumns */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetBufferComparisonBuffer hQueryWindow 
PROCEDURE qg_SetBufferComparisonBuffer :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcDatabaseName as character no-undo.
define input parameter phBuffer       as handle    no-undo.
define input parameter piBufferNo     as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i            as integer   no-undo.
define variable iIndex       as integer   no-undo.
define variable hField       as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttBufferComparisonField for temp-table ttBufferComparisonField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Reset values. */

for each bttBufferComparisonField
  on error undo, throw:
  
  if bttBufferComparisonField.BufferNo = piBufferNo then
    delete bttBufferComparisonField.
  
  else
    bttBufferComparisonField.IsEqual = ?.
  
end. /* for each bttBufferComparisonField */

do i = 1 to phBuffer:num-fields:
  
  hField = phBuffer:buffer-field(i).
  
  do iIndex = integer(hField:extent > 0) to hField:extent:
    
    find bttBufferComparisonField
      where bttBufferComparisonField.BufferNo   = piBufferNo
        and bttBufferComparisonField.FieldName  = hField:name
        and bttBufferComparisonField.FieldIndex = iIndex
      no-error.
    
    if not available bttBufferComparisonField then
    do:
      
      create bttBufferComparisonField.
      
      assign
        bttBufferComparisonField.BufferNo   = piBufferNo
        bttBufferComparisonField.FieldName  = hField:name
        bttBufferComparisonField.FieldIndex = iIndex
        .
      
    end. /* if not available bttBufferComparisonField */
    
    assign
      bttBufferComparisonField.DatabaseName = pcDatabaseName
      bttBufferComparisonField.TableName    = phBuffer:table
      bttBufferComparisonField.BufferName   = phBuffer:name
      bttBufferComparisonField.DataType     = hField:data-type
      bttBufferComparisonField.FieldFormat  = hField:format
      bttBufferComparisonField.IsVirtual    = no
      bttBufferComparisonField.FieldType    = {&K_FIELD_TYPE_DB_FIELD}
      .
    
    if    hField:data-type <> 'blob':U
      and phBuffer:available then
    do:
      
      if hField:data-type = 'clob':U then
        copy-lob hField:buffer-value(iIndex) to bttBufferComparisonField.FieldValue no-error.
      
      else
        bttBufferComparisonField.FieldValue = string(hField:buffer-value(iIndex)) no-error.
      
    end. /* if hField:data-type <> 'blob':U */
    
    validate bttBufferComparisonField.
    
  end. /* do iIndex = integer(phBuffer:extent > 0) to phBuffer:extent */
  
end. /* do i = 1 to phBuffer:num-fields */

run qg_AddVirtualFieldsToBufferComparisonBuffer( pcDatabaseName,
                                                 phBuffer,
                                                 piBufferNo ).

end procedure. /* qg_SetBufferComparisonBuffer */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetBufferPattern hQueryWindow 
PROCEDURE qg_SetBufferPattern :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Sets a buffer pattern for given index and updates the buffer name.         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcPattern                      = Buffer pattern that should be used.       */
/* piIndex                        = Index that should be used.                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcPattern as character no-undo.
define input parameter piIndex   as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cIndex as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cIndex          = (if piIndex > 0 then
                       string(piIndex)
                     else
                       '':U)
  gcBufferPattern = qg_cSubstituteChar(pcPattern, '#':U, cIndex)
  .

run qg_UpdateBufferName.

apply 'entry':U to gcBufferName in frame {&FRAME-NAME}.

end procedure. /* qg_SetBufferPattern */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetDefaultValues hQueryWindow 
PROCEDURE qg_SetDefaultValues :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set default values.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

/* Assign default values. */

assign
  gcTableFilter             = '':U
  gcTableFieldFilter        = '':U
  gcIndexFilter             = '':U
  gcIndexFieldFilter        = '':U
  gcRelationFilter          = '':U
  gcRelationFieldFilter     = '':U
  gcFieldFilter             = '':U
  gcFieldLabelFilter        = '':U
  gcBufferPattern           = {&K_DEFAULT_BUFFER_PATTERN}
  glDefineBuffer            = {&K_DEFAULT_DEFINE_BUFFER}
  glNoError                 = {&K_DEFAULT_NO_ERROR}
  glIfStatement             = {&K_DEFAULT_IF_STATEMENT}
  glNot                     = {&K_DEFAULT_NOT}
  glDoBlock                 = {&K_DEFAULT_DO_BLOCK}
  glDefineVariables         = {&K_DEFAULT_DEFINE_VARIABLES}
  glUseVirtualIndexIncludes = {&K_DEFAULT_USE_VIRTUAL_INDEX_INCLUDES}
  glExclusiveLock           = {&K_DEFAULT_EXCLUSIVE_LOCK}
  glCompanyViaClass         = {&K_DEFAULT_COMPANY_VIA_CLASS}
  glOnError                 = {&K_DEFAULT_ON_ERROR}
  giOnErrorPhrase           = {&K_DEFAULT_ON_ERROR_PHRASE}
  gcBlockPattern            = {&K_DEFAULT_BLOCK_PATTERN}
  glDefineBlock             = {&K_DEFAULT_DEFINE_BLOCK}
  glRetryBlock              = {&K_DEFAULT_RETRY_BLOCK}
  glFinallyBlock            = {&K_DEFAULT_FINALLY_BLOCK}
  giQueryType               = {&K_DEFAULT_QUERY_TYPE}
  giIndentation             = {&K_DEFAULT_INDENTATION}
  glInsertMode              =     OEIDEIsRunning
                              and glIDECanInsert
                              and {&K_DEFAULT_INSERT_MODE}
  .

display unless-hidden
  gcTableFilter
  gcTableFieldFilter
  gcIndexFilter
  gcIndexFieldFilter
  gcRelationFilter
  gcRelationFieldFilter
  gcFieldFilter
  gcFieldLabelFilter
  glDefineBuffer
  glNoError
  glIfStatement
  glNot
  glDoBlock
  glDefineVariables
  glUseVirtualIndexIncludes
  glExclusiveLock
  glCompanyViaClass
  glOnError
  giOnErrorPhrase
  glDefineBlock
  glRetryBlock
  glFinallyBlock
  giQueryType
  with frame {&FRAME-NAME}.

run qg_FillQueryRange.

end procedure. /* qg_SetDefaultValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetDisplayMode hQueryWindow 
PROCEDURE qg_SetDisplayMode :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set display mode.                                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piDisplayMode                  = Display mode that should be set.          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piDisplayMode as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iRelationId         as integer   no-undo.
define variable cRelationBufferName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelationView for temp-table ttTableRelationView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if piDisplayMode = {&K_DISPLAYMODE_FIELD} then
do:
  
  assign
    glInvertQuery:hidden in frame {&FRAME-NAME}               = yes
    gcFieldFilter:hidden in frame {&FRAME-NAME}               = no
    btnClearFieldFilter:hidden in frame {&FRAME-NAME}         = no
    gcFieldLabelFilter:hidden in frame {&FRAME-NAME}          = no
    btnClearFieldLabelFilter:hidden in frame {&FRAME-NAME}    = no
    gcFieldDummy:hidden in frame {&FRAME-NAME}                = no
    brField:hidden in frame {&FRAME-NAME}                     = no
    gcIndexFilter:hidden in frame {&FRAME-NAME}               = yes
    btnClearIndexFilter:hidden in frame {&FRAME-NAME}         = yes
    gcIndexFieldFilter:hidden in frame {&FRAME-NAME}          = yes
    btnClearIndexFieldFilter:hidden in frame {&FRAME-NAME}    = yes
    gcIndexDummy:hidden in frame {&FRAME-NAME}                = yes
    brIndex:hidden in frame {&FRAME-NAME}                     = yes
    gcRelationFilter:hidden in frame {&FRAME-NAME}            = yes
    btnClearRelationFilter:hidden in frame {&FRAME-NAME}      = yes
    gcRelationFieldFilter:hidden in frame {&FRAME-NAME}       = yes
    btnClearRelationFieldFilter:hidden in frame {&FRAME-NAME} = yes
    gcRelationDummy:hidden in frame {&FRAME-NAME}             = yes
    brRelation:hidden in frame {&FRAME-NAME}                  = yes
    giDisplayMode                                          = {&K_DISPLAYMODE_FIELD}
    .
  
  display unless-hidden
    {&DISPLAYED-OBJECTS}
    with frame {&FRAME-NAME}.
  
  if glRefreshFieldBrowse then
    run qg_RefreshFieldBrowse.
  
  else
  do:
    
    run qg_FillQueryRange.
    apply 'value-changed':U to brField in frame {&FRAME-NAME}.
    
  end. /* else: if glRefreshFieldBrowse */
  
end. /* if piDisplayMode = {&K_DISPLAYMODE_FIELD} */

else if piDisplayMode = {&K_DISPLAYMODE_INDEX} then
do:
  
  assign
    glInvertQuery:hidden in frame {&FRAME-NAME}               = yes
    gcFieldFilter:hidden in frame {&FRAME-NAME}               = yes
    btnClearFieldFilter:hidden in frame {&FRAME-NAME}         = yes
    gcFieldLabelFilter:hidden in frame {&FRAME-NAME}          = yes
    btnClearFieldLabelFilter:hidden in frame {&FRAME-NAME}    = yes
    gcFieldDummy:hidden in frame {&FRAME-NAME}                = yes
    brField:hidden in frame {&FRAME-NAME}                     = yes
    gcIndexFilter:hidden in frame {&FRAME-NAME}               = no
    btnClearIndexFilter:hidden in frame {&FRAME-NAME}         = no
    gcIndexFieldFilter:hidden in frame {&FRAME-NAME}          = no
    btnClearIndexFieldFilter:hidden in frame {&FRAME-NAME}    = no
    gcIndexDummy:hidden in frame {&FRAME-NAME}                = no
    brIndex:hidden in frame {&FRAME-NAME}                     = no
    gcRelationFilter:hidden in frame {&FRAME-NAME}            = yes
    btnClearRelationFilter:hidden in frame {&FRAME-NAME}      = yes
    gcRelationFieldFilter:hidden in frame {&FRAME-NAME}       = yes
    btnClearRelationFieldFilter:hidden in frame {&FRAME-NAME} = yes
    gcRelationDummy:hidden in frame {&FRAME-NAME}             = yes
    brRelation:hidden in frame {&FRAME-NAME}                  = yes
    giDisplayMode                                          = {&K_DISPLAYMODE_INDEX}
    .
  
  display unless-hidden
    {&DISPLAYED-OBJECTS}
    with frame {&FRAME-NAME}.
  
  if glRefreshIndexBrowse then
    run qg_RefreshIndexBrowse.
  
  else
  do:
    
    run qg_FillQueryRange.
    apply 'value-changed':U to brIndex in frame {&FRAME-NAME}.
    
  end. /* else: if glRefreshIndexBrowse */
  
end. /* else if piDisplayMode = {&K_DISPLAYMODE_INDEX} */

else if piDisplayMode = {&K_DISPLAYMODE_RELATION} then
do:
  
  assign
    glInvertQuery:hidden in frame {&FRAME-NAME}               = no
    gcFieldFilter:hidden in frame {&FRAME-NAME}               = yes
    btnClearFieldFilter:hidden in frame {&FRAME-NAME}         = yes
    gcFieldLabelFilter:hidden in frame {&FRAME-NAME}          = yes
    btnClearFieldLabelFilter:hidden in frame {&FRAME-NAME}    = yes
    gcFieldDummy:hidden in frame {&FRAME-NAME}                = yes
    brField:hidden in frame {&FRAME-NAME}                     = yes
    gcIndexFilter:hidden in frame {&FRAME-NAME}               = yes
    btnClearIndexFilter:hidden in frame {&FRAME-NAME}         = yes
    gcIndexFieldFilter:hidden in frame {&FRAME-NAME}          = yes
    btnClearIndexFieldFilter:hidden in frame {&FRAME-NAME}    = yes
    gcIndexDummy:hidden in frame {&FRAME-NAME}                = yes
    brIndex:hidden in frame {&FRAME-NAME}                     = yes
    gcRelationFilter:hidden in frame {&FRAME-NAME}            = no
    btnClearRelationFilter:hidden in frame {&FRAME-NAME}      = no
    gcRelationFieldFilter:hidden in frame {&FRAME-NAME}       = no
    btnClearRelationFieldFilter:hidden in frame {&FRAME-NAME} = no
    gcRelationDummy:hidden in frame {&FRAME-NAME}             = no
    brRelation:hidden in frame {&FRAME-NAME}                  = no
    giDisplayMode                                             = {&K_DISPLAYMODE_RELATION}
    .
  
  display unless-hidden
    {&DISPLAYED-OBJECTS}
    with frame {&FRAME-NAME}.
  
  if    available ttTable
    and giRelationId <> 0
    and ( not available ttTableRelationView
       or ttTableRelationView.RelationId <> giRelationId ) then
  do:
    
    assign
      iRelationId           = giRelationId
      cRelationBufferName   = gcRelationBufferName
      gcRelationFilter      = '':U
      gcRelationFieldFilter = '':U
      .
    
    display unless-hidden
      gcRelationFilter
      gcRelationFieldFilter
      with frame {&FRAME-NAME}.
    
    run qg_RefreshRelationBrowse.
    
    find first bttTableRelationView
      where bttTableRelationView.RelationId         = iRelationId
        and bttTableRelationView.DatabaseName       = ttTable.DatabaseName
        and bttTableRelationView.ReferenceTableName = ttTable.TableName
      no-error.
    
    if available bttTableRelationView then
    do:
      
      reposition brRelation to rowid rowid(bttTableRelationView) no-error.
      
      assign
        giRelationid         = iRelationid
        glParentRelation     = ttTableRelationView.ParentRelation
        gcRelationBufferName = (if    available ttTableRelationView
                                  and ttTableRelationView.RelationId = iRelationId then
                                  cRelationBufferName
                                else if available ttTableRelationView then
                                  ttTableRelationView.RelatedTableName
                                else
                                  '?':U)
        .
      
      run qg_FillQueryRange.
      run qg_UpdateQueryText.
      
    end. /* if available bttTableRelationView */
    
  end.
  
  else if giRelationId = 0 then
  do:
    
    glRefreshRelationBrowse = yes.
    run qg_RefreshRelationBrowse.
    
  end. /* else if giRelationId = 0 */
  
  else
  do:
    
    run qg_FillQueryRange.
    run qg_UpdateQueryText.
    
  end. /* else: if glRefreshRelationBrowse */
  
end. /* else if piDisplayMode = {&K_DISPLAYMODE_INDEX} */

run qg_WidgetState( '*':U ).

end procedure. /* qg_SetDisplayMode */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetExternalParameters hQueryWindow 
PROCEDURE qg_SetExternalParameters :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set external parameters.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = List of external parameters.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcParamList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iHandlerId    as integer   no-undo.
define variable cSettingValue as character no-undo. 

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

iHandlerId = qg_iParamListReadValue(pcParamList,
                                    {&K_EDITOR_INSERT_REQUEST_HANDLER},
                                    {&K_PARAM_SPLITTER}).

if iHandlerId > 0 then
  run qg_SetHandlerId({&K_EDITOR_INSERT_REQUEST_HANDLER},
                      iHandlerId).

iHandlerId = qg_iParamListReadValue(pcParamList,
                                    {&K_SAVE_PLUGIN_SETTING_HANDLER},
                                    {&K_PARAM_SPLITTER}).

if iHandlerId > 0 then
  run qg_SetHandlerId({&K_SAVE_PLUGIN_SETTING_HANDLER},
                      iHandlerId).

iHandlerId = qg_iParamListReadValue(pcParamList,
                                    {&K_LOAD_PLUGIN_SETTING_HANDLER},
                                    {&K_PARAM_SPLITTER}).

if iHandlerId > 0 then
  run qg_SetHandlerId({&K_LOAD_PLUGIN_SETTING_HANDLER},
                      iHandlerId).

run qg_WidgetState('*':U).

if    OEIDEIsRunning
  and glIDECanLoadSetting then
do:
  
  /* gcTableFilter history */
  run qg_LoadIDESetting('FieldHistory_gcTableFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcTableFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcTableFieldFilter history */
  run qg_LoadIDESetting('FieldHistory_gcTableFieldFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcTableFieldFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcIndexFilter history */
  run qg_LoadIDESetting('FieldHistory_gcIndexFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcIndexFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcIndexFieldFilter history */
  run qg_LoadIDESetting('FieldHistory_gcIndexFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcIndexFieldFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcRelationFilter history */
  run qg_LoadIDESetting('FieldHistory_gcRelationFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcRelationFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcRelationFieldFilter history */
  run qg_LoadIDESetting('FieldHistory_gcRelationFieldFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcRelationFieldFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcFieldFilter history */
  run qg_LoadIDESetting('FieldHistory_gcFieldFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcFieldFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcFieldLabelFilter history */
  run qg_LoadIDESetting('FieldHistory_gcFieldLabelFilter':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    gcFieldLabelFilter:list-items in frame {&FRAME-NAME} = cSettingValue.
  
  /* gcBufferName initial value */
  run qg_LoadIDESetting('FieldInitial_gcBufferName':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    gcBufferPattern = cSettingValue.
    run qg_UpdateBufferName.
    
  end. /* if cSettingValue > '':U */
  
  /* glDefineBuffer initial value */
  run qg_LoadIDESetting('FieldInitial_glDefineBuffer':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glDefineBuffer = logical(cSettingValue, 'true/false':U).
  
  /* glCompanyViaClass initial value */
  run qg_LoadIDESetting('FieldInitial_glCompanyViaClass':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glCompanyViaClass = logical(cSettingValue, 'true/false':U).
  
  /* glExclusiveLock initial value */
  run qg_LoadIDESetting('FieldInitial_glExclusiveLock':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glExclusiveLock = logical(cSettingValue, 'true/false':U).
  
  /* glNoError initial value */
  run qg_LoadIDESetting('FieldInitial_glNoError':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glNoError = logical(cSettingValue, 'true/false':U).
  
  /* glIfStatement initial value */
  run qg_LoadIDESetting('FieldInitial_glIfStatement':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glIfStatement = logical(cSettingValue, 'true/false':U).
  
  /* glNot initial value */
  run qg_LoadIDESetting('FieldInitial_glNot':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glNot = logical(cSettingValue, 'true/false':U).
  
  /* glDoBlock initial value */
  run qg_LoadIDESetting('FieldInitial_glDoBlock':U,
                        output cSettingValue).
  
  /* glDefineVariables initial value */
  run qg_LoadIDESetting('FieldInitial_glDefineVariables':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glDefineVariables = logical(cSettingValue, 'true/false':U).
  
  /* glUseVirtualIndexIncludes initial value */
  run qg_LoadIDESetting('FieldInitial_glUseVirtualIndexIncludes':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glUseVirtualIndexIncludes = logical(cSettingValue, 'true/false':U).
  
  if cSettingValue > '':U then
    glDoBlock = logical(cSettingValue, 'true/false':U).
  
  /* glOnError initial value */
  run qg_LoadIDESetting('FieldInitial_glOnError':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glOnError = logical(cSettingValue, 'true/false':U).
  
  /* giOnErrorPhrase initial value */
  run qg_LoadIDESetting('FieldInitial_giOnErrorPhrase':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    giOnErrorPhrase = integer(cSettingValue).
  
  /* gcBlockName initial value */
  run qg_LoadIDESetting('FieldInitial_gcBlockName':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    gcBlockPattern = cSettingValue.
    run qg_UpdateBlockName.
    
  end. /* if cSettingValue > '':U */
  
  /* glDefineBlock initial value */
  run qg_LoadIDESetting('FieldInitial_glDefineBlock':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glDefineBlock = logical(cSettingValue, 'true/false':U).
  
  /* glRetryBlock initial value */
  run qg_LoadIDESetting('FieldInitial_glRetryBlock':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glRetryBlock = logical(cSettingValue, 'true/false':U).
  
  /* glFinallyBlock initial value */
  run qg_LoadIDESetting('FieldInitial_glFinallyBlock':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    glFinallyBlock = logical(cSettingValue, 'true/false':U).
  
  /* giQueryType initial value */
  run qg_LoadIDESetting('FieldInitial_giQueryType':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    giQueryType = integer(cSettingValue).
  
  /*--------------------------------------------------------------------------*/
  /* Options                                                                  */
  /*--------------------------------------------------------------------------*/

  /* Show query type modifier */
  
  run qg_LoadIDESetting('Options_ShowQueryTypeModifier':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    menu-item mi_ShowQueryTypeModifier:checked in menu m_Options = logical(cSettingValue, 'true/false':U).
    run qg_SetShowQueryTypeModifier(menu-item mi_ShowQueryTypeModifier:checked in menu M_Options).
    
  end. /* if cSettingValue > '':U */
  
  /* Always use 'find first' */
  
  run qg_LoadIDESetting('Options_AlwaysUseFindFirst':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    assign
      glAlwaysUseFindFirst                                      = logical(cSettingValue, 'true/false':U)
      menu-item mi_AlwaysUseFindFirst:checked in menu m_Options = glAlwaysUseFindFirst
      .
  
  /* Always use 'can-find first' */
  
  run qg_LoadIDESetting('Options_AlwaysUseCanFindFirst':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    assign
      glAlwaysUseCanFindFirst                                      = logical(cSettingValue, 'true/false':U)
      menu-item mi_AlwaysUseCanFindFirst:checked in menu m_Options = glAlwaysUseCanFindFirst
      .
  
  /* Use virtual index API */
  
  run qg_LoadIDESetting('Options_UseVirtualIndexApi':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    
    assign
      glUseVirtualIndexApi = logical(cSettingValue, 'true/false':U)
      menu-item mi_UseVirtualIndexApi:checked in menu m_Options = glUseVirtualIndexApi
      .
  
  /* Open query window for persistent temp-tables */
  
  run qg_LoadIDESetting('Options_OpenQueryWindowForPersistentTT':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    menu-item mi_OpenQueryWindowPersistentTT:checked in menu m_Options = logical(cSettingValue, 'true/false':U).
  
  /* Open query window for snapshot temp-tables */
  
  run qg_LoadIDESetting('Options_OpenQueryWindowForSnapshotTT':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    menu-item mi_OpenQueryWindowSnapshotTT:checked in menu m_Options = logical(cSettingValue, 'true/false':U).
  
  /*--------------------------------------------------------------------------*/
  /* Session-Trigger settings                                                 */
  /*--------------------------------------------------------------------------*/
  
  run qg_LoadIDESetting('Options_SessionTriggerShowMessage':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    glSessionTriggerShowMessage = logical(cSettingValue, 'true/false':U).
    
    if valid-handle(ghSessionTriggerShowMessage) then
      ghSessionTriggerShowMessage:screen-value = string(glSessionTriggerShowMessage).
    
  end. /* if cSettingValue > '':U */

  run qg_LoadIDESetting('Options_SessionTriggerWriteLog':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    glSessionTriggerWriteLog = logical(cSettingValue, 'true/false':U).
    
    if valid-handle(ghSessionTriggerWriteLog) then
      ghSessionTriggerWriteLog:screen-value = string(glSessionTriggerWriteLog).
    
  end. /* if cSettingValue > '':U */

  run qg_LoadIDESetting('Options_SessionTriggerLogFileName':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    gcSessionTriggerLogFileName = cSettingValue.
    
    if valid-handle(ghSessionTriggerLogFileName) then
      ghSessionTriggerLogFileName:screen-value = string(gcSessionTriggerLogFileName).
    
  end. /* if cSettingValue > '':U */

  run qg_LoadIDESetting('Options_SessionTriggerIndexValues':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    glSessionTriggerIndexValues = logical(cSettingValue, 'true/false':U).
    
    if valid-handle(ghSessionTriggerIndexValues) then
      ghSessionTriggerIndexValues:screen-value = string(glSessionTriggerIndexValues).
    
  end. /* if cSettingValue > '':U */

  run qg_LoadIDESetting('Options_SessionTriggerStackTrace':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
  do:
    
    glSessionTriggerStackTrace = logical(cSettingValue, 'true/false':U).
    
    if valid-handle(ghSessionTriggerStackTrace) then
      ghSessionTriggerStackTrace:screen-value = string(glSessionTriggerStackTrace).
    
  end. /* if cSettingValue > '':U */

  /*--------------------------------------------------------------------------*/
  /* Virtual Fields                                                           */
  /*--------------------------------------------------------------------------*/
  
  run qg_LoadIDESetting('Options_ShowVirtualFields':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    
    assign
      glShowVirtualFields = logical( cSettingValue, 'true/false':U )
      menu-item mi_VirtualFields:checked in menu POPUP-MENU-brField = glShowVirtualFields.
      .
  
  run qg_LoadIDESetting('Options_ShowVirtualIndices':U,
                        output cSettingValue).
  
  if cSettingValue > '':U then
    
    assign
      glShowVirtualIndices = logical( cSettingValue, 'true/false':U )
      menu-item mi_VirtualIndices:checked in menu POPUP-MENU-brIndex = glShowVirtualIndices.
      .
  
  /*--------------------------------------------------------------------------*/
  /* Update gui                                                               */
  /*--------------------------------------------------------------------------*/

  display unless-hidden
    glDefineBuffer
    glCompanyViaClass
    glExclusiveLock
    glNoError
    glIfStatement
    glNot
    glDoBlock
    glDefineVariables
    glUseVirtualIndexIncludes
    glOnError
    giOnErrorPhrase
    glDefineBlock
    glRetryBlock
    glFinallyBlock
    giQueryType
    with frame {&FRAME-NAME}.
  
  run qg_WidgetState('*':U).
  
  run qg_FillQueryRange.
  run qg_UpdateQueryText.
  
end. /* if glIDECanLoadSetting */

end procedure. /* qg_SetExternalParameters */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetHandlerId hQueryWindow 
PROCEDURE qg_SetHandlerId :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set handler id.                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcHandlerName                  = Handler name.                             */
/* piHandlerId                    = Handler Id                                */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcHandlerName as character no-undo.
define input parameter piHandlerId   as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttIDEHandler for temp-table ttIDEHandler.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttIDEHandler
  where bttIDEHandler.HandlerName = pcHandlerName
  no-error.

if not available bttIDEHandler then
do:
  
  create bttIDEHandler.
  
  bttIDEHandler.HandlerName = pcHandlerName.
  
end. /* not available bttIDEHandler */

case bttIDEHandler.HandlerName:
  
  when {&K_EDITOR_INSERT_REQUEST_HANDLER} then
    assign
      glIDECanInsert =     piHandlerId <> ?
                       and piHandlerId  > 0
      glInsertMode   =     OEIDEIsRunning
                       and glIDECanInsert
                       and {&K_DEFAULT_INSERT_MODE}
      .
  
  when {&K_SAVE_PLUGIN_SETTING_HANDLER} then
    glIDECanSaveSetting =     piHandlerId <> ?
                          and piHandlerId  > 0.
  
  when {&K_LOAD_PLUGIN_SETTING_HANDLER} then
    glIDECanLoadSetting =     piHandlerId <> ?
                          and piHandlerId  > 0.
  
end case. /* bttIDEHandler.HandlerName */

bttIDEHandler.HandlerId = piHandlerId.

end procedure. /* qg_SetHandlerId */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetQueryType hQueryWindow 
PROCEDURE qg_SetQueryType :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set query type.                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piQueryType                    = Query type that should be used.           */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter piQueryType as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

giQueryType = piQueryType.

display unless-hidden
  giQueryType
  with frame {&FRAME-NAME}.

run qg_FillQueryRange.
run qg_WidgetState('*':U).
run qg_UpdateQueryText.


end procedure. /* qg_SetQueryType */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetScrollbars hQueryWindow 
PROCEDURE qg_SetScrollbars :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWidget     as handle    no-undo.
define input parameter plHorizontal as logical   no-undo.
define input parameter plVertical   as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iCurrentFlags   as integer   no-undo.
define variable iNewFlags       as integer   no-undo.

define variable iDummy          as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run GetWindowLongA(phWidget:hwnd,
                   {&K_WIN_CONST_GWL_STYLE},
                   output iCurrentFlags).

iNewFlags = iCurrentFlags.

if    plHorizontal <> ?
  and qg_lTestBits({&K_WIN_CONST_WS_HSCROLL}, iCurrentFlags) <> plHorizontal then
  iNewFlags = (if plHorizontal then
                 iNewFlags + {&K_WIN_CONST_WS_HSCROLL}
               else
                 iNewFlags - {&K_WIN_CONST_WS_HSCROLL}).

if    plVertical <> ?
  and qg_lTestBits({&K_WIN_CONST_WS_VSCROLL}, iCurrentFlags) <> plVertical then
  iNewFlags = (if plVertical then
                 iNewFlags + {&K_WIN_CONST_WS_VSCROLL}
               else
                 iNewFlags - {&K_WIN_CONST_WS_VSCROLL}).

if iNewFlags <> iCurrentFlags then
do:
  
  run SetWindowLongA(phWidget:hwnd,
                     {&K_WIN_CONST_GWL_STYLE},
                     iNewFlags,
                     output iDummy).
  
  /* Running SetWindowPos with SWP_FRAMECHANGED is necessary to activate  */
  /* the newly set window style.                                          */

  run SetWindowPos(phWidget:hwnd,
                   0,
                   phWidget:x,
                   phWidget:y,
                   phWidget:width-pixels,
                   phWidget:height-pixels,
                   {&K_WIN_CONST_SWP_FRAMECHANGED},
                   output iDummy).
  
end. /* if iNewFlags <> iCurrentFlags */

end procedure. /* qg_SetScrollbars */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetShowQueryTypeModifier hQueryWindow 
PROCEDURE qg_SetShowQueryTypeModifier :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set the "show query type modifier" option.                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* plShowQueryTypeModifier        = Indicates wether to show the query type   */
/*                                  modifier.                                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plShowQueryTypeModifier as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

glShowQueryTypeModifier = plShowQueryTypeModifier.

if glShowQueryTypeModifier then
  assign
    giQueryType:private-data in frame {&FRAME-NAME}
        = qg_cParamListWriteDecimal(giQueryType:private-data in frame {&FRAME-NAME},
                                    'OriginalHeight':U,
                                    1,
                                    ',':U)
    giQueryType:height in frame {&FRAME-NAME}         = 1
    giQueryTypeModifier:hidden in frame {&FRAME-NAME} = glSlimMode
    . 

else
  assign
    giQueryType:private-data in frame {&FRAME-NAME}
        = qg_cParamListWriteDecimal(giQueryType:private-data in frame {&FRAME-NAME},
                                    'OriginalHeight':U,
                                    2,
                                    ',':U)
    giQueryType:height in frame {&FRAME-NAME}         = 2
    giQueryTypeModifier:hidden in frame {&FRAME-NAME} = yes
    . 

end procedure. /* qg_SetShowQueryTypeModifier */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetSlimMode hQueryWindow 
PROCEDURE qg_SetSlimMode :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set or unset slim mode.                                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* plSlimMode                     = Indicates wether slim mode should be set  */
/*                                  or unset.                                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter plSlimMode as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if plSlimMode <> glSlimMode then
do:
  
  if hQueryWindow:window-state = {&K_WINDOW_MAXIMIZED} then
    hQueryWindow:window-state = {&K_WINDOW_NORMAL}.
  
  glSlimMode = plSlimMode.
  
  if not glSlimMode then
  do:
    
    assign
      gdOriginalWidth          = gdOriginalWidth * {&K_SLIM_MODE_FACTOR}
      gdMinWidth               = {&K_WINDOW_MIN_WIDTH}
      gdMinHeight              = {&K_WINDOW_MIN_HEIGHT}
      hQueryWindow:width-chars = hQueryWindow:width-chars * {&K_SLIM_MODE_FACTOR}.
    
    apply 'window-resized':U to hQueryWindow.
    
  end. /* if not glSlimMode */
  
  do with frame {&FRAME-NAME}:
    
    assign
      gcBufferName:hidden              = glSlimMode
      btnClearBufferPattern:hidden     = glSlimMode
      btnBuffer1:hidden                = glSlimMode or ({&K_BUFFER_PATTERN_1} = '':U)
      btnBuffer2:hidden                = glSlimMode or ({&K_BUFFER_PATTERN_2} = '':U)
      btnBuffer3:hidden                = glSlimMode or ({&K_BUFFER_PATTERN_3} = '':U)
      btnBuffer4:hidden                = glSlimMode or ({&K_BUFFER_PATTERN_4} = '':U)
      glDefineBuffer:hidden            = glSlimMode
      glCompanyViaClass:hidden         = glSlimMode
      glExclusiveLock:hidden           = glSlimMode
      glNoError:hidden                 = glSlimMode
      glIfStatement:hidden             = glSlimMode
      glNot:hidden                     = glSlimMode
      glDoBlock:hidden                 = glSlimMode
      glDefineVariables:hidden         = glSlimMode
      glUseVirtualIndexIncludes:hidden = glSlimMode
      glOnError:hidden                 = glSlimMode
      giOnErrorPhrase:hidden           = glSlimMode
      giQueryTypeModifier:hidden       = glSlimMode or not glShowQueryTypeModifier
      gcBlockName:hidden               = glSlimMode
      btnClearBlockName:hidden         = glSlimMode
      btnBlock1:hidden                 = glSlimMode or ({&K_BLOCK_PATTERN_1} = '':U)
      btnBlock2:hidden                 = glSlimMode or ({&K_BLOCK_PATTERN_2} = '':U)
      btnBlock3:hidden                 = glSlimMode or ({&K_BLOCK_PATTERN_3} = '':U)
      btnBlock4:hidden                 = glSlimMode or ({&K_BLOCK_PATTERN_4} = '':U)
      glDefineBlock:hidden             = glSlimMode
      glRetryBlock:hidden              = glSlimMode
      glFinallyBlock:hidden            = glSlimMode
      glFinallyBlock:hidden            = glSlimMode
      giQueryType:hidden               = glSlimMode
      btnCopyToClipboard:hidden        = glSlimMode
      btnExecuteQuery:hidden           = glSlimMode
      btnResetAll:hidden               = glSlimMode
      gcQueryText:hidden               = glSlimMode
      btnIncreaseIndentation:hidden    = glSlimMode
      btnDecreaseIndentation:hidden    = glSlimMode
      btnResetIndentation:hidden       = glSlimMode
      btnOf:hidden                     = glSlimMode
      gdIndexUsage:hidden              = glSlimMode
      .
    
  end. /* do with frame {&FRAME-NAME} */
  
  if glSlimMode then
  do:
    
    assign
      gdOriginalWidth          = gdOriginalWidth / {&K_SLIM_MODE_FACTOR}
      gdMinWidth               = {&K_WINDOW_MIN_WIDTH_SLIM}
      gdMinHeight              = {&K_WINDOW_MIN_HEIGHT_SLIM}
      hQueryWindow:width-chars = hQueryWindow:width-chars / {&K_SLIM_MODE_FACTOR}
      .
    
    apply 'window-resized':U to hQueryWindow.
    
  end. /* else: if not glSlimMode */
  
  run qg_UpdateBufferName.
  run qg_UpdateBlockName.
  
end. /* if plSlimMode <> glSlimMode */

end procedure. /* qg_SetSlimMode */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetWindowPos hQueryWindow 
PROCEDURE qg_SetWindowPos :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow as handle    no-undo.

define input parameter piXPos   as integer   no-undo.
define input parameter piYPos   as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iHwnd  as int64     no-undo.
define variable iDummy as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if phWindow:type = 'WINDOW':U then
  run GetParent(phWindow:hwnd,
                output iHwnd).

else
  iHwnd = phWindow:hwnd.

run SetWindowPos(iHwnd,
                 0,
                 piXPos,
                 piYPos,
                 0,
                 0,
                 {&K_WIN_CONST_SWP_FRAMECHANGED} + {&K_WIN_CONST_SWP_NOSIZE},
                 output iDummy).

end procedure. /* qg_SetWindowPos */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SetWorkingDatabase hQueryWindow 
PROCEDURE qg_SetWorkingDatabase :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Sets the working database to the currently selected database.              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    available ttDatabase
  and ttDatabase.PhysicalDB then
  create alias dictdb for database value(ttDatabase.DatabaseName).

end procedure. /* qg_SetWorkingDatabase */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ShowBrowseGrid hQueryWindow 
PROCEDURE qg_ShowBrowseGrid :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set "separators" property for given Browse.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = Browse for which you want to set the      */
/*                                  property.                                 */
/* phMenuItem                     = Menu-item that contains the logical value */
/*                                  wether separators should be displayed or  */
/*                                  not.                                      */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBrowse   as handle    no-undo.
define input parameter phMenuItem as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

phBrowse:separators = phMenuItem:checked.

end procedure. /* qg_ShowBrowseGrid */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ShowBrowseRecordCount hQueryWindow 
PROCEDURE qg_ShowBrowseRecordCount :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show a message with the number of records in the given browse.             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = Browse that contains the records.         */
/* phParentWindow                 = Parent window for the message dialog.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBrowse       as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

message /* code checked by mth */
  substitute('The browser currently contains &1 record&2.':T,
             trim(string(phBrowse:query:num-results, {&K_MAX_INT64_FORMAT})),
             (if phBrowse :query:num-results = 1 then
                '':U
              else
                's':U)) skip
  view-as alert-box
    information
    buttons ok
    in window phBrowse:window.

end procedure. /* qg_ShowBrowseRecordCount */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ShowQueryWindow hQueryWindow 
PROCEDURE qg_ShowQueryWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Show a dialog to select a query window and bring it to front.              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phParentWindow                 = Parent window for the dialog.             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phParentWindow as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lShowLinkedChildWindows as logical
  label 'Show linked child windows':T
  view-as toggle-box
  size 30 by 1
  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow  for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

define query brQueryWindow
  for bttQueryWindow
  scrolling.

define browse brQueryWindow
  query brQueryWindow no-lock
    display
      bttQueryWindow.WindowTitle
      with no-assign size 96 by 16.

define button btnOk
  label 'Ok':T2
  size 20 by 1.14
  auto-go.

define button btnCancel
  label 'Cancel':T
  size 20 by 1.14
  auto-end-key.

define frame fSelectQueryWindow
  brQueryWindow at row 1.5 col 3
  lShowLinkedChildWindows at row 18 col 3
  btnOk at row 20 col 31
  btnCancel at row 20 col 51
  with 1 down keep-tab-order overlay
    view-as dialog-box 
    title gcTitlePrefix + 'Select query window':U
    side-labels no-underline three-d 
    size 101 by 21.94
    default-button btnOk
    cancel-button btnCancel.

on window-close of frame fSelectQueryWindow
  apply 'end-error' to self.

on default-action of brQueryWindow in frame fSelectQueryWindow
  apply 'go':U to frame fSelectQueryWindow.

if not can-find(first ttQueryWindow) then
  leave.

run qg_InitBrowse(browse brQueryWindow:handle).

open query brQueryWindow
  for each bttQueryWindow
    no-lock
    by bttQueryWindow.QuerySeq.

if query brQueryWindow:num-results > 0 then
do:
  
  display unless-hidden
    brQueryWindow
    with frame fSelectQueryWindow
      in window phParentWindow. 
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = phParentWindow
    no-error.
  
  if available bttQueryWindow then
    reposition brQueryWindow to rowid rowid(bttQueryWindow).
  
  else
    brQueryWindow:select-row(1) in frame fSelectQueryWindow.
  
end. /* if query brQueryWindow:num-results > 0 */

lShowLinkedChildWindows = glShowLinkedChildWindows.

update unless-hidden
  brQueryWindow
  lShowLinkedChildWindows
  btnOk
  btnCancel
  with frame fSelectQueryWindow
    in window phParentWindow.

if    available bttQueryWindow
  and valid-handle(bttQueryWindow.WindowHandle) then
do:
  
  if lShowLinkedChildWindows then
    run qg_QueryWindowShowChildWindows(bttQueryWindow.QuerySeq).
  
  run qg_ActivateWindow(bttQueryWindow.WindowHandle, bttQueryWindow.QueryBrowseHandle).
  
  glShowLinkedChildWindows = lShowLinkedChildWindows.
  
end. /* if available bttQueryWindow */

end procedure. /* qg_ShowQueryWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_ActivateWindow hQueryWindow 
PROCEDURE qg_ActivateWindow :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phWindow      as handle    no-undo.
define input parameter phFocusWidget as handle    no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if phWindow:window-state = {&K_WINDOW_MINIMIZED} then
  phWindow:window-state = {&K_WINDOW_NORMAL}.

phWindow:move-to-top().

if phFocusWidget <> ? then
  apply 'entry':U to phFocusWidget.

end procedure. /* qg_ActivateWindow */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SplitFieldName hQueryWindow 
PROCEDURE qg_SplitFieldName :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcFieldName     as character no-undo.

define output parameter opcDatabaseName as character no-undo.
define output parameter opcBufferName   as character no-undo.
define output parameter opcFieldName    as character no-undo.
define output parameter opiFieldIndex   as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

case num-entries(pcFieldName, '.':U):
  
  when 2 then
    assign
      opcBufferName = entry(1, pcFieldName, '.':U)
      opcFieldName  = entry(2, pcFieldName, '.':U)
      .
  
  when 3 then
    assign
      opcDatabaseName = entry(1, pcFieldName, '.':U)
      opcBufferName   = entry(2, pcFieldName, '.':U)
      opcFieldName    = entry(3, pcFieldName, '.':U)
      .
  
  otherwise
    opcFieldName = pcFieldName.
  
end. /* case num-entries(pcFieldName, '.':U) */

if index(opcFieldName, '[':U) > 0 then
  assign
    opiFieldIndex = qg_iExtractIndex(opcFieldName)
    opcFieldName  = qg_cExtractFieldName(opcFieldName)
    .

end procedure. /* qg_SplitFieldName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_SubstituteChar hQueryWindow 
PROCEDURE qg_SubstituteChar :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Substitutes all occurrences of given character. Double sequential          */
/* occurrences of the character will be changed to one character.             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcString                       = Text in that the characters should be     */
/*                                  substituted.                              */
/* pcFromChar                     = Character to replace.                     */
/* pcToChar                       = Replacement character.                    */
/* opcResultString                = Result string with replaced characters.   */
/* opiNumReplacements             = Number of replaced characters.            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input  parameter pcString           as character no-undo.
define input  parameter pcFromChar         as character no-undo.
define input  parameter pcToChar           as character no-undo.
define output parameter opcResultString    as character no-undo. 
define output parameter opiNumReplacements as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i         as integer   no-undo.
define variable iLength   as integer   no-undo.
define variable cChar     as character no-undo.
define variable cNextChar as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if index(pcString, pcFromChar) = 0 then
do:
  opcResultString = pcString.
  return.
end. /* if index(pcString, pcFromChar) = 0 */

/* Replace counter. */
iLength = length(pcString).

do i = 1 to iLength:
  
  assign
    cChar     = substring(pcString, i, 1)
    cNextChar = (if i < iLength then
                   substring(pcString, i + 1, 1)
                 else
                   '':U)
    .
  
  if cChar <> pcFromChar then
    opcResultString = opcResultString + cChar.
  
  else
  do:
    
    if cNextChar <> pcFromChar then
      assign
        opcResultString    = opcResultString + pcToChar
        opiNumReplacements = opiNumReplacements + 1
        .
    
    else
      assign
        opcResultString = opcResultString + cChar
        i       = i + 1
        .
    
  end. /* if cNextChar <> pcFromChar */
  
end. /* do i = 1 to length(pcString) */

end procedure. /* qg_SubstituteChar */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateBlockName hQueryWindow 
PROCEDURE qg_UpdateBlockName :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update block name.                                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  gcBufferName = (if glSlimMode then
                    substitute({&K_DEFAULT_BUFFER_PATTERN},
                               qg_cGetBufferBaseName(no))
                  else
                    input frame {&FRAME-NAME} gcBufferName)
  gcBlockName  = substitute(gcBlockPattern, gcBufferName)
  .

display unless-hidden
  gcBlockName
  with frame {&FRAME-NAME}.

run qg_ProcessBlockNameChange.

assign
  btnBlock1:tooltip in frame {&FRAME-NAME} = substitute('Use blockname &1':U,
                                                        substitute({&K_BLOCK_PATTERN_1},
                                                                   gcBufferName))
  btnBlock2:tooltip in frame {&FRAME-NAME} = substitute('Use blockname &1':U,
                                                        substitute({&K_BLOCK_PATTERN_2},
                                                                   gcBufferName))
  btnBlock3:tooltip in frame {&FRAME-NAME} = substitute('Use blockname &1':U,
                                                        substitute({&K_BLOCK_PATTERN_3},
                                                                   gcBufferName))
  btnBlock4:tooltip in frame {&FRAME-NAME} = substitute('Use blockname &1':U,
                                                        substitute({&K_BLOCK_PATTERN_4},
                                                                   gcBufferName))
  .

end procedure. /* qg_UpdateBlockName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateBufferName hQueryWindow 
PROCEDURE qg_UpdateBufferName :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update buffer name.                                                        */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  glDefineBuffer   = (if glSlimMode then
                        {&K_DEFAULT_DEFINE_BUFFER}
                      else
                        input frame {&FRAME-NAME} glDefineBuffer)
  gcBufferBaseName = qg_cGetBufferBaseName(   glDefineBuffer
                                           or (  gcBufferPattern > '':U
                                             and gcBufferPattern <> '&1':U))
  gcBufferName     = (if gcBufferPattern > '':U then
                        substitute(gcBufferPattern, gcBufferBaseName)
                      else
                        gcBufferBaseName)
  .

display unless-hidden
  gcBufferName
  with frame {&FRAME-NAME}.

run qg_ProcessBufferNameChange.

assign
  gcBufferBaseName                          = qg_cGetBufferBaseName(yes)
  btnBuffer1:tooltip in frame {&FRAME-NAME} = substitute('Use buffername &1':U,
                                                         substitute(qg_cSubstituteChar({&K_BUFFER_PATTERN_1},
                                                                                       '#':U,
                                                                                       '':U),
                                                                    gcBufferBaseName))
  btnBuffer2:tooltip in frame {&FRAME-NAME} = substitute('Use buffername &1':U,
                                                         substitute(qg_cSubstituteChar({&K_BUFFER_PATTERN_2},
                                                                                       '#':U,
                                                                                       '':U),
                                                                    gcBufferBaseName))
  btnBuffer3:tooltip in frame {&FRAME-NAME} = substitute('Use buffername &1':U,
                                                         substitute(qg_cSubstituteChar({&K_BUFFER_PATTERN_3},
                                                                                       '#':U,
                                                                                       '':U),
                                                                    gcBufferBaseName))
  btnBuffer4:tooltip in frame {&FRAME-NAME} = substitute('Use buffername &1':U,
                                                         substitute(qg_cSubstituteChar({&K_BUFFER_PATTERN_4},
                                                                                       '#':U,
                                                                                       '':U),
                                                                    gcBufferBaseName))
  .

end procedure. /* qg_UpdateBufferName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateDatabasePopupMenu hQueryWindow 
PROCEDURE qg_UpdateDatabasePopupMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update database popup menu.                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if available ttDatabase then
  assign
    menu-item mi_CopyDatabaseName:label in menu POPUP-MENU-brDatabase
        = substitute('Copy name (&1)':U, ttDatabase.DatabaseName)
    menu-item mi_CopyDatabaseName:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = yes
    menu-item mi_CopyPhysicalName:label in menu POPUP-MENU-brDatabase
        = substitute('Copy name (&1)':U, ttDatabase.PhysicalName)
    menu-item mi_CopyPhysicalName:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = yes
    menu-item mi_LoadDataDefinitions:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = ttDatabase.PhysicalDB
    menu-item mi_DataDictionary:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = ttDatabase.PhysicalDB
    menu-item mi_DataAdministration:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = ttDatabase.PhysicalDB
    .

else
  assign
    menu-item mi_CopyDatabaseName:label in menu POPUP-MENU-brDatabase
        = 'Copy name':U
    menu-item mi_CopyDatabaseName:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = no
    menu-item mi_CopyPhysicalName:label in menu POPUP-MENU-brDatabase
        = 'Copy name':U
    menu-item mi_CopyPhysicalName:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = no
    menu-item mi_LoadDataDefinitions:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = no
    menu-item mi_DataDictionary:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */
        = no
    menu-item mi_DataAdministration:sensitive in menu POPUP-MENU-brDatabase /* code checked by mth 30.07.2015 */ 
        = no
    .

end procedure. /* qg_UpdateDatabasePopupMenu */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateEditor hQueryWindow 
PROCEDURE qg_UpdateEditor :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Set selecton for given editor to given lines.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phEditor                       = Editor for which the selection should be  */
/*                                  set.                                      */
/* pcEditorText                   = Editor text.                              */
/* piFirstSelectedLine            = First line to select.                     */
/* piLastSelectedLine             = Last line to select.                      */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phEditor            as handle    no-undo.
define input parameter pcEditorText        as character no-undo.
define input parameter piFirstSelectedLine as integer   no-undo.
define input parameter piLastSelectedLine  as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cEditorText     as character no-undo.
define variable i               as integer   no-undo.
define variable iOffset         as integer   no-undo initial 1.
define variable iLineEndOffset  as integer   no-undo.
define variable iSelectionStart as integer   no-undo.
define variable iSelectionEnd   as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    piFirstSelectedLine  > 0
  and piLastSelectedLine  >= piFirstSelectedLine then
do:
  
  do i = 1 to num-entries(pcEditorText, '~n':U):
    
    iLineEndOffset = iOffset + length(entry(i, pcEditorText, '~n':U)).
    
    if i = piFirstSelectedLine then
      iSelectionStart = iOffset.
    
    if i = piLastSelectedLine then
    do:
      
      iSelectionEnd = iLineEndOffset.
      leave.
      
    end. /* if i = iLine + iSelectedLines - 1 */
    
    iOffset = iLineEndOffset + length('~n':U).
    
  end. /* do i = 1 to num-entries(cEditorText, '~n':U) */
  
end. /* if    piFirstSelectedLine > 0 ... */

phEditor:screen-value = pcEditorText.

if    iSelectionStart > 0
  and iSelectionEnd   > 0 then
  phEditor:set-selection(iSelectionStart, iSelectionEnd).

end procedure. /* qg_UpdateEditor */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateFieldDataypeFilter hQueryWindow 
PROCEDURE qg_UpdateFieldDataypeFilter :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update datatype filter variable according to menu items state.             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabase               as character no-undo.
define variable cTable                  as character no-undo.

define variable cDataType               as character no-undo.
define variable cDatatTypesList         as character no-undo.
define variable cSelectedDatatTypesList as character no-undo.

define variable lOk                     as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cDatabase           = (if available(ttDatabase) then
                           ttDatabase.DatabaseName
                         else
                           '':U)
  cTable              = (if available(ttTable) then
                           ttTable.TableName
                         else
                           '':U)
  .

for each bttField
  where bttField.DatabaseName = cDatabase
    and bttField.TableName    = cTable
  break by bttField.DataType
  on error undo, throw:
  
  if first-of(bttField.DataType) then
  do:
    
    assign
      cDataType       = substitute('&1&2':U,
                                   caps(substring(bttField.DataType, 1, 1)),
                                   lc(substring(bttField.DataType, 2)))
      cDatatTypesList = substitute('&1,&2':U,
                                   cDatatTypesList,
                                   cDataType)
      .
    
    if can-do(gcFieldDatatypeFilter, cDataType) then
      cSelectedDatatTypesList   = substitute('&1,&2':U,
                                             cSelectedDatatTypesList,
                                             cDataType).
    
  end. /* if first-of(bttField.DataType) */
  
end. /* for each bttField */

assign
  cDatatTypesList         = trim(cDatatTypesList, ',':U)
  cSelectedDatatTypesList = trim(cSelectedDatatTypesList, ',':U)
  .

run qg_SelectionDialog(cDatatTypesList,
                       cDatatTypesList,
                       input-output cSelectedDatatTypesList,
                       'Select data types':U,
                       hQueryWindow,
                       no,
                       output lOk) no-error.

if lOk then
do:
    
  gcFieldDatatypeFilter = cSelectedDatatTypesList.
  
  glRefreshFieldBrowse = yes.
  run qg_RefreshFieldBrowse.
  
end. /* if lOk */

end procedure. /* qg_UpdateFieldDataypeFilter */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateFieldPopupMenu hQueryWindow 
PROCEDURE qg_UpdateFieldPopupMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Updates the label of various menu items.                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lSessionTrigger as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if giDisplayMode = {&K_DISPLAYMODE_FIELD} then
do:
  
  if available(ttField) then
  do:
    
    assign
      menu-item mi_CopyFieldName:label in menu POPUP-MENU-brField
          = substitute('Copy name (&1)':T, ttField.FieldName)
      menu-item mi_CopyFullFieldName:label in menu POPUP-MENU-brField
          = substitute('Copy name (&1)':T, substitute('&1.&2':U,
                                                      (if glSlimMode then
                                                         substitute({&K_DEFAULT_BUFFER_PATTERN},
                                                                    qg_cGetBufferBaseName(no))
                                                       else
                                                         input frame {&FRAME-NAME} gcBufferName),
                                                      ttField.FieldName))
      menu-item mi_SessionTriggerFieldAssign:label in menu POPUP-MENU-brField
          = (if can-find(first ttSessionTrigger
                           where ttSessionTrigger.TriggerEvent = 'assign':U
                             and ttSessionTrigger.DatabaseName = ttField.DatabaseName
                             and ttSessionTrigger.TableName    = ttField.TableName
                             and ttSessionTrigger.FieldName    = ttField.FieldName) then
               'Remove session trigger (assign)':T
             else
               'Add session trigger (assign)':T)
      menu-item mi_CopyFieldInitialValue:label in menu POPUP-MENU-brField
          = (if trim(ttField.FieldInitialValue) > '':U then
               substitute('Copy initial value (&1)':T, ttField.FieldInitialValue)
             else
               'Copy initial value':T)
      menu-item mi_CopyFieldFormat:label in menu POPUP-MENU-brField
          = substitute('Copy format (&1)':T, ttField.FieldFormat)
      menu-item mi_CopyFieldLabel:label in menu POPUP-MENU-brField
          = (if trim(ttField.FieldLabel) > '':U then
               substitute('Copy label (&1)':T, ttField.FieldLabel)
             else
               'Copy label':T)
      menu-item mi_CopyFieldColumnLabel:label in menu POPUP-MENU-brField
          = (if trim(ttField.FieldColumnLabel) > '':U then
               substitute('Copy column label (&1)':T, ttField.FieldColumnLabel)
             else
               'Copy column label':T)
      menu-item mi_CopyFieldDomain:label in menu POPUP-MENU-brField
          = (if trim(ttField.Domain) > '':U then
               substitute('Copy domain (&1)':T, ttField.Domain)
             else
               'Copy domain':T)
      .
    
  end. /* if available(ttField) */
  
  else
    assign
      menu-item mi_CopyFieldName:label             in menu POPUP-MENU-brField = 'Copy name':T
      menu-item mi_CopyFullFieldName:label         in menu POPUP-MENU-brField = 'Copy full name':T
      menu-item mi_SessionTriggerFieldAssign:label in menu POPUP-MENU-brField = 'Add session trigger (assign)':T
      menu-item mi_CopyFieldInitialValue:label     in menu POPUP-MENU-brField = 'Copy initial value':T
      menu-item mi_CopyFieldFormat:label           in menu POPUP-MENU-brField = 'Copy format':T
      menu-item mi_CopyFieldLabel:label            in menu POPUP-MENU-brField = 'Copy label':T
      menu-item mi_CopyFieldColumnLabel:label      in menu POPUP-MENU-brField = 'Copy column label':T
      menu-item mi_CopyFieldDomain:label           in menu POPUP-MENU-brField = 'Copy domain':T
      .
  
  lSessionTrigger = (     available ttDatabase
                          and not ttDatabase.TempDB
                      and available ttTable
                      and ttTable.PhysicalTable ).
  
  assign
    menu-item mi_CopyFieldName:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
    menu-item mi_CopyFullFieldName:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
          and ( not qg_lIsPhysicalDatabase( ttField.DatabaseName )
             or not ttField.IsVirtual )
    menu-item mi_SessionTriggerFieldAssign:sensitive in menu POPUP-MENU-brField /* code checked by mth 30.07.2015 */
        =     lSessionTrigger
          and brField:num-selected-rows > 0
          and available ttField
          and ttField.FieldExtent = 0
    menu-item mi_SessionTriggerAddFieldsAssign:sensitive in sub-menu m_SelectedFields /* code checked by mth 30.07.2015 */
        =     lSessionTrigger
          and brField:num-selected-rows > 0
    menu-item mi_SessionTriggerRemoveFieldsAssign:sensitive in sub-menu m_SelectedFields /* code checked by mth 30.07.2015 */
        =     lSessionTrigger
          and brField:num-selected-rows > 0
    menu-item mi_CopyFieldInitialValue:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
          and ttField.FieldInitialValue      <> ?
          and trim(ttField.FieldInitialValue) > '':U
    menu-item mi_CopyFieldFormat:sensitive in menu POPUP-MENU-brField /* code checked by mth */ 
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
    menu-item mi_CopyFieldLabel:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
          and ttField.FieldLabel      <> ?
          and trim(ttField.FieldLabel) > '':U
    menu-item mi_CopyFieldColumnLabel:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
          and ttField.FieldColumnLabel      <> ?
          and trim(ttField.FieldColumnLabel) > '':U
    menu-item mi_CopyFieldDomain:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     brField:num-selected-rows in frame {&FRAME-NAME} > 0
          and available(ttField)
          and ttField.Domain      <> ?
          and trim(ttField.Domain) > '':U
    sub-menu m_SelectedFields:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        = brField:num-selected-rows in frame {&FRAME-NAME} > 0
    menu-item mi_VirtualFields:sensitive in menu POPUP-MENU-brField /* code checked by mth */
        =     available ttDatabase
          and ttDatabase.VirtualDBFieldsPossible
    menu-item mi_VirtualFields:checked in menu POPUP-MENU-brField /* code checked by mth */
        =     glShowVirtualFields
    .

end. /* if giDisplayMode = {&K_DISPLAYMODE_FIELD} then */

end procedure. /* qg_UpdateFieldPopupMenu */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateIndexPopupMenu hQueryWindow 
PROCEDURE qg_UpdateIndexPopupMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Updates the label of various menu items.                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if available(ttIndex) then
  assign
    menu-item mi_CopyIndexName:label in menu POPUP-MENU-brIndex
        = substitute('Copy name (&1)':U, ttIndex.IndexName)
    menu-item mi_CopyIndexFields:label in menu POPUP-MENU-brIndex
        = substitute('Copy fields (&1)':U, ttIndex.IndexFields)
    .

else
  assign
    menu-item mi_CopyIndexName:label in menu POPUP-MENU-brIndex
        = 'Copy name':U
    menu-item mi_CopyIndexFields:label in menu POPUP-MENU-brIndex
        = 'Copy fields':U
    .

assign
  menu-item mi_CopyIndexName:sensitive in menu POPUP-MENU-brIndex /* code checked by mth */
      =     brIndex:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttIndex)
  menu-item mi_CopyIndexFields:sensitive in menu POPUP-MENU-brIndex /* code checked by mth */
      =     brIndex:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttIndex)
  menu-item mi_ModifyIndexQueryFields:sensitive in menu POPUP-MENU-brIndex /* code checked by mth */
      =     brIndex:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttIndex)
  menu-item mi_VirtualIndices:sensitive in menu POPUP-MENU-brIndex /* code checked by mth */
      =     available ttDatabase
        and ttDatabase.VirtualIndicesPossible
  menu-item mi_VirtualIndices:checked in menu POPUP-MENU-brIndex /* code checked by mth */
      =     glShowVirtualIndices
  .


end procedure. /* qg_UpdateIndexPopupMenu */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateQueryParameterVariables Method-Library
procedure qg_UpdateQueryParameterVariables :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if glSlimMode then
  assign
    glDefineBuffer            = {&K_DEFAULT_DEFINE_BUFFER}
    glExclusiveLock           = {&K_DEFAULT_EXCLUSIVE_LOCK}
    glNoError                 = {&K_DEFAULT_NO_ERROR}
    glIfStatement             = {&K_DEFAULT_IF_STATEMENT}
    glNot                     = {&K_DEFAULT_NOT}
    glDoBlock                 = {&K_DEFAULT_DO_BLOCK}
    glDefineVariables         = {&K_DEFAULT_DEFINE_VARIABLES}
    glUseVirtualIndexIncludes = {&K_DEFAULT_USE_VIRTUAL_INDEX_INCLUDES}
    glOnError                 = {&K_DEFAULT_ON_ERROR}
    giOnErrorPhrase           = {&K_DEFAULT_ON_ERROR_PHRASE}
    gcBlockName               = substitute({&K_DEFAULT_BLOCK_PATTERN}, gcBufferName)
    glDefineBlock             = {&K_DEFAULT_DEFINE_BLOCK}
    glRetryBlock              = {&K_DEFAULT_RETRY_BLOCK}
    glFinallyBlock            = {&K_DEFAULT_FINALLY_BLOCK}
    giQueryType               = {&K_DEFAULT_QUERY_TYPE}
    .

else
  
  assign
    glDefineBuffer            = input frame {&FRAME-NAME} glDefineBuffer
    glExclusiveLock           = input frame {&FRAME-NAME} glExclusiveLock
    glNoError                 = input frame {&FRAME-NAME} glNoError
    glIfStatement             = input frame {&FRAME-NAME} glIfStatement
    glNot                     = input frame {&FRAME-NAME} glNot
    glDoBlock                 = input frame {&FRAME-NAME} glDoBlock
    glDefineVariables         = input frame {&FRAME-NAME} glDefineVariables
    glUseVirtualIndexIncludes = input frame {&FRAME-NAME} glUseVirtualIndexIncludes
    glOnError                 = input frame {&FRAME-NAME} glOnError
    giOnErrorPhrase           = input frame {&FRAME-NAME} giOnErrorPhrase
    giQueryTypeModifier       = input frame {&FRAME-NAME} giQueryTypeModifier when glShowQueryTypeModifier
    gcBlockName               = input frame {&FRAME-NAME} gcBlockName
    glDefineBlock             = input frame {&FRAME-NAME} glDefineBlock
    glRetryBlock              = input frame {&FRAME-NAME} glRetryBlock
    glFinallyBlock            = input frame {&FRAME-NAME} glFinallyBlock
    giQueryType               = input frame {&FRAME-NAME} giQueryType
    .

end procedure. /* qg_UpdateQueryParameterVariables */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateQueryText hQueryWindow 
PROCEDURE qg_UpdateQueryText :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create and display query text.                                             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldList    as character no-undo.
define variable cDatabaseName as character no-undo.
define variable cTableName    as character no-undo.
define variable cIndexName    as character no-undo.
define variable cIndexFields  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndex for temp-table ttIndex.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cFieldList  = qg_cCurrentFieldList()
  gcQueryText = qg_cCreateQueryText( /* pcFieldList */ cFieldList,
                                     /* plAddTags   */ no )
  .

  /* Workaround: for some unknown reason the display statement results in the
     gcTableFilter field to loose its focus which doesnt happen if we set the
     screen-value instead.
     
     display unless-hidden
       gcQueryText
       with frame {&FRAME-NAME}.
  */

if gcQueryText:screen-value in frame {&FRAME-NAME} <> gcQueryText then
do:
  
  gcQueryText:screen-value in frame {&FRAME-NAME} = gcQueryText.
  
  if input frame {&FRAME-NAME} giDisplayMode = {&K_DISPLAYMODE_INDEX} then
    
    assign
      cIndexName   = (if available ttIndex then
                        ttIndex.IndexName
                      else
                        '':U)
      cIndexFields = (if available ttIndex then
                        ttIndex.IndexFields
                      else
                        '':U)
      gdIndexUsage = (if cIndexName > '':U then
                        100
                      else
                        0)
      .
  
  else
  do:
    
    assign
      cDatabaseName = (if available ttDatabase then
                         ttDatabase.DatabaseName
                       else
                         '':U)
      cTableName    = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                         and glInvertQuery then
                         (if available ttTableRelationView then
                            ttTableRelationView.RelatedTableName
                          else
                            '':U)
                       else
                         (if available(ttTable) then
                            ttTable.TableName
                          else
                            '':U))
      .
    
    if cFieldList > '':U then
    do:
      
      assign
        cIndexName    = qg_cQueryIndexInfo(cDatabaseName,
                                           cTableName,
                                           substitute('for each &1~n&2~n':U,
                                                      cTableName,
                                                      qg_cCreateWhereClause( /* pcDatabaseName   */ cDatabaseName,
                                                                             /* pcTableNames     */ cTableName,
                                                                             /* pcBufferNames    */ cTableName,
                                                                             /* pcFieldList      */ cFieldList,
                                                                             /* pcFieldLabelList */ ?,
                                                                             /* plStartWithWhere */ yes,
                                                                             /* piValueMode      */ {&K_VALUE_MODE_DEFAULT_VALUE},
                                                                             /* pcValueList      */ ?,
                                                                             /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                                                             /* plAddTags        */ no,
                                                                             /* piIndentBlanks   */ 2 )))
        cIndexName    = entry(num-entries(cIndexName), cIndexName)
        gdIndexUsage  = qg_dIndexUsage(cDatabaseName,
                                       cTableName,
                                       cIndexName,
                                       cFieldList)
                        * 100
        .
      
      find first bttIndex
        where bttIndex.Databasename = cDatabaseName
          and bttIndex.TableName    = cTableName
          and bttIndex.IndexName    = cIndexName
        no-error.
      
      cIndexFields = (if available bttIndex then
                        bttIndex.Indexfields
                      else
                        '':U).
      
    end. /* if cFieldList > '':U */
    
    else
    do:
      
      find first bttIndex
        where bttIndex.Databasename = cDatabaseName
          and bttIndex.TableName    = cTableName
          and bttIndex.IsPrimary    = yes
        no-error.
      
      assign
        gdIndexUsage = 0
        cIndexName   = (if available bttIndex then
                          bttIndex.IndexName
                        else
                          '':U)
        cIndexFields = (if available bttIndex then
                          bttIndex.Indexfields
                        else
                          '':U)
        .
    
    end. /* else: if cFieldList > '':U */
    
  end. /* if input frame {&FRAME-NAME} giDisplayMode = {&K_DISPLAYMODE_INDEX} */
  
  if gdIndexUsage <> input frame {&FRAME-NAME} gdIndexUsage then
    assign
      &IF {&K_COLORED_INDEX_USAGE} &THEN
        gdIndexUsage:fgcolor in frame {&FRAME-NAME}    = (if gdIndexUsage = 100 then
                                                            {&K_COLOR_GREEN}
                                                          else if gdIndexUsage > 0 then
                                                            {&K_COLOR_DARK_RED}
                                                          else
                                                            {&K_COLOR_RED})
      &ENDIF
      gdIndexUsage:screen-value in frame {&FRAME-NAME} = string(gdIndexUsage)
      .
  
  gdIndexUsage:tooltip in frame {&FRAME-NAME} = (if cIndexName > '':U then
                                                   substitute('Index used: ~'&1~' (&2)':U,
                                                              cIndexName,
                                                              cIndexFields)
                                                 else
                                                   'Index usage':U).
  
end. /* if gcQueryText:screen-value in frame {&FRAME-NAME} <> gcQueryText */

end procedure. /* qg_UpdateQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateQueryWindowView hQueryWindow 
PROCEDURE qg_UpdateQueryWindowView :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i         as integer   no-undo.

define variable cLineText as character no-undo.
define variable lLine     as logical   no-undo.
define variable cPrefix   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.
define buffer b2ttQueryWindow     for temp-table ttQueryWindow.
define buffer bttQueryLink        for temp-table ttQueryLink.
define buffer bttQueryWindowView  for temp-table ttQueryWindowView.
define buffer b2ttQueryWindowView for temp-table ttQueryWindowView.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

ghQueryWindowListWindowSeq = 0.

/* Check for new entries. */

for each bttQueryWindow
  on error undo, throw:
  
  find first bttQueryLink
    where bttQueryLink.TargetSeq = bttQueryWindow.QuerySeq
      and can-find(first ttQueryWindow
                     where ttQueryWindow.QuerySeq = bttQueryLink.SourceSeq)
    no-error.
  
  if available bttQueryLink then
    next.
  
  run qg_AddQueryWindowViewLine(buffer bttQueryWindow, ?, ?, 0).
  
end. /* for each bttQueryWindow */

/* Remove invalid entries. */

for each bttQueryWindowView
  on error undo, throw:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = bttQueryWindowView.WindowHandle
    no-error.
  
  if not available bttQueryWindow then
  do:
    
    delete bttQueryWindowView.
    next.
    
  end. /* if not available bttQueryWindow */
  
  if bttQueryWindowView.ParentWindowHandle = ? then
  do:
    
    find first bttQueryLink
      where bttQueryLink.TargetSeq = bttQueryWindow.QuerySeq
        and can-find(first ttQueryWindow
                       where ttQueryWindow.QuerySeq = bttQueryLink.SourceSeq)
      no-error.
    
    if available bttQueryLink then
    do:
      
      delete bttQueryWindowView.
      next.
      
    end. /* if can-find(first ttQueryLink */
    
  end. /* if bttQueryWindowView.ParentWindowHandle = ? */
  
  else
  do:
    
    find b2ttQueryWindow
      where b2ttQueryWindow.WindowHandle = bttQueryWindowView.ParentWindowHandle
      no-error.
    
    if not available b2ttQueryWindow then
    do:
      
      delete bttQueryWindowView.
      next.
      
    end. /* if   not available b2ttQueryWindow ... */
    
    find first bttQueryLink
      where bttQueryLink.SourceSeq = b2ttQueryWindow.QuerySeq
        and bttQueryLink.TargetSeq = bttQueryWindow.QuerySeq
        and can-find(first ttQueryWindow
                       where ttQueryWindow.QuerySeq = bttQueryLink.SourceSeq)
      no-error.
    
    if not available bttQueryLink then
    do:
      
      delete bttQueryWindowView.
      next.
      
    end. /* if not available bttQueryLink */
    
  end. /*else: if bttQueryWindowView.ParentWindowHandle = ? */
  
end. /* for each bttQueryWindowView */

/* Update structure */

for each bttQueryWindowView
  on error undo, throw:
  
  assign
    cPrefix   = '':U
    lLine     = no
    cLineText = bttQueryWindowView.LineText
    .
  
  do i = 1 to bttQueryWindowView.Depth:
    
    find first b2ttQueryWindowView
      where b2ttQueryWindowView.Root  = bttQueryWindowView.Root
        and b2ttQueryWindowView.Id    > bttQueryWindowView.Id
        and b2ttQueryWindowView.Depth < i
      no-error.
    
    lLine = can-find(first ttQueryWindowView
                       where ttQueryWindowView.Depth = i
                         and ttQueryWindowView.Root  = bttQueryWindowView.Root
                         and ttQueryWindowView.Id    > bttQueryWindowView.Id
                         and ( not available b2ttQueryWindowView
                            or ttQueryWindowView.Id  < b2ttQueryWindowView.Id )).
    
    if i >= bttQueryWindowView.Depth then
      leave.
    
    cPrefix = substitute('&1&2':U,
                         cPrefix,
                         (if lLine then
                            gcLineVertical
                          else
                            gcSpace)).
    
  end. /* do i = 1 to bttQueryWindowView.Depth - 1 */
  
  find first b2ttQueryWindowView
    where b2ttQueryWindowView.Id > bttQueryWindowView.Id
    no-error.
  
  bttQueryWindowView.LineText = substitute('&1&2&3   &4':U,
                                           cPrefix,
                                           (if bttQueryWindowView.Depth >= 1 then
                                              (if lLine then
                                                 gcLineVerticalAndRight
                                               else
                                                 gcLineUpAndRight)
                                            else
                                              '':U),
                                           (if    bttQueryWindowView.Depth = 0 then
                                              gcBulletChar2
                                              /*
                                              (if bttQueryWindowView.WindowHandle:visible then
                                                 gcBulletChar2
                                               else
                                                 gcBulletChar2White)
                                              */
                                            else if not glUnicode then
                                              substitute(' &1':U, gcBulletChar1)
                                            else
                                              gcBulletChar1
                                              /*
                                              (if bttQueryWindowView.WindowHandle:visible then
                                                 gcBulletChar1
                                               else
                                                 gcBulletChar1White)
                                              */
                                              ),
                                           cLineText).
  
end. /* for each bttQueryWindowView */

end procedure. /* qg_UpdateQueryWindowView */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateRecordField hQueryWindow 
PROCEDURE qg_UpdateRecordField :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update given record field temp-table entry.                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phField                        = Field handle that contains the values.    */
/* piIndex                        = Field index that should be updated.       */
/* phBuffer                       = Buffer that should be updated.            */
/* plDeep                         = Deep resolve Object id field overlay      */
/*                                  values.                                   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phField  as handle    no-undo.
define input parameter piIndex  as integer   no-undo.
define input parameter phBuffer as handle    no-undo.
define input parameter plDeep   as logical   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable clUnformattedValue as longchar  no-undo.
define variable clFormattedValue   as longchar  no-undo.

define variable hBuffer            as handle    no-undo.
define variable cKeyValues         as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttFieldOverlay for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if valid-handle( phField ) then
  
  if not phField:available then
    
    assign
      clUnformattedValue = '?':U
      clFormattedValue   = '?':U
      .
  
  else
    
    case phField:data-type:
    
      when 'CLOB':U then
      do:
        
        copy-lob phField:buffer-value(piIndex)
          to clUnformattedValue no-error.
          
        clFormattedValue = clUnformattedValue.
        
      end. /* when 'CLOB':U */
      
      otherwise
        
        assign
          clUnformattedValue = string(phField:buffer-value(piIndex))
          clFormattedValue   = trim(phField:string-value(piIndex))
          no-error.
      
    end case. /* hField:data-type */

else
do:
  
  if    phBuffer::IsVirtual
    and phBuffer:available
    and valid-handle( handle( phBuffer::BufferHandle ) )
    and phBuffer::BufferHandle:available then
    
    assign
      clUnformattedValue = qg_clVirtualFieldValueAsLongchar( phBuffer::FieldType,
                                                             phBuffer::DataType,
                                                             phBuffer::FieldName,
                                                             qg_cObjectIdForBuffer( phBuffer::BufferHandle ),
                                                             string( ? ) )
      clFormattedValue   = qg_clVirtualFieldValueAsLongchar( phBuffer::FieldType,
                                                             phBuffer::DataType,
                                                             phBuffer::FieldName,
                                                             qg_cObjectIdForBuffer( phBuffer::BufferHandle ),
                                                             phBuffer::FieldFormat )
      .
    
  else
    
    assign
      clUnformattedValue = '?':U
      clFormattedValue   = '?':U
      .
  
end. /* else: if valid-handle( phField ) */

if phBuffer::IsOverlay then
do:
  
  phBuffer::IsOverlayResolved = no.
  
  if    clUnformattedValue > '':U
    and num-entries(clUnformattedValue, ':':U) = 3 then
  do:
  
    hBuffer = phBuffer::BufferHandle.
    
    if valid-handle(hBuffer) then
    do:
      
      find bttFieldOverlay
        where bttFieldOverlay.OwnerHandle = hBuffer:query
          and bttFieldOverlay.BufferName  = hBuffer:name
          and bttFieldOverlay.FieldName   = ( if valid-handle( phField ) then
                                                phField:name
                                              else
                                                phBuffer::FieldName )
          and bttFieldOverlay.FieldIndex  = piIndex
        no-error.
      
      if available bttFieldOverlay then
      do:
      
        cKeyValues = qg_cOverlayFieldValue(buffer bttFieldOverlay,
                                           string(clUnformattedValue),
                                           plDeep).
        
        if cKeyValues <> ? then
          assign
            clUnformattedValue          = cKeyValues
            phBuffer::IsOverlayResolved = yes
            .
        
      end. /* if available bttFieldOverlay */
      
    end. /* if valid-handle(hBuffer) */

  end. /* if    clUnformattedValue > '':U ... */
  
  clFormattedValue = clUnformattedValue.

end. /* if phBuffer::IsOverlay */

copy-lob clUnformattedValue
  to phBuffer::CurrentUnformattedValue no-error.

copy-lob clFormattedValue
  to phBuffer::CurrentFormattedValue no-error.

end procedure. /* qg_UpdateRecordField */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_QueryWindowUpdateFieldTempTable hQueryWindow 
PROCEDURE qg_QueryWindowUpdateFieldTempTable :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Refresh entire record field temp-table. Returns yes, if the field records  */
/* have been rebuilt. If only field values have been updated the return value */
/* will be no.                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phQuery                        = Query or buffer handle that contains the  */
/*                                  record(s) that should be used for the up- */
/*                                  date.                                     */
/* phWindow                       = Window handle of the record field         */
/*                                  window.                                   */
/* pcFieldList                    = Field list to determine field order. If   */
/*                                  empty then all fields will be displayed   */
/*                                  in alphabetical order.                    */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phQuery     as handle    no-undo.
define input parameter phWindow    as handle    no-undo.
define input parameter pcFieldList as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iBuffer       as integer   no-undo.
define variable hBuffers      as handle    no-undo extent.

define variable iField        as integer   no-undo.
define variable hField        as handle    no-undo.
define variable iIndex        as integer   no-undo.
define variable cDatabaseName as character no-undo.

define variable cFieldList    as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindowField  for temp-table ttQueryWindowField.
define buffer b2ttQueryWindowField for temp-table ttQueryWindowField.

define buffer bttField             for temp-table ttField.
define buffer bttFieldOverlay      for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phQuery) then
  leave.

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = phWindow
  on error undo, throw:
  
  delete bttQueryWindowField.
  
end. /* for each bttQueryWindowField */

case phQuery:type:
  
  when 'BUFFER':U then
    assign
      extent(hBuffers) = 1
      hBuffers[1]      = phQuery
      .
  
  when 'QUERY':U then
  do:
    
    if phQuery:num-buffers = 0 then
      leave.
    
    extent(hBuffers) = phQuery:num-buffers.
    
    do iBuffer = 1 to extent(hBuffers):
      
      hBuffers[iBuffer] = phQuery:get-buffer-handle(iBuffer).
      
    end. /* do iBuffer = 1 to extent(hBuffers) */
    
  end. /* when 'QUERY':U */
  
end case. /* phQuery:type */

do iBuffer = 1 to extent(hBuffers):
  
  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hBuffers[iBuffer] ).
  
  if    cDatabaseName = '':u
     or cDatabaseName = ? then
    
    cDatabaseName = hBuffers[iBuffer]:dbname.
  
  for each bttField
    where bttField.DatabaseName = cDatabaseName
      and bttField.TableName    = hBuffers[iBuffer]:table
    on error undo, throw:
    
    do iIndex = integer(bttField.FieldExtent > 0) to bttField.FieldExtent:
      
      if not can-find(ttQueryWindowField
                        where ttQueryWindowField.WindowHandle = phWindow
                          and ttQueryWindowField.BufferId     = iBuffer
                          and ttQueryWindowField.FieldName    = bttField.FieldName
                          and ttQueryWindowField.FieldIndex   = iIndex
                          and ttQueryWindowField.IsOverlay    = no) then
      do:
        
        hField = hBuffers[iBuffer]:buffer-field(bttField.FieldName) no-error.
        
        if error-status:error then
          
          hField = ?.
        
        create bttQueryWindowField.
        
        assign
          bttQueryWindowField.WindowHandle = phWindow
          bttQueryWindowField.BufferId     = iBuffer
          bttQueryWindowField.DatabaseName = cDatabaseName
          bttQueryWindowField.TableName    = bttField.TableName
          bttQueryWindowField.BufferName   = hBuffers[iBuffer]:name
          bttQueryWindowField.FieldName    = bttField.FieldName
          bttQueryWindowField.BufferHandle = hBuffers[iBuffer]
          bttQueryWindowField.FieldHandle  = hField
          bttQueryWindowField.FieldIndex   = iIndex
          bttQueryWindowField.FieldLabel   = bttField.FieldLabel
          bttQueryWindowField.DisplayName  = qg_cFormattedFieldName(?,
                                                                    (if extent(hBuffers) > 1 then
                                                                       hBuffers[iBuffer]:name
                                                                     else
                                                                       ?),
                                                                    bttField.FieldName,
                                                                    iIndex)
          bttQueryWindowField.DataType     = bttField.DataType
          bttQueryWindowField.FieldFormat  = bttField.FieldFormat
          bttQueryWindowField.FieldViewAs  = bttField.FieldViewAs
          bttQueryWindowField.FieldType    = bttField.FieldType
          bttQueryWindowField.IsVirtual    = bttField.IsVirtual
          bttQueryWindowField.IsObjectId   = bttField.IsObjectId
          bttQueryWindowField.Order        = ( if pcFieldList > '':U then
                                                 lookup( qg_cFormattedFieldName( ?,
                                                                                 hBuffers[iBuffer]:name,
                                                                                 bttField.FieldName,
                                                                                 iIndex ),
                                                         pcFieldList )
                                               else if    not bttField.IsVirtual
                                                       or glShowVirtualFields then
                                                 1
                                               else
                                                 0 )
          .
        
        validate bttQueryWindowField.
        
      end. /* if not can-find(ttQueryWindowField */
      
    end. /* do iIndex = integer(bttField.FieldExtent > 0) to bttField.FieldExtent */
    
  end. /* for each bttField */
  
end. /* do iBufferIndex = 1 to hQuery:num-buffers */

run qg_QueryWindowCreateFieldTempTableOverlayEntries( phWindow, pcFieldList).

end procedure. /* qg_QueryWindowUpdateFieldTempTable */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateRecordFieldDisplayValue hQueryWindow 
PROCEDURE qg_UpdateRecordFieldDisplayValue :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update display value for given temp-table record.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phbuffer                       = Buffer that contains the record that      */
/*                                  should be updated.                        */
/* plRawValue                     = Flag to indicate if the raw value or the  */
/*                                  formatted value should be displayed.      */
/* piMaxChars                     = Maximum number of chars that should be    */
/*                                  displayed.                                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter phBuffer   as handle    no-undo.
define input parameter plRawValue as logical   no-undo.
define input parameter piMaxChars as integer   no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable clValue as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if plRawValue then
  copy-lob phBuffer::CurrentUnformattedValue to clValue.

else
  copy-lob phBuffer::CurrentFormattedValue to clValue.

phBuffer::CurrentDisplayValue = (if length(clValue) > piMaxChars then
                                   substitute('&1 ...':U,
                                              substring(clValue,
                                                        1, piMaxChars - 4))
                                 else
                                   clValue).

end procedure. /* qg_UpdateRecordFieldDisplayValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateRelationPopupMenu hQueryWindow 
PROCEDURE qg_UpdateRelationPopupMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Updates the label of various menu items.                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if available(ttTableRelationView) then
  assign
    menu-item mi_CopyRelationTable:label in menu POPUP-MENU-brRelation
        = substitute('Copy table (&1)':U, ttTableRelationView.RelatedTableName)
    menu-item mi_CopyRelationFields:label in menu POPUP-MENU-brRelation
        = substitute('Copy fields (&1)':U, ttTableRelationView.RelatedFields)
    menu-item mi_SwitchToRelatedTable:label in menu POPUP-MENU-brRelation
        = substitute('Swtich to related table (&1)':U, ttTableRelationView.RelatedTableName)
    .

else
  assign
    menu-item mi_CopyRelationTable:label in menu POPUP-MENU-brRelation
        = 'Copy table':U
    menu-item mi_CopyRelationFields:label in menu POPUP-MENU-brRelation
        = 'Copy fields':U
    menu-item mi_SwitchToRelatedTable:label in menu POPUP-MENU-brRelation
        = 'Swtich to related table':U
    .

assign
  menu-item mi_CopyRelationTable:sensitive in menu POPUP-MENU-brRelation /* code checked by mth */
      =     brRelation:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTableRelationView)
  menu-item mi_CopyRelationFields:sensitive in menu POPUP-MENU-brRelation /* code checked by mth */
      =     brRelation:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTableRelationView)
  menu-item mi_ModifyRelationQueryFields:sensitive in menu POPUP-MENU-brRelation /* code checked by mth */
      =     brRelation:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTableRelationView)
  menu-item mi_SwitchToRelatedTable:sensitive in menu POPUP-MENU-brRelation /* code checked by mth */
      =     brRelation:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTableRelationView)
  menu-item mi_ShowChildRelations:checked in menu POPUP-MENU-brRelation
      = glShowChildRelations.
  menu-item mi_ShowParentRelations:checked in menu POPUP-MENU-brRelation
      = glShowParentRelations
  .

end procedure. /* qg_UpdateRelationPopupMenu */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_UpdateTablePopupMenu hQueryWindow 
PROCEDURE qg_UpdateTablePopupMenu :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Updates the labels of various menu items.                                  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cCompanyInclude as character no-undo.
define variable lCompanyInclude as logical   no-undo.
define variable cKeyInclude     as character no-undo.
define variable lKeyInclude     as logical   no-undo.
define variable cFillInclude    as character no-undo.
define variable lFillInclude    as logical   no-undo.

define variable lSessionTrigger as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not available(ttTable) then
  assign
    menu-item mi_CopyTableName:label in menu POPUP-MENU-brTable
        = 'Copy name':T
    menu-item mi_CopyTableDefineBuffer:label in menu POPUP-MENU-brTable
        = (if glInsertMode then
             'Insert "define buffer"':T
           else
             'Copy "define buffer"':T)
    sub-menu m_TableCreateTrigger:label in menu POPUP-MENU-brTable
        = 'Create trigger':T
    sub-menu m_TableWriteTrigger:label in menu POPUP-MENU-brTable
        = 'Write trigger':T
    sub-menu m_TableDeleteTrigger:label in menu POPUP-MENU-brTable
        = 'Delete trigger':T
    sub-menu m_TableCompanyInclude:label in menu POPUP-MENU-brTable
        = 'Company include':T
    sub-menu m_TableKeyInclude:label in menu POPUP-MENU-brTable
        = 'Key include':T
    sub-menu m_TableFillInclude:label in menu POPUP-MENU-brTable
        = 'Fill include':T
    menu-item mi_SessionTriggerCreate:label in menu POPUP-MENU-brTable
        = 'Add session trigger (create)':T
    menu-item mi_SessionTriggerWrite:label in menu POPUP-MENU-brTable
        = 'Add session trigger (write)':T
    menu-item mi_SessionTriggerDelete:label in menu POPUP-MENU-brTable
        = 'Add session trigger (delete)':T
    menu-item mi_SessionTriggerFind:label in menu POPUP-MENU-brTable
        = 'Add session trigger (find)':T
    .

else
do:
  
  assign
    cCompanyInclude = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                       ttTable.CompanyInclude)
    cKeyInclude     = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                       ttTable.KeyInclude)
    cFillInclude    = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                       ttTable.FillInclude)
    no-error.

  assign
    lCompanyInclude = (search(cCompanyInclude) <> ?)
    lKeyInclude     = (search(cKeyInclude) <> ?)
    lFillInclude    = (search(cFillInclude) <> ?)
    gcBufferName    = (if glSlimMode then
                         substitute({&K_DEFAULT_BUFFER_PATTERN},
                                    qg_cGetBufferBaseName(no))
                       else
                         input frame {&FRAME-NAME} gcBufferName)
    .
  
  assign
    menu-item mi_CopyTableName:label in menu POPUP-MENU-brTable
        = substitute('Copy name (&1)':T, gcBufferName)
    menu-item mi_CopyTableDefineBuffer:label in menu POPUP-MENU-brTable
        = (if glInsertMode then
             substitute('Insert "define buffer &1 ..."':T, gcBufferName)
           else
             substitute('Copy "define buffer &1 ..."':T, gcBufferName))
    sub-menu m_TableCreateTrigger:label in menu POPUP-MENU-brTable
        = (if trim(ttTable.CreateTriggerProcName) > '':U then
             substitute('Create trigger (&1)':T, ttTable.CreateTriggerProcName)
           else
             'Create trigger':U)
    sub-menu m_TableWriteTrigger:label in menu POPUP-MENU-brTable
        = (if trim(ttTable.WriteTriggerProcName) > '':U then
             substitute('Write trigger (&1)':T, ttTable.WriteTriggerProcName)
           else
             'Write trigger':T)
    sub-menu m_TableDeleteTrigger:label in menu POPUP-MENU-brTable
        = (if trim(ttTable.DeleteTriggerProcName) > '':U then
             substitute('Delete trigger (&1)':T, ttTable.DeleteTriggerProcName)
           else
             'Delete trigger':T)
    sub-menu m_TableCompanyInclude:label in menu POPUP-MENU-brTable
        = (if trim(ttTable.CompanyInclude) > '':U then
             substitute('Company include (&1)':T, ttTable.CompanyInclude)
           else
             'Company include':T)
    sub-menu m_TableKeyInclude:label in menu POPUP-MENU-brTable
        = (if trim(ttTable.KeyInclude) > '':U then
             substitute('Key include (&1)':T, ttTable.KeyInclude)
           else
             'Key include':T)
    sub-menu m_TableFillInclude:label in menu POPUP-MENU-brTable
        = (if trim(ttTable.FillInclude) > '':U then
             substitute('Fill include (&1)':T, ttTable.FillInclude)
           else
             'Fill include':T)
    menu-item mi_SessionTriggerCreate:label in menu POPUP-MENU-brTable
        = (if can-find(ttSessionTrigger
                         where ttSessionTrigger.TriggerEvent = 'create':U
                           and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                           and ttSessionTrigger.TableName    = ttTable.TableName
                           and ttSessionTrigger.FieldName    = '':U) then
             'Remove session trigger (create)':T
           else
             'Add session trigger (create)':T)
    menu-item mi_SessionTriggerWrite:label in menu POPUP-MENU-brTable
        = (if can-find(ttSessionTrigger
                         where ttSessionTrigger.TriggerEvent = 'write':U
                           and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                           and ttSessionTrigger.TableName    = ttTable.TableName
                           and ttSessionTrigger.FieldName    = '':U) then
             'Remove session trigger (write)':T
           else
             'Add session trigger (write)':T)
    menu-item mi_SessionTriggerDelete:label in menu POPUP-MENU-brTable
        = (if can-find(ttSessionTrigger
                         where ttSessionTrigger.TriggerEvent = 'delete':U
                           and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                           and ttSessionTrigger.TableName    = ttTable.TableName
                           and ttSessionTrigger.FieldName    = '':U) then
             'Remove session trigger (delete)':T
           else
             'Add session trigger (delete)':T)
    menu-item mi_SessionTriggerFind:label in menu POPUP-MENU-brTable
        = (if can-find(ttSessionTrigger
                         where ttSessionTrigger.TriggerEvent = 'find':U
                           and ttSessionTrigger.DatabaseName = ttTable.DatabaseName
                           and ttSessionTrigger.TableName    = ttTable.TableName
                           and ttSessionTrigger.FieldName    = '':U) then
             'Remove session trigger (find)':T
           else
             'Add session trigger (find)':T)
    .
  
end. /* else: if not available(ttTable) */

lSessionTrigger = (     available ttDatabase
                    and not ttDatabase.TempDB
                    and available ttTable
                    and ttTable.PhysicalTable ).


assign
  menu-item mi_CopyTableName:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
  menu-item mi_CopyTableDefineBuffer:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      = available(ttTable)
  sub-menu m_TableCreateTrigger:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and ttTable.CreateTriggerProcName      <> ?
        and trim(ttTable.CreateTriggerProcName) > '':U
  menu-item mi_OpenTableCreateTrigger:sensitive in sub-menu m_TableCreateTrigger /* code checked by mth */
      =     available ttTable
        and search(ttTable.CreateTrigger) <> ?
  sub-menu m_TableWriteTrigger:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and ttTable.WriteTriggerProcName      <> ?
        and trim(ttTable.WriteTriggerProcName) > '':U
  menu-item mi_OpenTableWriteTrigger:sensitive in sub-menu m_TableWriteTrigger /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available ttTable
        and search(ttTable.WriteTrigger) <> ?
  sub-menu m_TableDeleteTrigger:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and ttTable.DeleteTriggerProcName      <> ?
        and trim(ttTable.DeleteTriggerProcName) > '':U
  menu-item mi_OpenTableDeleteTrigger:sensitive in sub-menu m_TableDeleteTrigger /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available ttTable
        and search(ttTable.DeleteTrigger) <> ?
  sub-menu  m_TableCompanyInclude:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and ttTable.CompanyInclude             <> ?
        and trim(ttTable.CompanyInclude)        > '':U
  menu-item mi_CopyTableCompanyIncludeReference:sensitive in sub-menu m_TableCompanyInclude /* code checked by mth */
      = lCompanyInclude
  menu-item mi_OpenTableCompanyInclude:sensitive in sub-menu m_TableCompanyInclude /* code checked by mth */
      = lCompanyInclude
  sub-menu  m_TableKeyInclude:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and ttTable.KeyInclude                 <> ?
        and trim(ttTable.KeyInclude)            > '':U
  menu-item mi_CopyTableKeyIncludeReference:sensitive in sub-menu m_TableKeyInclude /* code checked by mth */
      = lKeyInclude
  menu-item mi_OpenTableKeyInclude:sensitive in sub-menu m_TableKeyInclude /* code checked by mth */
      = lKeyInclude
  sub-menu  m_TableFillInclude:sensitive in menu POPUP-MENU-brTable /* code checked by mth */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and ttTable.FillInclude                <> ?
        and trim(ttTable.FillInclude)           > '':U
  menu-item mi_CopyTableFillIncludeReference:sensitive in sub-menu m_TableFillInclude /* code checked by mth */
      = lFillInclude
  menu-item mi_OpenTableFillInclude:sensitive in sub-menu m_TableFillInclude /* code checked by mth */
      = lFillInclude
  menu-item mi_SessionTriggerCreate:sensitive in menu POPUP-MENU-brTable /* code checked by mth 31.10.2014 */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and lSessionTrigger
  menu-item mi_SessionTriggerWrite:sensitive in menu POPUP-MENU-brTable /* code checked by mth 31.10.2014 */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and lSessionTrigger
  menu-item mi_SessionTriggerDelete:sensitive in menu POPUP-MENU-brTable /* code checked by mth 31.10.2014 */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and lSessionTrigger
  menu-item mi_SessionTriggerFind:sensitive in menu POPUP-MENU-brTable /* code checked by mth 31.10.2014 */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and lSessionTrigger
  menu-item mi_AddSnapshotBtn:sensitive in menu POPUP-MENU-brTable /* code checked by mth 31.10.2014 */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and not ttTable.Snapshot
  menu-item mi_RemoveTable:sensitive in menu POPUP-MENU-brTable /* code checked by mth 31.10.2014 */
      =     brTable:num-selected-rows in frame {&FRAME-NAME} > 0
        and available(ttTable)
        and not ttTable.PhysicalTable
  .

end procedure. /* qg_UpdateTablePopupMenu */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_WidgetState hQueryWindow 
PROCEDURE qg_WidgetState :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Update sensitive state for all widgets.                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcWidgets                      = Matchcodelist of widgets that should be   */
/*                                  updated.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pcWidgets as character no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lVirtualIndex as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

lVirtualIndex = (     giDisplayMode = {&K_DISPLAYMODE_INDEX}
                  and available ttIndex
                  and ttIndex.IsVirtual ).

if glSlimMode then
  assign
    giQueryType               = {&K_DEFAULT_QUERY_TYPE}
    glNoError                 = {&K_DEFAULT_NO_ERROR}
    glIfStatement             = {&K_DEFAULT_IF_STATEMENT}
    glUseVirtualIndexIncludes = {&K_DEFAULT_USE_VIRTUAL_INDEX_INCLUDES}
    gcBufferName              = substitute({&K_DEFAULT_BUFFER_PATTERN},
                                           qg_cGetBufferBaseName(no))
    gcBlockName               = substitute({&K_DEFAULT_BLOCK_PATTERN},
                                           gcBufferName)
    glOnError                 = {&K_DEFAULT_ON_ERROR}
    giOnErrorPhrase           = {&K_DEFAULT_ON_ERROR_PHRASE}
    .

else
  assign
    giQueryType               = input frame {&FRAME-NAME} giQueryType
    glNoError                 = input frame {&FRAME-NAME} glNoError
    glIfStatement             = input frame {&FRAME-NAME} glIfStatement
    glUseVirtualIndexIncludes = input frame {&FRAME-NAME} glUseVirtualIndexIncludes
    gcBlockName               = input frame {&FRAME-NAME} gcBlockName
    glOnError                 = input frame {&FRAME-NAME} glOnError
    giOnErrorPhrase           = input frame {&FRAME-NAME} giOnErrorPhrase
    .

assign
  btnExecuteQuery:sensitive in frame {&FRAME-NAME}
      = not lVirtualIndex
        when can-do(pcWidgets, btnExecuteQuery:name)
  menu-item mi_ExecuteQuery:sensitive in sub-menu m_Tools
      = btnExecuteQuery:sensitive in frame {&FRAME-NAME}
      when can-do(pcWidgets, 'mi_ExecuteQuery':U)
  glExclusiveLock:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (    giQueryType <> {&K_QUERYTYPE_CANFIND}
         and (not available(ttDatabase)
           or not ttDatabase.TempDB))
  glNoError:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (giQueryType = {&K_QUERYTYPE_FINDFIRST})
        when can-do(pcWidgets, glNoError:name)
  glIfStatement:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (giQueryType = {&K_QUERYTYPE_CANFIND})
        when can-do(pcWidgets, glIfStatement:name)
  glNot:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (   giQueryType = {&K_QUERYTYPE_CANFIND}
         or (    giQueryType = {&K_QUERYTYPE_FINDFIRST}
            and glNoError))
        when can-do(pcWidgets, glNot:name)
  glDoBlock:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = ((    giQueryType = {&K_QUERYTYPE_FINDFIRST}
          and glNoError)
            or (  giQueryType = {&K_QUERYTYPE_CANFIND}
              and glIfStatement))
        when can-do(pcWidgets, glDoBlock:name)
  glDefineVariables:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = ( lVirtualIndex
            and ( not glUseVirtualIndexApi
               or not glUseVirtualIndexIncludes ) )
        when can-do(pcWidgets, glDefineVariables:name)
  glUseVirtualIndexIncludes:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (     lVirtualIndex
          and glUseVirtualIndexApi )
        when can-do(pcWidgets, glNoError:name)
  glOnError:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (giQueryType = {&K_QUERYTYPE_FOREACH})
        when can-do(pcWidgets, glOnError:name)
  giOnErrorPhrase:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      =   ( glOnError
        and giQueryType = {&K_QUERYTYPE_FOREACH} )
        when can-do(pcWidgets, giOnErrorPhrase:name)
  gcBlockName:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = ( giQueryType = {&K_QUERYTYPE_FOREACH}
            and ( not lVirtualIndex
               or not glUseVirtualIndexApi ) )
        when can-do(pcWidgets, gcBlockName:name)
  btnClearBlockName:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = gcBlockName:sensitive in frame {&FRAME-NAME}
        when can-do(pcWidgets, btnClearBlockName:name)
  btnBlock1:sensitive in frame {&FRAME-NAME}  /* code checked by mth */
      = gcBlockName:sensitive in frame {&FRAME-NAME}
        when can-do(pcWidgets, btnBlock1:name)
  btnBlock2:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = gcBlockName:sensitive in frame {&FRAME-NAME}
        when can-do(pcWidgets, btnBlock2:name)
  btnBlock3:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = gcBlockName:sensitive in frame {&FRAME-NAME}
        when can-do(pcWidgets, btnBlock3:name)
  btnBlock4:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = gcBlockName:sensitive in frame {&FRAME-NAME}
        when can-do(pcWidgets, btnBlock4:name)
  glDefineBlock:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (    gcBlockName:sensitive in frame {&FRAME-NAME}
         and gcBlockName > '':U)
        when can-do(pcWidgets, glDefineBlock:name)
  glRetryBlock:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (    giQueryType     = {&K_QUERYTYPE_FOREACH}
         and glOnError
         and giOnErrorPhrase = {&K_ON_ERROR_PHRASE_RETRY})
        when can-do(pcWidgets, glRetryBlock:name)
  glFinallyBlock:sensitive in frame {&FRAME-NAME} /* code checked by mth */
      = (giQueryType = {&K_QUERYTYPE_FOREACH})
        when can-do(pcWidgets, glFinallyBlock:name)
  .

if glInsertMode then
do:
  
  assign
    btnCopyToClipboard:label in frame {&FRAME-NAME}
        = 'Insert':T
        when can-do(pcWidgets, btnCopyToClipboard:name)
    btnCopyToClipboard:tooltip in frame {&FRAME-NAME}
        = 'Insert query text into active text editor (Ctrl+Ins)':T 
        when can-do(pcWidgets, btnCopyToClipboard:name)
    menu-item mi_CopyTableCompanyIncludeReference:label in sub-menu m_TableCompanyInclude
        = 'Insert include reference':T
        when can-do(pcWidgets, 'mi_CopyTableCompanyIncludeReference':U)
    menu-item mi_CopyTableKeyIncludeReference:label in sub-menu m_TableKeyInclude
        = 'Insert include reference':T
        when can-do(pcWidgets, 'mi_CopyTableKeyIncludeReference':U)
    menu-item mi_CopyTableFillIncludeReference:label in sub-menu m_TableFillInclude
        = 'Insert include reference':T
        when can-do(pcWidgets, 'mi_CopyTableFillIncludeReference':U)
    menu-item mi_CopyFieldAssignStatement:label in sub-menu m_SelectedFields
        = 'Insert assign statement':T
        when can-do(pcWidgets, 'mi_CopyFieldAssignStatement':U)
    menu-item mi_CopyFieldAssignments:label in sub-menu m_SelectedFields
        = 'Insert field assignments':T
        when can-do(pcWidgets, 'mi_CopyFieldAssignments':U)
    menu-item mi_CopyPutStatement:label in sub-menu m_SelectedFields
        = 'Insert put statement':T
        when can-do(pcWidgets, 'mi_CopyPutStatement':U)
    .
  
end. /* if glInsertMode */

else
do:
  
  assign
    btnCopyToClipboard:label in frame {&FRAME-NAME}
        = 'Copy':T
        when can-do(pcWidgets, btnCopyToClipboard:name)
    btnCopyToClipboard:tooltip in frame {&FRAME-NAME}
        = 'Copy query text to clipboard (Ctrl+Ins)':T
        when can-do(pcWidgets, btnCopyToClipboard:name)
    menu-item mi_CopyTableCompanyIncludeReference:label in sub-menu m_TableCompanyInclude
        = 'Copy include reference':T
        when can-do(pcWidgets, 'mi_CopyTableCompanyIncludeReference':U)
    menu-item mi_CopyTableKeyIncludeReference:label in sub-menu m_TableKeyInclude
        = 'Copy include reference':T
        when can-do(pcWidgets, 'mi_CopyTableKeyIncludeReference:label':U)
    menu-item mi_CopyTableFillIncludeReference:label in sub-menu m_TableFillInclude
        = 'Copy include reference':T
        when can-do(pcWidgets, 'mi_CopyTableFillIncludeReference':U)
    menu-item mi_CopyFieldAssignStatement:label in sub-menu m_SelectedFields
        = 'Copy assign statement':T
        when can-do(pcWidgets, 'mi_CopyFieldAssignStatement':U)
    menu-item mi_CopyFieldAssignments:label in sub-menu m_SelectedFields
        = 'Copy field assignments':T
        when can-do(pcWidgets, 'mi_CopyFieldAssignments':U)
    menu-item mi_CopyPutStatement:label in sub-menu m_SelectedFields
        = 'Copy put statement':T
        when can-do(pcWidgets, 'mi_CopyPutStatement':U)
    .
  
end. /* else: if glInsertMode */

end procedure. /* qg_WidgetState */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_WriteExportLine hQueryWindow 
PROCEDURE qg_WriteExportLine :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write given string to the export file.                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* Stream strExport must be open before you call this procedure.              */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pclLine                        = Text line that should be written.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pclLine as longchar  no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do while yes:
   
  put stream strExport unformatted string(substring(pclLine, (i * 2000) + 1, 2000)).
  
  if (i * 2000) + 2000 > length(pclLine) then
    leave.
  
  i = i + 1.
  
end. /* do while yes */

end procedure. /* qg_WriteExportLine */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_WriteLongcharToClipboard hQueryWindow 
PROCEDURE qg_WriteLongcharToClipboard :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write given string to clipboard.                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pclString                      = String that should be written to          */
/*                                  clipboard.                                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

define input parameter pclString as longchar  no-undo.

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iStringLength  as integer   no-undo.
define variable iChunkSize     as integer   no-undo initial 30000.
define variable iChunkCount    as integer   no-undo.
define variable iChunkCounter  as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  iStringLength = length( pclString )
  iChunkCount   = ( if iStringLength mod iChunkSize = 0 then
                      iStringLength / iChunkSize
                    else
                      truncate( iStringLength / iChunkSize, 0 ) + 1 )
  .

do on error undo, throw:
  
  output stream strClipboard to 'clipboard':U
    convert target 'UTF-8':U.
  
  do iChunkCounter = 0 to iChunkCount - 1:
    
    put stream strClipboard unformatted
      string( substring( pclString,
                         iChunkCounter * iChunkSize + 1,
                         iChunkSize ) )
      .
    
  end. /* do iChunkCounter = 1 to iChunkCount */
  
  finally:
    
    output stream strClipboard close.
    
  end finally.
  
end.

end procedure. /* qg_WriteLongcharToClipboard */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE qg_WriteSessionTriggerProc Method-Library
procedure qg_WriteSessionTriggerProc :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define input parameter piTriggerId as integer   no-undo.

define variable cTableName as character no-undo.
define variable cFieldName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

define buffer bttTable          for temp-table ttTable.
define buffer bttField          for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  return ?.

output stream strSeTrigger to value(bttSessionTrigger.TriggerFileName).

put stream strSeTrigger unformatted
  'define variable ghQueryGenerator as handle    no-undo.':U skip
  'define variable gcAdditionalInfo as character no-undo.':U skip
  ' ':U skip
  substitute('ghQueryGenerator = handle(~'&1~':U).':U,
             string(this-procedure)) skip
  ' ':U skip
  .

if bttSessionTrigger.TriggerEvent = 'assign':U then
do:
  
  find bttTable
    where bttTable.DatabaseName = bttSessionTrigger.DatabaseName
      and bttTable.TableName    = bttSessionTrigger.TableName
    no-error.
  
  if available bttTable then
  do:
    
    if not bttTable.DetailsLoaded then
      
      run qg_AddTableDetails( bttTable.DatabaseName,
                              bttTable.TableName ).
    
    find first bttField
      where bttField.DatabaseName = bttTable.DatabaseName
        and bttField.TableName    = bttTable.TableName
        and bttField.FieldName    = bttSessionTrigger.FieldName
      no-error.
    
    if    available bttField
      and bttField.IsVirtual
      and bttField.FieldType = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
      
      assign
        cTableName = dynamic-invoke( qg_oVirtualDBFieldDataFieldApiInstance(),
                                     'cTableNameByDataType':U,
                                     bttField.DataType )
        cFieldName = 'FieldValue':U
        .
      
    else
      
      assign
        cTableName = bttSessionTrigger.TableName
        cFieldName = bttSessionTrigger.FieldName
        .
    
  end. /* if available bttTable */
  
end. /* if bttSessionTrigger.TriggerEvent = 'assign':U */

case bttSessionTrigger.TriggerEvent:
  
  when 'create':U then
    put stream strSeTrigger unformatted
      substitute('on &1 of &2.&3':U,
                 bttSessionTrigger.TriggerEvent,
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 .
  
  when 'delete':U then
    put stream strSeTrigger unformatted
      substitute('on &1 of &2.&3':U,
                 bttSessionTrigger.TriggerEvent,
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 .
  
  when 'assign':U then
    
    put stream strSeTrigger unformatted
      substitute('define variable &3_old like &1.&2.&3 no-undo.':U,
                 bttSessionTrigger.DatabaseName,
                 cTableName,
                 cFieldName) skip
      ' ':U skip
      substitute('on &1 of &2.&3.&4 old value &4_old':U,
                 bttSessionTrigger.TriggerEvent,
                 bttSessionTrigger.DatabaseName,
                 cTableName,
                 cFieldName) skip
                 .
  
  when 'write':U then
    put stream strSeTrigger unformatted
      substitute('on &1 of &2.&3 old buffer &3_old':U,
                 bttSessionTrigger.TriggerEvent,
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 .
  
  when 'find':U then
    put stream strSeTrigger unformatted
      substitute('on &1 of &2.&3':U,
                 bttSessionTrigger.TriggerEvent,
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 .
  
end case. /* case bttSessionTrigger.TriggerEvent */

put stream strSeTrigger unformatted
  'do:':U skip
  '  ':U skip.

if    bttSessionTrigger.TriggerEvent = 'assign':U
  and available bttTable
  and available bttField
  and bttField.IsVirtual
  and bttField.FieldType = {&K_FIELD_TYPE_VIRTUAL_DB_FIELD} then
do:
  
  put stream strSeTrigger unformatted
    substitute( '  if    not &1.&2.Owning_Obj  begins ~'&3:~':U':U,
                bttSessionTrigger.DatabaseName,
                cTableName,
                bttTable.InternalIdentifier ) skip
    substitute( '     or &1.&2.DRC_VirtualField_ID <> ~'&3~':U then':U,
                bttSessionTrigger.DatabaseName,
                cTableName,
                bttSessionTrigger.FieldName ) skip
    '    ':U skip
    '    leave.':U skip
    '  ':U skip
    substitute( '  find first &1.&2':U,
                bttSessionTrigger.DatabaseName,
                bttSessionTrigger.TableName ) skip
    substitute( '    where &1.&2.&2_Obj = &1.&3.Owning_Obj':U,
                bttSessionTrigger.DatabaseName,
                bttSessionTrigger.TableName,
                cTableName ) skip
    '    no-lock no-error.':U skip
    '  ':U skip
    .
  
end. /* if    bttSessionTrigger.TriggerEvent = 'assign':U */

if bttSessionTrigger.Condition then
  put stream strSeTrigger unformatted
    substitute('  if not ( &1 ) then':U,
               bttSessionTrigger.ConditionText) skip
    '    leave.':U skip
    '  ':U skip
    .

if bttSessionTrigger.CustomCode then
  put stream strSeTrigger unformatted
    bttSessionTrigger.CustomCodeText skip
    '  ':U skip
    .

if bttSessionTrigger.AdditionalInfo then
  put stream strSeTrigger unformatted
    substitute('  gcAdditionalInfo = &1.':U,
               bttSessionTrigger.AdditionalInfoText) skip
    '  ':U skip
    .

case bttSessionTrigger.TriggerEvent:
  
  when 'create':U then
    put stream strSeTrigger unformatted
      substitute('  run qg_SessionTriggerCreate in ghQueryGenerator (&1, (buffer &2.&3:handle), gcAdditionalInfo, ~{&&LINE-NUMBER}).':U,
                 string(bttSessionTrigger.Id),
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 '  ':U skip
                 .
  
  when 'delete':U then
    put stream strSeTrigger unformatted
      substitute('  run qg_SessionTriggerDelete in ghQueryGenerator (&1, (buffer &2.&3:handle), gcAdditionalInfo, ~{&&LINE-NUMBER}).':U,
                 string(bttSessionTrigger.Id),
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 '  ':U skip
                 .
  
  when 'assign':U then
    put stream strSeTrigger unformatted
      substitute('  run qg_SessionTriggerAssign in ghQueryGenerator (&1, (buffer &2.&3:handle), string(&4_old), gcAdditionalInfo, ~{&&LINE-NUMBER}).':U,
                 string(bttSessionTrigger.Id),
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName,
                 cFieldName) skip
                 '  ':U skip
                 .
  
  when 'write':U then
    put stream strSeTrigger unformatted
      substitute('  run qg_SessionTriggerWrite in ghQueryGenerator (&1, (buffer &2.&3:handle), (buffer &3_old:handle), gcAdditionalInfo, ~{&&LINE-NUMBER}).':U,
                 string(bttSessionTrigger.Id),
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 '  ':U skip
                 .
  
  when 'find':U then
    put stream strSeTrigger unformatted
      substitute('  run qg_SessionTriggerFind in ghQueryGenerator (&1, (buffer &2.&3:handle), gcAdditionalInfo, ~{&&LINE-NUMBER}).':U,
                 string(bttSessionTrigger.Id),
                 bttSessionTrigger.DatabaseName,
                 bttSessionTrigger.TableName) skip
                 '  ':U skip
                 .
  
end case. /* case bttSessionTrigger.TriggerEvent */

put stream strSeTrigger unformatted
  '  debugger:cancel-break( ~'~{&FILE-NAME}~':U, ~{&LINE-NUMBER} ). ':U skip
  '  ':U skip
  'end.':U skip
  .

finally:
  
  output stream strSeTrigger close.
  
end.

end procedure. /* qg_WriteSessionTriggerProc */


/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

/* ************************  Function Implementations ***************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cBeautifyQueryText hQueryWindow 
function qg_cBeautifyQueryText returns character
  ( pcQueryText as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fix various things in given query text.                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcQueryText                    = Query text that should be beautified.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i                        as integer   no-undo.
define variable cLine                    as character no-undo.
define variable iOffset                  as integer   no-undo initial 1.

define variable iLength                  as integer   no-undo.
define variable iMaxCompEnd              as integer   no-undo.

define variable cQueryText               as character no-undo.

define variable cKeywordFunctions        as character no-undo.

define variable lComparator              as logical   no-undo.
define variable iPrevCompOffset          as integer   no-undo.
define variable iPrevCompLevel           as integer   no-undo.
define variable iPrevTokenType           as integer   no-undo.
define variable cPrevTokenText           as character no-undo.
define variable iPrevConditionLeftStart  as integer   no-undo.
define variable iPrevConditionRightStart as integer   no-undo.
define variable cSpace                   as character no-undo.
define variable iAddSpaces               as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryAST       for temp-table ttQueryAST.
define buffer bttQueryCondition for temp-table ttQueryCondition.
define buffer bttQueryLine      for temp-table ttQueryLine.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

cKeywordFunctions = {&K_QP_KEYWORD_FUNCTIONS}.

run qg_ParseQueryConditions(pcQueryText).

/*----------------------------------------------------------------------------*/
/* Step 1: analyze query text lines.                                          */
/*----------------------------------------------------------------------------*/

empty temp-table ttQueryLine.

do i = 1 to num-entries(pcQueryText, '~n':U):
  
  assign
    iLength        = 0
    lComparator    = no
    cLine          = entry(i, pcQueryText, '~n':U)
    .
  
  create bttQueryLine.
  
  assign
    bttQueryLine.LineNo         = i
    bttQueryLine.StartPos       = iOffset
    bttQueryLine.EndPos         = iOffset + length(cLine).
    .
  
  find first bttQueryAST
    where bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_TOKEN}
      and bttQueryAST.TokenStart < bttQueryLine.StartPos
      and bttQueryAST.TokenEnd  >= bttQueryLine.StartPos
    no-error.
  
  if available bttQueryAST then
    assign
      bttQueryLine.ExceedingToken = yes
      iPrevTokenType              = bttQueryAST.TokenType
      cPrevTokenText              = bttQueryAST.TokenText
      .
  
  else
    assign
      iPrevTokenType = {&K_QP_TOKEN_TYPE_UNDEFINED}
      cPrevTokenText = '':U
      .
  
  validate bttQueryLine.
  
  for each bttQueryAST
    where bttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
      and bttQueryAST.TokenStart >= iOffset
      and bttQueryAST.TokenStart <= bttQueryLine.EndPos
    break by bttQueryAST.TokenStart
    on error undo, throw:
    
    find first bttQueryCondition
      where bttQueryCondition.StartPos <= bttQueryAST.TokenStart
        and bttQueryCondition.EndPos   >= bttQueryAST.TokenEnd
      no-error.
    
    if first(bttQueryAST.TokenStart) then
    do:
      
      bttQueryLine.LineLevel = bttQueryAST.Level.
      
      if bttQueryLine.ExceedingToken then
        iLength = length(cPrevTokenText) - r-index(cPrevTokenText, '~n':U).
      
      else
      do:
        
        if    bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
          and lookup(bttQueryAST.TokenText, 'FOR,EACH,FIRST,LAST':U) > 0 then
          bttQueryLine.LineIndentation = 0.
          
        else
          if    bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
            and lookup(bttQueryAST.TokenText, 'NO-LOCK,SHARE-LOCK,EXCLUSIVE-LOCK,ON,BREAK,BY':U) > 0 then
            bttQueryLine.LineIndentation = 2.
        
        else
          if    bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
            and lookup(bttQueryAST.TokenText, {&K_QP_COMPARATOR_OPERATORS}) > 0 then
              bttQueryLine.LineIndentation = 10 + (bttQueryLine.LineLevel * 2).
        
        else
          if   (  bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_KEYWORD}
              and bttQueryAST.TokenText = 'WHERE':U)
            or (  bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
              and lookup(bttQueryAST.TokenText, 'AND,OR':U) > 0) then
            bttQueryLine.LineIndentation = 2 + (bttQueryLine.LineLevel * 2) + 5 - length(bttQueryAST.TokenText).
        
        else
          if bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_COMMENT} then
            bttQueryLine.LineIndentation = bttQueryAST.TokenStart - bttQueryLine.StartPos.
        
        else
          bttQueryLine.LineIndentation = (if    available bttQueryCondition
                                            and bttQueryCondition.RightStartPos <= bttQueryAST.TokenStart
                                            and bttQueryCondition.RightEndPos   >= bttQueryAST.TokenEnd then
                                            ?
                                          else
                                            7 + (bttQueryLine.LineLevel * 2) + 1). 
        
      end. /* else: if bttQueryLine.ExceedingToken */
      
    end. /* if first(bttQueryAST.TokenStart) */
    
    assign
      cSpace  = (if ( (     not first(bttQueryAST.TokenStart)
                         or bttQueryLine.ExceedingToken )
                     and bttQueryAST.TokenType <> {&K_QP_TOKEN_TYPE_PUNCTUATION}
                     and ( ( bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
                         and iPrevTokenType        <> {&K_QP_TOKEN_TYPE_IDENTIFIER}
                         and ( iPrevTokenType      <> {&K_QP_TOKEN_TYPE_KEYWORD}
                            or lookup(cPrevTokenText, cKeywordFunctions) = 0))
                        or iPrevTokenType         = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
                        or bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}
                        or iPrevTokenType         = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}
                        or bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_OPERATOR}
                        or iPrevTokenType         = {&K_QP_TOKEN_TYPE_OPERATOR}
                        or iPrevTokenType         = {&K_QP_TOKEN_TYPE_PUNCTUATION}
                        or index(' ~t~n':U,
                                 substring(pcQueryText,
                                           bttQueryAST.TokenStart - 1,
                                           1)) > 0 ) ) then
                  ' ':U
                else
                  '':U)
      iLength =   iLength
                + length(cSpace)
      .
    
    if    not lComparator
      and bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
      and lookup(bttQueryAST.TokenText, {&K_QP_COMPARATOR_OPERATORS}) > 0
      and ( not available bttQueryCondition
         or bttQueryCondition.RightStartPos > bttQueryAST.TokenStart
         or bttQueryCondition.RightEndPos   < bttQueryAST.TokenEnd )
      and not can-find(first ttQueryCondition
                         where ttQueryCondition.EndPos >= bttQueryLine.StartPos
                           and ttQueryCondition.EndPos <= bttQueryAST.TokenStart) then
    do:
      
      assign
        lComparator = yes
        iMaxCompEnd = max(iMaxCompEnd,
                            (if bttQueryLine.LineIndentation <> ? then
                               bttQueryLine.LineIndentation
                             else
                               0)
                          + iLength
                          + length(bttQueryAST.TokenText))
        .
      
      leave.
      
    end. /* if    bttQueryLine.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR} */
    
    assign
      iLength        = iLength + length(bttQueryAST.TokenText)
      iPrevTokenType = bttQueryAST.TokenType
      cPrevTokenText = bttQueryAST.TokenText
      .
    
  end. /* for each bttQueryAST */
    
  iOffset = iOffset + length(cLine) + length('~n':U).
  
end. /* do i = 1 to num-entries(pcQueryText, '~n':U) */

/*----------------------------------------------------------------------------*/
/* Step 2: fix query text lines.                                              */
/*----------------------------------------------------------------------------*/

for each bttQueryLine
  on error undo, throw:
  
  assign
    iLength        = 0
    lComparator    = no
    .
  
  if bttQueryLine.ExceedingToken then
  do:
    
    find first bttQueryAST
      where bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_TOKEN}
        and bttQueryAST.TokenStart < bttQueryLine.StartPos
        and bttQueryAST.TokenEnd  >= bttQueryLine.StartPos
      no-error.
    
    if available bttQueryAST then
      assign
        iPrevTokenType              = bttQueryAST.TokenType
        cPrevTokenText              = bttQueryAST.TokenText
        .

  end. /* if bttQueryLine.ExceedingToken */
  
  else
  do:
    
    assign
      iPrevTokenType = {&K_QP_TOKEN_TYPE_UNDEFINED}
      cPrevTokenText = '':U
      .
    
    if bttQueryLine.LineNo > 1 then
      cQueryText = cQueryText + '~n':U.
    
  end. /* else: if bttQueryLine.ExceedingToken */
  
  if not can-find(first bttQueryAST
                    where bttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
                      and bttQueryAST.TokenStart >= bttQueryLine.StartPos
                      and bttQueryAST.TokenStart <= bttQueryLine.EndPos) then
  do:
    
    cLine = '':U.
    
    if not bttQueryLine.ExceedingToken then
      cLine = entry(bttQueryLine.LineNo, pcQueryText, '~n':U).
      
    else
    do:
      
      find first bttQueryAST
        where bttQueryAST.NodeType   = {&K_QP_NODE_TYPE_TOKEN}
          and bttQueryAST.TokenStart < bttQueryLine.StartPos
          and bttQueryAST.TokenEnd  >= bttQueryLine.StartPos
          and bttQueryAST.TokenEnd   < bttQueryLine.EndPos
        no-error.
      
      if available bttQueryAST then
        cLine = substring(pcQueryText,
                          bttQueryAST.TokenEnd,
                          bttQueryLine.EndPos - bttQueryAST.TokenEnd).
      
    end. /* else: if not bttQueryLine.ExceedingToken */
    
    if trim(cLine) > '':U then
      cQueryText = cQueryText + cLine.
    
  end. /* if not can-find(first bttQueryAST */
  
  else
  do:
    
    for each bttQueryAST
      where bttQueryAST.NodeType    = {&K_QP_NODE_TYPE_TOKEN}
        and bttQueryAST.TokenStart >= bttQueryLine.StartPos
        and bttQueryAST.TokenStart <= bttQueryLine.EndPos
      break by bttQueryAST.TokenStart
      on error undo, throw:
      
      find first bttQueryCondition
        where bttQueryCondition.StartPos <= bttQueryAST.TokenStart
          and bttQueryCondition.EndPos   >= bttQueryAST.TokenEnd
        no-error.
      
      if not available bttQueryCondition then
        assign
          iPrevCompOffset          = 0
          iPrevCompLevel           = 0
          iPrevConditionLeftStart  = 0
          iPrevConditionRightStart = 0
          .
      
      if first(bttQueryAST.TokenStart) then
      do:
        
        if bttQueryLine.ExceedingToken then
          iLength = length(cPrevTokenText) - r-index(cPrevTokenText, '~n':U).
        
        else
        do:
          
          if available bttQueryCondition then
          do:
          
            if    iPrevConditionLeftStart         > 0
              and bttQueryCondition.LeftStartPos <= bttQueryAST.TokenStart
              and ( (     bttQueryCondition.ComparatorEndPos > 0
                      and bttQueryCondition.ComparatorEndPos >= bttQueryAST.TokenEnd )
                    or bttQueryCondition.LeftEndPos >= bttQueryAST.TokenEnd ) then
              bttQueryLine.LineIndentation = iPrevConditionLeftStart + 2.
            
            else
              if    iPrevConditionRightStart > 0
                and bttQueryCondition.RightStartPos <= bttQueryAST.TokenStart
                and bttQueryCondition.RightEndPos   >= bttQueryAST.TokenEnd then
                bttQueryLine.LineIndentation = iPrevConditionRightStart + ((bttQueryAST.Level - iPrevCompLevel) * 2).
            
          end. /* if available bttQueryCondition */
          
          if bttQueryLine.LineIndentation = ? then
            bttQueryLine.LineIndentation =   iPrevCompOffset
                                           + ((bttQueryAST.Level - iPrevCompLevel) * 2) + 1.
          
          cQueryText =   cQueryText
                       + fill(' ':U, bttQueryLine.LineIndentation).
          
        end. /* else: if bttQueryLine.ExceedingToken */
        
      end. /* if first(bttQueryAST.TokenStart) */
      
      assign
        cSpace  = (if ( (     not first(bttQueryAST.TokenStart)
                           or bttQueryLine.ExceedingToken )
                       and bttQueryAST.TokenType <> {&K_QP_TOKEN_TYPE_PUNCTUATION}
                       and ( ( bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
                           and iPrevTokenType        <> {&K_QP_TOKEN_TYPE_IDENTIFIER}
                           and ( iPrevTokenType      <> {&K_QP_TOKEN_TYPE_KEYWORD}
                              or lookup(cPrevTokenText, cKeywordFunctions) = 0))
                          or iPrevTokenType         = {&K_QP_TOKEN_TYPE_PARENTHESE_OPEN}
                          or bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}
                          or iPrevTokenType         = {&K_QP_TOKEN_TYPE_PARENTHESE_CLOSE}
                          or bttQueryAST.TokenType  = {&K_QP_TOKEN_TYPE_OPERATOR}
                          or iPrevTokenType         = {&K_QP_TOKEN_TYPE_OPERATOR}
                          or iPrevTokenType         = {&K_QP_TOKEN_TYPE_PUNCTUATION}
                          or index(' ~t~n':U,
                                   substring(pcQueryText,
                                             bttQueryAST.TokenStart - 1,
                                             1)) > 0 ) ) then
                    ' ':U
                  else
                    '':U)
        iLength = iLength + length(cSpace)
          .
      
      if    bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR}
        and lookup(bttQueryAST.TokenText, {&K_QP_COMPARATOR_OPERATORS}) > 0
        and ( not available bttQueryCondition
           or bttQueryCondition.RightStartPos > bttQueryAST.TokenStart
           or bttQueryCondition.RightEndPos   < bttQueryAST.TokenEnd )  then
      do:
        
        if    not lComparator
          and not first(bttQueryAST.TokenStart)
          and not can-find(first ttQueryCondition
                             where ttQueryCondition.EndPos >= bttQueryLine.StartPos
                               and ttQueryCondition.EndPos <= bttQueryAST.TokenStart)  then
          assign
            iAddSpaces = /*max(0,*/
                               iMaxCompEnd
                             - iLength
                             - (if bttQueryLine.LineIndentation <> ? then
                                  bttQueryLine.LineIndentation
                                else
                                  0)
                              - length(bttQueryAST.TokenText) /*)*/
            cSpace     = cSpace + fill(' ':U, iAddSpaces)
            iLength    = iLength + iAddSpaces
            .
        
        assign
          lComparator     = yes
          iPrevCompOffset =   iLength
                            + length(bttQueryAST.TokenText)
                            + bttQueryLine.LineIndentation
          iPrevCompLevel  = bttQueryAST.Level
          .
        
      end. /* if    bttQueryAST.TokenType = {&K_QP_TOKEN_TYPE_OPERATOR} */
      
      if bttQueryAST.TokenText > '':U then
      do:
        
        if available bttQueryCondition then
        do:
          
          if    iPrevConditionLeftStart = 0
            and bttQueryCondition.LeftStartPos <= bttQueryAST.TokenStart
            and bttQueryCondition.LeftEndPos   >= bttQueryAST.TokenEnd then
            iPrevConditionLeftStart = bttQueryLine.LineIndentation + iLength.
          
          if    iPrevConditionRightStart = 0
            and bttQueryCondition.RightStartPos <= bttQueryAST.TokenStart
            and bttQueryCondition.RightEndPos   >= bttQueryAST.TokenEnd then
            iPrevConditionRightStart = bttQueryLine.LineIndentation + iLength.
          
        end. /* if available bttQueryCondition */
        
        assign
          cQueryText = cQuerytext + cSpace + bttQueryAST.TokenText
          iLength    = iLength + length(bttQueryAST.TokenText)
          .
        
      end. /* if bttQueryAST.TokenText > '':U */
      
      assign
        iPrevTokenType = bttQueryAST.TokenType
        cPrevTokenText = bttQueryAST.TokenText
        .
      
    end. /* for each bttQueryAST */
    
  end. /* if not can-find(first bttQueryAST */
  
end. /* for each bttQueryLine */

return cQueryText.
  
end function. /* qg_cBeautifyQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cBrowseColumnList hQueryWindow 
function qg_cBrowseColumnList returns character
  ( phBrowse      as handle,
    plBuffernames as logical,
    plAllColumns  as logical,
    plColumnWidth as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns a list of all columns in a browse widget.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBrowse                       = Browse widget whose columns should be     */
/*                                  listed.                                   */
/* plBuffernames                  = Flag do indicate if the buffer name       */
/*                                  should be included in the column name.    */
/* plAllColumns                   = Flag to indicate if only visible columns  */
/*                                  should be listed.                         */
/* plColumnWidth                  = Flag to indicat if the column widths      */
/*                                  should be included.                       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i           as integer   no-undo.
define variable hColumn     as handle    no-undo.
define variable cColumnList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

do i = 1 to phBrowse:num-columns:
  
  hColumn = phBrowse:get-browse-column(i).
  
  if    plAllColumns
     or hColumn:visible then
    cColumnList = substitute('&1,&2&3':U,
                             cColumnList,
                             qg_cColumnFieldName(hColumn,
                                                 plBuffernames),
                             (if plColumnWidth then
                                substitute(':&1':U,
                                           replace(string(hColumn:width-chars),
                                                   session:numeric-decimal-point,
                                                   '.':U))
                              else
                                '':U)).
  
end. /* do i = 1 to phBrowse:num-columns */

return trim(cColumnList, ',':U).

end function. /* qg_cBrowseColumnList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_clBrowseValues hQueryWindow 
function qg_clBrowseValues returns longchar
  ( phBrowse    as handle,
    plRawValues as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lBufferName         as logical   no-undo.
define variable lOverlayColumns     as logical   no-undo.
define variable lDeep               as logical   no-undo.

define variable cFieldName          as character no-undo.
define variable iMaxFieldNameLength as integer   no-undo.
define variable i                   as integer   no-undo.
define variable hQuery              as handle    no-undo.
define variable hColumn             as handle    no-undo.
define variable hField              as handle    no-undo.
define variable clFieldValue        as longchar  no-undo.
define variable cKeyValues          as character no-undo.
define variable lResolved           as logical   no-undo.

define variable clText              as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow        for temp-table ttQueryWindow.

define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.
define buffer bttFieldOverlay       for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  hQuery      = phBrowse:query
  lBufferName = (hQuery:num-buffers > 1)
  .

/* First get the length of the longest field name. */

do i = 1 to phBrowse:num-columns:
  
  assign
    hColumn     = phBrowse:get-browse-column(i)
    hField      = hColumn:buffer-field
    .
  
  if    not hColumn:visible
     or ( valid-handle(hField)
      and hField:data-type = 'BLOB':U ) then
    next.
  
  cFieldName = qg_cColumnFieldName(phBrowse:get-browse-column(i), lBufferName).
  
  if length(cFieldName) > iMaxFieldNameLength then
    iMaxFieldNameLength = length(cFieldName).
  
end. /* do i = 1 to phBrowse:num-columns */

lOverlayColumns = can-find( first ttFieldOverlay
                              where ttFieldOverlay.OwnerHandle = hQuery ).

if lOverlayColumns then
do:
  
  find bttQueryWindow
    where bttQueryWindow.WindowHandle = phBrowse:window
    no-error.
  
  if available bttQueryWindow then
    lDeep = bttQueryWindow.DeepResolveObjectIds.
  
end. /* if lOverlayColumns */

BrowseColumn:
do i = 1 to phBrowse:num-columns
  on error undo, next:
  

  assign
    hColumn      = phBrowse:get-browse-column(i)
    cFieldName   = qg_cColumnFieldName(hColumn, lBufferName)
    hField       = hColumn:buffer-field
    clFieldValue = '':U
    .
  
  if not hColumn:visible then
    
    next.
  
  if valid-handle(hField) then
  do:
    
    if hField:data-type = 'BLOB':U then
      
      next.
    
    if hField:data-type = 'CLOB':U then
    do:
      
      copy-lob hField:buffer-value(hColumn:index) to clFieldValue.
      clFieldValue = quoter(clFieldValue).
      
    end. /* if hField:data-type = 'CLOB':U then */
    
    else
      
      if lookup(hField:data-type, 'CHARACTER,LONGCHAR':U) > 0 then
        
        clFieldValue = quoter((if plRawValues then
                                 hField:buffer-value(hColumn:index)
                               else
                                 hField:string-value(hColumn:index))).
      
    else
      
      clFieldValue = (if plRawValues then
                        hField:buffer-value(hColumn:index)
                      else
                        hField:string-value(hColumn:index)).
    
  end. /* if valid-handle(hField) */
  
  else
  do:
    
    find bttVirtualFieldColumn
      where bttVirtualFieldColumn.OwnerHandle  = hQuery
        and bttVirtualFieldColumn.ColumnHandle = hColumn
      no-error.
    
    if available bttVirtualFieldColumn then
      
      clFieldValue = qg_clVirtualFieldValueAsLongchar( bttVirtualFieldColumn.FieldType,
                                                       bttVirtualFieldColumn.DataType,
                                                       bttVirtualFieldColumn.FieldName,
                                                       qg_cObjectIdForBuffer( bttVirtualFieldColumn.BufferHandle ),
                                                       ( if plRawValues then
                                                           ?
                                                         else
                                                           bttVirtualFieldColumn.FieldFormat ) ).
    
    else
    
      if lOverlayColumns then
      do:
        
        find first bttFieldOverlay
          where bttFieldOverlay.OwnerHandle         = hQuery
            and bttFieldOverlay.OverlayColumnHandle = hColumn
          no-error.
        
        if available bttFieldOverlay then
          
          run qg_GetOverlayColumnValue( buffer bttFieldOverlay,
                                        lDeep,
                                        yes,
                                        output clFieldValue,
                                        output lResolved ).
        
      end. /* if lOverlayColumns */
    
  end. /* else: if valid-handle(hField) */
  
  finally:
    
    clText = substitute('&1~n&2&3: &4':U,
                        clText,
                        cFieldName,
                        fill(' ':U, iMaxFieldNameLength - length(cFieldName)),
                        clFieldValue) no-error.
    
  end finally.
  
end. /* do i = 1 to phBrowse:num-columns */

return trim(clText, '~n':U).

end function. /* qg_clBrowseValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cBufferCompare hQueryWindow 
function qg_cBufferCompare returns character
  ( phBuffer1 as handle,
    phBuffer2 as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Buffer compare that returns a list of not equal fields.                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* We have to do this manually because the regular buffer compare method only */
/* returns yes or no.                                                         */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer1                      = Buffer 1 for comparison.                  */
/* phBuffer2                      = Buffer 2 for comparison.                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*---------------------------------resetStorageAreaTable()-------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
 
define variable iFieldCounter        as integer   no-undo.
define variable iIndex               as integer   no-undo.
define variable lValueChanged        as logical   no-undo.
define variable cFieldList           as character no-undo.
define variable cVirtualFieldList    as character no-undo.
define variable iVirtualFieldCounter as integer   no-undo.
define variable cVirtualField        as character no-undo.

define variable hField1              as handle    no-undo.
define variable hField2              as handle    no-undo.

define variable iIndexMin            as integer   no-undo.
define variable iIndexMax            as integer   no-undo.

define variable clValue1             as longchar  no-undo.
define variable clValue2             as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField-1 for temp-table ttField.
define buffer bttField-2 for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    not valid-handle(phBuffer1)
   or not phBuffer2:available
   or not valid-handle(phBuffer2)
   or not phBuffer2:available then
  
  return ?.

do iFieldCounter = 1 to phBuffer1:num-fields:
  
  hField1 = phBuffer1:buffer-field(iFieldCounter) no-error.
  
  if    error-status:error
     or not valid-handle( hField1 ) then
    
    next.
  
  hField2 = phBuffer2:buffer-field(hField1:name) no-error.
  
  if    not error-status:error
    and valid-handle( hField2 ) then
  do:
    
    if    hField2:data-type <> hField1:data-type
      and hField2:extent    <> hField1:extent then
      
      next.
    
    if hField2:extent > 0 then
      
      assign
        iIndexMin = 1
        iIndexMax = hField2:extent
        .
    
    else
      
      assign
        iIndexMin = 0
        iIndexMax = 0
        .
    
    do iIndex = iIndexMin to iIndexMax:
      
      if lookup(hField2:data-type, 'CLOB,BLOB':U) = 0 then
      do:
        
        /* Compare non-lob datatypes. For character and longchar we do a raw  */
        /* comparison.                                                        */
        
        if lookup(hField2:data-type, 'character,longchar':U) = 0 then
          
          lValueChanged = hField2:buffer-value(iIndex) <> hField1:buffer-value(iIndex).

        else
          
          lValueChanged = not compare(hField2:buffer-value(iIndex),
                                      'EQ':U,
                                      hField1:buffer-value(iIndex),
                                      'RAW':U).
        
      end. /* if lookup(hField2:data-type, 'clob,blob':U) = 0 */
      
      else
      do:
        
        /* Compare lob datatypes. We have to copy the field content to a      */
        /* longchar variable first. Then we can do a raw comparison.          */
        
        copy-lob from hField1:buffer-value(iIndex) to clValue1.
        copy-lob from hField2:buffer-value(iIndex) to clValue2.
        
        lValueChanged = not compare(clValue2,
                                    'EQ':U,
                                    clValue1,
                                    'RAW':U).
        
      end. /* if lookup(hField2:data-type, 'clob,blob':U) = 0 */
      
      if lValueChanged then
        cFieldList = substitute('&1,&2':U,
                                cFieldList,
                                qg_cFormattedFieldName(?,
                                                       ?,
                                                       phBuffer2:buffer-field(iFieldCounter):name,
                                                       iIndex)).
      
    end. /* do iIndex = iIndexMin to iIndexMax */
    
  end. /* if    not error-status:error */
  
end. /* do iFieldCounter = 1 to phBuffer2:num-fields */

cVirtualFieldList = qg_cBufferCompareVirtualFields( phBuffer1, phBuffer2 ).

do iVirtualFieldCounter = 1 to num-entries( cVirtualFieldList ):
  
  cVirtualField = entry( iVirtualFieldCounter, cVirtualFieldList ).
  
  if lookup( cVirtualField, cFieldList ) = 0 then
    
    cFieldList = cFieldList + ',':U + cVirtualField.
  
end. /* do iVirtualFieldCounter = 1 to num-entries( cVirtualFieldList ) */

return trim( cFieldList, ',':U) .

end function. /* qg_cBufferCompare */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cColumnFieldName hQueryWindow 
function qg_cColumnFieldName returns character
  ( phColumn      as handle,
    plBuffernames as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Retuns the name of the given browse column (including extent index).       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phColumn                       = Column widget whoose name should be       */
/*                                  returned.                                 */
/* plBuffernames                  = Flag to indicate if the buffer name       */
/*                                  be included.                              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hField      as handle    no-undo.

define variable cBufferName as character no-undo.
define variable cFieldName  as character no-undo.
define variable iFieldIndex as integer   no-undo.

define variable cColumnName as character no-undo.
define variable lIsOverlay  as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.
define buffer bttFieldOverlay       for temp-table ttFieldOverlay.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

hField = phColumn:buffer-field.

if valid-handle( hField ) then
  
  assign
    cBufferName = hField:buffer-name
    cFieldName  = hField:name
    iFieldIndex = phColumn:index
    .

else
do:

  find bttVirtualFieldColumn
    where bttVirtualFieldColumn.OwnerHandle  = phColumn:parent:query
      and bttVirtualFieldColumn.ColumnHandle = phColumn
    no-error.
  
  if available bttVirtualFieldColumn then
    
    assign
      cBufferName = bttVirtualFieldColumn.BufferName
      cFieldName  = bttVirtualFieldColumn.FieldName
      iFieldIndex = bttVirtualFieldColumn.FieldIndex
      .
  
  else
  do:
    
    find first bttFieldOverlay
      where bttFieldOverlay.OwnerHandle         = phColumn:parent:query
        and bttFieldOverlay.OverlayColumnHandle = phColumn
      no-error.
    
    if available bttFieldOverlay then
      
      assign
        cBufferName = bttFieldOverlay.BufferName
        cFieldName  = bttFieldOverlay.FieldName
        iFieldIndex = bttFieldOverlay.FieldIndex
        lIsOverlay  = yes
        .
    
  end. /* else: if available bttVirtualFieldColumn */
  
end.

cColumnName = qg_cFormattedFieldName( ?,
                                      ( if plBuffernames then
                                          cBufferName
                                        else
                                          ? ),
                                        cFieldName,
                                        iFieldIndex ).

return ( if lIsOverlay then
           substitute({&K_OBJECTID_OVERLAY_NAME_PATTERN}, cColumnName)
         else
           cColumnName ).

end function. /* qg_cColumnFieldName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cCreateQueryText hQueryWindow 
function qg_cCreateQueryText returns character
  ( pcFieldList as character,
    plAddTags   as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create query text.                                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFieldList                    = Field list for query.                     */
/* plAddTags                      = Add tags for ide editor.                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabase                    as character no-undo.
define variable cTable                       as character no-undo.
define variable cBufferName                  as character no-undo.
define variable cFieldList                   as character no-undo.
define variable cValueList                   as character no-undo.
define variable cRelationBufferName          as character no-undo.

define variable cQueryText                   as character no-undo.
define variable cWhereClause                 as character no-undo.

define variable lVirtualIndex                as logical   no-undo.
define variable cVirtualIndexTableName       as character no-undo.
define variable cVirtualIndexBufferName      as character no-undo.
define variable iVirtualFieldCounter         as integer   no-undo.
define variable cFieldName                   as character no-undo.
define variable cFieldDataType               as character no-undo.
define variable cVariableName                as character no-undo.
define variable iVariableNameLength          as integer   no-undo.
define variable iLongestVariableName         as integer   no-undo.
define variable iNumberOfVariables           as integer   no-undo.
define variable cVirtualIndexFieldValues     as character no-undo.

define variable oVirtualIndexDataApiInstance as class Progress.Lang.Object no-undo.

define variable cLockMode                    as character no-undo.
define variable cBlockName                   as character no-undo.

define variable cIndentation                 as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelationField for temp-table ttTableRelationField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not available(ttDatabase) then
  
  return '':U.

assign
  lVirtualIndex   = (     giDisplayMode = {&K_DISPLAYMODE_INDEX}
                      and available ttIndex
                      and ttIndex.IsVirtual )
  cFieldList      = pcFieldList
  .

assign
  giDisplayMode = input frame {&FRAME-NAME} giDisplayMode
  cDatabase     = ttDatabase.DatabaseName
  cTable        = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                     and glInvertQuery then
                     ( if available ttTableRelationView then
                         ttTableRelationView.RelatedTableName
                       else
                         '':U )
                   else if available(ttTable) then
                     ttTable.TableName
                   else
                     '':U )
  .

run qg_UpdateQueryParameterVariables.

if glSlimMode then
  
  assign
    cBufferName         = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                             and glInvertQuery then
                             cTable
                           else
                             substitute({&K_DEFAULT_BUFFER_PATTERN},
                                        qg_cGetBufferBaseName(no)))
    cRelationBufferName = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                             and glInvertQuery then
                             substitute({&K_DEFAULT_BUFFER_PATTERN},
                                        qg_cGetBufferBaseName(no))
                           else
                             cTable)
    cIndentation        = fill(' ':U, {&K_DEFAULT_INDENTATION})
    .

else
  
  assign
    cBufferName         = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                             and glInvertQuery then
                             gcRelationBufferName
                           else
                             input frame {&FRAME-NAME} gcBufferName)
    cRelationBufferName = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                             and glInvertQuery then
                             input frame {&FRAME-NAME} gcBufferName
                           else
                             gcRelationBufferName)
    cIndentation        = fill(' ':U, giIndentation)
    .

if    lVirtualIndex
  and not glUseVirtualIndexApi then
  
  assign
    cVirtualIndexTableName  = gcVirtualIndexDataTableName
    cVirtualIndexBufferName = gcRelationBufferName
    .

cLockMode = (if not ttDatabase.TempDB then
               (if glExclusiveLock then
                   'exclusive-lock':U
                 else
                   'no-lock':U)
             else
               '':U).

if    lVirtualIndex
  and ( not glUseVirtualIndexApi
     or not glUseVirtualIndexIncludes ) then
do:
  
  if glUseVirtualIndexApi then
  do:
    
    if    glDefineVariables
      and gcVirtualQueryApiClassName > '':U then
      
      cQueryText = substitute(   '&1':U
                               + '~n&2':U + 'define variable o&4 as class &3.&4 no-undo.':U
                               + '~n&2':U,
                               cQueryText,
                               cIndentation,
                               gcVirtualQueryApiPackageName,
                               gcVirtualQueryApiClassName ).
    
  end. /* if glUseVirtualIndexApi */
  
  else
  do:
    
    do iVirtualFieldCounter = 1 to num-entries( ttIndex.VirtualFieldList ):
      
      assign
        cFieldName     = entry( iVirtualFieldCounter, ttIndex.VirtualFieldList )
        cFieldDataType = entry( iVirtualFieldCounter, ttIndex.VirtualFieldDataTypes )
        .
      
      if not cFieldDataType begins 'datetime':U then
        
        next.
      
      assign
        cVariableName       = qg_cVirtualIndexFieldVariableName( cFieldName, 'decimal':U )
        iVariableNameLength = length( cVariableName )
        .
  
      if iVariableNameLength > iLongestVariableName then
        
        iLongestVariableName = iVariableNameLength.
      
      iNumberOfVariables = iNumberOfVariables + 1.
      
    end. /* do iVirtualFieldCounter = 1 to num-entries( bttIndex.VirtualFieldList ) */
    
    if    glDefineVariables
      and iNumberOfVariables > 0 then
    do:
      
      do iVirtualFieldCounter = 1 to num-entries( ttIndex.VirtualFieldList ):
        
        assign
          cFieldName     = entry( iVirtualFieldCounter, ttIndex.VirtualFieldList )
          cFieldDataType = entry( iVirtualFieldCounter, ttIndex.VirtualFieldDataTypes )
          .
        
        if not cFieldDataType begins 'datetime':U then
          
          next.
        
        assign
          cVariableName       = qg_cVirtualIndexFieldVariableName( cFieldName, 'decimal':U )
          iVariableNameLength = length( cVariableName )
          .
        
        cQueryText = substitute(   '&1':U
                                 + '~n&2':U + 'define variable &3 &4as decimal   no-undo.':U,
                                 cQueryText,
                                 cIndentation,
                                 cVariableName,
                                 fill( ' ':U, iLongestVariableName - iVariableNameLength ) ).
        
      end. /* do iVirtualFieldCounter = 1 to num-entries( bttIndex.VirtualFieldList ) */
      
      cQueryText = substitute( '&1~n&2':U, cQueryText, cWhereClause ).
      
    end. /* if    glDefineVariables */
    
  end. /* else: if glUseVirtualIndexApi */
  
end. /* if    lVirtualIndex */

if glDefineBuffer then
  
  assign
    cQueryText = substitute(   '&1':U
                             + '~n&2':U + 'define buffer &3 &4for &5&6.':U,
                             cQueryText,
                             cIndentation,
                             cBufferName,
                             ( if    lVirtualIndex
                                 and not glUseVirtualIndexApi
                                 and length( cBufferName ) < length( cVirtualIndexBufferName ) then
                                   fill( ' ':U, length( cVirtualIndexBufferName ) - length( cBufferName ) )
                               else
                                 '':U ),
                             (if ttDatabase.TempDB then
                                'temp-table ':U
                              else
                                '':U),
                              cTable )
    cQueryText = ( if    lVirtualIndex
                     and not glUseVirtualIndexApi then
                     substitute( '&1':U
                                 + '~n&2':U + 'define buffer &3 &4for &5.':U
                                 + '~n&2':U,
                                 cQueryText,
                                 cIndentation,
                                 cVirtualIndexBufferName,
                                 ( if    lVirtualIndex
                                     and length( cVirtualIndexBufferName ) < length( cBufferName ) then
                                       fill( ' ':U, length( cBufferName ) - length( cVirtualIndexBufferName ) )
                                   else
                                     '':U ),
                                 cVirtualIndexTableName )
                   else
                     substitute( '&1~n&2':U, cQueryText, cIndentation ) )
    .

if    not lVirtualIndex
   or not glUseVirtualIndexApi then
  
  cBlockName = gcBlockName.

if    lVirtualIndex
  and ( not glUseVirtualIndexApi
     or not glUseVirtualIndexIncludes ) then
do:
  
  if glUseVirtualIndexApi then
  do:
    
    if    glDefineVariables
      and gcVirtualQueryApiClassName > '':U then
      
      cQueryText = substitute(   '&1':U
                               + '~n&2':U + 'o&4 = new &3.&4( &5 ).':U
                               + '~n&2':U,
                               cQueryText,
                               cIndentation,
                               gcVirtualQueryApiPackageName,
                               gcVirtualQueryApiClassName,
                               ( if giQueryType = {&K_QUERYTYPE_CANFIND} then
                                   substitute( '~'&1~':U':U, cTable )
                                 else
                                   substitute( 'buffer &1:handle':U, cBufferName ) ) ).
    
    cQueryText = substitute(   '&1':U
                             + '~n&2':U + '&3&4o&5':U,
                             cQueryText,
                             cIndentation,
                             ( if    giQueryType = {&K_QUERYTYPE_CANFIND}
                                 and glIfStatement then
                                   'if ':U
                                 else
                                   '':U ),
                             ( if    giQueryType = {&K_QUERYTYPE_CANFIND}
                                 and glNot then
                                   'not ':U
                                 else
                                   '':U ),
                             gcVirtualQueryApiClassName ).
    
    
  end. /* if glUseVirtualIndexApi */
  
  else
  do:
    
    if iNumberOfVariables > 0 then
    do:
      
      cQuerytext = ( if iNumberOfVariables > 1 then
                       substitute(   '&1':U
                                   + '~n&2':U + 'assign':U,
                                   cQueryText,
                                   cIndentation )
                     else
                       cQuerytext ).
      
      oVirtualIndexDataApiInstance = qg_oVirtualIndexDataApiInstance().
      
      do iVirtualFieldCounter = 1 to num-entries( ttIndex.VirtualFieldList ):
        
        assign
          cFieldName     = entry( iVirtualFieldCounter, ttIndex.VirtualFieldList )
          cFieldDataType = entry( iVirtualFieldCounter, ttIndex.VirtualFieldDataTypes )
          .
        
        if not cFieldDataType begins 'datetime':U then
          
          next.
        
        assign
          cVariableName       = qg_cVirtualIndexFieldVariableName( cFieldName, 'decimal':U )
          iVariableNameLength = length( cVariableName )
          .
        
        cQueryText = substitute(   '&1':U
                                 + '~n&2':U + '&3 &4= &5:prpoInstance:dToDecimal( &6 )':U,
                                 cQueryText,
                                 cIndentation
                                   + ( if iNumberOfVariables > 1 then
                                         '  ':U
                                       else
                                         '':U ),
                                 cVariableName,
                                 fill( ' ':U, iLongestVariableName - iVariableNameLength ), 
                                 oVirtualIndexDataApiInstance:getClass():TypeName,
                                 qg_cTaggedValue( substitute( '<&1>':U, caps( cFieldDataType ) ),
                                                  plAddTags ) )
                                 .
        
      end. /* do iVirtualFieldCounter = 1 to num-entries( ttIndex.VirtualFieldList ) */
      
      assign
        cQueryText = ( if iNumberOfVariables > 1 then
                         substitute( '&1~n&2.':U, cQueryText, cIndentation + '  ':U )
                       else
                         substitute( '&1.':U, cQueryText ) )
        cQueryText = substitute( '&1~n&2':U, cQueryText, cIndentation )
        .
      
    end. /* if iNumberOfVariables > 0 */
    
    case giQueryType:
      
      when {&K_QUERYTYPE_FINDFIRST} then
        
        cQueryText = substitute(   '&1':U
                                 + '~n&2':U + 'find&3 &4':U,
                                 cQueryText,
                                 cIndentation,
                                 ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                     ' first':U
                                   else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                     ' last':U
                                   else
                                     '':U ),
                                 cVirtualIndexBufferName ).
      
      when {&K_QUERYTYPE_FOREACH} then
        
        assign
          cQueryText = substitute(   '&1':U
                                   + '~n&2':U + '&3:':U,
                                   cQueryText,
                                   cIndentation,
                                   cBlockName )
              when ( glDefineBlock
                       and cBlockName > '':U )
          cQueryText = substitute(   '&1':U
                                   + '~n&2':U + 'for&3 &4':U,
                                   cQueryText,
                                   cIndentation,
                                   ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                       ' first':U
                                     else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                       ' last':U
                                     else
                                      ' each':U ),
                                   cVirtualIndexBufferName )
          .
      
      when {&K_QUERYTYPE_CANFIND} then
        
        cQueryText = substitute( '&1~n&2&3&4can-find( &5&6':U,
                                 cQueryText,
                                 cIndentation,
                                 ( if glIfStatement then
                                     'if ':U
                                  else
                                    '':U),
                                 ( if glNot then
                                     'not ':U
                                   else
                                      '':U),
                                 ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                     'first ':U
                                   else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                     'last ':U
                                   else
                                     '':U ),
                                 cVirtualIndexBufferName ).
      
    end case. /* giQueryType */
    
    cWhereClause = qg_cCreateWhereClause( /* pcDatabaseName   */ cDatabase,
                                          /* pcTableNames     */ cVirtualIndexTableName,
                                          /* pcBufferNames    */ cVirtualIndexBufferName,
                                          /* pcFieldList      */ ttIndex.VirtualIndexDataFieldList,
                                          /* pcFieldLabelList */ ttIndex.VirtualIndexDataFieldLabels,
                                          /* plStartWithWhere */ yes,
                                          /* piValueMode      */{&K_VALUE_MODE_PARAMETER},
                                          /* pcValueList      */ replace( ( if plAddTags then
                                                                              ttIndex.VirtualIndexDataTaggedValues
                                                                            else
                                                                              ttIndex.VirtualIndexDataUntaggedValues ),
                                                                          '%COMPANY%':U,
                                                                          qg_cTaggedValue( ( if glCompanyViaClass then
                                                                                               '{&K_CLASS_COMPANY_STATEMENT}':U
                                                                                             else
                                                                                               'pa-Firma':U ),
                                                                                           plAddTags ) ),
                                          /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                                          /* plAddTags        */ no,
                                          /* piIndentBlanks   */   giIndentation
                                                                 + ( if giQueryType = {&K_QUERYTYPE_CANFIND} then
                                                                         12
                                                                       + ( if glIfStatement then
                                                                             3
                                                                           else
                                                                             0 )
                                                                       + ( if glNot then
                                                                             4
                                                                           else
                                                                             0 )
                                                                     else
                                                                       2 ) ).
    
    if cWhereClause > '':U then
      
      cQueryText = substitute( '&1~n&2':U, cQueryText, cWhereClause ).
    
    case giQueryType:
      
      when {&K_QUERYTYPE_FINDFIRST} then
        
        assign
          cQueryText = substitute( '&1':U
                                   + '~n&2':U + '  no-lock&3.':U,
                                   cQueryText,
                                   cIndentation,
                                   ( if glNoError then
                                       ' no-error':U
                                     else
                                       '':U ) )
          cQueryText =  ( if glNoError then
                            substitute(   '&1':U
                                        + '~n&2':U
                                        + '~n&2':U + 'if not available &3 then':U
                                        + '~n&2':U + '  ':U
                                        + '~n&2':U + '  release &4.':U
                                        + '~n&2':U + '  ':U
                                        + '~n&2':U + 'else':U
                                        + '~n&2':U + '  ':U,
                                        cQueryText,
                                        cIndentation,
                                        cVirtualIndexBufferName,
                                        cBufferName )
                          else
                            substitute(   '&1':U
                                        + '~n&2':U ,
                                        cQueryText,
                                        cIndentation ) )
          .
      
      when {&K_QUERYTYPE_FOREACH} then
        
        cQueryText = substitute(   '&1':U
                                 + '~n&2':U + '  no-lock,':U,
                                 cQueryText,
                                 cIndentation ).
      
    end case. /* giQueryType */
    
    assign
      cFieldList = substitute( '&1_Obj':U, cTable )
      cValueList = substitute( '&1.Owning_Obj':U, cVirtualIndexBufferName )
      .
    
  end. /* else: if glUseVirtualIndexApi */
  
end. /* if lVirtualIndex */

if    not lVirtualIndex
   or not glUseVirtualIndexApi
   or glUseVirtualIndexIncludes then

  case giQueryType:
    
    when {&K_QUERYTYPE_FINDFIRST} then
      
      cQueryText = substitute('&1~n&2&3find&4 &5':U,
                              cQueryText,
                              cIndentation
                                + ( if    lVirtualIndex
                                      and not glUseVirtualIndexApi
                                      and glNoError then
                                      '  ':U
                                    else
                                      '':U ),
                              ( if    lVirtualIndex
                                  and glUseVirtualIndexApi
                                  and glUseVirtualIndexIncludes then
                                  '~{':U
                                else
                                  '':U ),
                              ( if    lVirtualIndex
                                  and not glUseVirtualIndexApi then
                                  '':U
                                else if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                  ' first':U
                                else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                  ' last':U
                                else
                                  '':U ),
                              cBufferName).
    
    when {&K_QUERYTYPE_FOREACH} then
      
      assign
        cQueryText = substitute(   '&1':U
                                 + '~n&2':U + '&3:':U,
                                 cQueryText,
                                 cIndentation,
                                 cBlockName )
            when ( glDefineBlock
                     and cBlockName > '':U
                     and not lVirtualIndex )
        cQueryText = substitute('&1~n&2&3&4&5 &6':U,
                                cQueryText,
                                cIndentation,
                                ( if    lVirtualIndex
                                    and glUseVirtualIndexApi
                                    and glUseVirtualIndexIncludes then
                                    '~{':U
                                  else
                                    '':U ),
                                ( if lVirtualIndex
                                    and not glUseVirtualIndexApi then
                                    '':U
                                  else
                                    'for ':U ),
                                (if    ( lVirtualIndex
                                     and not glUseVirtualIndexApi ) 
                                    or giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                   'first':U
                                 else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                   'last':U
                                 else
                                  'each':U),
                                cBufferName)
        .
      
    when {&K_QUERYTYPE_CANFIND} then
      
      if    not lVirtualIndex
         or glUseVirtualIndexApi then
        
        cQueryText = substitute('&1~n&2&3&4&5can-find&6( &7&8':U,
                                cQueryText,
                                cIndentation,
                                (if glIfStatement then
                                   'if ':U
                                 else
                                   '':U),
                                (if glNot then
                                   'not ':U
                                 else
                                   '':U),
                                ( if    lVirtualIndex
                                    and glUseVirtualIndexApi
                                    and glUseVirtualIndexIncludes then
                                    '~{':U
                                  else
                                    '':U ),
                                ( if    lVirtualIndex
                                    and glUseVirtualIndexApi
                                    and glUseVirtualIndexIncludes then
                                    ' ':U
                                  else
                                    '':U ),
                                ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                   'first ':U
                                 else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                   'last ':U
                                 else
                                   '':U ),
                                 cBufferName).
    
  end case. /* giQueryType */

if    not lVirtualIndex
   or glUseVirtualIndexApi
   or giQueryType <> {&K_QUERYTYPE_CANFIND} then
do:
  
  if giRelationId > 0 then
    
    cValueList = qg_cCreateRelationValueList(cFieldList,
                                             giRelationId,
                                             glParentRelation,
                                             cRelationBufferName).
  
  cWhereClause = qg_cCreateWhereClause( /* pcDatabaseName   */ cDatabase,
                                        /* pcTableNames     */ cTable,
                                        /* pcBufferNames    */ cBufferName,
                                        /* pcFieldList      */ ( if lVirtualIndex
                                                                   and not glUseVirtualIndexApi then
                                                                   substitute( '&1_Obj':U, cTable )
                                                                 else
                                                                   cFieldList ),
                                        /* pcFieldLabelList */ ?,
                                        /* plStartWithWhere */ yes,
                                        /* piValueMode      */ ( if cValueList > '':U then
                                                                   {&K_VALUE_MODE_PARAMETER}
                                                                 else
                                                                   {&K_VALUE_MODE_DATA_TYPE} ),
                                        /* pcValueList      */ cValueList,
                                        /* piAccessMode     */ ( if lVirtualIndex then
                                                                   ( if glUseVirtualIndexApi then
                                                                       ( if glUseVirtualIndexIncludes then
                                                                           {&K_ACCESS_MODE_VIRTUAL_INDEX_INCLUDE}
                                                                         else
                                                                           {&K_ACCESS_MODE_VIRTUAL_INDEX_API} )
                                                                     else
                                                                       {&K_ACCESS_MODE_PHYSICAL} )
                                                                 else
                                                                   {&K_ACCESS_MODE_PHYSICAL} ),
                                        /* plAddTags        */ ( if lVirtualIndex
                                                                   and not glUseVirtualIndexApi then
                                                                   no
                                                                 else
                                                                   plAddTags ),
                                        /* piIndentBlanks   */   giIndentation
                                                               + ( if giQueryType = {&K_QUERYTYPE_CANFIND}
                                                                    and ( not lVirtualIndex
                                                                       or not glUseVirtualIndexApi
                                                                       or glUseVirtualIndexIncludes ) then
                                                                       12
                                                                     + ( if glIfStatement then
                                                                           3
                                                                         else
                                                                           0 )
                                                                     + ( if glNot then
                                                                           4
                                                                         else
                                                                           0 )
                                                                   else
                                                                     2 )
                                                               + ( if    lVirtualIndex then
                                                                     ( if not glUseVirtualIndexApi then
                                                                         ( if    giQueryType = {&K_QUERYTYPE_FINDFIRST}
                                                                             and glNoError then
                                                                             2
                                                                           else
                                                                             0 )
                                                                       else
                                                                         ( if    glUseVirtualIndexIncludes
                                                                             and giQueryType = {&K_QUERYTYPE_CANFIND} then
                                                                             2
                                                                           else
                                                                             0 ) )
                                                                   else
                                                                     0 ) ).
  
  if cWhereClause > '':U then
    
    cQueryText = substitute('&1~n&2':U,
                            cQueryText,
                            cWhereClause).
  
end. /* if    not lVirtualIndex */

if    lVirtualIndex
  and glUseVirtualIndexApi
  and not glUseVirtualIndexIncludes then
do:
  
  cQueryText = substitute(   '&1':U
                           + '~n&2':U + '  :oUseIndex( ~'&3~':U )':U,
                           cQueryText,
                           cIndentation,
                           ttIndex.IndexName ).
  
  case giQueryType:
    
    when {&K_QUERYTYPE_FINDFIRST} then
      
      cQueryText = substitute(   '&1':U
                               + '~n&2':U + '  :cFind&3( &4 )&5.':U,
                               cQueryText,
                               cIndentation,
                               ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                   'First':U
                                  else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                    'Last':U
                                  else
                                    '':U ),
                               cLockMode,
                               ( if glNoError then
                                   ' no-error':U
                                 else
                                   '':U ) )
      
      .
    
    when {&K_QUERYTYPE_FOREACH} then
      
      cQueryText = substitute(   '&1.':U
                               + '~n&2':U
                               + '~n&2':U + 'do while o&3:lGetNext( &4 )':U,
                               cQueryText,
                               cIndentation,
                               gcVirtualQueryApiClassName,
                               cLockMode ).
    
    when {&K_QUERYTYPE_CANFIND} then
      
      cQueryText = substitute(   '&1':U
                               + '~n&2':U + '  :lCanFind&3()&4':U,
                               cQueryText,
                               cIndentation,
                               ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                   'First':U
                                 else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                   'First':U
                                 else
                                   '':U ),
                               ( if glIfStatement then
                                   ' then':U
                                 else
                                   '':U ) ).
    
  end case. /* giQueryType */
  
end. /* if    lVirtualIndex */

else
do:
  
  if    lVirtualIndex
    and glUseVirtualIndexApi
    and glUseVirtualIndexIncludes then
    
    cQueryText = substitute(   '&1':U
                             + '~n&2':U + '&3use-index &4':U,
                             cQuerytext,
                             cIndentation,
                             ( if giQueryType = {&K_QUERYTYPE_CANFIND} then
                                 fill( ' ':U, 17 )
                               else
                                 fill( ' ':U, 2 ) ),
                             ttIndex.IndexName ).
  
  case giQueryType:
    
    when {&K_QUERYTYPE_FINDFIRST} then
      
      cQueryText = substitute('&1~n&2  &3&4&5.':U,
                              cQueryText,
                              cIndentation
                              + ( if    lVirtualIndex
                                    and not glUseVirtualIndexApi
                                    and glNoError then
                                    '  ':U
                                  else
                                    '':U ),
                              cLockMode,
                              ( if    lVirtualIndex
                                  and glUseVirtualIndexApi
                                  and glUseVirtualIndexIncludes then
                                  '}':U
                                else
                                  '':U ),
                              (if glNoError then
                                 ' no-error':U
                               else
                                 '':U)).
      
    when {&K_QUERYTYPE_FOREACH} then
      
      assign
        cQueryText = substitute('&1~n&2  &3':U,
                                cQueryText,
                                cIndentation,
                                cLockMode)
            when cLockMode > '':U
        cQueryText = substitute( '&1&2':U,
                                 cQueryText,
                                 ( if    lVirtualIndex
                                     and glUseVirtualIndexApi
                                     and glUseVirtualIndexIncludes then
                                     '}':U
                                   else
                                     '':U ) )
        .
    
    when {&K_QUERYTYPE_CANFIND} then
      
        cQueryText = substitute( '&1 )&2&3':U,
                                 cQueryText,
                                 ( if    lVirtualIndex
                                     and glUseVirtualIndexApi
                                     and glUseVirtualIndexIncludes then
                                     '}':U
                                   else
                                     '':U ),
                                 ( if glIfStatement then
                                     ' then':U
                                   else
                                     '':U ) ).
    
  end case. /* giQueryType */
  
end. /* else: if    lVirtualIndex */

case giQueryType:

  when {&K_QUERYTYPE_FINDFIRST} then
    
    assign
      cQueryText = substitute('&1~n&2':U,
                              cQueryText,
                              cIndentation) when glNoError
      cQueryText = substitute('&1~n&2if &3available &4 then':U,
                              cQueryText,
                              cIndentation,
                              (if glNot then
                                 'not ':U
                               else
                                 '':U),
                              cBufferName) when glNoError
      cQueryText = substitute('&1~n&2do:~n&2  &3~n&2end. /* if &4available &5 */':U,
                              cQueryText,
                              cIndentation,
                              (if plAddTags then
                                 qg_cTaggedValue('cursor':U, yes)
                               else
                                 '':U),
                              (if glNot then
                                 'not ':U
                               else
                                 '':U),
                              cBufferName) when glNoError and glDoBlock
    .

    when {&K_QUERYTYPE_FOREACH} then

      assign
        cQueryText = substitute( '&1:':U,
                                 cQueryText )
            when not glOnError
        cQueryText = substitute('&1~n&2  &3:':U,
                                cQueryText,
                                cIndentation,
                                (if giOnErrorPhrase = {&K_ON_ERROR_PHRASE_NEXT} then
                                   substitute('on error undo&1, next&1':U,
                                              (if cBlockName > '':U then
                                                 ' ':U + cBlockName
                                               else
                                                 '':U))
                                 else if giOnErrorPhrase = {&K_ON_ERROR_PHRASE_RETRY} then
                                   substitute('on error undo&1, retry&1':U,
                                              (if cBlockName > '':U then
                                                 ' ':U + cBlockName
                                               else
                                                 '':U))
                                 else if giOnErrorPhrase = {&K_ON_ERROR_PHRASE_THROW} then
                                   'on error undo, throw':U
                                 else
                                   substitute('on error undo&1, leave&1':U,
                                              (if cBlockName > '':U then
                                                 ' ':U + cBlockName
                                               else
                                                 '':U))))
            when glOnError
        cQueryText = substitute('&1~n&2  ~n&2  &3':U,
                                cQueryText,
                                cIndentation,
                                substitute('if retry then~n&1  do:~n&1    /* TODO */~n&1  end. /* retry */':U,
                                           cIndentation))
            when ( glOnError
               and giOnErrorPhrase = {&K_ON_ERROR_PHRASE_RETRY}
               and glRetryBlock )
        cQueryText = substitute('&1~n&2  ~n&2  &3':U,
                                cQueryText,
                                cIndentation,
                                substitute('finally:~n&1    /* TODO */~n&1  end finally.':U,
                                           cIndentation))
            when glFinallyBlock
        .
    
end case. /* giQueryType */

if    lVirtualIndex
  and glUseVirtualIndexApi
  and not glUseVirtualIndexIncludes then
  
  case giQueryType:
    
    when {&K_QUERYTYPE_FOREACH} then
      
      cQueryText = substitute(   '&1':U
                               + '~n&2':U + '  &3':U
                               + '~n&2':U + 'end. /* do while o&4:lGetNext( &5 ) */':U,
                               cQueryText,
                               cIndentation,
                               ( if plAddTags then
                                   qg_cTaggedValue('cursor':U, yes)
                                 else
                                   '':U ),
                               gcVirtualQueryApiClassName,
                               cLockMode ).
    
    when {&K_QUERYTYPE_CANFIND} then
      
      if    glIfStatement
        and glDoBlock then
      
        cQueryText = substitute( '&1':U
                                 + '~n&2':U + 'do:':U
                                 + '~n&2':U + '  &3':U
                                 + '~n&2':U + 'end. /* &4&5o&6 ... :lCanFind&7() */':U,
                                 cQueryText,
                                 cIndentation,
                                 ( if plAddTags then
                                     qg_cTaggedValue('cursor':U, yes)
                                   else
                                     '':U ),
                                 ( if glIfStatement then
                                     'if ':U
                                   else
                                     '':U ),
                                 ( if glNot then
                                     'not ':U
                                   else
                                     '':U ),
                                 gcVirtualQueryApiClassName,
                                 ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                     'First':U
                                   else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                     'Last ':U
                                   else
                                     '':U ) ).
    
  end case. /* giDisplayMode */

else
  
  case giQueryType:
    
    when {&K_QUERYTYPE_FOREACH} then
      
      cQueryText = substitute(   '&1':U
                               + '~n&2':U + '  &3':U
                               + '~n&2':U + 'end. /* &4for&5 &6 */':U,
                               cQueryText,
                               cIndentation,
                               ( if plAddTags then
                                   qg_cTaggedValue( 'cursor':U, yes )
                                 else
                                   '':U ),
                               ( if    lVirtualIndex
                                   and glUseVirtualIndexApi
                                   and glUseVirtualIndexIncludes then
                                   '~{':U
                                 else
                                   '':U ),
                               ( if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                   ' first':U
                                 else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                   ' last':U
                                 else
                                  ' each':U ),
                               ( if    lVirtualIndex
                                   and not glUseVirtualIndexApi then
                                   cVirtualIndexBufferName
                                 else
                                   cBufferName ) ).
    
    when {&K_QUERYTYPE_CANFIND} then
      
      if    glIfStatement
        and glDoBlock then
      
        cQueryText = substitute(   '&1':U
                                 + '~n&2':U + 'do:':U
                                 + '~n&2':U + '  &3':U
                                 + '~n&2':U + 'end. /* &4&5&6can-find( &7&8 */':U,
                                 cQueryText,
                                 cIndentation,
                                 (if plAddTags then
                                    qg_cTaggedValue('cursor':U, yes)
                                  else
                                    '':U),
                                 (if glIfStatement then
                                    'if ':U
                                  else
                                    '':U),
                                 (if glNot then
                                    'not ':U
                                  else
                                    '':U),
                                 ( if    lVirtualIndex
                                     and glUseVirtualIndexApi
                                     and glUseVirtualIndexIncludes then
                                     '~{':U
                                   else
                                     '':U ),
                                 (if giQueryTypeModifier = {&K_QUERYRANGE_FIRST} then
                                    'first ':U
                                  else if giQueryTypeModifier = {&K_QUERYRANGE_LAST} then
                                    'last ':U
                                  else
                                    '':U),
                                 ( if    lVirtualIndex
                                     and not glUseVirtualIndexApi then
                                     cVirtualIndexBufferName
                                   else
                                     cBufferName ) ).
    
  end case. /* giDisplayMode */

  
return trim( cQueryText, '~n':U ).

end function. /* qg_cCreateQueryText */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cCreateRelationValueList hQueryWindow 
function qg_cCreateRelationValueList returns character
  ( pcFieldList      as character,
    piRelationId     as integer,
    plParentRelation as logical,
    pcBufferName     as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Create query text.                                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName   as character no-undo.
define variable cTableName      as character no-undo.

define variable cFieldName      as character no-undo.
define variable cValue          as character no-undo.
define variable cValueList      as character no-undo.

define variable i               as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable              for temp-table ttTable.
define buffer bttField              for temp-table ttField.
define buffer bttTableRelation      for temp-table ttTableRelation.
define buffer bttTableRelationField for temp-table ttTableRelationField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if not available ttDatabase then
  return '':U.

assign
  cDatabaseName = ttDatabase.DatabaseName
  cTableName    = (if    giDisplayMode = {&K_DISPLAYMODE_RELATION}
                     and glInvertQuery then
                     (if available ttTableRelationView then
                        ttTableRelationView.RelatedTableName
                      else
                        '':U)
                   else
                     (if available ttTable then
                        ttTable.TableName
                      else
                        '':U))
  .

find bttTableRelation
  where bttTableRelation.RelationId = piRelationId
  no-error.

if not available bttTableRelation then
  return '':U.

do i = 1 to num-entries(pcFieldList):
  
  cFieldName = entry(i, pcFieldList).
  
  if can-do({&K_COMPANY_FIELDS}, cFieldName) then
    cValue = '%COMPANY%':U.
  
  else
  do:
  
    if plParentRelation then
      find first bttTableRelationField
        where bttTableRelationField.ChildFieldName = cFieldName
          and bttTableRelationField.Relationid     = bttTableRelation.RelationId
        no-error.
    
    else
      find first bttTableRelationField
        where bttTableRelationField.ParentFieldName = cFieldName
          and bttTableRelationField.Relationid      = bttTableRelation.RelationId
        no-error.
    
    if available bttTableRelationField then
      cValue = qg_cGetRelationField(buffer bttTableRelation,
                                    buffer bttTableRelationField,
                                    pcBufferName,
                                    not plParentRelation,
                                    yes).
    
    else
    do:
      
      if plParentRelation then
        find bttField
          where bttField.DatabaseName = cDatabaseName
            and bttField.TableName    = bttTableRelation.ChildTableName
            and bttField.FieldName    = cFieldName
          no-error.
        
      else
        find bttField
          where bttField.DatabaseName = cDatabaseName
            and bttField.TableName    = bttTableRelation.ParentTableName
            and bttField.FieldName    = cFieldName
          no-error.
      
      cValue = (if available bttField then
                  substitute('&1.&2':U, pcBufferName, bttField.FieldName)
                else
                  '%DATATYPE%':U).
      
    end. /* else: if available bttTableRelationField */
    
  end. /* if can-do({&K_COMPANY_FIELDS}, cFieldName) */
  
  cValueList = substitute('&1&2&3':U,
                          cValueList,
                          (if i > 1 then
                             {&K_PARAM_SPLITTER}
                           else
                             '':U),
                          cValue).
  
end. /* do i = 1 to num-entries(pcFieldList) */

return cValueList.

end function. /* qg_cCreateRelationValueList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cCreateRelatedWhereClause hQueryWindow 
function qg_cCreateRelatedWhereClause returns character
  ( buffer pbttTableRelation for ttTableRelation,
    plParent           as logical,
    pcBufferName       as character,
    pcParentBufferName as character,
    piParentQuerySeq   as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldList   as character no-undo.
define variable cValueList   as character no-undo.

define variable cWhereClause as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTableRelationField for temp-table ttTableRelationField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

for each bttTableRelationField
  where bttTableRelationField.RelationId = pbttTableRelation.RelationId
  on error undo, throw:
  
  if    bttTableRelationField.FieldRelationType = 'KEY':U
    and ( ( plParent
        and bttTableRelationField.ChildConstantData = '$KEY':U )
       or ( not plParent
        and bttTableRelationField.ParentConstantData = '$KEY':U ) ) then
  do:
    
    assign
      cFieldList = substitute('&1,%COMMENT%':U, cFieldList)
      cValueList = substitute('&1&2&3':U,
                              cValueList,
                              {&K_PARAM_SPLITTER},
                              '/* !!! Please set Key values manually !!! */':T)
      .
    
    next.
    
  end. /* if    bttTableRelationField.FieldRelationType = 'KEY':U */
  
  assign
    cFieldList = substitute('&1,&2':U,
                            cFieldList,
                            qg_cGetRelationField(buffer pbttTableRelation,
                                                 buffer bttTableRelationField,
                                                 pcBufferName,
                                                 not plParent,
                                                 no))
    cValueList = substitute('&1&2&3':U,
                            cValueList,
                            {&K_PARAM_SPLITTER},
                            (if    piParentQuerySeq > 0
                               and ( bttTableRelationField.FieldRelationType   = '':U
                                  or bttTableRelationField.FieldRelationType   = 'DB-Field':U
                                  or ( bttTableRelationField.FieldRelationType = 'CONSTANT':U
                                   and ( ( plParent
                                       and bttTableRelationField.ParentFieldName > '':U )
                                      or ( not plParent
                                       and bttTableRelationField.ChildFieldName > '':U ) ) ) ) then
                               substitute('$~{&1:&2.&3~}':U,
                                          string(piParentQuerySeq),
                                          pcParentBufferName,
                                          (if plParent then
                                             bttTableRelationField.ChildFieldName
                                           else
                                             bttTableRelationField.ParentFieldName))
                             else
                               qg_cGetRelationField(buffer pbttTableRelation,
                                                    buffer bttTableRelationField,
                                                    pcParentBufferName,
                                                    plParent,
                                                    no)))
    .
  
end. /* for each bttTableRelationField */

assign
  cFieldList = trim(cFieldList, ',':U)
  cValueList = trim (cValueList, {&K_PARAM_SPLITTER})
  .

return qg_cCreateWhereClause( /* pcDatabaseName   */pbttTableRelation.DatabaseName,
                              /* pcTableNames     */( if plParent then
                                                         pbttTableRelation.ParentTableName
                                                       else
                                                         pbttTableRelation.ChildTableName ),
                              /* pcBufferNames    */ pcBufferName,
                              /* pcFieldList      */ cFieldList,
                              /* pcFieldLabelList */ ?,
                              /* plStartWithWhere */ yes,
                              /* piValueMode      */ {&K_VALUE_MODE_PARAMETER},
                              /* pcValueList      */ cValueList,
                              /* piAccessMode     */ {&K_ACCESS_MODE_PHYSICAL},
                              /* plAddTags        */ no,
                              /* piIndentBlanks   */ 2 ).

end function. /* qg_cCreateRelatedWhereClause */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cCreateWhereClause hQueryWindow 
function qg_cCreateWhereClause returns character
  ( pcDatabaseName   as character,
    pcTableNames     as character,
    pcBufferNames    as character,
    pcFieldList      as character,
    pcFieldLabelList as character,
    plStartWithWhere as logical,
    piValueMode      as integer,
    pcValueList      as character,
    piAccessMode     as integer,
    plAddTags        as logical,
    piIndentBlanks   as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the where clause for the current query.                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcBufferNames                  = Buffer name that should be used.          */
/* pcFieldList                    = List of fields that the where clause      */
/*                                  should contain.                           */
/* piValaueMode                   = Value mode.                               */
/* plAddTags                      = Flag to indicate if a tag should be added */
/*                                  to the values.                            */
/* piIndentBlanks                 = Numer of blanks that should be used for   */
/*                                  indentation.                              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iField             as integer   no-undo.
define variable iIndex             as integer   no-undo.
define variable iFirstIndex        as integer   no-undo.
define variable iLastIndex         as integer   no-undo.

define variable cDatabaseName      as character no-undo.
define variable cBfferName         as character no-undo.
define variable cTableName         as character no-undo.
define variable cFieldName         as character no-undo.
define variable iFieldIndex        as integer   no-undo.
define variable cFieldLabel        as character no-undo.

define variable cDatabaseNames     as character no-undo extent.
define variable cBfferNames        as character no-undo extent.
define variable cTableNames        as character no-undo extent.
define variable cFieldNames        as character no-undo extent.
define variable iFieldIndices      as integer   no-undo extent.
define variable cFieldLabels       as character no-undo extent.
define variable cFieldValues       as character no-undo extent.

define variable cWhereClause       as character no-undo.

define variable lCompany           as logical   no-undo.
define variable cCompanyInclude    as character no-undo.
define variable cCompany           as character no-undo.

define variable iFieldNameLength   as integer   no-undo.
define variable iLongestFieldname  as integer   no-undo.

define variable iFieldLabelLength  as integer   no-undo.
define variable iLongestFieldLabel as integer   no-undo.

define variable cFieldValue        as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField      for temp-table ttField.
define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if pcFieldList > '':U then
do:
  
  assign
    extent(cDatabaseNames) = num-entries(pcFieldList)
    extent(cBfferNames)    = extent(cDatabaseNames)
    extent(cTableNames)    = extent(cDatabaseNames)
    extent(cFieldNames)    = extent(cDatabaseNames)
    extent(cFieldLabels)   = extent(cDatabaseNames)
    extent(iFieldIndices)  = extent(cDatabaseNames)
    extent(cFieldValues)   = extent(cDatabaseNames)
    glCompanyViaClass      = (if glSlimMode then
                                {&K_DEFAULT_COMPANY_VIA_CLASS}
                              else
                                input frame {&FRAME-NAME} glCompanyViaClass)
    .
  
  do iField = 1 to num-entries(pcFieldList):
    
    run qg_SplitFieldName(entry(iField, pcFieldList),
                          output cDatabaseName,
                          output cTableName,
                          output cFieldName,
                          output iFieldIndex).
    
    assign
      cDatabaseNames[iField] = (if cDatabaseName > '':U then
                                  cDatabaseName
                                else
                                  pcDatabaseName)
      cBfferNames[iField]    = (if cTableName > '':U then
                                  cTableName
                                else
                                  entry(1, pcBufferNames))
      cTableNames[iField]    = (if cTableName > '':U then
                                  entry(lookup(cTableName, pcBufferNames), pcTableNames)
                                else
                                  entry(1, pcTableNames))
      cFieldNames[iField]    = cFieldName
      iFieldIndices[iField]  = iFieldIndex
      cFieldLabels[iField]   = ( if num-entries( pcFieldLabelList ) >= iField then
                                   entry( iField, pcFieldLabelList )
                                 else
                                   ? )
      .
    
    if    piValueMode = {&K_VALUE_MODE_PARAMETER}
      and iField     <= num-entries(pcValueList, {&K_PARAM_SPLITTER}) then
      
      cFieldValues[iField] = entry(iField, pcValueList, {&K_PARAM_SPLITTER}).
    
    if cFieldName <> '%COMMENT%':U then
    do:
      
      find first bttField
        where bttField.DatabaseName = cDatabaseNames[iField]
          and bttField.TableName    = cTableNames[iField]
          and bttField.FieldName    = cFieldNames[iField]
        no-error.
    
      if    not available(bttField)
         or lookup(bttField.DataType, {&K_WHERE_DATA_TYPE_BLACKLIST}) = 0 then
      do:
        
        assign
          iFieldIndex       = ( if iFieldIndices[iField] > 0 then
                                  iFieldIndices[iField]
                                else if available bttField then
                                  bttField.FieldExtent
                                else
                                  0 )
          cFieldName        = qg_cFormattedFieldName( ?,
                                                      ( if piAccessMode = {&K_ACCESS_MODE_VIRTUAL_INDEX_API} then
                                                           ?
                                                         else
                                                           cBfferNames[iField] ),
                                                      cFieldNames[iField],
                                                      iFieldIndex )
          iFieldNameLength  = length( cFieldName )
          .
        
        if iFieldNameLength > iLongestFieldname then
          
          iLongestFieldname = iFieldNameLength.
        
        assign
          cFieldLabel       = ( if cFieldLabels[iField] = ? then
                                  '':U
                                else if iFieldIndex > 0 then
                                  substitute( '&1 &2',
                                              cFieldLabels[iField],
                                              string( iFieldIndex ) )
                                else
                                  cFieldLabels[iField] )
          iFieldLabelLength = length( cFieldLabel )
          .
        
        if iFieldLabelLength > iLongestFieldLabel then
          
          iLongestFieldLabel = iFieldLabelLength.
        
      end. /* if    available(bttField) ... */
      
    end. /* if cFieldName <> '%COMMENT%':U */
    
  end. /* do iField = 1 to num-entries(pcFieldList) */
  
  do iField = 1 to extent(cFieldNames):
    
    if cFieldNames[iField] = '%COMMENT%':U then
    do:
      
      cWhereClause = substitute('&1~n&2&3&4':U,
                                cWhereClause,
                                fill(' ':U, piIndentBlanks),
                                (if    plStartWithWhere
                                   and iField = 1 then
                                   '':U
                                 else
                                   '  ':U),
                                cFieldValues[iField]).
      
      next.
      
    end. /* if cFieldNames[iField] = '%COMMENT%':U */
    
    find first bttField
      where bttField.DatabaseName = cDatabaseNames[iField]
        and bttField.TableName    = cTableNames[iField]
        and bttField.FieldName    = cFieldNames[iField]
      no-error.
    
    if    not available(bttField)
       or ( lookup(bttField.DataType, {&K_WHERE_DATA_TYPE_BLACKLIST}) = 0
        and ( not bttField.IsVirtual
           or piAccessMode <> {&K_ACCESS_MODE_PHYSICAL} ) ) then
    do:
      
      if not available bttField then
        
        assign
          lCompany        = no
          cCompanyInclude = '':U
          cCompany        = '':U
          .
      
      else
      do:
        
        lCompany = (     can-do( {&K_COMPANY_FIELDS}, bttField.FieldName )
                      or ( piValueMode = {&K_VALUE_MODE_PARAMETER}
                       and cFieldValues[iField] = '%COMPANY%':U ) ).
        
        if lCompany then
          assign
            cCompanyInclude = qg_cGetCompanyInclude(bttField.TableName)
            cCompany        = (if piValueMode = {&K_VALUE_MODE_DEFAULT_VALUE} then
                                 substitute('~'&1~'', qg_cGetCompany(bttField.TableName, ?))
                               else if glCompanyViaClass then
                                 '{&K_CLASS_COMPANY_STATEMENT}':U
                               else
                                 'pa-Firma':U)
            .
        
      end. /* if not available bttField */
      
      if iFieldIndices[iField] > 0 then
        
        assign
          iFirstIndex = iFieldIndices[iField]
          iLastIndex  = iFieldIndices[iField]
          .
      
      else
        
        if    available bttField
          and bttField.FieldExtent > 0 then
          assign
            iFirstIndex = 1
            iLastIndex  = bttField.FieldExtent
            .
      
      else
        
        assign
          iFirstIndex = 0
          iLastIndex  = 0
          .
      
      do iIndex = iFirstIndex to iLastIndex:
      
        assign
          cFieldName       = (if not available bttField then
                                cFieldNames[iField]
                              else
                                qg_cFormattedFieldName(?,
                                                       ( if piAccessMode = {&K_ACCESS_MODE_VIRTUAL_INDEX_API} then
                                                           ?
                                                         else
                                                           cBfferNames[iField] ),
                                                       bttField.FieldName,
                                                       iIndex))
          iFieldNameLength = length(cFieldName)
          cFieldLabel      = ( if cFieldLabels[iField] = ? then
                                  '':U
                               else if iIndex > 0 then
                                 substitute( '&1 &2':U,
                                             cFieldLabels[iField],
                                             string( iIndex ) )
                               else
                                 cFieldLabels[iField] )
          iFieldLabelLength = length( cFieldLabel )
          cFieldValue       = ( if piValueMode = {&K_VALUE_MODE_DEFAULT_VALUE} then
                                  qg_cTaggedValue((if lCompany then
                                                     cCompany
                                                   else if available bttField then
                                                     qg_cGetDefaultValue(bttField.DataType)
                                                   else
                                                     '?':U),
                                                  plAddTags)
                                else if piValueMode = {&K_VALUE_MODE_PARAMETER} then
                                  (if cFieldValues[iField] = '%DATATYPE%':U then
                                     qg_cTaggedValue(substitute('<&1>':U,
                                                                (if available bttField then
                                                                   caps(bttField.DataType)
                                                                 else
                                                                   '?':U)),
                                                     plAddTags)
                                   else if cFieldValues[iField] = '%COMPANY%':U then
                                     (if cCompanyInclude > '':U then
                                        substitute('~{firma/&1 &2~}':U,
                                                   cCompanyInclude,
                                                   qg_cTaggedValue(cCompany,
                                                                   plAddTags))
                                      else
                                        qg_cTaggedValue(cCompany,
                                                        plAddTags))
                                   else
                                     qg_cTaggedValue(cFieldValues[iField],
                                                     plAddTags))
                                else
                                 (if    available bttField
                                    and can-do({&K_COMPANY_FIELDS}, bttField.FieldName) then
                                    (if cCompanyInclude > '':U then
                                       substitute('~{firma/&1 &2~}':U,
                                                  cCompanyInclude,
                                                  qg_cTaggedValue(cCompany,
                                                                  plAddTags))
                                     else
                                       qg_cTaggedValue(cCompany,
                                                       plAddTags))
                                  else
                                    qg_cTaggedValue(substitute('<&1>':U,
                                                               (if available bttField then
                                                                  caps(bttField.DataType)
                                                                else
                                                                  '?':U)),
                                                     plAddTags)))
          cWhereClause      = ( if piAccessMode = {&K_ACCESS_MODE_VIRTUAL_INDEX_API} then
                                  substitute( '&1~n&2&3( ~'&4~':U&5, &6~'=~':U, &7 )':U,
                                              cWhereClause,
                                              fill( ' ':U, piIndentBlanks ),
                                              ( if    plStartWithWhere
                                                  and iField = 1
                                                  and iIndex < 2 then
                                                  ':oWhere':U
                                                else if plStartWithWhere then
                                                  '  :oAnd':U
                                                else
                                                  ':oAnd':U ),
                                              cFieldName,
                                              ( if iFieldLabelLength > 0 then
                                                  substitute( ' /* &1&2 */':U,
                                                              cFieldLabel,
                                                              fill( ' ':U, max( 0, iLongestFieldLabel - iFieldLabelLength ) ) )
                                                else if iLongestFieldLabel > 0 then
                                                  fill( ' ':U, iLongestFieldLabel + 7 )
                                                else
                                                  '':U ),
                                              fill(' ':U, max(0, iLongestFieldname - iFieldNameLength)),
                                              cFieldValue )
                                else
                                  substitute( '&1~n&2&3 &4&5&6 = &7':U,
                                              cWhereClause,
                                              fill(' ':U, piIndentBlanks),
                                              ( if    plStartWithWhere
                                                  and iField = 1
                                                  and iIndex < 2 then
                                                  'where':U
                                                else if plStartWithWhere then
                                                  '  and':U
                                                else
                                                  'and':U ),
                                              cFieldName,
                                              fill(' ':U, max(0, iLongestFieldname - iFieldNameLength)),
                                              ( if iFieldLabelLength > 0 then
                                                  substitute( ' /* &1&2 */':U,
                                                              cFieldLabel,
                                                              fill( ' ':U, max( 0, iLongestFieldLabel - iFieldLabelLength ) ) )
                                                else if iLongestFieldLabel > 0 then
                                                  fill( ' ':U, iLongestFieldLabel + 7 )
                                                else
                                                  '':U ),
                                              ( if    piAccessMode = {&K_ACCESS_MODE_VIRTUAL_INDEX_INCLUDE}
                                                  and ( index( cFieldValue, ' ':U )  > 0
                                                     or index( cFieldValue, '~t':U ) > 0
                                                     or index( cFieldValue, '~n':U ) > 0 ) then
                                                  quoter( cFieldValue )
                                                else
                                                  cFieldValue ) ) )
          .
        
      end. /* do iIndex = iFirstIndex to iLastIndex */
    
    end. /* if available(bttField) */
    
  end. /* do iField = 1 to extent(cFieldNames) */
  
end. /* if pcFieldList > '':U */

return trim(cWhereClause, '~n':U).

end function. /* qg_cCreateWhereClause */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cCurrentFieldList hQueryWindow 
function qg_cCurrentFieldList returns character
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get currently active field list depending von display mode.                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

giDisplayMode = input frame {&FRAME-NAME} giDisplayMode.

case giDisplayMode:
  
  when {&K_DISPLAYMODE_INDEX} then
    return (if available ttIndex then
              ttIndex.IndexFieldList
            else
              '':U).
  
  when {&K_DISPLAYMODE_RELATION} then
    return (if available ttTableRelationView then
              (if glInvertQuery then
                 ttTableRelationView.RelatedFieldList
               else
                 ttTableRelationView.ReferenceFieldList)
            else
              '':U).
  
  otherwise
    return qg_cGetSelectedFields(?, ',':U, no).
  
end case. /* giDisplayMode */

end function. /* qg_cCurrentFieldList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cExtractFieldName hQueryWindow 
function qg_cExtractFieldName returns character
  ( pcFieldName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Extract field name from <FieldName>[<Index>].                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFieldName                    = Character from which you want to extract  */
/*                                  the field name.                           */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if index(pcFieldName, '[':U) > 0 then
  return substring(pcFieldName,
                   1,
                   index(pcFieldName, '[':U) - 1).

else
  return pcFieldName.

end function. /* qg_cExtractFieldName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFieldAssignments hQueryWindow 
function qg_cFieldAssignments returns character
  ( plInsertMode as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns field assignments text for current field selection.                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* plInsertMode                   = Flag to indicate if insert mode should    */
/*                                  be used.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldList as character no-undo.
define variable cValueList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

gcBufferName = (if glSlimMode then
                  substitute({&K_DEFAULT_BUFFER_PATTERN},
                             qg_cGetBufferBaseName(no))
                else
                  input frame {&FRAME-NAME} gcBufferName).

if not available ttTable then
  return '':U.

else
do:
  
  cFieldList = qg_cGetSelectedFields(?, ',':U, no).
  
  if giRelationId > 0 then
    cValueList = qg_cCreateRelationValueList(cFieldList,
                                             giRelationId,
                                             glParentRelation,
                                             gcRelationBufferName).
  
  return   qg_cGetFieldAssignmentsStatement
             ( ttTable.DatabaseName,
               ttTable.TableName,
               gcBufferName,
               cFieldList,
               (if giRelationId > 0 then
                  {&K_VALUE_MODE_PARAMETER}
                else
                  {&K_VALUE_MODE_DATA_TYPE}),
               cValueList,
               plInsertMode,
               0 )
         + qg_cGetFieldAssignmentsStatementForVirtualFields
             ( ttTable.DatabaseName,
               ttTable.TableName,
               gcBufferName,
               cFieldList,
               (if giRelationId > 0 then
                  {&K_VALUE_MODE_PARAMETER}
                else
                  {&K_VALUE_MODE_DATA_TYPE}),
               cValueList,
               plInsertMode,
               0 )
         
         .
  
end. /* else: if not available ttTable */

end function. /* qg_cFieldAssignments */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFieldAssignStatement hQueryWindow 
function qg_cFieldAssignStatement returns character
  ( plInsertMode as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns field assign statement for current field selection.                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* plInsertMode                   = Flag do indicate if insert mode should    */
/*                                  be used.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldList as character no-undo.
define variable cValueList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

gcBufferName = (if glSlimMode then
                  substitute({&K_DEFAULT_BUFFER_PATTERN},
                             qg_cGetBufferBaseName(no))
                else
                  input frame {&FRAME-NAME} gcBufferName).

if not available ttTable then
  return '':U.

else
do:
  
  cFieldList = qg_cGetSelectedFields(?, ',':U, no).
  
  if giRelationId > 0 then
    cValueList = qg_cCreateRelationValueList(cFieldList,
                                             giRelationId,
                                             glParentRelation,
                                             gcRelationBufferName).
  
  return substitute('assign~n&1~n  .':U,
                    qg_cGetFieldAssignmentsStatement
                      (ttTable.DatabaseName,
                       ttTable.TableName,
                       gcBufferName,
                       cFieldList,
                       (if giRelationId > 0 then
                          {&K_VALUE_MODE_PARAMETER}
                        else
                          {&K_VALUE_MODE_DATA_TYPE}),
                       cValueList,
                       plInsertMode,
                       2))
         + qg_cGetFieldAssignmentsStatementForVirtualFields
                      (ttTable.DatabaseName,
                       ttTable.TableName,
                       gcBufferName,
                       cFieldList,
                       (if giRelationId > 0 then
                          {&K_VALUE_MODE_PARAMETER}
                        else
                          {&K_VALUE_MODE_DATA_TYPE}),
                       cValueList,
                       plInsertMode,
                       0)
         + ( if plInsertMode then
               '$~{cursor}':U
             else
               '':U ).
  
end. /* else: if not available ttTable */

end function. /* qg_cFieldAssignStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFieldValues hQueryWindow 
function qg_cFieldValues returns character
  ( phBuffer    as handle,
    phOldBuffer as handle,
    pcFieldList as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get values for given field list as <field name> = <value> list (line       */
/* separated).                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer                       = Buffer that contains the field values.    */
/* phOldBuffer                    = Old buffer that contains the old values   */
/*                                  (may be ?)                                */
/* pcFieldList                    = List of fields to be used.                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iCounter           as integer   no-undo.
define variable cDatabaseName      as character no-undo.
define variable cFieldName         as character no-undo.
define variable iIndex             as integer   no-undo.
define variable iIndexCounter      as integer   no-undo.

define variable hBufferField       as handle    no-undo.
define variable hOldBufferField    as handle    no-undo.
define variable cFieldValue        as character no-undo.
define variable cOldFieldValue     as character no-undo.
define variable cResolved          as character no-undo.
define variable cFieldValues       as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

Main:
do on error undo Main, leave Main:
  
  if not valid-handle(phBuffer) then
    
    leave Main.

  cDatabaseName = qg_cDatabaseNameForTableOrBuffer( phBuffer ).

  do iCounter = 1 to num-entries(pcFieldList):
    
    assign
      cFieldName     = qg_cExtractFieldName(entry(iCounter, pcFieldList))
      iIndex         = qg_iExtractIndex(entry(iCounter, pcFieldList))
      cFieldValue    = '':U
      cOldFieldValue = '':U
      .
    
    hBufferField = phBuffer:buffer-field(cFieldName) no-error.
    
    if valid-handle( phOldBuffer ) then
      
      hOldBufferField = phOldBuffer:buffer-field(cFieldName) no-error.
    
    if iIndex > 0 then
    do:
      
      if valid-handle( hBufferField ) then
      do:
         
        cFieldValue = hBufferField:buffer-value(iIndex).
        
        if    num-entries( cFieldValue, ':':U ) <> 3
           or hBufferField:name = substitute( '&1_Obj':U, phBuffer:table ) then
          
          cFieldValue = quoter( cFieldValue ).
        
        else
          
          assign
            cResolved   = qg_cResolveObjectId( phBuffer:dbname,
                                               hBufferField:name,
                                               cFieldValue,
                                               yes,
                                               yes )
            cFieldValue = ( if    cResolved  > '':U
                              and cResolved <> cFieldValue then
                              substitute( '&1 <resolved: &2>':U,
                                          quoter( cFieldValue ),
                                          cResolved )
                            else
                              quoter( cFieldValue ) )
            .
        
      end. /* if valid-handle( hBufferField ) */
      
      if valid-handle( hOldBufferField ) then
      do:
        
        cOldFieldValue = hOldBufferField:buffer-value(iIndex).
        
        if    num-entries( cOldFieldValue, ':':U ) <> 3
           or hBufferField:name = substitute( '&1_Obj':U, phBuffer:table ) then
          cOldFieldValue = quoter( cOldFieldValue ).
        
        else
          assign
            cResolved      = qg_cResolveObjectId( phBuffer:dbname,
                                                  hBufferField:name,
                                                  cOldFieldValue,
                                                  yes,
                                                  yes )
            cOldFieldValue = ( if    cResolved  > '':U
                                 and cResolved <> cFieldValue then
                                 substitute( '&1 <resolved: &2>':U,
                                             quoter( cOldFieldValue ),
                                             cResolved )
                               else
                                 quoter( cOldFieldValue ) )
            .
        
      end. /* if valid-handle( hOldBufferField ) */
      
      cFieldValues = substitute('&1~n-> &2: &3':U,
                                cFieldValues,
                                substitute('&1[&2]':U,
                                           cFieldName,
                                           iIndex),
                                (if valid-handle(hOldBufferField) then
                                   substitute('&1 (alt) -> &2 (neu)':U,
                                              cOldFieldValue,
                                              cFieldValue)
                                 else
                                   cFieldValue)).
      
    end. /* if iIndex > 0 */
    
    else
    do:
      
      if valid-handle( hBufferField ) then
        
        do iIndexCounter = integer(hBufferField:extent > 0) to hBufferField:extent:
          
          cFieldValue = hBufferField:buffer-value(iIndexCounter).
          
          if    num-entries( cFieldValue, ':':U ) <> 3
             or hBufferField:name = substitute( '&1_Obj':U, phBuffer:table ) then
            
            cFieldValue = quoter( cFieldValue ).
          
          else
            
            assign
              cResolved   = qg_cResolveObjectId( phBuffer:dbname,
                                                 hBufferField:name,
                                                 cFieldValue,
                                                 yes,
                                                 yes )
              cFieldValue = ( if    cResolved  > '':U
                                and cResolved <> cFieldValue then
                                substitute( '&1 <resolved: &2>':U,
                                            quoter( cFieldValue ),
                                            cResolved )
                              else
                                quoter( cFieldValue ) )
              .
          
          if valid-handle( hOldBufferField ) then
          do:
            
            cOldFieldValue = hOldBufferField:buffer-value(iIndexCounter).
            
            if    num-entries( cOldFieldValue, ':':U ) <> 3
               or hBufferField:name = substitute( '&1_Obj':U, phBuffer:table ) then
              cOldFieldValue = quoter( cOldFieldValue ).
            
            else
              assign
                cResolved      = qg_cResolveObjectId( phBuffer:dbname,
                                                      hBufferField:name,
                                                      cOldFieldValue,
                                                      yes,
                                                      yes )
                cOldFieldValue = ( if    cResolved  > '':U
                                     and cResolved <> cFieldValue then
                                     substitute( '&1 <resolved: &2>':U,
                                                 quoter( cOldFieldValue ),
                                                 cResolved )
                                   else
                                     quoter( cOldFieldValue ) )
                .
            
          end. /* if valid-handle( hOldBufferField ) */

        cFieldValues = substitute('&1~n-> &2: &3':U,
                                  cFieldValues,
                                  qg_cFormattedFieldName(?,
                                                         ?,
                                                         hBufferField:name,
                                                         iIndexCounter),
                                  (if valid-handle(hOldBufferField) then
                                     substitute('&1 (alt) -> &2 (neu)':U,
                                                cOldFieldValue,
                                                cFieldValue)
                                   else
                                     cFieldValue)).
        
      end. /* do iIndexCounter = integer(hBufferField:extent > 0) to hBufferField:extent */
    
    else
      
      if qg_lIsPhysicalDatabase( phBuffer:dbname ) then
      do:
        
        find bttField
          where bttField.DatabaseName = cDatabaseName
            and bttField.TableName    = phBuffer:table
            and bttField.FieldName    = cFieldName
          no-error.
        
        if    available bttField
          and bttField.IsVirtual then
        do:
          
          cFieldValue = string( qg_clVirtualFieldValueAsLongchar( bttField.FieldType,
                                                                  bttField.DataType,
                                                                  bttField.FieldName,
                                                                  qg_cObjectIdForBuffer( phBuffer ),
                                                                  ? ) ).
          
          if    num-entries( cFieldValue, ':':U ) <> 3
             or bttField.FieldName = substitute( '&1_Obj':U, phBuffer:table ) then
            
            cFieldValue = quoter( cFieldValue ).
          
          else
            
            assign
              cResolved   = qg_cResolveObjectId( phBuffer:dbname,
                                                 bttField.FieldName,
                                                 string( cFieldValue ),
                                                 yes,
                                                 yes )
              cFieldValue = ( if    cResolved  > '':U
                                and cResolved <> string( cFieldValue ) then
                                substitute( '&1 <resolved: &2>':U,
                                            quoter( cFieldValue ),
                                            cResolved )
                              else
                                quoter( cFieldValue ) )
              .
          
          cFieldValues = substitute('&1~n-> &2: &3':U,
                                    cFieldValues,
                                    cFieldName,
                                    (if valid-handle(hOldBufferField) then
                                       substitute('&1 (alt) -> &2 (neu)':U,
                                                  cOldFieldValue,
                                                  cFieldValue)
                                     else
                                       cFieldValue)).
          
        end. /* if    available bttField */
        
      end. /* if qg_lIsPhysicalDatabase( cDatabaseName ) */

    end. /* do i = 1 to num-entries(pcFieldList) */
    
  end. /* if iIndex > 0 */
  
  return trim(cFieldValues, '~n':U).
  
end. /* Main */

return '?':U.

end function. /* qg_cFieldValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFileName Method-Library
function qg_cFileName returns character 
  ( pcFilename as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Repalce variables and rerurn actual filename.                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFilename                     = Filename that contains variables.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTempDir  as character no-undo.
define variable cFileName as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  cTempDir  = right-trim(session:temp-dir, '/\':U)
  cFileName = replace(pcFilename, '%Temp%', cTempDir)
  .

return cFileName.

end function. /* qg_cFileName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFilterEntryMatchcode hQueryWindow 
function qg_cFilterEntryMatchcode returns character
  ( pcFilterEntry as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Add matchcodes to filter entry.                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFilterEntry                  = Filter entry.                             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return (if   pcFilterEntry matches '"*"':U
          or index(pcFilterEntry, '*':U) > 0
          or index(pcFilterEntry, '.':U) > 0 then
          trim(pcFilterEntry, '"':U)
        else
          substitute('*&1*':U, trim(pcFilterEntry, '"':U))).

end function. /* qg_cFilterEntryMatchcode */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFixQuerySeq hQueryWindow 
function qg_cFixQuerySeq returns character
  ( pcQuerytext as character,
    piQuerySeq  as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Fix query window sequence while loading query scenario.                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcQuerytext                    = Query text that should be fixed.          */
/* piQuerySeq                     = Sequence of query window that the query   */
/*                                  text belongs to.                          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iPos                 as integer   no-undo.
define variable cTokenText           as character no-undo.
define variable cTargetTokenText     as character no-undo.
define variable cTargetQueryText     as character no-undo.

define variable hLinkTempTable       as handle    no-undo.
define variable hLinkTempTableBuffer as handle    no-undo.
define variable hQuery               as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindowExport    for temp-table ttQueryWindowExport.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

create temp-table hLinkTempTable.
hLinkTempTable:create-like(temp-table ttQueryLink:handle).
hLinkTempTable:temp-table-prepare( 'ttQueryLinkImport':U ).

create buffer hLinkTempTableBuffer for table hLinkTempTable.

create query hQuery.
hQuery:add-buffer(hLinkTempTableBuffer).
hQuery:query-prepare(substitute('for each &1 by &1.StartPos':U,
                                hLinkTempTableBuffer:name)).

run qg_ParseQueryLinks(pcQuerytext,
                       piQuerySeq,
                       hLinkTempTable).

assign
  iPos             = 1
  cTargetQueryText = '':U
  .

hQuery:query-open().
hQuery:get-first().

do while not hQuery:query-off-end:

  assign
    cTargetQueryText  =   cTargetQueryText
                        + substring(pcQuerytext,
                                    iPos,
                                    hLinkTempTableBuffer::StartPos - iPos)
    cTokenText        = substring(pcQuerytext,
                                  hLinkTempTableBuffer::StartPos + 2,
                                  hLinkTempTableBuffer::EndPos
                                    - hLinkTempTableBuffer::StartPos
                                    - 3)
    .
  
  find bttQueryWindowExport
    where bttQueryWindowExport.QuerySeq = integer(entry(1, cTokenText, ':':U))
    no-lock no-error.
  
  assign
    cTargetTokenText = substitute('$~{&1:&2~}':U,
                                  (if available bttQueryWindowExport then
                                     string(bttQueryWindowExport.NewQuerySeq)
                                   else
                                     '0':U),
                                  (if num-entries(cTokenText, ':':U) >= 2 then
                                     entry(2, cTokenText, ':':U)
                                   else
                                     '?':U))
    cTargetQueryText =   cTargetQueryText
                       + cTargetTokenText
    iPos             = hLinkTempTableBuffer::EndPos
    .
  
  hQuery:get-next().
  
end. /* do while not hQuery:query-off-end */

hQuery:query-close.

cTargetQueryText =   cTargetQueryText
                 + substring(pcQuerytext,
                             iPos).

return cTargetQueryText.

finally:
  
  if valid-handle(hQuery) then
    delete object hQuery no-error.
  
  if valid-handle(hLinkTempTableBuffer) then
    delete object hLinkTempTableBuffer no-error.
  
  if valid-handle(hLinkTempTable) then
    delete object hLinkTempTable no-error.
  
end finally.

end function. /* qg_cFixQuerySeq */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cFormattedFieldName hQueryWindow 
function qg_cFormattedFieldName returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcFieldName    as character,
    piIndex        as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName as character no-undo.
define variable cTableName    as character no-undo.
define variable cFieldName    as character no-undo.
define variable cFieldIndex   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    pcDatabaseName > '':U
  and pcTableName    > '':U then
  cDatabaseName = substitute('&1.':U, pcDatabaseName).

if    pcTableName > '':U
  and pcFieldName > '':U then
  cTableName = substitute('&1.':U, pcTableName).

if piIndex > 0 then
  cFieldIndex = substitute('[&1]':U, string(piIndex)).

return substitute('&1&2&3&4':U,
                  cDatabaseName,
                  cTableName,
                  pcFieldName,
                  cFieldIndex).

end function. /* qg_cFormattedFieldName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetBufferBaseName hQueryWindow 
function qg_cGetBufferBaseName returns character
  ( plCustomBuffer as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get buffer name.                                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* plCustomBuffer                 = Idicates wether or not the base name is   */
/*                                  needed for the default buffer or a custom */
/*                                  buffer (this is relevant for temp-tables).*/
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cTable      as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

assign
  cTable         = (if available ttTable then
                      ttTable.TableName
                    else
                      '':U)
  glDefineBuffer = (if glSlimMode then
                      {&K_DEFAULT_DEFINE_BUFFER}
                    else
                      input frame {&FRAME-NAME} glDefineBuffer)
  .

return (if not available ttDatabase then
          '':U
        else
         (if    ttDatabase.TempDB
            and cTable begins 'TD_':U then
            (if plCustomBuffer then
               substitute('tt&1':U, substring(cTable, 4))
             else
               substitute('TT_&1':U, substring(cTable, 4)))
          else
            cTable)).

end function. /* qg_cGetBufferBaseName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetCompany hQueryWindow 
function qg_cGetCompany returns character
  ( pcTableName as character,
    pcCompany   as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get currently active company.                                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTableName                    = Table for which the company should be     */
/*                                  returned.                                 */
/* pcCompany                      = Company to use. If ? then the currently   */
/*                                  active company is used.                   */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cCompany         as character no-undo initial ?.
define variable cResolvedCompany as character no-undo initial ?.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cCompany = pcCompany.

&IF keyword-all('dynamic-property':U) <> ? &THEN

  if cCompany = ? then
    cCompany = dynamic-property('pACConnectionSvc':U, 'prpcCompany':U) no-error.

&ENDIF

if    cCompany = ?
  and valid-handle(pa-broker-hdl)
  and lookup('get-attribute':U, pa-broker-hdl:internal-entries) > 0 then
do:
  
  run get-attribute in pa-broker-hdl ( 'Firma':U ) no-error.
  
  if not error-status:error then
    cCompany = return-value.
  
end. /* valid-handle hBroker */

if    pcTableName > '':U
  and cCompany   <> ? then
do:
  
  cResolvedCompany = dynamic-function('cPADynReturnFirmaTab':U in target-procedure,
                                      pcTableName,
                                      cCompany) no-error.
  
  if    not error-status:error
    and cResolvedCompany <> ? then
    cCompany = cResolvedCompany.
  
end. /* if    pcTableName > '':U */

return cCompany.

end function. /* qg_cGetCompany */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetCompanyInclude hQueryWindow 
function qg_cGetCompanyInclude returns character
  ( pcTableName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get company include.                                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcTableName                    = Table for which the company include       */
/*                                  should be added.                          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText       as character no-undo.

define variable hDRC_TableBuffer as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if   not available ttDatabase
  or not ttDatabase.BasisDB
  or not ttDatabase.PhysicalDB then
  return '':U.

create buffer hDRC_TableBuffer for table substitute('&1.DRC_Table':U,
                                                    ttDatabase.DatabaseName).

assign
  cQueryText = 'where DRC_Table.DRC_Table_ID = "&1"':U
  cQueryText = substitute(cQueryText,
                          pcTableName).

hDRC_TableBuffer:find-first(cQueryText, no-lock) no-error.

if    hDRC_TableBuffer:available
  and not can-do({&K_COMPANY_INCLUDE_BLACKLIST}, hDRC_TableBuffer::CompanyInclude) then
  return hDRC_TableBuffer::CompanyInclude.
else
  return '':U.

finally:
  delete object hDRC_TableBuffer no-error.
end finally.

end function. /* qg_cGetCompanyInclude */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetDefaultValue hQueryWindow 
function qg_cGetDefaultValue returns character
  ( pcDatatype as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the default value for the given datatype.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatatype                     = Datatype for which the default value      */
/*                                  should be added.                          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

case pcDatatype:
  
     when 'character':U
  or when 'longchar':U then
    return '~'~'':U.
  
     when 'integer':U
  or when 'int64':U then
    return '0':U.
  
  when 'recid':U then
    return '0':U.
  
  when 'decimal':U then
    return '0.0':U.
  
  when 'logical':U then
    return 'yes':U.
  
  when 'date':U then
    return 'today':U.
  
     when 'datetime':U
  or when 'datetime-tz':U then
    return 'now':U.
  
  otherwise
    return '~'?~'':U.
  
end case. /* pcDatatype */

end function. /* qg_cGetDefaultValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetFieldAssignmentsStatement hQueryWindow 
function qg_cGetFieldAssignmentsStatement returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcBufferName   as character,
    pcFieldList    as character,
    piValueMode    as integer,
    pcValueList    as character,
    plAddTags      as logical,
    piIndentBlanks as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Generates an assignment statement for given field list.                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Database name of the table that the       */
/*                                  fields belong to.                         */
/* pcTableName                    = Table name that the fields belong to.     */
/* pcFieldList                    = Field list for assignments.               */
/* pcBufferName                   = Buffer name for the table.                */
/* plAddTags                      = Add tags for ide editor.                  */
/* piIndentBlanks                 = Indentation for assignments.              */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iFieldCounter       as integer   no-undo.
define variable iFieldExtentCounter as integer   no-undo.
define variable cAssingStatement    as character no-undo.

define variable cCompanyInclude     as character no-undo.
define variable cCompany            as character no-undo.

define variable iFieldNameLength    as integer   no-undo.
define variable iLongestFieldname   as integer   no-undo.

define variable cValue              as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

assign
  glCompanyViaClass = (if glSlimMode then
                         {&K_DEFAULT_COMPANY_VIA_CLASS}
                       else
                         input frame {&FRAME-NAME} glCompanyViaClass)
  cCompanyInclude   = qg_cGetCompanyInclude(pcTableName)
  cCompany          = (if glCompanyViaClass then  
                         '{&K_CLASS_COMPANY_STATEMENT}':U
                       else
                         'pa-Firma':U)
  .

do iFieldCounter = 1 to num-entries(pcFieldList):
  
  find first bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = pcTableName
      and bttField.FieldName    = entry(iFieldCounter, pcFieldList)
      and bttField.FieldType    = {&K_FIELD_TYPE_DB_FIELD}
    no-error.

  if available(bttField) then
  do:
    
    iFieldNameLength =   length(bttField.FieldName)
                       + (if bttField.FieldExtent > 0 then
                            length(string(bttField.FieldExtent)) + 2
                          else
                            0).
  
    if iFieldNameLength > iLongestFieldname then
      iLongestFieldname = iFieldNameLength.
    
  end. /* if    available(bttField) ... */
  
end. /* do iFieldCounter = 1 to num-entries(pcFieldList) */

do iFieldCounter = 1 to num-entries(pcFieldList):
  
  find first bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = pcTableName
      and bttField.FieldName    = entry(iFieldCounter, pcFieldList)
      and bttField.FieldType    = {&K_FIELD_TYPE_DB_FIELD}
    no-error.
  
  if available(bttField) then
  do:
    
    if piValueMode = {&K_VALUE_MODE_PARAMETER} then
      cValue = entry(iFieldCounter, pcValueList, {&K_PARAM_SPLITTER}).

    do iFieldExtentCounter = integer(bttField.FieldExtent > 0) to bttField.FieldExtent:
    
      assign
        iFieldNameLength =   length(bttField.FieldName)
                           + (if bttField.FieldExtent > 0 then
                                length(string(iFieldExtentCounter)) + 2
                              else
                                0)
        cAssingStatement = substitute('&1~n&2&3.&4&5&6 = &7':U,
                                      cAssingStatement,
                                      fill(' ':U, piIndentBlanks),
                                      pcBufferName,
                                      bttField.FieldName,
                                      (if iFieldExtentCounter > 0 then
                                          substitute('[&1]':U, string(iFieldExtentCounter))
                                        else
                                          '':U),
                                      fill(' ':U, max(0, iLongestFieldname - iFieldNameLength)),
                                      (if piValueMode = {&K_VALUE_MODE_PARAMETER} then
                                         (if cValue = '%DATATYPE%':U then
                                            qg_cTaggedValue(substitute('<&1>':U, caps(bttField.DataType)),
                                                            plAddTags)
                                          else if cValue = '%COMPANY%':U then
                                            (if cCompanyInclude > '':U then
                                               substitute('~{firma/&1 &2~}':U,
                                                          cCompanyInclude,
                                                          qg_cTaggedValue(cCompany,
                                                                          plAddTags))
                                             else
                                               qg_cTaggedValue(cCompany,
                                                               plAddTags))
                                          else
                                            qg_cTaggedValue(cValue,
                                                            plAddTags))
                                       else
                                         (if can-do({&K_COMPANY_FIELDS}, bttField.FieldName) then
                                            (if cCompanyInclude > '':U then
                                               substitute('~{firma/&1 &2~}':U,
                                                          cCompanyInclude,
                                                          qg_cTaggedValue(cCompany,
                                                                          plAddTags))
                                             else
                                               qg_cTaggedValue(cCompany,
                                                               plAddTags))
                                          else
                                            qg_cTaggedValue(substitute('<&1>':U,
                                                                    caps(bttField.DataType)),
                                                            plAddTags)))).
  
    end. /* do iFieldExtentCounter = integer(bttField.FieldExtent > 0) to bttField.FieldExtent */
  
  end. /* if available(bttField) */
  
end. /* do iFieldCounter = 1 to num-entries(pcFieldList) */

return trim(cAssingStatement, '~n':U).

end function. /* qg_cGetFieldAssignmentsStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetPrimaryKeyValues hQueryWindow 
function qg_cGetPrimaryKeyValues returns character
  ( phBuffer            as handle,
    pcSplitter          as character,
    plResolveObjectIds  as logical,
    plIncludeFieldNames as logical,
    plIncludeCompany    as logical,
    plQuoteValues       as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the primary key values for given buffer.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iIndexCounter        as integer   no-undo initial 1.
define variable iFieldCounter        as integer   no-undo.
define variable cIndexInfo           as character no-undo.

define variable cDatabaseName        as character no-undo.
define variable cFieldName           as character no-undo.
define variable hField               as handle    no-undo.
define variable cFieldValue          as character no-undo.
define variable cOverlayDatabaseName as character no-undo.
define variable cOverlayTableName    as character no-undo.
define variable hBuffer              as handle    no-undo.
define variable lObjectId            as logical   no-undo.
define variable cFieldList           as character no-undo.
define variable cValueList           as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phBuffer) then
  return '?':U.

do while phBuffer:index-information(iIndexCounter) <> ?:

  cIndexInfo = phBuffer:index-information(iIndexCounter).

  /* Third entry = 1 means the index is primary. */
  
  if entry(3, cIndexInfo) = '1':U then
  do:

    /* Read index fields. Every second entry from the 5th entry on. */
    
    do iFieldCounter = 5 to num-entries(cIndexInfo) by 2:
      
      cFieldName = entry(iFieldCounter, cIndexInfo).
      
      if    not plIncludeCompany
        and lookup(cFieldName, {&K_COMPANY_FIELDS}) > 0 then
        next.
      
      cFieldList = substitute('&1,&2':U, cFieldList, cFieldName).
      
    end. /* do iFieldCounter = 5 to num-entries(cIndexInfo) by 2 */
    
    leave.
    
  end. /* if entry(3, cIndexInfo) = '1':U */

  iIndexCounter = iIndexCounter + 1.

end. /* do while phBuffer:index-information(i) <> ? */

cFieldList = trim(cFieldList, ',':U).

do iFieldCounter = 1 to num-entries(cFieldList):
  
  assign
    hBuffer     = ?
    lObjectId   = no
    cFieldName  = entry(iFieldCounter, cFieldList)
    hField      = phBuffer:buffer-field(cFieldName)
    cFieldValue = hField:buffer-value
    .
  
  if    plResolveObjectIds
    and lookup(hField:data-type, 'CHARACTER,LONGCHAR':U) > 0
    and not hField:name                            matches substitute('&1_Obj':U,
                                                                      hField:table)
    and num-entries(cFieldValue, ':':U)                  = 3 then
  do:
    
    cDatabaseName = qg_cDatabaseNameForTableOrBuffer( hField:buffer-handle ).
    
    if    cDatabaseName = ?
       or cDatabaseName = '':U then
      cDatabaseName = hField:dbname.
    
    if    hField:name matches '*_Obj':U
       or can-find(first ttField
                     where ttField.DatabaseName = cDatabaseName
                       and ttField.TableName    = hField:table
                       and ttField.FieldName    = hField:name
                       and ttField.isObjectId   = yes) then
    do:
    
      run qg_GetObjectIdTable(cDatabaseName,
                              cFieldValue,
                              output cOverlayDatabaseName,
                              output cOverlayTableName).
      
      if    cOverlayDatabaseName > '':U
        and cOverlayTableName    > '':U then
      do:
        
        create buffer hBuffer
          for table substitute('&1.&2':U,
                               cOverlayDatabaseName,
                               cOverlayTableName) no-error.
        
        if valid-handle(hBuffer) then
          assign
            cFieldValue = qg_cResolveObjectIdForBuffer( cFieldValue,
                                                        hBuffer,
                                                        yes,
                                                        no,
                                                        yes ).
            lObjectId   = yes
            .
        
      end. /* if    cOverlayDatabaseName > '':U */
      
    end. /* if    hField:name matches '*_Obj':U ... */
      
  end. /* if    plResolveObjectIds ... */
  
  if cValueList > '':U then
    cValueList = substitute('&1&2':U, cValueList, pcSplitter).
  
  cValueList = substitute( '&1&2&3':U,
                           cValueList,
                           (if plIncludeFieldNames then
                              substitute('&1=':U, hField:name)
                            else
                              '':U),
                           ( if lookup(hField:data-type, 'CHARACTER,LONGCHAR':U) > 0 then
                               ( if    not lObjectId
                                   and ( plQuoteValues   = yes
                                      or ( plQuoteValues = ?
                                       and num-entries(cFieldList) > 1 ) ) then
                                   quoter(cFieldValue)
                                 else
                                   cFieldValue )
                             else
                               cFieldValue ) ).
  
end. /* do iFieldCounter = 1 to num-entries(cFieldList) */

return cValueList.

end function. /* qg_cGetPrimaryKeyValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetPutStatement hQueryWindow 
function qg_cGetPutStatement returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcBufferName   as character,
    pcFieldList    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Generate put statement for given field list.                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Database name of fields.                  */
/* pcTableName                    = Table name of fields.                     */
/* pcBufferName                   = Buffer name of fields.                    */
/* pcFieldList                    = List of fields for the put statement.     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cPutStatement                  as character no-undo.

define variable i                              as integer   no-undo.
define variable j                              as integer   no-undo.
define variable iFieldNameLength               as integer   no-undo.
define variable iLongestFieldname              as integer   no-undo.
define variable cFieldName                     as character no-undo.

define variable oVirtualDBFieldDataApiInstance as Progress.Lang.Object no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttField for temp-table ttField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

do i = 1 to num-entries(pcFieldList):
  
  find first bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = pcTableName
      and bttField.FieldName    = entry(i, pcFieldList)
    no-error.

  if    available(bttField) then
  do:
    
    iFieldNameLength =   length(bttField.FieldName)
                       + (if bttField.FieldExtent > 0 then
                            length(string(bttField.FieldExtent)) + 2
                          else
                            0).
  
    if iFieldNameLength > iLongestFieldname then
      iLongestFieldname = iFieldNameLength.
    
  end. /* if    available(bttField) ... */
  
end. /* do i = 1 to num-entries(pcFieldList) */

do i = 1 to num-entries(pcFieldList):
  
  find first bttField
    where bttField.DatabaseName = pcDatabaseName
      and bttField.TableName    = pcTableName
      and bttField.FieldName    = entry(i, pcFieldList)
    no-error.
  
  if available(bttField) then
  do:
    
    if    bttField.IsVirtual
      and not valid-object( oVirtualDBFieldDataApiInstance ) then
    do:
      
      oVirtualDBFieldDataApiInstance = qg_oVirtualDBFieldDataApiInstance() no-error.
      
      if not valid-object( oVirtualDBFieldDataApiInstance ) then
        
        next.
      
    end.
    
    do j = integer(bttField.FieldExtent > 0) to bttField.FieldExtent:
    
        assign
          iFieldNameLength =   length(bttField.FieldName)
                             + (if bttField.FieldExtent > 0 then
                                  length(string(j)) + 2
                                else
                                  0)
          cFieldName       = qg_cFormattedFieldName(?,
                                                    ?,
                                                    bttField.FieldName,
                                                    bttField.FieldExtent)
          cPutStatement    = ( if bttField.IsVirtual then
                                 substitute( '&1~n  ~'&2&3 : ~':U &4:prpoInstance:&5( &7.&6_Obj, ~'&2~':U ) skip':U,
                                             cPutStatement,
                                             cFieldName,
                                             fill(' ':U, iLongestFieldname - iFieldNameLength),
                                             oVirtualDBFieldDataApiInstance:getClass():TypeName,
                                             dynamic-invoke( oVirtualDBFieldDataApiInstance,
                                                             'cMethodNameByDataType':U,
                                                             bttField.DataType ),
                                             pcTableName,
                                             pcBufferName )
                              else
                                substitute( '&1~n  ~'&2&3 : ~':U &4.&2 skip':U,
                                            cPutStatement,
                                            cFieldName,
                                            fill(' ':U, iLongestFieldname - iFieldNameLength),
                                            pcBufferName ) )
          .
  
    end. /* do j = integer(bttField.FieldExtent > 0) to bttField.FieldExtent */
  
  end. /* if available(bttField) */
  
end. /* do i = 1 to num-entries(pcFieldList) */

return trim(cPutStatement, '~n':U).

end function. /* qg_cGetPutStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetRelationField hQueryWindow 
function qg_cGetRelationField returns character
  ( buffer pbttTableRelation      for ttTableRelation,
    buffer pbttTableRelationField for ttTableRelationField,
    pcBufferName    as character,
    plParentValue   as logical,
    plKeyAllowed     as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cValue          as character no-undo.
define variable cKeyInclude     as character no-undo.

define variable cTableName      as character no-undo.
define variable cFieldName      as character no-undo.
define variable cConstantData   as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if plParentValue then
  assign
    cTableName    = pbttTableRelation.ChildTableName
    cFieldName    = pbttTableRelationField.ChildFieldName
    cConstantData = pbttTableRelationField.ChildConstantData
    .

else
  assign
    cTableName    = pbttTableRelation.ParentTableName
    cFieldName    = pbttTableRelationField.ParentFieldName
    cConstantData = pbttTableRelationField.ParentConstantData
    .

if    pbttTableRelationField.FieldRelationType = 'DB-FIELD':U
   or cConstantData = '':U then
  return substitute('&1.&2':U, pcBufferName, cFieldName).

else if pbttTableRelationField.FieldRelationType = 'CONSTANT':U then
  return ( if cConstantData matches '~'*~'':U or cConstantData matches '"*"':U then
             cConstantData + ':U':U
           else
             cConstantData).

else if pbttTableRelationField.FieldRelationType = 'KEY':U then
do:
  
  if not plKeyAllowed then
    return '~'~' /* !!! Please set key value manually !!! */':U.
  
  else
  do:
    
    find bttTable
      where bttTable.DatabaseName = pbttTableRelation.DatabaseName
        and bttTable.TableName    = cTableName
      no-error.
  
    if available bttTable then
    do:
      
      if not bttTable.DetailsLoaded then
        run qg_AddTableDetails(bttTable.DatabaseName,
                               bttTable.TableName).
      
      cKeyInclude = dynamic-function('pa_cDevelObjectRelativePath':U in target-procedure,
                                     bttTable.KeyInclude) no-error.
      
      if cKeyInclude > '':U then
        return substitute('~{&1 &&Tabelle = "&2"~}':U,
                          cKeyInclude,
                          pcBufferName).
      
    end. /* if not available bttTable */
  
  end. /* if not plKeyAllowd */
  
end. /* else if pbttTableRelationField.FieldRelationType = 'KEY':U */

return '?':U.

end function. /* qg_cGetRelationField */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cGetSelectedFields hQueryWindow 
function qg_cGetSelectedFields returns character
  ( pcBufferName as character,
    pcSeparator  as character,
    plQuoted     as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns currently selected fields of field browse as comma separted list.  */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcBufferName                   = Buffer name to use for the field list. If */
/*                                  Buffer name is ? no buffer names will be  */
/*                                  added                                     */
/* pcSeparator                    = Separator to use for the field list.      */
/* plQuoted                       = Add quotes around fields.                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i          as integer   no-undo.
define variable cFieldList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

giDisplayMode = input frame {&FRAME-NAME} giDisplayMode.

if giDisplayMode = {&K_DISPLAYMODE_INDEX} then
  cFieldList = (if available ttIndex then
                  ttIndex.IndexFieldList
                else
                  '':U).

else if giDisplayMode = {&K_DISPLAYMODE_RELATION} then
  cFieldList = (if available ttTableRelationView then
                  ttTableRelationView.ReferenceFieldList
                else
                  '':U).

else
do:
  
  do i = 1 to brField:num-selected-rows in frame {&FRAME-NAME}:
    
    browse brField:fetch-selected-row (i).
    
    cFieldList = substitute('&1&2&3':U,
                            cFieldList,
                            pcSeparator,
                            (if pcBufferName > '':U then
                               substitute('&1.&2':U,
                                          pcBufferName,
                                          (if plQuoted then
                                             quoter(ttField.FieldName)
                                           else
                                             ttField.FieldName))
                             else
                               (if plQuoted then
                                  quoter(ttField.FieldName)
                                else
                                  ttField.FieldName))).
    
  end. /* do i = 1 to browse brField:num-selected-rows in frame {&FRAME-NAME} */
  
end. /* if giDisplayMode = {&K_DISPLAYMODE_INDEX} */

return trim(cFieldList, pcSeparator).

end function. /* qg_cGetSelectedFields */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cIndexFieldValues hQueryWindow 
function qg_cIndexFieldValues returns character
  ( phBuffer    as handle,
    pcIndexName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get values for fields of given index as <field name> = <value> list (line  */
/* separated).                                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phBuffer                       = Buffer that contains the values.          */
/* pcIndexName                    = Index that contains the fields.           */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iIndexCounter   as integer   no-undo initial 1.
define variable cIndexInfo      as character no-undo.

define variable iFieldCounter   as integer   no-undo.
define variable cFieldList      as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

Main:
do on error undo Main, leave Main:

  if not valid-handle(phBuffer) then
    undo Main, return '?':U.

  do while phBuffer:index-information(iIndexCounter) <> ?:

    cIndexInfo = phBuffer:index-information(iIndexCounter).

    /* Second entry = index name, third entry = 1 -> index is primary.  */
    
    if    ( pcIndexName > '':U
        and entry(2, cIndexInfo) = pcIndexName )
       or ( pcIndexName = ?
        and entry(3, cIndexInfo) = '1':U ) then
    do:

      do iFieldCounter = 5 to num-entries(cIndexInfo) by 2:
        cFieldList = substitute('&1,&2':U, cFieldList, entry(iFieldCounter, cIndexInfo)).
      end. /* do iFieldCounter = 5 to num-entries(cIndexInfo) by 2 */

      return qg_cFieldValues(phBuffer, ?, trim(cFieldList, ',':U)).

    end. /* if entry(3, cIndexInfo) = '1':U */

    iIndexCounter = iIndexCounter + 1.

  end. /* do while phBuffer:index-information(i) <> ? */

end. /* Main */

return '':U.

end function. /* qg_cIndexFieldValues */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cMaximumDataTypeFormat Method-Library
function qg_cMaximumDataTypeFormat returns character 
  ( pcDataType as character,
    piDecimals as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get format that will be able to display the maximum data type value for    */
/* given data type.                                                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDataType                     The data type.                              */
/* piDecimals                     Number of decimal places (only relevant for */
/*                                data type "decimal").                       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

case pcDataType:
  
  when 'character':U
     or when 'longchar':U then
    
    return 'x(2048)':U.
  
  when 'integer':U then
    
    return '-z,zzz,zzz,zz9':U.
  
  when 'int64':U
     or when 'recid':U then
    
    return '-z,zzz,zzz,zzz,zzz,zzz,zz9':U.
  
  when 'decimal':U then
    
    return substitute( '-&1&2&3zz9&4':U,
                        fill( 'z':U, ( 50 - piDecimals - 3 ) mod 3 ),
                        ( if ( 50 - piDecimals - 3 ) mod 3 > 0 then
                            ',':U
                          else
                            '':U ),
                        fill( 'zzz,':U, integer( truncate( ( 50 - piDecimals - 3 ) / 3, 0 ) ) ),
                        ( if piDecimals > 0 then
                            substitute( '.&1':U, fill( '9':U, piDecimals ) )
                          else
                            '':U ) ).
  
  when 'logical':U then
    
    return 'true/false':U.
  
  when 'date':U then
    
    return '99/99/9999':U.
  
  when 'datetime':U then
    
    return '99/99/9999 HH:MM:SS.SSS':U.
  
  when 'datetime-tz':U then
    
    return '99/99/9999 HH:MM:SS.SSS+HH:MM':U.
  
  otherwise
    return '':U.

end case. /* pcDataType */

end function. /* qg_cMaximumDataTypeFormat */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cModulePathByChar Method-Library
function qg_cModulePathByChar returns character 
  ( pcChar as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get module path by character.                                              */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hModuleBuffer    as handle    no-undo.
define variable hSubModuleBuffer as handle    no-undo.

define variable cQueryText       as character no-undo.

define variable cPath            as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttDatabase for temp-table ttDatabase.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    not available ttDatabase
   or not ttDatabase.BasisDB
   or not ttDatabase.PhysicalDB then
  
  return '':U.

if length( pcChar ) > 0 then
do on error undo, throw:
  
  /* Find and add Module. */
  
  create buffer hModuleBuffer for table substitute( '&1.D_Modul':U,
                                                    ttDatabase.DatabaseName ).
  
  assign
    cQueryText = 'where D_Modul.Kennbuchstabe = &1':U
    cQueryText = substitute( cQueryText, quoter( substring( pcChar, 1, 1 ) ) )
    .
  
  hModuleBuffer:find-first( cQueryText, no-lock ) no-error.
  
  if hModuleBuffer:available then
    
    cPath = hModuleBuffer::Unterverzeichnis.
  
  /* Find and add sub module. */
  
  if length( pcChar ) >= 2 then
  do on error undo, throw:
  
    create buffer hSubModuleBuffer for table substitute( '&1.D_UnterModul':U,
                                                         ttDatabase.DatabaseName ).
    
    assign
      cQueryText =   'where D_UnterModul.ModulName     = &1':U
                   + '  and D_UnterModul.Kennbuchstabe = &2':U
      cQueryText = substitute( cQueryText,
                               quoter( hModuleBuffer::ModulName ),
                               quoter( substring( pcChar, 2, 1 ) ) )
      .
    
    hSubModuleBuffer:find-first( cQueryText, no-lock ) no-error.
    
    if hSubModuleBuffer:available then
      
      cPath = ( if    cPath > '':U
                  and hSubModuleBuffer::Unterverzeichnis > '':U then
                  substitute( '&1/&2':U, cPath, hSubModuleBuffer::Unterverzeichnis )
                else if hSubModuleBuffer::Unterverzeichnis > '':U then
                  hSubModuleBuffer::Unterverzeichnis
                else
                  '':U ).
    
    finally:
      delete object hSubModuleBuffer no-error.
    end finally.
    
  end. /* if length( pcChar ) >= 2 */
  
  finally:
    delete object hModuleBuffer no-error.
  end finally.
  
end. /* length( pcChar ) */

return cPath.

end function. /* qg_cModulePathByChar */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cOverlayFieldValue hQueryWindow 
function qg_cOverlayFieldValue returns character
  ( buffer pbttFieldOverlay for ttFieldOverlay,
    pcFieldValue as character,
    plDeep       as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cDatabaseName        as character no-undo.
define variable cTableId             as character no-undo.
define variable cOverlayDatabaseName as character no-undo.
define variable cOverlayTableName    as character no-undo.
define variable cObjectIdFieldName   as character no-undo.
define variable lIncludeTablename    as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if    pcFieldValue > '':U
  and num-entries(pcFieldValue, ':':U) = 3 then
do:
  
  cTableId = entry(1, pcFieldValue, ':':U).
  
  if    cTableId = pbttFieldOverlay.OverlayTableId
    and valid-handle(pbttFieldOverlay.OverlayBufferHandle) then
    assign
      cOverlayDatabaseName = pbttFieldOverlay.OverlayBufferHandle:dbname
      cOverlayTableName    = pbttFieldOverlay.OverlayBufferHandle:table
      .
  
  else
  do:
    
    if valid-handle(pbttFieldOverlay.OverlayBufferHandle) then
      delete object pbttFieldOverlay.OverlayBufferHandle.
    
    run qg_GetObjectIdTable(pbttFieldOverlay.DatabaseName,
                            pcFieldValue,
                            output cOverlayDatabaseName,
                            output cOverlayTableName).
    
    if    cOverlayDatabaseName > '':U
      and cOverlayTableName    > '':U then
    do:
      
      create buffer pbttFieldOverlay.OverlayBufferHandle
        for table substitute('&1.&2':U,
                             cOverlayDatabaseName,
                             cOverlayTableName).
      
      if valid-handle(pbttFieldOverlay.OverlayBufferHandle) then
        pbttFieldOverlay.OverlayTableId = cTableId.
      
    end. /* if    cOverlayDatabaseName > '':U */
    
  end. /* if    cTableId = pbttFieldOverlay.OverlayTableId */
  
  if valid-handle(pbttFieldOverlay.OverlayBufferHandle) then
  do:
    
    assign
      cObjectIdFieldName = substitute('&1_Obj':U, cOverlayTableName).
      lIncludeTablename = not pbttFieldOverlay.FieldName matches substitute('*&1*':U, cOverlayTableName)
      .
    
    if valid-handle(pbttFieldOverlay.OverlayBufferHandle) then
      return qg_cResolveObjectIdForBuffer(pcFieldValue,
                                          pbttFieldOverlay.OverlayBufferHandle,
                                          lIncludeTablename,
                                          no,
                                          plDeep).
    
  end. /* if valid-handle(pbttFieldOverlay.OverlayBufferHandle) */
  
  return ?.
  
end. /* if    pcFieldValue > '':U ... */

return ?.

end function. /* qg_cOverlayFieldValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cParamListReadValue hQueryWindow 
function qg_cParamListReadValue returns character
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Read a character value from given parameter list.                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = List that contains the value.             */
/* pcParamName                    = Name of the relevant parameter.           */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i           as integer   no-undo.

define variable cParameter  as character no-undo.
define variable cParamName  as character no-undo.
define variable cParamValue as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

do i = 1 to num-entries(pcParamList, pcSplitter):
  
  cParameter = entry(i, pcParamList, pcSplitter).
  
  if num-entries(cParameter, '=':U) < 2 then
    next.
  
  assign
    cParamName  = entry(1, cParameter, '=':U)
    cParamValue = entry(2, cParameter, '=':U)
    .
  
  if trim(cParamName) = trim(pcParamName) then
    return cParamValue.
  
end. /* do i = 1 to num-entries(pcParamList, {&K_PARAM_SPLITTER}) */

return '':U.

end function. /* qg_cParamListReadValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cParamListWriteCharacter hQueryWindow 
function qg_cParamListWriteCharacter returns character
  ( pcParamList  as character,
    pcParamName  as character,
    pcParamValue as character,
    pcSplitter   as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write character value to param list.                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = Param list.                               */
/* pcParamName                    = Name of the relevant parameter.           */
/* pcParamValue                   = Value to write to given param list.       */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i as integer   no-undo.

define variable cParameter  as character no-undo.
define variable cParamName  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if   pcParamList = ?
  or pcParamList = '?':U then
  pcParamList = '':U.

do i = 1 to num-entries(pcParamList, pcSplitter):
  
  cParameter = entry(i, pcParamList, pcSplitter).
  
  if num-entries(cParameter, '=':U) < 2 then
    next.
  
  cParamName = entry(1, cParameter, '=':U).
  
  if trim(cParamName) = trim(pcParamName) then
  do:
    
    assign
      entry(2, cParameter, '=':U)       = pcParamValue
      entry(i, pcParamList, pcSplitter) = cParameter
      .
    
    return pcParamList.
    
  end. /* if trim(cParamName) = trim(pcParamName) */
  
end. /* do i = 1 to num-entries(pcParamList) */

pcParamList = substitute('&1&2&3=&4':U,
                         pcParamList,
                         (if trim(pcParamList) > '':U then
                            pcSplitter
                          else
                            '':U),
                         pcParamName,
                         pcParamValue).

return pcParamList.

end function. /* qg_cParamListWriteCharacter */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cParamListWriteDecimal hQueryWindow 
function qg_cParamListWriteDecimal returns character
  ( pcParamList  as character,
    pcParamName  as character,
    pdParamValue as decimal,
    pcSplitter   as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write decimal value to param list.                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = Param list.                               */
/* pcParamName                    = Name of the relevant parameter.           */
/* pdParamValue                   = Value to write to given param list.       */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return qg_cParamListWriteCharacter(pcParamList,
                                   pcParamName,
                                   replace(string(pdParamValue),
                                           session:numeric-decimal-point,
                                           '.':U),
                                   pcSplitter).

end function. /* qg_cParamListWriteDecimal */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cParamListWriteInteger hQueryWindow 
function qg_cParamListWriteInteger returns character
  ( pcParamList  as character,
    pcParamName  as character,
    piParamValue as integer,
    pcSplitter   as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write integer value to pks.                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = Param list.                               */
/* pcParamName                    = Name of the relevant parameter.           */
/* piParamValue                   = Value to write to given param list.       */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return qg_cParamListWriteCharacter(pcParamList,
                                   pcParamName,
                                   string(piParamValue),
                                   pcSplitter).

end function. /* qg_cParamListWriteInteger */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cParamListWriteLogical hQueryWindow 
function qg_cParamListWriteLogical returns character
  ( pcParamList  as character,
    pcParamName  as character,
    plParamValue as logical,
    pcSplitter   as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Write logical value to pks.                                                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = Param list.                               */
/* pcParamName                    = Name of the relevant parameter.           */
/* plParamValue                   = Value to write to given param list.       */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return qg_cParamListWriteCharacter(pcParamList,
                                   pcParamName,
                                   string(plParamValue),
                                   pcSplitter).

end function. /* qg_cParamListWriteLogical */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cPutStatement hQueryWindow 
function qg_cPutStatement returns character
  ( plInsertMode as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns field assign statement for current field selection.                */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* plInsertMode                   = Flag do indicate if insert mode should    */
/*                                  be used.                                  */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

gcBufferName = (if glSlimMode then
                  substitute({&K_DEFAULT_BUFFER_PATTERN},
                             qg_cGetBufferBaseName(no))
                else
                  input frame {&FRAME-NAME} gcBufferName).

return (if available ttTable then
          substitute('put stream &1 unformatted~n&2~n  .&3':U,
                     (if plInsertMode then
                        '$~{<Stream-Name>}':U
                      else
                        '<Stream-Name>':U),
                     qg_cGetPutStatement
                       (ttTable.DatabaseName,
                        ttTable.TableName,
                        gcBufferName,
                        qg_cGetSelectedFields(?, ',':U, no)),
                      (if plInsertMode then
                         '$~{cursor}':U
                       else
                         '':U))
        else
          '':U).

end function. /* qg_cPutStatement */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cQueryIndexInfo hQueryWindow 
function qg_cQueryIndexInfo returns character
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcQueryText    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the index that progress uses for a query that contains given       */
/* fields.                                                                    */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Database of table.                        */
/* pcTableName                    = Table name for query.                     */
/* pcFieldList                    = Fields for query.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer           as handle    no-undo.
define variable hQuery            as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable for temp-table ttTable.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

find bttTable
  where bttTable.DatabaseName = pcDatabaseName
    and bttTable.TableName    = pcTableName
  no-lock no-error.

if not available bttTable then
  return '?':U.

if bttTable.PhysicalTable then
  create buffer hBuffer for table substitute('&1.&2':U,
                                             pcDatabaseName,
                                             pcTableName) no-error.

else
do:
  
  if not valid-handle(bttTable.TableHandle) then
    leave.
  
  else
    create buffer hBuffer for table bttTable.TableHandle no-error.
  
end. /* else: if    available bttTable */

if not valid-handle(hBuffer) then
  return ?.

create query hQuery.
hQuery:add-buffer(hBuffer).
hQuery:query-prepare(pcQueryText) no-error.

if error-status:error then
  return ?.

return hQuery:index-information(1).

finally:
  
  if valid-handle(hQuery) then
    delete object hQuery no-error.
  
  if valid-handle(hBuffer) then
    delete object hBuffer no-error.
  
end finally.
  
end function. /* qg_cQueryIndexInfo */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cQueryLabel hQueryWindow 
function qg_cQueryLabel returns character
  ( pcQueryText as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns Label for given query.                                             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcQueryText                    = Query text for which the label should be  */
/*                                  Returned.                                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i           as integer   no-undo.
define variable cQueryLabel as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

/* Remove all line feeds. */

do i = 1 to num-entries(pcQueryText, '~n':U):
  if trim(entry(i, pcQueryText, '~n':U)) > '':U then
    cQueryLabel = substitute('&1 &2':U,
                             cQueryLabel,
                             trim(entry(i, pcQueryText, '~n':U))).
end. /* do i = 1 to num-entries(cQueryText, '~n':U) */

/* Remove all double spaces. */

do while index(cQueryLabel, '  ':U) > 0:
  cQueryLabel = replace(cQueryLabel, '  ':U, ' ':U).
end.

return substitute('&1&2':U,
                  substring(trim(cQueryLabel), 1, 250),
                  (if length(cQueryLabel) > 250 then
                     ' ...':U
                   else
                     '':U)).

end function. /* qg_cQueryLabel */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cQueryWindowFieldList hQueryWindow 
function qg_cQueryWindowFieldList returns character
  ( phWindow      as handle,
    plBuffernames as logical,
    plAllFields   as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cFieldName as character no-undo.
define variable cFieldList as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow      for temp-table ttQueryWindow.

define buffer bttQueryWindowField for temp-table ttQueryWindowField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

for each bttQueryWindowField
  where bttQueryWindowField.WindowHandle = phWindow
  by Order
  on error undo, throw:
  
  if    plAllFields
     or bttQueryWindowField.Order > 0 then
    assign
      cFieldName = qg_cFormattedFieldName(?,
                                          (if plBuffernames then
                                             bttQueryWindowField.BufferName
                                           else
                                             ?),
                                          bttQueryWindowField.FieldName,
                                          bttQueryWindowField.FieldIndex)
      cFieldList = substitute('&1,&2':U,
                              cFieldList, 
                              (if bttQueryWindowField.IsOverlay then
                                 substitute( {&K_OBJECTID_OVERLAY_NAME_PATTERN},
                                             cFieldName )
                               else
                                 cFieldName))
      .
  
end. /* for each bttQueryWindowField */ 

return trim(cFieldList, ',':U).

end function. /* qg_cQueryWindowFieldList */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cReadRegistryValue hQueryWindow 
function qg_cReadRegistryValue returns character
  ( piSection as integer,
    pcSubKey  as character,
    pcKeyName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Read a registry key value.                                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piSection                      = Registry section.                         */
/* pcSubKey                       = Reigistry path.                           */
/* pcKeyName                      = Key name.                                 */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iKeyResult as int64     no-undo.
define variable iResult    as int64     no-undo.
define variable mData      as memptr    no-undo.
define variable iBufSize   as int64     no-undo initial 255.
define variable iDataType  as int64     no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

/* Initialization */

set-size(mData) = iBufSize.

/* Open the specified key. */

run RegOpenKeyExA(piSection,
                  pcSubKey,
                  0,
                  {&K_WIN_CONST_KEY_QUERY_VALUE},
                  output iKeyResult,
                  output iResult).

/* Retrieve data for a specified value name associated with an open registry  */
/* key                                                                        */

run RegQueryValueExA(iKeyResult,
                     pcKeyName,
                     0,
                     output iDataType,
                     get-pointer-value(mData),
                     output iBufSize,
                     output iResult).

/* Releases the handle of the specified key. */

run RegCloseKey(iKeyResult, output iResult).

return get-string(mData, 1).

finally:
  
  set-size(mData) = 0.
  
end finally.

end function. /* qg_cReadRegistryValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cReplaceColumn hQueryWindow 
function qg_cReplaceColumn returns character
  ( pcColumnList as character,
    pcColumn     as character,
    pcNewColumn  as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i            as integer   no-undo.

define variable cColumnEntry as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do i = 1 to num-entries(pcColumnList):
  
  cColumnEntry = entry(i, pcColumnList).
  
  if entry(1, cColumnEntry, ':':U) = pcColumn then
  do:
    
    assign
      entry(1, cColumnEntry, ':':U) = pcNewColumn
      entry(i, pcColumnList)        = cColumnEntry
      .
    
  end. /* if entry(1, cColumnEntry, ':':U) = pcColumn */
  
end. /* do i = 1 to num-entries(pcColumnList) */

return pcColumnList.

end function. /* qg_cReplaceColumn */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cResolveObjectId hQueryWindow 
function qg_cResolveObjectId returns character
  ( pcDatabaseName as character,
    pcFieldName    as character,
    pcObjectId     as character,
    plForceQuote   as logical,
    plDeep         as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hBuffer              as handle    no-undo.

define variable cOverlayDatabaseName as character no-undo.
define variable cOverlayTableName    as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_GetObjectIdTable( pcDatabaseName,
                         pcObjectId,
                         output cOverlayDatabaseName,
                         output cOverlayTableName ).

if    cOverlayDatabaseName > '':U
  and cOverlayTableName    > '':U then
do on error undo, throw:
  
  create buffer hBuffer
    for table substitute( '&1.&2':U,
                          cOverlayDatabaseName,
                          cOverlayTableName ) no-error.
  
  if valid-handle( hBuffer ) then
    return  qg_cResolveObjectIdForBuffer( pcObjectId,
                                          hBuffer,
                                          not pcFieldName matches substitute( '*&1*':U,
                                                                              cOverlayTableName ),
                                          plForceQuote,
                                          yes ).
  
  finally:
    
    if valid-handle( hBuffer ) then
      delete object hBuffer.
    
  end finally.
  
end. /* if    cOverlayDatabaseName > '':U */

return ?.

end function. /* qg_cResolveObjectId */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cResolveObjectIdForBuffer hQueryWindow 
function qg_cResolveObjectIdForBuffer returns character
  ( pcObjectId   as character,
    phBuffer     as handle,
    plTable      as logical,
    plForceQuote as logical,
    plDeep       as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cObjectIdFieldName as character no-undo.
define variable cKeyValues         as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if not valid-handle(phBuffer) then
  leave.

cObjectIdFieldName = substitute('&1_Obj':U, phBuffer:table).

phBuffer:find-first(substitute('where &1.&2 = &3':U,
                               phBuffer:name,
                               cObjectIdFieldName,
                               quoter(pcObjectId)),
                    no-lock) no-error.

if not phBuffer:available then
  return ?.

cKeyValues = qg_cGetPrimaryKeyValues(phBuffer,
                                     ' | ':U,
                                     plDeep,
                                     no,
                                     no,
                                     (if    plForceQuote
                                         or plTable then
                                        yes
                                      else
                                        ?)).

return (if plTable then
          substitute('&1 ( &2 )':U,
                     phBuffer:table,
                     cKeyValues)
        else
          cKeyValues).
  
end function. /* qg_cResolveObjectIdForBuffer */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cSoundexCode hQueryWindow 
function qg_cSoundexCode returns character
  ( pcText as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns soundex code for given Text.                                       */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcText                         = Text for soundex code generation.         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i            as integer   no-undo.
define variable cChar        as character no-undo.
define variable iCode        as integer   no-undo.
define variable iLastCode    as integer   no-undo.
define variable cSoundexCode as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do i = 1 to length(pcText):
  
  cChar = lc(substring(pcText, i, 1)).
  
  if index('bfpv':U, cChar) > 0 then
    iCode = 1.
  
  else if index('cgjkqsxz':U, cChar) > 0 then
    iCode = 2.
  
  else if index('dt':U, cChar) > 0 then
    iCode = 3.
  
  else if index('l':U, cChar) > 0 then
    iCode = 4.
  
  else if index('mn':U, cChar) > 0 then
    iCode = 5.
  
  else if index('r':U, cChar) > 0 then
    iCode = 6.
  
  else
    iCode = 0.

  if i = 1 then
    cSoundexCode = cChar.
  
  else if iCode <> 0
    and   iCode <> iLastCode then
    cSoundexCode = cSoundexCode + string(iCode).
  
  if length(cSoundexCode) >= 4 then
    leave.
  
  iLastCode = iCode.
  
end. /* do i = 1 to length(pcText) */

return cSoundexCode + fill('0':U, max(0, 4 - length(cSoundexCode))).

end function. /* qg_cSoundexCode */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cStacktrace hQueryWindow 
function qg_cStacktrace returns character
  (  ) :
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns stack trace for session trigger events.                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/

/* Variables -----------------------------------------------------------------*/

define variable iCounter         as integer   no-undo initial 3.
define variable cStackTrace      as character no-undo initial '':U.

define variable lReverseStack    as logical   no-undo.

define variable lErrorStackTrace as logical   no-undo.
define variable cTempStackTrace  as character no-undo initial '':U.
define variable iCounterStart    as integer   no-undo.
define variable iCounterEnd      as integer   no-undo.
define variable iIncrement       as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

Main:
do on error undo Main, leave Main:
  
  /* Apply error to get stack trace. */
  
  do on error undo, throw:
  
    lErrorStackTrace = session:error-stack-trace.
    session:error-stack-trace = yes.
  
    apply 'error':U.
  
    catch oError as class progress.lang.error:
      
      assign
        cTempStackTrace = oError:callstack
        lReverseStack   = not cTempStackTrace begins program-name(1)
        .
      
    end catch.
    
    finally:
      session:error-stack-trace = lErrorStackTrace.
    end finally.
  
  end.
  
  /* Modify stack trace (remove entries and add arrow) */
  
  if lReverseStack then
    assign
      iCounterStart = num-entries(cTempStackTrace, '~n':U) - 3
      iCounterEnd   = 1
      iIncrement    = -1
      .
  
  else
    assign
      iCounterStart = 4
      iCounterEnd   = num-entries(cTempStackTrace, '~n':U)
      iIncrement    = 1
      .
  
  iCounter = iCounterStart.
  
  do while yes:
    
    cStackTrace =   cStackTrace
                  + (if (    iIncrement < 0
                         and iCounter   < iCounterStart)
                       or
                         (   iIncrement > 0
                         and iCounter   > iCounterStart) then
                       '~n    ':U
                     else
                       '~n--> ':U)
                  + entry(iCounter, cTempStackTrace, '~n':U).
    
    if iCounter = iCounterEnd then
      leave.
    
    iCounter = iCounter + iIncrement.
    
  end. /* do while iCounter <> iCounterEnd */
    
  return trim(cStackTrace, '~n':U).

end. /* Main */

return '':U.

end function. /* qg_cStacktrace */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cSubstituteChar hQueryWindow 
function qg_cSubstituteChar returns character
  ( pcString   as character,
    pcFromChar as character,
    pcToChar   as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Substitutes all occurrences of given character. Double sequential          */
/* occurrences of the character will be changed to one character.             */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcString                       = Text in that the characters should be     */
/*                                  substituted.                              */
/* pcFromChar                     = Character to replace.                     */
/* pcToChar                       = Replacement character.                    */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cString          as character no-undo.
define variable iNumReplacements as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

run qg_SubstituteChar(pcString,
                      pcFromChar,
                      pcToChar,
                      output cString,
                      output iNumReplacements).

return cString.

end function. /* qg_cSubstituteChar */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cSubstituteLinkTokens hQueryWindow 
function qg_cSubstituteLinkTokens returns character
  ( pcText          as character,
    piTargetSeq     as integer,
    phLinkTempTable as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Replaces placeholders for values from other query windows.                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText         as character no-undo.

define variable hQuery             as handle    no-undo.
define variable hBuffer            as handle    no-undo.

define variable iPos               as integer   no-undo initial 1.

define variable cTargetQueryText   as character no-undo.

define variable hSourceBuffer      as handle    no-undo.
define variable hSourceBufferField as handle    no-undo.

define variable cReplacementValue  as character no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer b2ttQueryWindow       for temp-table ttQueryWindow.
define buffer bttVirtualFieldColumn for temp-table ttVirtualFieldColumn.
define buffer bttQueryLink          for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

create query hQuery.

create buffer hBuffer for table phLinkTempTable. /* code checked by mth 30.07.2015 */

cQueryText =            'for each &1':U
             + '~n':U + '  where &1.TargetSeq = &2':U
             + '~n':U + '  by &1.StartPos':U.

hQuery:set-buffers(hBuffer).
hQuery:query-prepare(substitute(cQueryText, hBuffer:name, string(piTargetSeq))).

hQuery:query-open().
hQuery:get-first().

do while not hQuery:query-off-end
  on error undo, throw:

  if   hBuffer::StartPos = 0
    or hBuffer::EndPos <= hBuffer::StartPos then
    next.

  assign
    hSourceBuffer      = ?
    hSourceBufferField = ?
    cReplacementValue  = ?
    cTargetQueryText   =   cTargetQueryText
                         + substring(pcText,
                                     iPos,
                                     hBuffer::StartPos - iPos)
    .
  
  find b2ttQueryWindow
    where b2ttQueryWindow.QuerySeq = hBuffer::SourceSeq
    no-error.
  
  if available b2ttQueryWindow then
  do:
    
    hSourceBuffer = (if valid-handle(b2ttQueryWindow.QueryHandle) then
                       b2ttQueryWindow.QueryHandle:get-buffer-handle(string(hBuffer::BufferName))
                     else
                       ?) no-error.
    
    if    valid-handle(hSourceBuffer)
      and hSourceBuffer:available then
    do:
      
      case string(hBuffer::FieldName):
          
        when '$recid':U then
          cReplacementValue = string( hSourceBuffer:recid ).
        
        when '$rowid':U then
          cReplacementValue = substitute( 'to-rowid( &1 )':U,
                                          quoter( string( hSourceBuffer:rowid ), '~'':U ) ).
        
        otherwise
        do:
          
          hSourceBufferField = hSourceBuffer:buffer-field( hBuffer::FieldName ) no-error.
          
          if    not error-status:error
            and valid-handle( hSourceBufferField ) then
            
            case hSourceBufferField:data-type:
              
              when 'rowid':U then
                
                cReplacementValue = substitute( 'to-rowid( &1 )':U,
                                                quoter( hSourceBufferField:buffer-value( integer( hBuffer::FieldIndex ) ) ) ).
              
              when 'datetime':U then
                cReplacementValue = substitute( 'datetime( &1 )':U,
                                                quoter( hSourceBufferField:buffer-value( integer( hBuffer::FieldIndex ) ) ) ).

              when 'datetime-tz':U then
                cReplacementValue = substitute( 'datetime-tz( &1 )':U,
                                                quoter( hSourceBufferField:buffer-value( integer( hBuffer::FieldIndex ) ) ) ).

              otherwise
                cReplacementValue = quoter( hSourceBufferField:buffer-value( integer( hBuffer::FieldIndex ) ),
                                            '~'':U ).

            end case. /* hSourceBufferField:data-type */
          
          else
          do:
            
            find bttVirtualFieldColumn
              where bttVirtualFieldColumn.OwnerHandle = hSourceBuffer:Query
                and bttVirtualFieldColumn.BufferName  = hBuffer::BufferName
                and bttVirtualFieldColumn.FieldName   = hBuffer::FieldName
                and bttVirtualFieldColumn.FieldIndex  = hBuffer::FieldIndex
              no-error.
            
            if available bttVirtualFieldColumn then
              
              cReplacementValue = quoter( string( qg_clVirtualFieldValueAsLongchar( bttVirtualFieldColumn.FieldType,
                                                                                    bttVirtualFieldColumn.DataType,
                                                                                    bttVirtualFieldColumn.FieldName,
                                                                                    qg_cObjectIdForBuffer( bttVirtualFieldColumn.BufferHandle ),
                                                                                    ? ) ) ).
              
            else
              
              cReplacementValue = quoter( '':U, '~'':U ).
            
          end. /* else: if valid-handle( hSourceBufferField ) */
          
        end. /* otherwise */
        
      end. /* case hBuffer::FieldName */
      
    end. /* case hBuffer::FieldName */
    
  end. /* if available bttQueryWindow */
  
  assign
    cTargetQueryText =   cTargetQueryText
                       + (if cReplacementValue <> ? then
                            cReplacementValue
                          else
                            quoter('':U, '~'':U))
    iPos             = hBuffer::EndPos
    .
  
  finally:
    hQuery:get-next().
  end finally.
  
end. /* for each bttQueryLink */

cTargetQueryText =   cTargetQueryText
                   + substring(pcText,
                               iPos).

return cTargetQueryText.

end function. /* qg_cSubstituteLinkTokens */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cSubstituteQueryLinkTokens hQueryWindow 
function qg_cSubstituteQueryLinkTokens returns character
  ( phWindow as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Replaces placeholders for values from other query windows.                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phWindow                       = Handle of the Query window.               */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryWindow for temp-table ttQueryWindow.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

if not valid-handle(phWindow) then
  leave.

find bttQueryWindow
  where bttQueryWindow.WindowHandle = phWindow
  no-error.

if not available bttQueryWindow then
  leave.

return qg_cSubstituteLinkTokens(bttQueryWindow.QueryText,
                                bttQueryWindow.QuerySeq,
                                temp-table ttQueryLink:handle).

end function. /* qg_cSubstituteQueryLinkTokens */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cTaggedValue hQueryWindow 
function qg_cTaggedValue returns character
  ( pcText   as character,
    plAddTag as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Adds a ${...} tag to given value.                                          */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcText                         = Text that should be tagged.               */
/* plAddTag                       = If yes then the tag is added otherwise    */
/*                                  pcText will be returned unmodified.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return (if not plAddTag then
          pcText
        else
          substitute('$~{&1~}':U,
                     pcText)).

end function. /* qg_cTaggedValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_cTTWidgetPool hQueryWindow 
function qg_cTTWidgetPool returns character
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns the name of the widget-pool that should be used for dynamically    */
/* created temp-tables. If no named widget pool for temp-tables exists yet,   */
/* a new one will be created.                                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if gcTTWidgetPool = '':U then
do:
  
  do while yes:
    
    assign
      i              = i + 1
      gcTTWidgetPool = substitute('QG_TT_WidgetPool_&1', string(i))
      .
    
    create widget-pool gcTTWidgetPool persistent no-error.
    
    if error-status:error then
      next.
    
    else
      leave. 
    
  end. /* do while yes */
  
end. /* if gcTTWidgetPool = '':U */

return gcTTWidgetPool.

end function. /* qg_cTTWidgetPool */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_dIndexUsage hQueryWindow 
function qg_dIndexUsage returns decimal
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcIndexName    as character,
    pcFieldList    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Compares given field list and given index and calculates the percentage    */
/* value.                                                                     */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcDatabaseName                 = Database of table.                        */
/* pcTableName                    = Table of index.                           */
/* pcIndexName                    = Index for comparison.                     */
/* pcFieldList                    = Field list for comparison.                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lIndex           as logical   no-undo initial yes.
define variable iIndexFieldCount as integer   no-undo.
define variable iIndexFieldsUsed as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if num-entries(pcFieldList) = 0 then
  return 0.

for each bttIndexField
  where bttIndexField.DatabaseName = pcDatabaseName
    and bttIndexField.TableName    = pcTableName
    and bttIndexField.IndexName    = pcIndexName
  by IndexSequence
  on error undo, throw:
  
  iIndexFieldCount = iIndexFieldCount + 1.
  
  if lIndex then
  do:
    
    if lookup(bttIndexField.FieldName, pcFieldList) = 0 then
      lIndex = no.
    
    else
      iIndexFieldsUsed = iIndexFieldsUsed + 1.
    
  end. /* if lIndex */
  
end. /* for each bttIndexField */

return iIndexFieldsUsed / minimum(num-entries(pcFieldList), iIndexFieldCount).

end function. /* qg_dIndexUsage */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_dParamListReadValue hQueryWindow 
function qg_dParamListReadValue returns decimal
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Read an decimal value from given parameter list.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = List that contains the value.             */
/* pcParamName                    = Name of the relevant parameter.           */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return decimal(replace(qg_cParamListReadValue(pcParamList,
                                              pcParamName,
                                              pcSplitter),
                       '.':U,
                       session:numeric-decimal-point)).

end function. /* qg_dParamListReadValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_hGetWidgetByName hQueryWindow 
function qg_hGetWidgetByName returns handle
  ( phContainer  as handle,
    pcWidgetName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get a widget in given container by its name.                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phContainer                    = Container widget.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hChild  as handle    no-undo.
define variable hWidget as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if phContainer:name = pcWidgetName then
  return phContainer.

if can-query(phContainer, 'first-child':U) then
do:
  
  hChild = phContainer:first-child.
  
  do while valid-handle(hChild):
    
    hWidget = qg_hGetWidgetByName(hChild, pcWidgetName).
    
    if hWidget <> ? then
      return hWidget.
    
    hChild = hChild:next-sibling.
    
  end. /* do while valid-handle(hChild) */
  
end. /* if can-query(phParent, 'first-child':U) */

return ?.

end function. /* qg_hGetWidgetByName */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_hStartSessionTrigger hQueryWindow 
function qg_hStartSessionTrigger returns handle
  ( piTriggerId as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get a widget in given container by its name.                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phContainer                    = Container widget.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hProcedure as handle    no-undo.
define variable i          as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttSessionTrigger for temp-table ttSessionTrigger.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

find bttSessionTrigger
  where bttSessionTrigger.Id = piTriggerId
  no-error.

if not available bttSessionTrigger then
  return ?.

run qg_WriteSessionTriggerProc(bttSessionTrigger.Id).
  
  compile value(bttSessionTrigger.TriggerFileName) no-error.
  
  if not compiler:error then
    run value(bttSessionTrigger.TriggerFileName) persistent set hProcedure no-error.
  
  else
  do:
    
    do i = 1 to compiler:num-messages:
      
      message
        compiler:get-message(i)
        view-as alert-box
        error
        buttons ok.
      
    end. /* do i = 1 to compiler:num-messages */
    
    message /* code checked by mth 30.07.2015 */
      (if bttSessionTrigger.TriggerEvent = 'assign':U then
         substitute('The session trigger procedure for "&1" of "&2.&3.&4" could not be started!':T,
                    bttSessionTrigger.TriggerEvent,
                    bttSessionTrigger.DatabaseName,
                    bttSessionTrigger.TableName,
                    bttSessionTrigger.FieldName)
       else
         substitute('The session trigger procedure for "&1" of "&2.&3" could not be started!':T,
                    bttSessionTrigger.TriggerEvent,
                    bttSessionTrigger.DatabaseName,
                    bttSessionTrigger.TableName)) skip
      view-as alert-box
      error
      buttons ok.
    
  end. /* else: if not compiler:error */
  
  return hProcedure.
  
end function. /* qg_hStartSessionTrigger */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_iExtractIndex hQueryWindow 
function qg_iExtractIndex returns integer
  ( pcFieldName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Extract index from <FieldName>[<Index>].                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcFieldName                    = Character from which you want to extract  */
/*                                  the index.                                */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable iStartPos as integer   no-undo.
define variable iEndPos   as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

assign
  iStartPos = index(pcFieldName, '[':U) + 1
  iEndPos   = index(pcFieldName, ']':U, iStartPos)
  .

if iEndPos > iStartPos then
  return integer(substring(pcFieldName,
                           iStartPos,
                           iEndPos - iStartPos)).

else
  return 0.

end function. /* qg_iExtractIndex */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_iFilterSeq hQueryWindow 
function qg_iFilterSeq returns integer
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

giFilterSeq = giFilterSeq + 1.

return giFilterSeq.

end function. /* qg_iFilterSeq */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_iGetHandlerId hQueryWindow 
function qg_iGetHandlerId returns integer
  ( pcHandlerName as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Get handler Id.                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcHandlerName                  = Handler name.                             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttIDEHandler for temp-table ttIDEHandler.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

find bttIDEHandler
  where bttIDEHandler.HandlerName = pcHandlerName
  no-error.

return (if available bttIDEHandler then
          bttIDEHandler.HandlerId
        else
          ?).

end function. /* qg_iGetHandlerId */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_iParamListReadValue hQueryWindow 
function qg_iParamListReadValue returns integer
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Read an integer value from given parameter list.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = List that contains the value.             */
/* pcParamName                    = Name of the relevant parameter.           */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return integer(qg_cParamListReadValue(pcParamList,
                                      pcParamName,
                                      pcSplitter)).

end function. /* qg_iParamListReadValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lcClipboardValue hQueryWindow 
function qg_lcClipboardValue returns longchar
  (  ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Returns clipboard value.                                                   */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* The clipboard value is read through a stream to avoid problems with long   */
/* strings.                                                                   */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* <none>                                                                     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable clLine               as character no-undo.
define variable clText               as longchar  no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if lookup('PRO_TEXT':U, clipboard:available-formats) = 0 then
  return ?.

input stream strClipboard from 'clipboard':U .

repeat
  on error undo, throw
  on endkey undo, leave:
  
  import stream strClipboard unformatted
    clLine.
  
  assign
    clText = clText + '~n':U when clText > '':U
    clText = clText + clLine
    .
  
end. /* repeat */

return clText.

finally:
  
  input stream strClipboard close.
  
end finally.
  
end function. /* qg_lcClipboardValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lCheckLinkReference hQueryWindow 
function qg_lCheckLinkReference returns logical
  ( piQuerySeq     as integer,
    pcQuerySeqList as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Check for circular references in query windows.                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* piQuerySeq                     = Query sequence that should be checked     */
/* pcQuerySeqList                 = List of query sequences that have already */
/*                                  been checked.                             */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryLink for temp-table ttQueryLink.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

pcQuerySeqList = substitute('&1&2&3':U,
                            pcQuerySeqList,
                            (if pcQuerySeqList > '':U then
                               ',':U
                             else
                               '':U),
                            string(piQuerySeq)).

for each bttQueryLink
  where bttQueryLink.TargetSeq = piQuerySeq
  on error undo, throw:
  
  if   lookup(string(bttQueryLink.SourceSeq), pcQuerySeqList) > 0
    or not qg_lCheckLinkReference(bttQueryLink.SourceSeq, pcQuerySeqList) then
    return no.
  
end. /* for each bttQueryLink */

return yes.

end function. /* qg_lCheckLinkReference */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lIsHostReachable hQueryWindow 
function qg_lIsHostReachable returns logical
  ( pcHost    as character,
    pcService as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Checks if given host is reachable.                                         */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcHost                         = Hostname that should be checked.          */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hSocket        as handle    no-undo.
define variable cConnectString as character no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

cConnectString = substitute('-H &1 -S &2':U, pcHost, pcService).

create socket hSocket.

hSocket:connect(cConnectString) no-error.

return hSocket:connected().

finally:
  
  if hSocket:connected() then
    hSocket:disconnect() no-error.
  
  delete object hSocket.
  
end finally.

end function. /* qg_lIsHostReachable */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lParamListReadValue hQueryWindow 
function qg_lParamListReadValue returns logical
  ( pcParamList as character,
    pcParamName as character,
    pcSplitter  as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Read an logical value from given parameter list.                           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* pcParamList                    = List that contains the value.             */
/* pcParamName                    = Name of the relevant parameter.           */
/* pcSplitter                     = Splitter to separate param entries.       */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

return logical(qg_cParamListReadValue(pcParamList,
                                      pcParamName,
                                      pcSplitter),
               'yes/':U).

end function. /* qg_lParamListReadValue */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lQueryOpen hQueryWindow 
function qg_lQueryOpen returns logical
  ( phQuery        as handle,
    pcQueryText    as character,
    phParentWindow as handle ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Open given Query using given query string.                                 */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phQuery                        = Query that should be opened.              */
/* pcQueryText                    = Text that should be used as query prepare */
/*                                  string.                                   */
/* phParentWindow                 = Parent window for the query (used for     */
/*                                  error messages during query prepare).     */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable hCurrentWindow as handle    no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

Main:
do
  on error  undo Main, leave Main
  on endkey undo Main, leave Main:

  if valid-handle(phParentWindow) then
    assign
      hCurrentWindow = current-window
      current-window = phParentWindow
      .

  if not valid-handle(phQuery) then
    return no.
  
  if phQuery:num-buffers = 0 then
    return no.
  
  if    pcQueryText <> ?
    and pcQueryText <> phQuery:prepare-string
    and not phQuery:query-prepare(pcQueryText) then
    return no.
  
  if not phQuery:query-open() then
    return no.
  
  return yes.
  
  finally:
    
    if valid-handle(hCurrentWindow) then
      current-window = hCurrentWindow.
    
  end finally.
  
end. /* Main */

end function. /* qg_lQueryOpen */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lSelectNextQueryCondition hQueryWindow 
function qg_lSelectNextQueryCondition returns logical
  ( phEditor as handle,
    plNext   as logical ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Select next query condition.                                               */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/* Returns yes if an condition has been selected otherwise reutrns no.        */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/* phEditor                       = Editor widget handle that contains the    */
/*                                  query text.                               */
/* plNext                         = If yes the next condition will be         */
/*                                  selected otherwise the previous condition */
/*                                  will be selected.                         */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable cQueryText      as character no-undo.
define variable cConditionText  as character no-undo.
define variable iSelectionStart as integer   no-undo.
define variable iSelectionEnd   as integer   no-undo.

define variable iStart          as integer   no-undo.
define variable iEnd            as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttQueryCondition for temp-table ttQueryCondition.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

assign
  cQueryText      = phEditor:input-value
  iSelectionStart = (if phEditor:selection-start > 0 then
                       phEditor:selection-start
                     else
                       phEditor:cursor-offset)
  iSelectionEnd   = (if phEditor:selection-end > 0 then
                       phEditor:selection-end
                     else
                       phEditor:cursor-offset)
  .

run qg_ParseQueryConditions(cQueryText).

if plNext = yes then
do:
  
  find first bttQueryCondition
    where bttQueryCondition.RightStartPos > iSelectionStart
    no-error.
  
  if available bttQueryCondition then
    assign
      iStart = bttQueryCondition.RightStartPos
      iEnd   = bttQueryCondition.RightEndPos
      .
  
end. /* if plNext = yes */

else
  if plNext = no then
  do:
    
    find last bttQueryCondition
      where bttQueryCondition.RightEndPos < iSelectionEnd
      no-error.
  
    if available bttQueryCondition then
      assign
        iStart = bttQueryCondition.RightStartPos
        iEnd   = bttQueryCondition.RightEndPos
        .

  end. /* if plNext = no */

else
do:
  
  find first bttQueryCondition
    where ( bttQueryCondition.RightStartPos  < iSelectionEnd
        and bttQueryCondition.RightEndPos   >= iSelectionStart)
      or (  bttQueryCondition.RightStartPos <= iSelectionStart
        and bttQueryCondition.RightEndPos   >= iSelectionStart)
    no-error.
  
  if available bttQueryCondition then
    assign
      iStart = bttQueryCondition.RightStartPos
      iEnd   = bttQueryCondition.RightEndPos
      .
  
  else
  do:
    
    find first bttQueryCondition
      where ( bttQueryCondition.LeftStartPos  < iSelectionEnd
          and bttQueryCondition.LeftEndPos   >= iSelectionStart)
        or (  bttQueryCondition.LeftStartPos <= iSelectionStart
          and bttQueryCondition.LeftEndPos   >= iSelectionStart)
      no-error.
  
    if available bttQueryCondition then
      assign
        iStart = bttQueryCondition.LeftStartPos
        iEnd   = bttQueryCondition.LeftEndPos
        .

    else
    do:

      if not available bttQueryCondition then
        find first bttQueryCondition
          where ( bttQueryCondition.ComparatorStartPos  < iSelectionEnd
              and bttQueryCondition.ComparatorEndPos   >= iSelectionStart)
            or (  bttQueryCondition.ComparatorStartPos <= iSelectionStart
              and bttQueryCondition.ComparatorEndPos   >= iSelectionStart)
          no-error.
    
      if available bttQueryCondition then
        assign
          iStart = bttQueryCondition.ComparatorStartPos
          iEnd   = bttQueryCondition.ComparatorEndPos
          .

    end. /* else: if available bttQueryCondition */

  end. /* else: if available bttQueryCondition */

end. /* else: if plNext = yes */

if    iStart > 0
  and iEnd   > iStart then
do:
  
  cConditionText = substring(cQueryText,
                             iStart,
                               iEnd
                             - iStart).
  
  if   cConditionText matches '~'*~'':U
    or cConditionText matches '~"*~"':U then
    assign
      iSelectionStart = iStart + 1
      iSelectionEnd   = iEnd - 1
      .
  
  else
    assign
      iSelectionStart = iStart
      iSelectionEnd   = iEnd
      .
    
  phEditor:set-selection(iSelectionStart, iSelectionEnd).
  
  return yes.
  
end. /* if available(bttQueryCondition) */

return no.

end function. /* qg_lSelectNextQueryCondition */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lTestBits hQueryWindow 
function qg_lTestBits returns logical
  ( piTestValue as integer,
    piRefValue  as integer ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable i as integer   no-undo.

/* Buffers -------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/

do while piTestValue >= exp(2, i):

  if    truncate(piTestValue / exp(2, i), 0) mod 2 = 1
    and truncate(piRefValue / exp(2, i), 0) mod 2  = 0 then
    return no.
  
  i = i + 1.

end. /* do while piValue1 > exp(2, i) */

return yes.

end function. /* qg_lTestBits */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION qg_lUniqueQuery hQueryWindow 
function qg_lUniqueQuery returns logical
  ( pcDatabaseName as character,
    pcTableName    as character,
    pcFieldList    as character ):
/* Description ---------------------------------------------------------------*/
/*                                                                            */
/* Checks wether a query with given fields matches an unique index.           */
/*                                                                            */
/* Notes ---------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Parameters ----------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/* Examples ------------------------------------------------------------------*/
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/* Variables -----------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

define variable lDetailsLoaded as logical   no-undo.

/* Buffers -------------------------------------------------------------------*/

define buffer bttTable      for temp-table ttTable.
define buffer bttIndex      for temp-table ttIndex.
define buffer bttIndexField for temp-table ttIndexField.

/*----------------------------------------------------------------------------*/
/* Processing                                                                 */
/*----------------------------------------------------------------------------*/                

if    available ttTable
  and ttTable.DatabaseName = pcDatabaseName
  and ttTable.TableName    = pcTableName then
  lDetailsLoaded = ttTable.DetailsLoaded.

else
do:

  find bttTable
    where bttTable.DatabaseName = pcDatabaseName
      and bttTable.TableName    = pcTableName
    no-error.
  
  if not available bttTable then
    return no.
  
  lDetailsLoaded = bttTable.DetailsLoaded.

end. /* else: if    available ttTable */

if not lDetailsLoaded then
  run qg_AddTableDetails(pcDatabaseName, pcTableName).

IndexSearch:
for each bttIndex
  where bttIndex.DatabaseName = pcDatabaseName
    and bttIndex.TableName    = pcTableName
    and bttIndex.IsUnique     = yes
  on error undo, throw:
  
  for each bttIndexField 
    where bttIndexField.Databasename = bttIndex.Databasename
      and bttIndexField.TableName    = bttIndex.TableName
      and bttIndexField.IndexName    = bttIndex.IndexName
    on error undo, throw:
    
    if lookup(bttIndexField.FieldName, pcFieldList) = 0 then
      next IndexSearch.
    
  end. /* do i = 1 to num-entries(pcFieldList) */
  
  return yes.
  
end. /* bttIndex */

return no.

end function. /* qg_lUniqueQuery */

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME